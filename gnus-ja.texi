\input texinfo

@setfilename gnus-ja
@settitle Gnus Manual
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex pg cp

@copying
Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契約書
第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、あるいは変更す
ることを許可します。変更不可部分は指定しません。「A GNU Manual」は表表紙
テキスト、以下の (a) は裏表紙テキストです。この利用許諾契約書の複写は
「Emacs manual」の「GNU フリー文書利用許諾契約書」という章に含まれていま
す。

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

(a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフトウェア
のように複製したり変更する自由があります。複製はフリーソフトウェア財団に
よって出版されました。(フリーソフトウェア財団は) GNU の開発のために必要
な資金を集めています。」

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.

この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集著作物
の一部です。もしあなたがこの文書を収集著作物から分離して配布したいときは、
契約書の第 6 項に記述されているように、文書に契約書の複写を付加すること
によって、行なうことができます。
@end quotation
@end copying

@iftex
@iflatex
\documentclass[twoside,a4paper,openright,11pt]{book}
\usepackage[latin1]{inputenc}
\usepackage{pagestyle}
\usepackage{epsfig}
\usepackage{pixidx}
\input{gnusconfig.tex}

\ifx\pdfoutput\undefined
\else
\usepackage[pdftex,bookmarks,colorlinks=true]{hyperref}
\usepackage{thumbpdf}
\pdfcompresslevel=9
\fi

\makeindex
\begin{document}

\newcommand{\gnusversionname}{No Gnus v0.3}
\newcommand{\gnuschaptername}{}
\newcommand{\gnussectionname}{}

\newcommand{\gnusbackslash}{/}

\newcommand{\gnusref}[1]{``#1'' on page \pageref{#1}}
\ifx\pdfoutput\undefined
\newcommand{\gnusuref}[1]{\gnustt{#1}}
\else
\newcommand{\gnusuref}[1]{\href{#1}{\gnustt{#1}}}
\fi
\newcommand{\gnusxref}[1]{See ``#1'' on page \pageref{#1}}
\newcommand{\gnuspxref}[1]{see ``#1'' on page \pageref{#1}}

\newcommand{\gnuskindex}[1]{\index{#1}}
\newcommand{\gnusindex}[1]{\index{#1}}

\newcommand{\gnustt}[1]{{\gnusselectttfont{}#1}}
\newcommand{\gnuscode}[1]{\gnustt{#1}}
\newcommand{\gnusasis}[1]{\gnustt{#1}}
\newcommand{\gnusurl}[1]{\gnustt{#1}}
\newcommand{\gnuscommand}[1]{\gnustt{#1}}
\newcommand{\gnusenv}[1]{\gnustt{#1}}
\newcommand{\gnussamp}[1]{``{\fontencoding{OT1}\gnusselectttfont{}#1}''}
\newcommand{\gnuslisp}[1]{\gnustt{#1}}
\newcommand{\gnuskbd}[1]{`\gnustt{#1}'}
\newcommand{\gnuskey}[1]{`\gnustt{#1}'}
\newcommand{\gnusfile}[1]{`\gnustt{#1}'}
\newcommand{\gnusdfn}[1]{\textit{#1}}
\newcommand{\gnusi}[1]{\textit{#1}}
\newcommand{\gnusr}[1]{\textrm{#1}}
\newcommand{\gnusstrong}[1]{\textbf{#1}}
\newcommand{\gnusemph}[1]{\textit{#1}}
\newcommand{\gnusvar}[1]{{\fontsize{10pt}{10}\selectfont\textsl{\textsf{#1}}}}
\newcommand{\gnussc}[1]{\textsc{#1}}
\newcommand{\gnustitle}[1]{{\huge\textbf{#1}}}
\newcommand{\gnusversion}[1]{{\small\textit{#1}}}
\newcommand{\gnusauthor}[1]{{\large\textbf{#1}}}
\newcommand{\gnusresult}[1]{\gnustt{=> #1}}
\newcommand{\gnusacronym}[1]{\textsc{#1}}
\newcommand{\gnusemail}[1]{\textit{#1}}

\newcommand{\gnusbullet}{{${\bullet}$}}
\newcommand{\gnusdollar}{\$}
\newcommand{\gnusampersand}{\&}
\newcommand{\gnuspercent}{\%}
\newcommand{\gnushash}{\#}
\newcommand{\gnushat}{\symbol{"5E}}
\newcommand{\gnusunderline}{\symbol{"5F}}
\newcommand{\gnusnot}{$\neg$}
\newcommand{\gnustilde}{\symbol{"7E}}
\newcommand{\gnusless}{{$<$}}
\newcommand{\gnusgreater}{{$>$}}
\newcommand{\gnusbraceleft}{{$>$}}
\newcommand{\gnusbraceright}{{$>$}}

\newcommand{\gnushead}{\raisebox{-1cm}{\epsfig{figure=ps/gnus-head,height=1cm}}}
\newcommand{\gnusinteresting}{
\marginpar[\mbox{}\hfill\gnushead]{\gnushead}
}

\newcommand{\gnuscleardoublepage}{\ifodd\count0\mbox{}\clearpage\thispagestyle{empty}\mbox{}\clearpage\else\clearpage\fi}

\newcommand{\gnuspagechapter}[1]{
{\mbox{}}
}

\newdimen{\gnusdimen}
\gnusdimen 0pt

\newcommand{\gnuschapter}[2]{
\gnuscleardoublepage
\ifdim \gnusdimen = 0pt\setcounter{page}{1}\pagestyle{gnus}\pagenumbering{arabic} \gnusdimen 1pt\fi
\chapter{#2}
\renewcommand{\gnussectionname}{}
\renewcommand{\gnuschaptername}{#2}
\thispagestyle{empty}
\hspace*{-2cm}
\begin{picture}(500,500)(0,0)
\put(480,350){\makebox(0,0)[tr]{#1}}
\put(40,300){\makebox(500,50)[bl]{{\Huge\bf{#2}}}}
\end{picture}
\clearpage
}

\newcommand{\gnusfigure}[3]{
\begin{figure}
\mbox{}\ifodd\count0\hspace*{-0.8cm}\else\hspace*{-3cm}\fi\begin{picture}(440,#2)
#3
\end{picture}
\caption{#1}
\end{figure}
}

\newcommand{\gnusicon}[1]{
\marginpar[\mbox{}\hfill\raisebox{-1.5cm}{\epsfig{figure=ps/#1-up,height=1.5cm}}]{\raisebox{-1cm}{\epsfig{figure=ps/#1-up,height=1cm}}}
}

\newcommand{\gnuspicon}[1]{
\margindex{\epsfig{figure=#1,width=2cm}}
}

\newcommand{\gnusxface}[2]{
\margindex{\epsfig{figure=#1,width=1cm}\epsfig{figure=#2,width=1cm}}
}

\newcommand{\gnussmiley}[2]{
\margindex{\makebox[2cm]{\hfill\epsfig{figure=#1,width=0.5cm}\hfill\epsfig{figure=#2,width=0.5cm}\hfill}}
}

\newcommand{\gnusitemx}[1]{\mbox{}\vspace*{-\itemsep}\vspace*{-\parsep}\item#1}

\newcommand{\gnussection}[1]{
\renewcommand{\gnussectionname}{#1}
\section{#1}
}

\newenvironment{codelist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{asislist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{kbdlist}%
{\begin{list}{}{
\labelwidth=0cm
}
}{\end{list}}

\newenvironment{dfnlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{stronglist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{samplist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{varlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{emphlist}%
{\begin{list}{}{
}
}{\end{list}}

\newlength\gnusheadtextwidth
\setlength{\gnusheadtextwidth}{\headtextwidth}
\addtolength{\gnusheadtextwidth}{1cm}

\newpagestyle{gnuspreamble}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\mbox{}}\textbf{\hfill\roman{page}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\roman{page}\hfill\mbox{}}}
}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnusindex}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\gnuschaptername\hfill\arabic{page}}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnus}%
{
{
\ifodd\count0
{
\makebox[12cm]{\hspace*{3.1cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{chapter}.\arabic{section}} \textbf{\gnussectionname\hfill\arabic{page}}}}}
}
\else
{
\makebox[12cm]{\hspace*{-2.95cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\pagenumbering{roman}
\pagestyle{gnuspreamble}

@end iflatex
@end iftex

@iftex
@iflatex

\begin{titlepage}
{

%\addtolength{\oddsidemargin}{-5cm}
%\addtolength{\evensidemargin}{-5cm}
\parindent=0cm
\addtolength{\textheight}{2cm}

\gnustitle{\gnustitlename}\hfill\gnusversion{\gnusversionname}\\
\rule{15cm}{1mm}\\
\vfill
\hspace*{0cm}\epsfig{figure=ps/gnus-big-logo,height=15cm}
\vfill
\rule{15cm}{1mm}\\
\gnusauthor{by Lars Magne Ingebrigtsen}
\newpage
}

\mbox{}
\vfill

\thispagestyle{empty}

@c @insertcopying
\newpage
\end{titlepage}
@end iflatex
@end iftex

@ifnottex
@insertcopying
@end ifnottex

@dircategory Emacs
@direntry
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
@end direntry
@iftex
@finalout
@end iftex
@setchapternewpage odd

@titlepage
@title Gnus Manual

@author by Lars Magne Ingebrigtsen
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@node Top
@top The Gnus Newsreader

@ifinfo
Gnus を使うことによって Emacs でニュースを (それにメールも) 読むことがで
きます。ニュースは @acronym{NNTP}、ローカルスプール、mbox ファイルなどの
あらゆる極悪な手段を駆使して手に入れることができます。運試しをしてみよう
と思うならば、すべてを同時に用いることもできます。

この説明書は No Gnus v0.3 に対応します。
@end ifinfo
@iftex

@iflatex
\tableofcontents
\gnuscleardoublepage
@end iflatex

Gnus は先進的で、説明不用で、カスタマイズ可能で、拡張可能な、リアルタイ
ムでない GNU Emacs のニュースリーダーです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう:

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます!

Emacs が文章を編集する人に力を与えるように、Gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように Gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う (もしく
は濫用する) ことによって、やりたいことをできるようになっているべきなので
す。

@end iftex

@menu
* Starting Up::              ニュースを見つけるのには苦労が伴うかもしれない
* Group Buffer::             グループを選択し、購読し、削除する
* Summary Buffer::           記事を読み、保存し、投稿する
* Article Buffer::           記事を表示し、扱う
* Composing Messages::       メールとニュースを送るための情報
* Select Methods::           Gnus はすべてのメッセージをいろいろな選択方法で読む
* Scoring::                  記事に値を付ける
* Various::                  一般的な設定
* The End::                  さらば、そしてさようなら
* Appendices::               用語、Emacs 入門、@acronym{FAQ}、歴史、内部構造
* Index::                    変数、関数、概念の索引
* Key Index::                キー索引

Other related manuals

* Message:(message-ja).      メッセージの作成
* Emacs-MIME:(emacs-mime-ja). メッセージの作成; @acronym{MIME} パート
* Sieve:(sieve-ja).          Emacs で Sieve スクリプトを管理する
* PGG:(pgg-ja).              Gnus で @acronym{PGP/MIME} を使う
* SASL:(sasl-ja).            Emacs で @acronym{SASL} の認証を行なう

@detailmenu
 --- The Detailed Node Listing ---

Starting Gnus

* Finding the News::            ニュースを取得する方法を選ぶ
* The First Time::              最初に起動したときに Gnus は何をするか
* The Server is Down::          そんなとき、どうすればメールを読めるか
* Slave Gnusae::                同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* New Groups::                  Gnus が新しいグループに対して何をするか
* Changing Servers::            あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::               やっかいなスタートアップファイル---@file{.newsrc}
* Auto Save::                   クラッシュからの回復
* The Active File::             遅い回線からのファイルの取得には時間がかかる
* Startup Variables::           変更したいと思うかもしれない変数

New Groups

* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる

Group Buffer

* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュースを読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Misc Group Stuff::            他にできること

Group Buffer Format

* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける

Group Topics

* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター

Misc Group Stuff

* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理

Summary Buffer

* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード

Summary Buffer Format

* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする

Choosing Articles

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数

Reply, Followup and Post

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::

Marking Articles

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方

Threading

* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令

Customizing Threading

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう@dots{} でもあなたは間違っていた!

Decoding Articles

* Uuencoded Articles::          記事を uuencode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?

Decoding Variables

* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数

Article Treatment

* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの

Alternative Approaches

* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする

Various Summary Stuff

* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令

Article Buffer

* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を @acronym{MIME} に通す
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他

Composing Messages

* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?

Select Methods

* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* IMAP::                        Gnus を @acronym{IMAP} のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケットを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む

Server Buffer

* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない

Getting News

* NNTP::                        @acronym{NNTP} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む

@acronym{NNTP}

* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
* NNTP marks::                  @acronym{NNTP} サーバー用の印の保存

Getting Mail

* Mail in a Newsreader::        ニュースリーダでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだつような分割をすることができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる

Mail Sources

* Mail Source Specifiers::      メールの元がどこかを指定する
* Mail Source Customization::   世の中に影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使用する

Choosing a Mail Back End

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Rmail Babyl::                 Emacs のプログラムは Rmail の Babyl フォーマットを使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察

Browsing the Web

* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* RSS::                         RDF Site Summary を読む
* Customizing w3::              Gnus から Emacs/W3 を操作する

@acronym{IMAP}

* Splitting in IMAP::           nnimap でメールを分割する
* Expiring in IMAP::            nnimap によるメールの期限切れ消去
* Editing IMAP ACLs::           メールボックスへの他の利用者の使用を制限/許可する
* Expunging mailboxes::         ``メールボックス圧縮'' ボタンと等価なもの
* A note on namespaces::        Gnus で @acronym{IMAP} 名前空間を使う (使わない) 方法
* Debugging IMAP::              ものごとが働かないときにするべきこと

Other Sources

* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        @sc{soup} パケットを ``オフライン'' で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する

Document Groups

* Document Server Internals::   あなた独自の文書種別を追加する方法

SOUP

* SOUP Commands::               @sc{soup} パケットを作成、送出する命令
* SOUP Groups::                 @sc{soup} パケットを読むバックエンド
* SOUP Replies::                @code{nnsoup} にメールとニュースを引き継がせる方法

Combined Groups

* Virtual Groups::              たくさんのグループの記事を合併させる
* Kibozed Groups::              ニューススプールの中からの記事を検索する

Email Based Diary

* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      NNDiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること

The NNDiary Back End

* Diary Messages::              メッセージを NNDiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル

The Gnus Diary Library

* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで

Gnus Unplugged

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               エージェントが概略バッファーに変化をもたらすかもしれない方法
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を消す方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and IMAP::              エージェントを @acronym{IMAP} で使う方法
* Outgoing Messages::           投稿、メールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{~/.gnus.el} の例
* Batching Agents::             @code{cron} ジョブによるニュース取得方法
* Agent Caveats::               あなたが予想することと、それが実際にすること

Agent Categories

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス

Agent Commands

* Group Agent Commands::        グループの設定とそれらの内容の取得
* Summary Agent Commands::      手動で選択した記事を取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択

Scoring

* Summary Score Commands::      現在のグループのためのスコア項目を追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする (まぁ、なんて用語 (Scoring) でしょう)
* Score File Format::           スコアファイルに何を入れるか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            大姉 (Big Sister) Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア項目がどこへ行くかをどのように指定するか
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                どうやって効果的にスコアを付けるか
* Reverse Scoring::             古いものの子であるという問題は問題ではない
* Global Score Files::          地をつかみ、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに変換する
* Advanced Scoring::            スコアの法則を作るために論理表現を使う
* Score Decays::                スコアを枯れていかせるのは役に立つこともある

Advanced Scoring

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限利用する

Various

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーがどのように見えるべきかを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 どのようにして Gnus の速度を上げるか
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏でものごとを実行することができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Image Enhancements::          最新の Emacs/XEmacs は絵を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        余計な商業的電子メールを避ける方法
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの

Formatting Variables

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を修正する
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

Image Enhancements

* X-Face::                      ファンキーなちっちゃな白黒の絵を表示する
* Face::                        よりファンキーでちっちゃなカラーの絵を表示する
* Smileys::                     表示されるべく生まれた幸せそうな顔を表示する方法
* Picons::                      あなたが読んでいるものの絵を表示する方法
* XVarious::                    その他の XEmacs で Gnus な変数

Thwarting Email Spam

* The problem of spam::         背景、そして解決
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する
* Filtering Spam Using The Spam ELisp Package::
* Filtering Spam Using Statistics with spam-stat::

Filtering Spam Using The Spam ELisp Package

* Spam ELisp Package Sequence of Events::
* Spam ELisp Package Filtering of Incoming Mail::
* Spam ELisp Package Global Variables::
* Spam ELisp Package Configuration Examples::
* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* SpamAssassin back end::
* ifile spam filtering::
* spam-stat spam filtering::
* SpamOracle::
* Extending the Spam ELisp package::

Filtering Spam Using Statistics with spam-stat

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::

Appendices

* XEmacs::                      XEmacs でインストールするための要件
* History::                     どうやって Gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 ここにあるような本当に難しい語を使う
* Customization::               あなたの要求に沿って Gnus を仕立てる
* Troubleshooting::             うまくいかなかったときに試すかもしれないこと
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短な導入
* Frequently Asked Questions::  Gnus の FAQ

History

* Gnus Versions::               どんなバージョンの Gnus がリリースされているか
* Other Gnus Versions::         リリースされている他のバージョンの Gnus
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性があるの?
* Conformity::                  Gnus はすべての標準を満たそうとする
* Emacsen::                     Gnus はいくつかの現代的な Emacs 環境で実行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                大量の人々
* New Features::                Gnus の新しいことに関する手がかり

New Features

* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の新しいこと
* September Gnus::              公式に Gnus 5.2/5.3 として知られているもの
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            五番目、P で始まる、もしくは Gnus 5.8/5.9 として知られているもの
* Oort Gnus::                   巨大な。遠く遥かな。Gnus 5.10/5.11。
* No Gnus::                     Lars さん、直して!

Customization

* Slow/Expensive Connection::   ローカルの Emacs を立ち上げて、他のところからニュースを得ることができる
* Slow Terminal Connection::    遠隔 Emacs を実行する
* Little Disk Space::           大きな起動ファイルを持つことはまずい
* Slow Machine::                速い機械を買おうと感じるであろう

Gnus Reference Guide

* Gnus Utility Functions::      使用できる共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル規格の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報形式
* Extended Interactive::        記号接頭引数など
* Emacs/XEmacs Code::           Gnus はすべての近代 Emacsen で動作する
* Various File Formats::        Gnus の使用するファイルの形式

Back End Interface

* Required Back End Functions::  実装しなければならない関数
* Optional Back End Functions::  実装しなくてもよい関数
* Error Messaging::             メッセージやエラー報告を得る方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言

Various File Formats

* Active File Format::          使用可能な記事グループの情報
* Newsgroups File Format::      グループの記述

Emacs for Heathens

* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語

@end detailmenu
@end menu

@node Starting Up
@chapter Gnus の起動
@cindex starting up

@kindex M-x gnus
@findex gnus
システム管理者が適切な設定をしていたならば、Gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。

@findex gnus-other-frame
@kindex M-x gnus-other-frame
別のフレーム (frame) で Gnus を起動したいときは、
@kbd{M-x gnus-other-frame} 命令を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus.el} ファイルの中で変数
をいくつかいじくりまわさなければならないでしょう。このファイル
は @file{~/.emacs} と似ていますが、こちらは Gnus が起動するときに読み込
まれます。

この説明書でよくわからない用語がでてきたときは、用語の
項 (@ref{Terminology}) を参照して下さい。

@menu
* Finding the News::      ニュースを取得する方法を選ぶ
* The First Time::        最初に起動したときに Gnus は何をするか
* The Server is Down::    そんなとき、どうすればメールを読めるか
* Slave Gnusae::          同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::      グループを読むためだけに Gnus を起動する
* New Groups::            Gnus が新しいグループに対して何をするか
* Changing Servers::      あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::         やっかいなスタートアップファイル---@file{.newsrc}
* Auto Save::             クラッシュからの回復
* The Active File::       遅い回線からのファイルの取得には時間がかかる
* Startup Variables::     変更したいと思うかもしれない変数
@end menu

@node Finding the News
@section ニュースを見つける
@cindex finding news

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は Gnus がどこでニュースを探すべきかを示
します。この変数ははじめの要素が @dfn{方法}、二番目の要素
が @dfn{場所} を表すリストである必要があります。この方法はあなたの基本方
法 (native method) になります。この方法で取ってこないグループはすべて外
部 (foreign) グループです。

たとえば、@acronym{NNTP} サーバー @samp{news.somewhere.edu} から毎日 (薬
のように) 一定の量のニュースを摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

@noindent
のようにすることができます。

ローカル・スプールのディレクトリーを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

@noindent
のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。でも、もしあなたのサーバー
が Leafnode (それは簡単な個人用のニュースサーバーです) であるならばロー
カルスプールを使ってはいけません。この場合
は @code{(nntp "localhost")} にしましょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @acronym{NNTP} server
もしこの変数が設定されていなければ、Gnus は @env{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、
Gnus は @code{gnus-nntpserver-file} (設定されていない場合
は @file{/etc/nntpserver}) がこの件に関して何かを言っていないかを調べま
す。もしそれも失敗したなら、Gnus は Emacs が動作しているサーバー
を @acronym{NNTP} サーバーとして使おうとします。随分な当て推量ですけどね。

@vindex gnus-nntp-server
@code{gnus-nntp-server} が設定されていると、この変数
は @code{gnus-select-method} よりも優先されます。ですか
ら @code{gnus-nntp-server} は @code{nil} に設定するべきで、それがディフォ
ルトです。

@vindex gnus-secondary-servers
@vindex gnus-nntp-server
Gnus に @acronym{NNTP} サーバーの名前を対話的に指定することもできます。
@code{gnus} に数値でない接頭引数を渡すと (例: @kbd{C-u M-x gnus})、
Gnus は @code{gnus-secondary-servers} リスト (もし存在するならば) からサー
バーを選ぶことができるようにします。ただ単に接続したいと思ったサーバーの
名前を打つこともできます。(これは @code{gnus-nntp-server} を設定し、これ
は後の Emacs のセッションで @kbd{M-x gnus} とすると、Gnus は同じサーバー
に接続しようとするということです。)

@findex gnus-group-browse-foreign-server
@kindex B (グループ)
しかし、普段日常的には一つの @acronym{NNTP} サーバーを使い、違ったサーバー
には興味のあるグループが少ししかない場合、グループバッファー
で @kbd{B} 命令を使うことの方が良いでしょう。それは、選択可能なグループ
を表示し、その中からどれでも好きなものを購読することができます。これ
は @file{.newsrc} の保持をずっとやりやすくします。
@xref{Foreign Groups, 外部グループ}.

@vindex gnus-secondary-select-methods
@c @head
外部グループに対する少し違ったやり方は、変
数 @code{gnus-secondary-select-methods} を設定する方法です。この変数に表
されている選択方法は、多くの点で @code{gnus-select-method} サーバーの選
択方法と同じように扱われます。起動中にアクティブファイルを探しにいき (も
し要求されていれば)、これらのサーバー上にできた新しいニュースグループは
元々のグループと同じように購読されます (もしくは、されません)。

たとえば、メールを読むために @code{nnmbox} バックエンド (back end) を使
いたいときは、普通、この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

@noindent
と設定します。

注: @acronym{NNTP} バックエンドは印ファイル (@pxref{NNTP marks}) に印を
保存します。この機能は Gnus がインストールされている複数のホスト間で印を
共有することを容易にしますが、新着記事の取得をちょっと遅くするかもしれま
せん。詳細については @ref{NNTP marks} を参照して下さい。

@node The First Time
@section 一番初め
@cindex first time usage

起動用ファイルが存在しないときは (@pxref{Startup Files})、Gnus はどのグ
ループがディフォルトで購読されているべきかを決定しようとします。

@vindex gnus-default-subscribed-newsgroups
変数 @code{gnus-default-subscribed-newsgroups} が設定されていると、
Gnus はそのリストの中のグループを購読し、残りを削除します。システム管理
者はこの変数を何か役に立つものに設定しておくことが望まれます。

そうでないときは、Gnus は少数の適当なグループを購読します (例:
@samp{*.newusers})。(@dfn{適当な} はここでは、@dfn{Lars さんが読むべきで
あると考えるもの} というように定義されています)

また、たいていの共通の問題の解決の手助けになるよう、Gnus に関する文書の
グループも購読することになるでしょう。

@code{gnus-default-subscribed-newsgroups} が @code{t} のときは、Gnus は
新しいグループを扱うのに普通の関数を使い、特別なことは何もしません。

@node The Server is Down
@section サーバーが落ちている
@cindex server errors

ディフォルトのサーバーが落ちているときは、当然 Gnus の起動にいくつかの問
題が発生します。しかし、ニュースグループの他にいくつかメールのグループが
あるのならば、それにもかかわらず Gnus を起動する必要があるかもしれません。

信頼できるプログラムの一つである Gnus は、サーバーと接続できないときは基
本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在し
ないとき (例えば、アドレスを間違えた場合) やサーバーが何らかの理由で一時
的に調子がおかしくなっているときに起こります。もしそのまま続行することに
して、外部グループが一つも無い場合、実はグループバッファーではほとんど何
もできないということに気が付くでしょう。でも、ねぇ、それはあなたの問題で
す。ブブーッ!

@findex gnus-no-server
@kindex M-x gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、Gnus を起動するのに @code{gnus-no-server} 命令を
使うことができます。急いでいるときにもぴったりでしょう。この命令は本来の
サーバーには接続しません---その代わりに、レベル 1 と 2 にあるすべてのグ
ループを活動状態にします (基本グループでないグループはその二つのレベルに
しておくのが望ましいでしょう)。@ref{Group Levels} も参照して下さい (訳
注: @code{gnus-no-server} は @code{gnus-group-use-permanent-levels} 変数
の値を 2 に設定することに注意して下さい)。

@node Slave Gnusae
@section Gnus をスレーブにする
@cindex slave

あなたには二つ以上の Gnus をそれぞれ別の Emacs 上で同時に動かす必要が生
じるかもしれません。違った @file{.newsrc} ファイルを使っているなら (例え
ば、二つの違ったサーバーから読み込むために、二つの違った Gnus を動作させ
ている場合)、まったく問題はありません。それを行なえば良いだけです。

問題は、同じ @file{.newsrc} ファイルを使う二つの Gnus を動かそうとしたと
きに起こります。

この問題に対処するために Gnus タワーのシンクタンクにいる私たちは、新しい
概念にたどりつきました。@dfn{マスター} と @dfn{スレーブ} です。(私たちは
この概念に特許を申請しました。そして、その言葉の著作権を得ました。お互い
に関連してこれらの言葉を使いたいなら、一回使う毎に、私に $1 を送らなけれ
ばなりません。もっちろん、@dfn{コンピューターアプリケーションのマスター／
スレーブ関係} の使用料はもっと高くなります。)

@findex gnus-slave
とにかく、@kbd{M-x gnus} (もしくは、普段やっている方法) で Gnus を普通に
起動します。その後のスレーブ Gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わり
に @dfn{スレーブファイル} にスレーブの起動中にどのようなグループが読まれ
たかという情報だけを保存します。マスター Gnus が起動するとき、それはそれ
らのスレーブファイルを読み込み (そして消し)、それらからすべての情報を取
り込みます。(スレーブファイルは、最終的な変更が優先されるようにそれらが
作られた順番で読まれます。)

もちろん、スレーブファイルからの情報は普通の (すなわち、マスター
の) @file{.newsrc} ファイルよりも優先されます。

スレーブを起動するときにもしマスターの @file{.newsrc*} ファイル群がセー
ブされていなかったら、自動保存されたファイルを読むかどうかを尋ねられるか
もしれません。``yes'' と答えると、マスターにセーブされていない変更はスレー
ブに反映されません。``no'' と答えると、マスターで読まれたいくつかの記事
が、スレーブでは未読であると見なされるかもしれません。

@node New Groups
@section 新しいグループ
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループをまったく見なくても満足ならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数
が @code{nil} に設定されていても、グループバッファーで @kbd{U} を押せば
いつでも新しいグループを購読することができます (@pxref{Group
Maintenance})。ディフォルトではこの変数は @code{ask-server} です。この変
数が @code{always} に設定されていると、@kbd{g} 命令を実行したときで
も Gnus はバックエンドに新しいグループを探すことを求めま
す (@pxref{Scanning New Messages})。

@menu
* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる
@end menu

@node Checking New Groups
@subsection 新しいグループを調べる

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除さ
れているグループのリストとアクティブファイルを比較することにより判定して
います。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、Gnus は
サーバーに、最後に接続してから新しいグループができているかどうかを尋ねま
す。この方法は速いし、安上がりです。これにより、削除されたグループのリス
トを保持しておくことからから完全に開放されます。ですから、
@code{gnus-save-killed-list} を @code{nil} にすることができるでしょう。
そうすれば、起動、終了の両方、そして全体にわたって時間を節約できます。ディ
スク消費量も少なくなります。それなら、どうしてこれがディフォルトではない
のでしょう? 残念ながら、すべてのサーバーがこの命令を理解するわけではない
のです。

私は今あなたが何を考えているかを当てられます。どうすればサーバー
が @code{ask-server} を理解するかがわかるのでしょう? え、違うのです
か? あぁ、良かった。というのは、確実な答は存在しないのです。私に言えるこ
とは、この変数を @code{ask-server} に設定して、数日間新しいグループが現
れるかどうかを調べて下さい、ということだけです。もしいくつかのグループが
現れたなら、それで動作しています。一つも現れなければ、それは動作していま
せん。私は、Gnus にサーバーが @code{ask-server} を理解するかどうかを推量
させる関数を書くこともできますが、それは単に推量しているにすぎません。で
すから、その関数を書くことはないでしょう。他の方法としては、サーバー
に @code{telnet} をして、@code{HELP} と打ち、サーバーが理解するコマンド
の中に @samp{NEWGROUPS} があるかどうかを調べることもできます。もしあれば、
おそらく動作するでしょう (しかし、適切に機能を提供することな
く @samp{NEWGROUPS} をリストに含めるサーバーもあります)。

この変数は、選択方法のリストであることもできます。そのときは、
Gnus は @code{ask-server} 命令をそれぞれの選択方法に対して実行し、普通の
方法で購読します (もしくは、しません)。これの副作用は、起動にかなり時間
がかかるので、待っている間に瞑想できることです。永久の幸福を達成するため
に、マントラ ``dingnusdingnusdingnus'' を使って下さい。

@node Subscription Methods
@subsection 購読方法

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに Gnus が何をするかは、変
数 @code{gnus-subscribe-newsgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code
@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします。これがディフォルトになっ
ています。後でゾンビを (@kbd{A z} によって) 概観したり、(@kbd{S z} によっ
て) 適切にすべてを削除したり、(@kbd{u} によって) 購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファーの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数
と @code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは Gnus が @strong{すべて} のグ
ループに対して尋ねることを意味しています。購読するグループは階層的に購読
されます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@item gnus-subscribe-topics
@vindex gnus-subscribe-topics
グループを、それに合致する @code{subscribe} トピックパラメーターを持って
いるグループに入れます (@pxref{Topc Parameters})。例えば、以下のよう
な @code{subscribe} パラメーター

@example
"nnslashdot"
@end example

は、その正規表現に合致するすべてのグループはそのトピックの下で購読される
ということです。

グループに合致するトピックが無い場合、グループは最上位のトピックで購読さ
れます。
@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と密接に関係する変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数
が @code{nil} でないと、Gnus は階層的な方法で新しいグループを購読するか
どうかを尋ねます。Gnus はそれぞれの階層で、それを下に降りるかどうかを尋
ねます。

よくある間違いは、数段落前の (@code{gnus-subscribe-newsgroup-method}) 変
数を @code{gnus-subscribe-herarchical-interactive} に設定することです。
これは誤りです。これは動作しません。これはおめでたい人のすることです。で
すから、絶対にしないで下さい。

@node Filtering New Groups
@subsection 新しいグループを選別する

どの新しいグループが購読 (もしくは、無視) されるべきかを管理する快適で手
軽な方法は、@file{.newsrc} ファイルの先頭に @dfn{options} 行を挿入するこ
とです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間 (あるいは彼女はどこにでも
いる単につまらない人かもしれないけれど) が書いたものです。なぜなら、これ
は @samp{alt} と @samp{rec} で始まる名前を持つグループはすべて無視され、
@samp{sci} で始まる名前を持つグループはすべて購読する、ということを表し
ているからです。Gnus はこれらのグループを購読するのに普通の購読方法を使
いません。代わりに @code{gnus-subscribe-options-newsgroup-method} が使わ
れます。この変数のディフォルト値
は @code{gnus-subscribe-alphabetically} です。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
@file{.newsrc} ファイルをいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の二
つの変数だけを設定することもできます。この二つの変数は @file{.newsrc} ファ
イルの @samp{optinos -n} 行とまったく同じことをします。どちらの変数も正
規表現で、新しいグループは前者に合致すれば無条件に購読され、後者に合致す
ると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、
@code{gnus-auto-subscribed-groups} です。それ
は @code{gnus-options-subscribe} とまったく同じように動作するので、本当
は余分なものです。しかし、私はこの二つがあった方が良いと思いました。もう
一方の変数は利用者がいじくるのに使われるのに対して、この変数はいくつかの
基本的な規則を設定するためのものです。ディフォルトではこの変数はメールバッ
クエンド (@code{nnml}, @code{nnbabyl}, @code{nnfolder}, @code{nnmbox},
@code{nnmh} および @code{nnmaildir}) からできるすべての新しいグループを
購読するようになっています。それが嫌であれば、この変数を @code{nil} に設
定して下さい。

この正規表現に合致する新しいグループ
は @code{gnus-subscribe-options-newsgroup-method} を使って購読されます。

@node Changing Servers
@section サーバーを換える
@cindex changing servers

ときどき、ある @acronym{NNTP} サーバーから別のサーバーへ移動しなければな
らないことがあります。このようなことはめったにおきませんが、おそらくあな
たが仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換
えたいというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね? @code{gnus-select-method} を新
しいサーバーを指し示すように変更すればいいだけですね?

@emph{違います!}

記事の番号は違った @acronym{NNTP} サーバーでも (どうにかして) 同じにして
あるということはありません。そして、Gnus がどの記事を読んだかを記録する
唯一の方法は、記事番号を記録することです。ですか
ら @code{gnus-select-method} を変更したときは、@file{.newsrc} ファイルは
役に立たなくなります。

Gnus は @file{.newsrc} ファイルをあるサーバー用から別のサーバー用に変換
する関数を二、三用意しています。それらには一つ共通点があります---実行に
ながーーい時間がかかることです。おそらく、どうしても必要になったとき以外
にこの関数を使おうとは思わないでしょう。

@kindex M-x gnus-change-server
@findex gnus-change-server
もし両方のサーバーに接続できるなら、Gnus はあなたが読んだ記事すべてに対
してヘッダー (headers) を要求して、@code{Message-ID} を比較し、読んだ記
事と記事の印を新しく記録します。@kbd{M-x gnus-change-server} コマンドは
これをすべての基本グループに対して行ないます。そのコマンドは移動先の方
法 (the method) を入力することを要求します。

@kindex M-x gnus-group-move-group-to-server
@findex gnus-group-move-group-to-server
個々のグループを @kbd{M-x gnus-group-move-group-to-server} 命令で移
動することもできます。これはあるサーバーから別のサーバーへ一つ
の (外部) グループを移動したいときに役に立ちます。

@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
古いサーバーと新しいサーバーの両方に接続することができないとき、印と読ん
だ範囲はすべて意味が無くなります。そのようなとき
は @kbd{M-x gnus-group-clear-data-on-native-groups} コマンドを使って、基
本グループに関するデータをすべて消去することができます。このコマンドは注
意して使って下さい。

@kindex M-x gnus-group-clear-data
@findex gnus-group-clear-data
@code{gnus-group-clear-data} コマンドは現在のグループのすべてのデータを
クリアします---マークと既読記事のリストを消し去ります。

サーバーを変更した後で、キャッシュ階層を移動させなけれ
ば @strong{なりません}。というのは、キャッシュ記事は間違った記事番号になっ
ており、それは Gnus がどの記事を読んだとみなすかに影響します。
@code{gnus-group-clear-data-on-native-groups} はそれを自動で行なってしま
うかどうかを尋ねます。@code{gnus-group-clear-data} では @kbd{M-x
gnus-cache-move-cache} が使えます (でも気を付けて、それはすべてのグルー
プのキャッシュを移動してしまいますから)。

@node Startup Files
@section 起動ファイル
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

最もありふれた Unix のニュースリーダーは、@file{.newsrc} と呼ばれる共用
の起動ファイルを使います。このファイルは、講読しているグループと、それら
のグループにおいてどの記事が読まれたかの、すべての情報を持っています。

@sc{gnus} ではものごとが少々複雑になっています。@file{.newsrc} ファイル
を最新のものにするだけではなく、@file{.newsrc} ファイルには合わない情報
を保存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。(実
際は @file{.newsrc} ファイルのすべての情報を複製して保持しています。)
@sc{gnus} はこれらの中で一番最後に保存されたものを使います。これをするこ
とにより、@sc{gnus} と他のニュースリーダーを切り替えて使うことができます。

これはちょっと間が抜けているので、Gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、
Gnus は @file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれ
らの中で一番新しいファイルを読みますが、@file{.newsrc.el} ファイルに書き
込むことはありません。@file{.newsrc.eld} ファイルは絶対に消すべきではあ
りません。---それは @file{.newsrc} ファイルにはないたくさんの情報を保持
しています。

@vindex gnus-save-newsrc-file
@vindex gnus-read-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによっ
て @file{.newsrc} ファイルに書き込むのを止めることができます。そうすれば、
そのファイルを削除することができ、ディスク容量を節約することができ、
Gnus の終了が速くなります。しかし、そうすると他のニュースリーダーを使え
なくなります。でも、ちょっと、誰かそうしたい人がいるでしょうか。同じよう
に @code{gnus-read-newsrc-file} を @code{nil} にすることによって、
Gnus は @file{.newsrc} ファイルとすべての @file{.newsrc-SERVER} ファイル
を無視するようになります。そのことは、あなたが時々違うニュースリーダーを
使ったり、利用可能なグループの異なるサブセットをそれらのニュースリーダー
で読みたい場合に、便利なことがあります。

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (ディフォルト値
は @code{t}) が @code{nil} であると、Gnus は削除されたグループを起動ファ
イルに保存しません。これは、(起動時と終了時の) 時間と、(ディスクの) 容量
を節約します。こうすると Gnus がどのグループが新しいかの記録を持っていな
いことになるので、新しいグループの自動購読方法は意味が無くなります。この
変数を @code{nil} にしたときは、@code{gnus-check-new-newsgroups} を常
に @code{nil} か @code{ask-server} にしておくべきでしょう (@pxref{New
Groups})。この変数は正規表現であることもできます。そのような場合は、ファ
イルを保存する直前にその正規表現に合致しないすべてのグループを消去します。
これは、すべてのサーバーが @code{ask-server} を理解するわけではない、と
いったような、いくらかあいまいな状況のときに役に立つでしょう。

@vindex gnus-startup-file
@vindex gnus-backup-startup-file
@vindex version-control
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
ディフォルト値は @file{~/.newsrc} で、それがどのようなものであれ、末尾
に @samp{.eld} を付けたものが Gnus (El Dingo) の起動ファイルになります。
このファイルのバージョン制御をしたいとき
は @code{gnus-backup-startup-file} をセットして下さい。それ
は @code{version-control} 変数と同じ値を取ります。

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は各種の newsrc ファイルのどれかを保存する
前に実行されるのに対し、
@code{gnus-save-quick-newsrc-hook} は @file{.newsrc.eld} ファイルを保存
する前に実行され、
@code{gnus-save-standard-newsrc-hook} は @file{.newsrc} ファイルを保存す
る前に実行されます。後の二つは普通はバージョン制御を on/off するのに使わ
れます。ディフォルトでは、起動ファイルを保存するときにバージョン制御が行
なわれます。バックアップファイルの作成を止めたいときは、次のようにして下
さい。

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
@vindex gnus-site-init-file
Gnus が起動すると、@code{gnus-site-init-file} (ディフォルト値
は @file{.../site-lisp/gnus-init}) と @code{gnus-init-file} (ディフォル
ト値は @file{~/.gnus}) のファイルを読み込みます。これらは普通
の Emacs Lisp ファイルで、@file{~/.emacs} や @file{site-init} ファイル
を Gnus 関係のもので乱雑にしないようにするために使うことができます。
Gnus はこれらと同じ名前のファイルに、接尾語 @file{.elc} と @file{.el} が
付いているものも調べます。言い換えれば、
@code{gnus-init-file} を @file{~/.gnus} に設定すると、
Gnus は @file{~/.gnus.elc}, @file{~/.gnus.el} を探し、最後
に @file{~/.gnus} を (この順番に) 探します。@option{-q} また
は @option{--no-init-file} オプション (@pxref{Initial Options, ,Initial
Options, emacs, The Emacs Editor}) が指定されて Emacs が起動された場合、
Gnus は @code{gnus-init-file} を読み込みません。

@node Auto Save
@section 自動保存
@cindex dribble file
@cindex auto-save

何か Gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別
な @dfn{ドリブルバッファー (dribble buffer)} に書き込まれます。このバッ
ファーは Emacs が普通するように自動保存されます。@file{.newsrc} ファイル
を保存する前に Emacs が落ちたときは、すべての変更をこのファイルから回復
することができるでしょう。

起動時に Gnus がこのファイルの存在を発見すると、Gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、Gnus はドリブルバッ
ファーを作ったり、維持したりしません。ディフォルト値は @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
Gnus は @file{.newsrc} ファイルの置かれているディレクトリー (これは普通
は利用者のホームディレクトリーです) に入っていってドリブルファイルを作り
ます。ドリブルファイルは @file{.newsrc} と同じ許可属性を与えられます。

@vindex gnus-always-read-dribble-file
もし @code{gnus-always-read-dribble-file} が @code{nil} でなければ、
Gnus は利用者に尋ねること無く、ドリブルファイルを起動時に読み込みます。

@node The Active File
@section アクティブファイル
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを判定しようとす
るときに、アクティブファイルを読み込みます。これはとても大きなファイルで、
そのサーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
アクティブファイルを検査する前に、Gnus は正規表
現 @code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主
に偽の名前を持つグループを排除するために使われてきましたが、興味の無いグ
ループの階層を無視するために使うこともできます。しかし、これはお勧めでき
ません。本当のことを言うと、まったく賛成できません。代わりに、そのような
用途に用いられる変数の概略を知るために、@ref{New Groups} を参照して下さ
い。
@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
アクティブファイルは比較的大きくなる傾向があるので、遅い回線を使っている
ときは、アクティブファイルを読み込まないよう
に @code{gnus-read-active-file} を @code{nil} に設定することができます。
この変数はディフォルトでは @code{some} です。

そのような時は、Gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} に設定すると、Gnus は速くなるどころか遅くなっ
てしまうということです。現状では、ニュースを 2400bps 以上のモデムを通し
て読んでいるのでない限り、Gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、Gnus は購
読しているグループに関する情報をだけを得ようとします。いくつかのサー
バー (@code{LIST ACTIVE group} 命令を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん @code{t} よりも速くなります。

いくつかのニュースサーバー (例えば古い Leafnode や古い INN) に
は @code{LIST ACTIVE group} 命令がありません。そういうサーバーに
は @code{nil} をこの変数の値に設定するのが、おそらくもっとも有効でしょう。

もしこの変数が @code{nil} であると、Gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @acronym{NNTP} サーバーを使っているときは、Gnus はで
きるだけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通は
より良い結果をもたらしますが、サーバーが @code{LIST ACTIVE group} 命令を
理解しないなら、サーバーにとってはあまり良いとは言えません。

Gnus の起動にあまりに時間がかかると思ったなら、この変数にこれらの三つの
違った値を試してみて、どれが一番良いかを探して下さい。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は二次 (secondary) 選択方法のアクティブファイル取得にも影響する
ことに気を付けて下さい。

@node Startup Variables
@section 起動変数

@table @code
@item gnus-load-hook
@vindex gnus-load-hook
Gnus (のプログラム) が読み込まれるときに実行されるフックです。何
度 Gnus を起動しても、Emacs が起動してから終了するまでに普通はこのフック
は一回しか実行されないことに注意して下さい。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus の起動に成功した後に実行されるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-setup-news-hook
@vindex gnus-setup-news-hook
@file{.newsrc} ファイルを読み込んだ後で、グループバッファーを作成する前
に実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、Gnus は起動時にすべての偽グループを調べて削除
します。@dfn{偽グループ (bogus group)} はあなたの @file{.newsrc} ファイ
ルには存在するけれど、ニュースサーバーには実際には存在しない、というグルー
プのことです。偽グループを調べるのにはかなり時間がかかるので、時間と資源
を節約するために、この機能は使わないほうがいいでしょう。そして、代わりに
グループバッファーで時々偽グループを調べるのが良いでしょう (@pxref{Group
Maintenance})。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニュースを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{~/.gnus.el} がロードされる前に使われるので、
@file{.emacs} に設定するべきである点を注意して下さい。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに Gnus が表示するメッセージです。

@item gnus-play-startup-jingle
@vindex gnus-play-startup-jingle
もし @code{nil} でないと、起動時に Gnus の短い曲を演奏します。

@item gnus-startup-jingle
@vindex gnus-startup-jingle
上の変数が @code{nil} でないときに演奏される短い曲です。ディフォルト値
は @samp{Tuxdemoon.Jingle4.au} です。
@end table

@node Group Buffer
@chapter グループバッファー
@cindex group buffer
@c Alex Schroeder suggests to rearrange this as follows:
@c
@c <kensanata> ok, just save it for reference.  I'll go to bed in a minute.
@c   1. Selecting a Group, 2. (new) Finding a Group, 3. Group Levels,
@c   4. Subscription Commands, 5. Group Maneuvering, 6. Group Data,
@c   7. Group Score, 8. Group Buffer Format
@c <kensanata> Group Levels should have more information on levels 5 to 9.  I
@c   suggest to split the 4th paragraph ("Gnus considers groups...") as follows:
@c <kensanata> First, "Gnus considers groups... (default 9)."
@c <kensanata> New, a table summarizing what levels 1 to 9 mean.
@c <kensanata> Third, "Gnus treats subscribed ... reasons of efficiency"
@c <kensanata> Then expand the next paragraph or add some more to it.
@c    This short one sentence explains levels 1 and 2, therefore I understand
@c    that I should keep important news at 3 and boring news at 4.
@c    Say so!  Then go on to explain why I should bother with levels 6 to 9.
@c    Maybe keep those that you don't want to read temporarily at 6,
@c    those that you never want to read at 8, those that offend your
@c    human rights at 9...

グループバッファー (@dfn{group buffer}) は有効なグループを全部 (あるいは
一部を) 一覧表示します。これは Gnus を起動したときに最初に表示されるバッ
ファーで、Gnus が生きている限り決して消されることはありません。

@iftex
@iflatex
\gnusfigure{The Group Buffer}{320}{
\put(75,50){\epsfig{figure=ps/group,height=9cm}}
\put(120,37){\makebox(0,0)[t]{Buffer name}}
\put(120,38){\vector(1,2){10}}
\put(40,60){\makebox(0,0)[r]{Mode line}}
\put(40,58){\vector(1,0){30}}
\put(200,28){\makebox(0,0)[t]{Native select method}}
\put(200,26){\vector(-1,2){15}}
}
@end iflatex
@end iftex
@menu
* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュース読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Misc Group Stuff::            他にできること
@end menu

@node Group Buffer Format
@section グループバッファーの形式

@menu
* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける
@end menu

@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファーのディフォルトの形式はきれいでつまんないけど、これは君
の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ?

@samp{news.announce.newusers} には 25 の未読記事があるのがわかります。
@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、印を付けた記事
がいくつかあります (行頭のちっちゃなアスタリスクが見える?)。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、どんな風に
でも変えられます。この変数は @code{format} の仕様風に動作します。つま
り (あのクソ) C 言語を使う人たちのため、printf の仕様とほぼ同じです。
@xref{Formatting Variables}.

上記の行を生成するのは @samp{%M%S%5y:%B%(%g%)\n} という値です。

コロンは、この行の中に必ず無くてはいけません。カーソルは何かの操作をした
後は常にコロンのところに移動するからです。@xref{Positioning Point}. 他に
は何も必要ではありません---グループ名さえもです。表示されている文字はす
べてただの画面の飾りであり、Gnus がそれを調べることはありません。Gnus は
必要とするすべての実情報を、テキスト属性を使って憶えています。

(もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとした
ら、みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使いし
たりなんかしてない、って信じてくれるよ。)

以下が使用できるフォーマット文字のリストです。

@table @samp
@item M
そのグループに印のついた記事しか無いときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item U
まだ読まれたことが無い記事の数。

@item t
推定全記事数 (これは実際は @var{max-number} - @var{min-number} + 1)。

Gnus がこの推定を使うのは、@acronym{NNTP} プロトコルは能率の良
い @var{max-number} と @var{min-number} へのアクセスを提供するものの、本
当の未読記事の数を得るには必ずしも能率的ではないからです。ヒステリックな
レーズン (訳注: 歴史的な理由のモジりか?) により、メールバックエンドにお
いても、限定された同じインターフェースを使って、本当の未読記事の数を能率
的に得ることはできるかもしれません。この制限を Gnus から取り払うことはバッ
クエンドのインターフェースを変更することを意味し、それは楽な仕事ではあり
ません。あなたがこの仕事をやりたいならば、どうぞ Gnus メーリングリストに
連絡して下さい。

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item C
グループのためのコメント (@pxref{Group Parameters})、またはグループパラ
メーターにコメントの要素が無い場合はグループ名。

@item D
ニュースグループの説明。これらが現れる前に、グループの説明を読む必要があ
ります。それには @code{gnus-read-active-file} を設定するか、グループバッ
ファーで @kbd{M-d} コマンドを使って下さい。

@item o
司会者付きの場合 @samp{m}。

@item O
司会者付きの場合 @samp{(m)}。

@item s
選択方法。

@item B
そのグループの概略バッファーが開いているかどうか。

@item n
どこからの選択か。(訳注: バックエンドのシンボル名)

@item z
外部選択方法が使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック (@pxref{Group Topics}) のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い (省略した) グループ名。@code{gnus-group-uncollapsed-levels} 変数は、
どのレベルまでグループ名を全部残すかを示します。ディフォルト値は 1 で
す---この意味は、@samp{gnu.emacs.gnus} のようなグループ名
を @samp{g.e.gnus} に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合
は @samp{%} (@code{gnus-new-mail-mark})。

@item p
@samp{#} (@code{gnus-process-mark}) で、そのグループにプロセス印が付いて
いることを示します。

@item d
最後にいつこのグループを読んだかを示す文字列 (@pxref{Group Timestamp})。

@item F
キャッシュとエージェントの両方によって取得された記事がディスクに占める容
量。値はカラム幅を最小にするために、自動的にバイト (B)、キロバイト (K)、
メガバイト (M)、またはギガバイト (G) に縮尺されます。固定幅カラム用には
%7F の形式で足ります。

@item u
利用者定義指定。フォーマット文字列中で、この次の文字はアルファベット文字
でなければいけません。
Gnus は @code{gnus-user-format-function-}@samp{X} 関数を呼び出します。こ
こで @samp{X} は @samp{%u} に続いている文字です。この関数は引数に一つの
ダミーパラメーターを渡されます。この関数は、他の各指定文字の情報と同様に、
バッファーに挿入される文字列を返さなければなりません。
@end table

@cindex *
すべての「〜の数」の指定は、もしその情報が利用できない場合にはアスタリス
ク (@samp{*}) で埋められます---例えば、起動されていない外部グループや、
不正な基本グループの場合です。

@node Group Mode Line Specification
@subsection グループモード行の仕様
@cindex group mode line

@vindex gnus-group-mode-line-format
モード行
は @code{gnus-group-mode-line-format} (@pxref{Mode Line Formatting}) を
設定することで変更できます。こいつは指定文字をあんまりたくさん知っていま
せん。

@table @samp
@item S
基本ニュースサーバー。
@item M
基本選択方法。
@end table

@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファーのハイライトは @code{gnus-group-highlight} 変数によっ
て制御されます。これは @code{(@var{form} . @var{face})} のようなものを要
素に持つ連想リストです。@var{form} が評価された結果が、@code{nil} 以外の
何かになると、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見えるかもし
れません。

@lisp
(cond (window-system
       (setq custom-background-mode 'light)
       (defface my-group-face-1
         '((t (:foreground "Red" :bold t))) "First group face")
       (defface my-group-face-2
         '((t (:foreground "DarkSeaGreen4" :bold t))) "Second group face")
       (defface my-group-face-3
         '((t (:foreground "Green4" :bold t))) "Third group face")
       (defface my-group-face-4
         '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
       (defface my-group-face-5
         '((t (:foreground "Blue" :bold t))) "Fifth group face")))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
        ((and (< level 3) (zerop unread)) . my-group-face-2)
        ((< level 3) . my-group-face-3)
        ((zerop unread) . my-group-face-4)
        (t . my-group-face-5)))
@end lisp

@ref{Faces and Fonts} も参照して下さい。

この form が評価されるときに動的に束縛されている変数には以下のものがあり
ます。

@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択方法。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、@var{max-number} マイナス
@var{min_number} プラス 1.
@item topic
トピックマイナーモードを使用している時、この変数は挿入されている現在のト
ピックに束縛されます。
@end table

この form が評価 (@code{eval}) されるときは、ポイントは問題のグループの
行頭にあります。従って、通常の Gnus の関数のほとんどを使ってそのグループ
の情報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び出されま
す。これは @code{gnus-visual} が @code{nil} のときは呼び出されません。こ
のフックはディフォルトでは @code{gnus-group-highlight-line} を呼び出しま
す。

@node Group Maneuvering
@section グループ操作
@cindex group movement

すべての移動コマンドは数値接頭引数を理解するので、期待する通りの動作をし
ます。たぶんね。

@table @kbd
@item n
@kindex n (グループ)
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動しま
す (@code{gnus-group-next-unread-group})。

@item p
@itemx DEL
@kindex DEL (グループ)
@kindex p (グループ)
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動しま
す (@code{gnus-group-prev-unread-group})。

@item N
@kindex N (グループ)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P (グループ)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-n
@kindex M-n (グループ)
@findex gnus-group-next-unread-group-same-level
一つ前の同じレベル (もしくはそれより小さいレベル) の未読グループに移動し
ます (@code{gnus-group-prev-unread-group-same-level})。

@item M-p
@kindex M-p (グループ)
@findex gnus-group-prev-unread-group-same-level
次の同じレベル (もしくはそれより小さいレベル) の未読グループに移動しま
す (@code{gnus-group-next-unread-group-same-level})。
@end table

次の三つの命令はグループにジャンプするためのものです:

@table @kbd
@item j
@kindex j (グループ)
@findex gnus-group-jump-to-group
グループにジャンプします (それが見えるようになっていなかったら見えるよう
にします) (@code{gnus-group-jump-to-group})。kill されているグループも、
生きているグループと同様にジャンプできます。

@item ,
@kindex , (グループ)
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプしま
す (@code{gnus-group-best-unread-group})。

@item .
@kindex . (グループ)
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプしま
す (@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} を @code{nil} にすると、すべての移動コマン
ドは、次の未読グループではなく次のグループに移動するようになります。その
コマンドが次の未読グループに移動すると言い張っていてもです。ディフォルト
値は @code{t} です。

@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd
@item SPACE
@kindex SPACE (グループ)
@findex gnus-group-read-group
現在のグループを選択し、概略バッファーに切り替えて最初の未読記事を表示し
ます (@code{gnus-group-read-group})。もしそのグループに未読記事が無い、
もしくはこの命令に数値以外の接頭引数を与えると、Gnus はサーバーからこの
グループのすべての古い記事を取得しようとします。@var{n} の数値接頭引数を
与えると、Gnus の取得する記事数は @var{n} になります。@var{n} が正の数で
あれば Gnus は新しい方から @var{n} 個の記事を取得し、@var{n} が負の数で
あれば Gnus は古い方から @code{abs(@var{n})} 個の記事を取得します。

したがって、@kbd{SPC} では普通にグループに入り、@kbd{C-u SPC} では古い記
事が現れます。@kbd{C-u 4 2 SPC} では 42 個の最新の記事を取得し、@kbd{C-u
- 4 2 SPC} では 42 個の最も古い記事を取得します。

グループにいる (概略バッファーにいる) ときは、@kbd{M-g} で新しい記事を取
得できるし、@kbd{C-u M-g} では古い記事を表示することができます。

@item RET
@kindex RET (グループ)
@findex gnus-group-select-group
現在のグループを選択し、概略バッファーに切り替えま
す (@code{gnus-group-select-group})。@code{gnus-group-read-group} と同じ
引数を取ります---唯一の違いは、グループに入ったときに最初の未読記事を表
示しない、ということです。

@item M-RET
@kindex M-RET (グループ)
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にしようと
します (@code{gnus-group-quick-select-group})。スコア・kill の処理は行な
われず、ハイライトも記事消去もしません。これは、あなたが本当に急いでいて、
どっかのやたらでっかいグループに入らなければいけないときに役に立つかもし
れません。また、接頭引数に 0 を与えれば (すなわち @kbd{0 M-RET})、
Gnus は概略バッファーを作ろうとさえしません。これは概略バッファーを作る
前にスレッド表示を切り替えたいとき役に立ちます (@pxref{Summary
Generation Commands})。

@item M-SPACE
@kindex M-SPACE (グループ)
@findex gnus-group-visible-select-group
これは @kbd{RET} コマンドと同じ動作をするさらにもう一つのコマンドですが、
このコマンドは記事消去と保留記事を隠す処理を行ないませ
ん (@code{gnus-group-visible-select-group})。

@item C-M-RET
@kindex C-M-RET (グループ)
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の処理をす
ることのないように選択しま
す (@code{gnus-group-select-group-ephemerally})。スレッド表示さえも行な
われません。この方法で選択した後にこのグループに対して行なったことはすべ
て、その後に影響を与えることはありません。
@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべきか
を Gnus に与えます。@code{nil} だったら、どのグループも大きいと考えませ
ん。ディフォルト値は 200 です。グループに (未読と可視の) 記事がこの数以
上あれば、Gnus はそのグループに入る前に利用者に確認を求めます。利用者は
サーバーからいくつの記事を取得するかを指定できます。もし利用者が負の
数 (@var{-n}) を指定すれば、古い方から @var{n} 個の記事を取得します。正
の数であれば、新しく到着した方から @var{n} 個の記事を取得します。

@vindex gnus-large-ephemeral-newsgroup
@code{gnus-large-ephemeral-newsgroup} は @code{gnus-large-newsgroup} と
同じですが、一時ニュースグループのためにだけ使われます。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
@vindex gnus-auto-select-subject
もし @code{gnus-auto-select-first} が非-@code{nil} だったら、
@kbd{SPACE} コマンドでグループに入ったときに自動的に記事を選択します。ど
の記事が選択されるかは、変数 @code{gnus-auto-select-subject} で制御され
ます。この変数に設定できる有効な値は:

@table @code
@item unread
最初の未読記事の表題の行にポイントを移動させます。

@item first
最初の記事の表題の行にポイントを移動させます。

@item unseen
まだ読まれたことが無い最初の記事の表題の行にポイントを移動させます。

@item unseen-or-unread
まだ読まれたことが無い最初の記事があれば、その記事の表題の行にポイントを
移動させ、無かったら最初の未読記事の表題の行にポイントを移動させます。

@item best
スコアが最も高い未読記事の表題の行にポイントを移動させます。
@end table

この変数は関数であることもできます。その場合、その関数は表題の行にポイン
トを移動させるために呼ばれます。

もしあるグループで自動記事選択をやめたいのであれば (例えばでっかい記事の
あるバイナリグループでは、とか)、グループが選択されたときに呼び出され
る @code{gnus-select-group-hook} の中で変
数 @code{gnus-auto-select-first} を @code{nil} に設定することができます。

@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

@table @kbd
@item S t
@itemx u
@kindex S t (グループ)
@kindex u (グループ)
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループを購読する/しないを切り替えま
す (@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s (グループ)
@kindex U (グループ)
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するようになっ
ている場合には、購読を止めます (@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k (グループ)
@kindex C-k (グループ)
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y (グループ)
@kindex C-y (グループ)
@findex gnus-group-yank-group
最後に kill したグループを yank します (@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t (グループ)
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます (@code{gnus-group-transpose-groups})。
これは本当は購読コマンドではありませんが、kill と yank を何度か続ける代
わりにこのコマンドが使えます。

@item S w
@itemx C-w
@kindex S w (グループ)
@kindex C-w (グループ)
@findex gnus-group-kill-region
リージョン内のすべてのグループを kill しま
す (@code{gnus-group-kill-region})。

@item S z
@kindex S z (グループ)
@findex gnus-group-kill-all-zombies
すべてのゾンビグループを kill しま
す (@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k (グループ)
@findex gnus-group-kill-level
あるレベルのグループをすべて kill します (@code{gnus-group-kill-level})。
kill した後、これらのグループを yank で戻すことはできないので、このコマ
ンドはいくらか注意して使って下さい。このコマンドが本当に便利になるのは、
@file{.newsrc} に捨ててしまいたい未購読のグループがたくさんあるときだけ
です。レベル 7 で @kbd{S C-k} を行なうと、@file{.newsrc} ファイル中にメッ
セージ番号がない未購読グループをすべて kill します。
@end table

@ref{Group Levels} も参照して下さい。

@node Group Data
@section グループデータ

@table @kbd
@item c
@kindex c (グループ)
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内のすべての無印の記事を既読にしま
す (@code{gnus-group-catchup-current})。グループバッファーから既読にした
場合は @code{gnus-group-catchup-group-hook} が呼び出されます。

@item C
@kindex C (グループ)
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にしま
す (@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c (グループ)
@findex gnus-group-clear-data
現在のグループのすべてのデータをクリアします---マークと既読記事のリスト
を消し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@kindex M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし @acronym{NNTP} サーバーを別のものに切り替えたとすると、すべてのマー
クと既読情報はもう役には立ちません。このコマンドを使って基本グループのす
べてのデータをクリアすることができます。注意して使ってね。
@end table

@node Group Levels
@section グループレベル
@cindex group level
@cindex level

すべてのグループは @dfn{購読度} (@dfn{subscribedness}) のレベルを持ちま
す。例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグループ
よりも「より購読している」ということです。Gnus に対して、あるレベルかそ
れより小さいレベルのグループのみ一覧表示するように頼むこともできる
し (@pxref{Listing Groups})、あるレベルかそれより小さいレベルのグループ
の新着記事のみを確認することもできます (@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd
@item S l
@kindex S l (グループ)
@findex gnus-group-set-current-level
現在のグループのレベルを設定します。数値の接頭引数が与えられると、そこか
ら @var{n} 個のグループのレベルが設定されます。レベルを入力するためのプ
ロンプトが出ます。
@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed} (この値を含む) (ディフォ
ルト値は 5) までのグループを購読、@code{gnus-level-subscribed} (この値を
含まない) から @code{gnus-level-unsubscribed} (この値を含む) (ディフォル
ト値は 7) までのグループを非購読、@code{gnus-level-zombie} をゾンビ (歩
く屍) (ディフォルト値は 8)、@code{gnus-level-killed} を kill されてい
る (完全に死んでる) (ディフォルト値は 9) と判断します。Gnus は購読と非購
読のグループはまったく同様に扱いますが、ゾンビと kill グループは、どの記
事を読んだか、存在するかなどの情報を一切持ちません。この死んでるグループ
と生きてるグループの区別は、別にそれがきれいだからとか賢いからというわけ
ではなく、純粋に効率的な理由のためです。

メール用のグループは (もしあれば) 非常に小さいレベル (例えば 1 か 2) に
しておくことをお勧めします。

次の Gnus のディフォルトの動作の説明は、ことによると、これらのレベルのす
べてを理解する助けになるかもしれません。ディフォルトでは、Gnus は講読し
ている空でないグループを表示しますが、@kbd{L} を叩くことによって空のグルー
プや非講読のグループも表示させることができます。つまり、非講読のグループ
は隠されている、と言っても良いでしょう。

ゾンビと kill グループは、ディフォルトでは隠されている点で非講読のグルー
プに似ています。しかし、Gnus がニュースサーバーに対してゾンビと kill グ
ループに関する情報 (記事数、未読記事数) の問い合わせをしない点で、購読お
よび非購読のグループとは違っています。ふつう、あなたは興味の無いグループ
を @kbd{C-k} で kill しますよね。もし、ほとんどのグループが kill されて
いると、Gnus は速くなります。

なぜ Gnus はゾンビと kill グループを区別するのでしょう?  ええと、サーバー
に新しいグループができると、Gnus はディフォルトでそれをゾンビにします。
これは、あなたがふつうは新しいグループに煩わされないことを意味しますが、
あなたは @kbd{A z} で新しいグループのリストを得ることができます。あなた
は好みのものを講読し、要らないものは kill すれば良いのです。
(@kbd{A k} で kill されたグループのリストを表示します。)

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があります。
いったんそれを設定したら、二度とそれに触らないで下さい。さらに言えば、自
分で何をやっているかを正確に理解していない限り、一切触らないで下さい。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する二つの変数は @code{gnus-level-default-subscribed} (ディフォ
ルト値は 3) と @code{gnus-level-default-unsubscribed} (ディフォルト値
は 6) です。これらは新しいグループが (非) 購読されたときのレベルです。も
ちろん、これら二つの変数の値は、意味のある正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマンドのい
くつかは同一 (あるいはそれより小さい) レベルのグループのみの移動になりま
す。特に、あるグループの最後の記事から次のグループに移るとき、次の同
一 (あるいはそれより小さい) レベルのグループに移動します。これは残りのグ
ループを読むより先に、より重要なグループを読んでおきたいときには便利かも
しれません。

もしこの値が @code{best} だったら、最も重要な (最もレベルの値が小さ
い) グループに移動します。

@vindex gnus-group-default-list-level
ディフォルトでは @code{gnus-group-default-list-level} と同じかそれより小
さいレベルのグループが、グループバッファーに一覧表示されます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれば、未読
のグループにアクティブでないグループも一緒に表示します。この変数はディフォ
ルトでは @code{t} です。もしこれが @code{nil} であれば、アクティブでない
グループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれば、いっ
たん @kbd{g} や @kbd{l} コマンドの接頭引数にレベルを与えると、その後のす
べてのコマンドにおいてそのレベルが「作用する」レベルになります。

@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルのグループ
のみを起動します (つまりサーバーに問い合わせをする)。購読していないグルー
プを起動したくなければ、この変数を例えば 5 に設定するとよいかもしれませ
ん。ディフォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方法では少々
制限がきついですよね。ひょっとしたら、グループをどれくらい頻繁に読むかに
よってグループバッファーを並べ替えたいなあ、なんて思いませんか? 理にかなっ
てるでしょ?

@dfn{グループスコア} (@dfn{group score}) はそのためのものです。Gnus に以
下で説明されている機構で、それぞれのグループに対してスコアを指定すること
ができます。そしてグループバッファーをこのスコアを基に並べ替えることがで
きます。あるいは、スコア順で並べ替えてその後レベルで並べ替えることもでき
ます。(レベルとスコアをひとまとめにして、グループ
の @dfn{ランク} (@dfn{rank}) と呼びます。レベルが 4 でスコアが 1 のグルー
プは、レベルが 5 でスコアが 300 のグループよりも高いランクとなります。
(レベルの方が重要度が高く、スコアの方は重要度が低くなります。))

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えたい
ときは、@code{gnus-summary-exit-hook} フック
に @code{gnus-summary-bubble-group} 関数を追加することができます。これで
バブル並べ替えの実行結果が (並べ替えの後で) 得られるでしょう。概略モード
を終了するたびにこの活動をさせたいのであれば、同じフック
に @code{gnus-group-sort-groups-by-rank} また
は @code{gnus-group-sort-groups-by-score} を追加できますが、いくらか遅く
なるでしょう。

@node Marking Groups
@section グループへの印
@cindex marking groups

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらがグ
ループバッファーに連続してある場合には、通常通り命令に対して数値接頭引数
を与えるだけです。そうすればほとんどのグループ命令は、これらのグループに
対してあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグルー
プに対して命令を実行することができます。単に始めにプロセス印でグループに
印を付けておき、そして命令を実行するだけです。

@table @kbd
@item #
@kindex # (グループ)
@itemx M m
@kindex M m (グループ)
@findex gnus-group-mark-group
現在のグループに印を付ける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# (グループ)
@itemx M u
@kindex M u (グループ)
@findex gnus-group-unmark-group
現在のグループから印を削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U (グループ)
@findex gnus-group-unmark-all-groups
すべてのグループから印を削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w (グループ)
@findex gnus-group-mark-region
ポイントとマークの間のすべてのグループに印を付け
る (@code{gnus-group-mark-region})。

@item M b
@kindex M b (グループ)
@findex gnus-group-mark-buffer
バッファー内のすべてのグループに印を付ける (@code{gnus-group-mark-buffer})。

@item M r
@kindex M r (グループ)
@findex gnus-group-mark-regexp
ある正規表現に合致するすべてのグループに印を付け
る (@code{gnus-group-mark-regexp})。
@end table

@ref{Process/Prefix} も参照して下さい。

@findex gnus-group-universal-argument
プロセス印が付けられているすべてのグループに対して何かの命令を実行したい
ときは、@kbd{M-&} (@code{gnus-group-universal-argument}) 命令を使うこと
ができます。プロンプトから実行したい命令を入力します。

@node Foreign Groups
@section 外部グループ
@cindex foreign groups

以下では、一般的な外部グループの作成、変更を行なうグループモードの命令を
いくつか、および特別な目的のグループを簡単に作成する命令を紹介します。こ
れらの命令はすべて、新規に作成したグループをポイント位置に挿入しま
す---@code{gnus-subscribe-newsgroup-method} は参照されません。

@table @kbd
@item G m
@kindex G m (グループ)
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前と方法と、場合によっては @dfn{address} の入力を求め
てきます。より簡単に @acronym{NNTP} グループを購読する方法については、
@ref{Browse Foreign Server} を参照して下さい。

@item G M
@kindex G M (グループ)
@findex gnus-group-read-ephemeral-group
一時ニュースグループを作成しま
す (@code{gnus-group-read-ephemeral-group})。 Gnus はプロンプトを表示し
て、名前、方法および @dfn{address} の入力を求めます。

@item G r
@kindex G r (グループ)
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更しま
す (@code{gnus-group-rename-group})。これはある種のグループ---主にメール
グループに対してのみ有効です。このコマンドはバックエンドによっては非常に
遅いことも有り得ます。

@item G c
@kindex G c (グループ)
@cindex customizing
@findex gnus-group-customize
グループパラメーターをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e (グループ)
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択方法を修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group-method})。

@item G p
@kindex G p (グループ)
@findex gnus-group-edit-group-parameters
グループパラメーターを修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E (グループ)
@findex gnus-group-edit-group
グループ情報を修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group})。

@item G d
@kindex G d (グループ)
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリーグループを作成します (@pxref{Directory Groups})。ディレク
トリー名をプロンプトで入力しま
す (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h (グループ)
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G a
@kindex G a (グループ)
@cindex (ding) archive
@cindex archive group
@findex gnus-group-make-archive-group
@vindex gnus-group-archive-directory
@vindex gnus-group-recent-archive-directory
Gnus アーカイブグループを作成しま
す (@code{gnus-group-make-archive-group})。ディフォルトでは最も最近の記
事を指しているグループが作成されます
が (@code{gnus-group-recent-archive-directory})、接頭引数を与えるとすべ
ての記事を含むグループが @code{gnus-group-archive-directory} を基に作成
されます。

@item G k
@kindex G k (グループ)
@findex gnus-group-make-kiboze-group
@cindex nnkiboze
kiboze グループを作成します。プロンプトで名前と、kiboze グループに「含め
たい」グループに合う正規表現と、ヘッダーに合う文字列の組を入力しま
す (@code{gnus-group-make-kiboze-group})。@xref{Kibozed Groups}.

@item G D
@kindex G D (グループ)
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリーを @code{nneething} バックエンドニュースグループであ
るかのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f (グループ)
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
ファイルなどをもとにグループを作成しま
す (@code{gnus-group-make-doc-group})。このコマンドに接頭引数を与えた場
合、ファイル名とファイルタイプをプロンプトで入力します。現在サポートされ
ているファイルタイプは @code{mbox}, @code{babyl}, @code{digest},
@code{news}, @code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx} および @code{mailman} です。接頭引数なしでこのコマンドを実
行すると、Gnus はファイルタイプを推測します。@xref{Document Groups}.

@item G u
@kindex G u (グループ)
@vindex gnus-useful-groups
@findex gnus-group-make-useful-group
@code{gnus-useful-groups} にあるグループの一つを作りま
す (@code{gnus-group-make-useful-group})。

@item G w
@kindex G w (グループ)
@findex gnus-group-make-web-group
@cindex Google
@cindex nnweb
@cindex gmane
ウェブ検索結果をもとに一時的なグループを作成しま
す (@code{gnus-group-make-web-group})。このコマンドに接頭引数を与えると、
一時的ではなく固定したグループを作成します。プロンプトで検索エンジンの種
類 (search engine type) と検索文字列を入力します。有効な検索エンジンの種
類には @code{google}, @code{dejanews}, @code{gmane} があります。
@xref{Web Searches}.

もし、@code{google} 検索エンジンを用いる場合には、
@samp{shaving group:alt.sysadmin.recovery} のような合致する文字列を用い
ることによって、検索対象を特定のグループに限定することが可能です。

@item G R
@kindex G R (グループ)
@findex gnus-group-make-rss-group
@acronym{RSS} feed に基づくグループを作りま
す (@code{gnus-group-make-rss-group})。URL の入力を促されます。
@xref{RSS}.

@item G DEL
@kindex G DEL (グループ)
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。
接頭引数が与えられると、この関数はそのグループ内の全記事を本当に削除し、
グループ自身をこの世から強制的に抹殺してしまいます。接頭引数は、あなたが
何をやろうとしているか、本当に自信があるときにのみ使って下さい。まあ、こ
のコマンドは (@code{nntp} グループのような) 読み出し専用グループには使え
ませんけれど。

@item G V
@kindex G V (グループ)
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成しま
す (@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}.

@item G v
@kindex G v (グループ)
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加しま
す (@code{gnus-group-add-to-virtual})。これはプロセス印/接頭引数の習慣に
従います。
@end table

さまざまな選択方法に関するさらなる情報は @ref{Select Methods} を参照して
下さい。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、Gnus は起
動時に、この数かそれよりも小さいレベルの外部グループをすべてチェックしま
す。これは特に違った @acronym{NNTP} サーバーからたくさんのグループを購読
している場合には、しばらく時間がかかるかもしれません。
@ref{Group Levels} も参照して下さい。@code{gnus-activate-level} も外部
ニュースグループの活性化に影響を及ぼします。

@node Group Parameters
@section グループパラメーター
@cindex group parameters

グループパラメーターは、ある特定のグループに固有な情報を保持します。以下
はグループパラメーターリストの例です:

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は『点対』(dotted pair)---つまり点 (dot) の前に鍵、点の後
ろに値があるもの、で構成されます。すべてのパラメーターはこの形式を取りま
すが、@emph{例外} として局所変数の指定は点対ではなく通常のリストになりま
す。

いくつかのパラメーターは対応するカスタマイズ可能な変数を持っています。そ
れらは正規表現と値の連想リストです。

以下は利用可能なグループパラメーターです:

@table @code
@item to-address
@cindex to-address
フォローアップとニュースへの投稿をするときに使用されるアドレス。

@example
(to-address . "some@@where.com")
@end example

これは主に、閉じたメーリングリストを表わすメールグループにおいて便利なも
のです---すなわちメーリングリストに投稿する人はすべてそれを購読している
はず、というメーリングリストのことです。このパラメーターを使用すると、メー
ルはそのメーリングリストにしか投稿されないことが保証されるので、参加者は
あなたのフォローアップ記事を二通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバー
上にあったとしましょう。これは本当のニュースグループですが、サーバーはメー
ルニュースゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@code{gnus-parameter-to-address-alist} も参照して下さい。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます---例外はそれがニュー
スグループを表わしているときは、@kbd{f} を押したときにメールグループのルー
ルが適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメーターも @code{to-address} もグループパラメーターも無ければ、
@code{to-list} グループパラメーターは、
@code{gnus-add-to-list} が @code{t} に設定されていればメッセージ送信時に
自動的に付加されます。
@vindex gnus-add-to-list

@findex gnus-mailing-list-mode
@cindex mail list groups
もしこのグループパラメーターが設定されていると、概略バッファーに入ったと
きに @code{gnus-mailing-list-mode} が有効になります。

@code{gnus-parameter-to-list-alist} も参照して下さい。

@anchor{subscribed}
@item subscribed
@cindex subscribed
@cindex Mail-Followup-To
@findex gnus-find-subscribed-addresses
もしこのパラメーターが @code{t} に設定されていると、Gnus はあなたがこの
グループを to-address と to-list パラメーターのアドレスで購読しているメー
リングリストであると解釈します。この情報を Gnus に与えることは、あなたが
それらのメーリングリストに投稿するときに正しい Mail-Followup-To ヘッダー
を生成するための (ほんの) 第一歩です。二歩目は @file{.gnus.el} に以下を
入れることです。

@lisp
(setq message-subscribed-address-functions
      '(gnus-find-subscribed-addresses))
@end lisp

利用できる MFT 対応機能を完全に扱うには、ここ (@pxref{Mailing Lists,
,メーリングリスト, message-ja, The Message Manual}) を見て下さい。

@item visible
@cindex visible
グループパラメーターのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファーにおいて、未読記事があるかどうかに関わら
ず、常に表示されます。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループで
は @code{Reply-To} は無視され、
@code{reply-to} が @code{gnus-boring-article-headers} の部分であれば、ヘッ
ダーが隠されるという意味です。これはある listserv によるメーリングリスト
を購読していて、それが @code{Reply-To} 欄を listserv 自身に返すように付
けられている場合に有効でしょう。これはおかしな振る舞いです。だからこれが
要るんです!

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
はすべて @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメーターリストに @code{(newsgroup . t)} があれば、Gnus はす
べての応答をニュース記事に対する応答であるかのように扱います。これは実際
にはニュースグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメーターリストに @code{(gcc-self . t)} があれば、新しく作成
するメッセージは現在のグループに @code{Gcc} されます。も
し @code{(gcc-self . none)} があれば、@code{Gcc:} 欄は生成されず、
@code{(gcc-self . "string")} があればこの文字列はそのまま @code{gcc} 欄
に挿入されます。このパラメーターは以下で説明するどんなディフォルト
の @code{Gcc} の規則よりも優先されます (@pxref{Archived Messages})。

@strong{警告}: @code{nntp} (またはその種の) グループのパラメーターリスト
に @code{(gcc-self . t)} を加えることに効力はありません。@code{nntp} サー
バーは記事を受け入れません。

@item auto-expire
@cindex auto-expire
グループパラメーターに @code{(auto-expire . t)} のような要素があれば、す
べての既読記事は期限切れ消去されるように印を付けられます。他の方法は、
@xref{Expiring Mail}.

@code{gnus-auto-expirable-newsgroups} も参照して下さい。

@item total-expire
@cindex total-expire
グループパラメーターに @code{(total-expire . t)} のような要素があれば、
既読記事は、期限切れ消去の印が付いていなくてもすべて期限切れ消去処理を施
されます。注意して使用して下さい。未読記事、印付き記事、保留記事は期限切
れ消去されません。

@code{gnus-total-expirable-newsgroups} も参照して下さい。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメーターに @code{(expiry-wait . 10)} のような要素があれば、
この値は記事を期限切れ消去するとき
に @code{nnmail-expiry-wait} と @code{nnmail-expiry-wait-function} の設
定 (@pxref{Expiring Mail}) よりも優先されます。この値は期限切れ消去の日
数 (整数である必要はない) かもしくは @code{never} か @code{immediate} の
シンボルを指定できます。

@item expiry-target
@cindex expiry-target
期限切れ消去されるメッセージの果てる場所。このパラメーター
は @code{nnmail-expiry-target} よりも優先されます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、@file{file} を現在のグルー
プに適用されるスコアファイルにします。適用されるスコア項目はすべてこのファ
イルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file} を現在のグルー
プの適応ファイルにします。すべての適応スコア項目はこのファイルに入ります。

@item admin-address
@cindex admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメーターにはどこか都合の良いな管理用アドレスを書いておくこと
ができます。

@item display
@cindex display
@code{(display . MODE)} のような要素は、グループに入るときにどの記事を表
示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方をすべて表示します。

@item an integer
そのグループの最後の @var{integer} 個の記事を表示します。これ
は @kbd{C-u @var{integer}} でそのグループに入るのと同じです。

@item default
ディフォルトの記事を表示します。これは通常は未読記事と可視記事です。

@item 配列
述語を満足するように記事を表示します。

いくつか例を挙げます:

@table @code
@item [unread]
未読の記事だけを表示します。

@item [not expire]
期限切れ消去可能な記事以外のすべてを表示します。

@item [and (not reply) (not expire)]
期限切れ消去可能とすでに返信した記事以外のすべてを表示します。
@end table

利用できる演算子は @code{not}, @code{and} および @code{or} です。述語
は @code{tick}, @code{unsend}, @code{undownload}, @code{unread},
@code{dormant}, @code{expire}, @code{reply}, @code{killed},
@code{bookmark}, @code{score}, @code{save}, @code{cache}, @code{forward},
@code{unseen} および @code{recent} を含みます。
@end table

@code{display} パラメーターは、概略バッファーを指定した一部の組だけに制
限するように働きます。制限を外すのは @kbd{/ w} コマンドでできま
す (@pxref{Limiting})。

@item comment
@cindex comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対
する任意のコメントです。グループ行に表示することができま
す (@pxref{Group Line Specification})。

@item charset
@cindex charset
@code{(charset . iso-8859-1)} のような要素は、@code{iso-8859-1} をディフォ
ルトの文字セットにします。すなわち、文字セットを指定しないすべての記事に、
その文字セットが使われます。

@code{gnus-group-charset-alist} も見て下さい。

@item ignored-charsets
@cindex ignored-charsets
@code{(ignored-charsets x-unknown iso-8859-1)} のような要素は、
@code{iso-8859-1} と @code{x-unknown} を無視します。すなわち、記事のデコー
ドにディフォルトの文字セットが使われます。

@code{gnus-group-ignored-charsets-alist} も見て下さい。

@item posting-style
@cindex posting-style
このグループの追加の投稿様式をここに保存することができま
す (@pxref{Posting Styles})。書式は @code{gnus-posting-style} 連想リスト
と同じですが、ここにはグループ名に合致する正規表現はありません (当然で
す)。このグループの様式の要素は @code{gnus-posting-styles} で見つかった
ものよりも優先されます。

例えば、このグループのみ、かっこいい名前と署名にしたいなら、
@code{gnus-posting-styles} をいじらずに、このようなものをグループパラメー
ターに入れることができます:

@example
(posting-style
  (name "Funky Name")
  ("X-My-Header" "Funky Value")
  (signature "Funky Signature"))
@end example

@item post-method
@cindex post-method
もしこれが設定されていると、メッセージを送信するための選択方法とし
て @code{gnus-post-method} の代わりに使われます。

@item banner
@cindex banner
@code{(banner . @var{regex})} のような項目は、記事のすべての場所で正規表
現 @var{regex} に合致するものを削除します。@var{regex} の代わりにシンボ
ル @code{signature} (最後の署名を削除) や連想リス
ト @code{gnus-article-banner-alist} の各要素を使うこともできます。

@item sieve
@cindex sieve
このパラメーターは、入ってきたメールがこのグループに置くに値するかどうか
を調べる Sieve (ふるい) テストを持ちます。このグループパラメーターを元
に @samp{fileinto "group.name";} というテスト条件を本体に持つ、
Sieve の @samp{IF} 制御構造体が作られます。

例えば、もし @samp{INBOX.list.sieve} グループが @code{(sieve address
"sender" "sieve-admin@@extundo.com")} というグループパラメーターを持って
いたならば、グループパラメーターを Sieve スクリプトに変換す
る (@pxref{Sieve Commands}) ときに、以下の Sieve コードが作られます:

@example
if address "sender" "sieve-admin@@extundo.com" @{
        fileinto "INBOX.list.sieve";
@}
@end example

複数の電子メールアドレスのためのテストを生成するには、@code{(sieve
address "sender" ("name@@one.org" else@@two.org"))} のようなグループパラ
メーターを使って下さい。Sieve スクリプト (@pxref{Sieve Commands}) を生成
すると、以下のような Sieve コードが作られます:

@example
if address "sender" ["name@@one.org", "else@@two.org"] @{
        fileinto "INBOX.list.sieve";
@}
@end example

Sieve パラメーターに関連する重要なコマンドと変数については、@ref{Sieve
Commands} を参照して下さい。

Sieve 言語は RFC 3028 で述べられていま
す (@pxref{Top, Emacs Sieve, Top, sieve-ja, Emacs Sieve})。

@item (agent parameters)
エージェントを使うようにしてあると、個々のグループでエージェントの振る舞
いを制御するどのパラメーターも設定することができます。エージェントパラメー
ターについては @ref{Category Syntax} を参照して下さい。たいていの利用者
は、設定に要する苦労を最小限にするために、エージェントカテゴリーかグルー
プトピックのどちらかでエージェントパラメーターを設定することを選ぶでしょ
う。

@item (@var{variable} @var{form})
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
ターを使用することができます。@samp{news.answers} においてスレッド表示を
行ないたくないときは、そのグループにグループパラメーター
に @code{(gnus-show-threads nil)} と書けます。
@code{gnus-show-threads} は、その概略バッファーの中のローカル変数になり、
form の @code{nil} はそこで評価されます。

この機能は、変数を概略バッファーでローカルに設定することに注意して下さい。
でも、いくつかの変数は記事バッファーか (返信、フォロー、あるいは新規に作
られたメッセージの) メッセージバッファーで評価されます。代わりに、問題の
変数を @code{gnus-newsgroup-variables} に加えることが助けになるかもしれ
ません。したがって、グループパラメーターを介し
て @code{message-from-style} を設定したいならば、@file{~/.gnus} ファイル
のどこか他のところに、次の述語が必要になるかもしれません:

@lisp
(add-to-list 'gnus-newsgroup-variables 'message-from-style)
@end lisp

@vindex gnus-list-identifiers
この機能の用途の一つは、記事の表題欄からメーリングリストの標識タグをはぎ
取ることです。もしニュースグループ

@example
nntp+news.gnus.org:gmane.text.docbook.apps
@end example

が、すべての記事の表題に @samp{DOC-BOOK-APPS:} というタグを持っているな
らば、そのグループのグループパラメーターに @code{(gnus-list-identifiers
"DOCBOOK-APPS:")} を入れることによって、そのグループの概略バッファーに表
示される記事の表題からタグをはぎ取ることができます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もし
あるグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメー
ターに @code{(dummy-variable (ding))} みたいなものを書いておくこともでき
ます。@code{dummy-variable} という変数に (無意味な) @code{(ding)} の評価
結果が設定されます。

あるいは、@var{variable} はそのグループに対してローカルになるので、この
様式は一時的にフックを変更するために使うことができます。例えば、以下のも
のがグループパラメーターに追加されると、

@lisp
(gnus-summary-prepared-hook
  '(lambda nil (local-set-key "d" (local-key-binding "n"))))
@end lisp

そのグループに入ったときに @kbd{d} キーは記事に期限切れ消去の印を付けな
いようになります。
@end table

グループパラメーターの修正には @kbd{G p} か @kbd{G c} 命令を使って下さ
い (@kbd{G p} は Lisp ベースの、@kbd{G c} は Custom ふうのインターフェー
スを提供します)。トピックパラメーターについて読んでみることも面白いでしょ
う (@pxref{Topic Parameters})。

@vindex gnus-parameters
グループパラメーターは @code{gnus-parameters} 変数を介在して設定すること
もできます。でもいくつかのパラメーター、例えば @code{visible} は効力を発
揮しません。例です。

@lisp
(setq gnus-parameters
      '(("mail\\..*"
         (gnus-show-threads nil)
         (gnus-use-scoring nil)
         (gnus-summary-line-format
          "%U%R%z%I%(%[%d:%ub%-23,23f%]%) %s\n")
         (gcc-self . t)
         (display . all))

        ("^nnimap:\\(foo.bar\\)$"
         (to-group . "\\1"))

        ("mail\\.me"
         (gnus-use-scoring  t))

        ("list\\..*"
         (total-expire . t)
         (broken-reply-to . t))))
@end lisp

文字列の値は、@code{to-group} の例が示すように、正規表現による置き換えを
受けることがあります。

@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd
@item l
@itemx A s
@kindex A s (グループ)
@kindex l (グループ)
@findex gnus-group-list-groups
未読記事を持つすべてのグループを表示しま
す (@code{gnus-group-list-groups})。数値接頭引数を使うと、このコマンドは
引数の数かそれよりも小さいレベルのグループのみを表示します。ディフォルト
では、これはレベル 5 (つまり @code{gnus-group-default-list-level}) かそ
れより小さいレベル (すなわち購読しているグループのみ) を表示します。

@item L
@itemx A u
@kindex A u (グループ)
@kindex L (グループ)
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、すべてのグループを表示しま
す (@code{gnus-group-list-all-groups})。数値接頭引数を使用すると、このコ
マンドは引数の数かそれよりも小さいレベルのグループのみを表示します。ディ
フォルトでは 7 かそれよりも小さいレベルのグループ (すなわち購読、非購読
のグループのみ) が表示されます。

@item A l
@kindex A l (グループ)
@findex gnus-group-list-level
未読記事があるグループのうち、指定したレベルのものだけを表示しま
す (@code{gnus-group-list-level})。接頭引数を与えると、未読記事の無いグ
ループも含めて表示します。

@item A k
@kindex A k (グループ)
@findex gnus-group-list-killed
kill されたグループをすべて表示します (@code{gnus-group-list-killed})。
接頭引数を与えると、購読または非購読のどちらにもなっていないすべての利用
可能なグループを表示します。これはサーバーからアクティブファイルを読むこ
とになるでしょう。

@item A z
@kindex A z (グループ)
@findex gnus-group-list-zombies
すべてのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m (グループ)
@findex gnus-group-list-matching
正規表現に合致する名前を持つグループで、未読記事のある購読グループをすべ
て表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M (グループ)
@findex gnus-group-list-all-matching
正規表現に合致するグループを表示しま
す (@code{gnus-group-list-all-matching})。

@item A A
@kindex A A (グループ)
@findex gnus-group-list-active
今接続しているサーバーのアクティブファイルにあるグループを、本当に全部表
示します (@code{gnus-group-list-active})。これはしばらく時間がかかること
も有り得ます。たぶん @kbd{A M} を実行して、合致させたい部分
を @samp{.} としてすべての合致するリストを表示させた方が良いでしょう。ま
た、このコマンドは (まだ) 存在しないグループも表示するかもしれませ
ん---これは kill されたグループであるかのように表示されます。出力は多少
割り引いて受け取ってね。

@item A a
@kindex A a (グループ)
@findex gnus-group-apropos
正規表現に合致する名前を持つグループをすべて表示しま
す (@code{gnus-group-apropos})。

@item A d
@kindex A d (グループ)
@findex gnus-group-description-apropos
正規表現に合致する名前か説明文を持つグループをすべて表示しま
す (@code{gnus-group-description-apropos})。

@item A c
@kindex A c (グループ)
@findex gnus-group-list-cached
キャッシュ記事を持つグループをすべて表示しま
す (@code{gnus-group-list-cached})。

@item A ?
@kindex A ? (グループ)
@findex gnus-group-list-dormant
保留記事を持つグループをすべて表示しま
す (@code{gnus-group-list-dormant})。

@item A /
@kindex A / (グループ)
@findex gnus-group-list-limit
現在の選択された範囲に限定したグループを表示しま
す (@code{gnus-group-list-limit})。

@item A f
@kindex A f (グループ)
@findex gnus-group-list-flush
現在の選択されたグループを書き出します (@code{gnus-group-list-flush})。

@item A p
@kindex A p (グループ)
@findex gnus-group-list-plus
現在の選択されたグループを加えたグループを表示しま
す (@code{gnus-group-list-plus})。
@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現に合致するグループは、未
読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
ターにおいて @code{visible} 要素を追加することでも同様の効果を得ることが
できます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファーに表示されます。も
し @code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、
そのグループは完全に空のグループであるかのように扱われます。ディフォルト
値は @code{t} です。

@node Sorting Groups
@section グループの並べ替え
@cindex sorting groups

@kindex C-c C-s (グループ)
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) 命令は、グループバッファー
を @code{gnus-group-sort-function} 変数で与えられる関数に従って並べ替え
ます。利用可能な並べ替え関数 (sorting function) には以下のものがありま
す:

@table @code
@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順に並べ替えます。これがディフォルトです。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の (前に何も付いていない) グループ名でアルファベット順に並
べ変えます。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルで並べ替えます。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアで並べ替えます。@xref{Group Score}.

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベルとス
コアは、ひとまとめにして @dfn{ランク} と呼ばれます。@xref{Group Score}.

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数で並べ替えます。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択方法のアルファベット順で並べ替えます。

@item gnus-group-sort-by-server
@findex gnus-group-sort-by-server
サーバー名のアルファベット順で並べ替えます。
@end table

@code{gnus-group-sort-function} は並べ替え関数のリストであっても構いませ
ん。この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりま
せん。

ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

@table @kbd
@item G S a
@kindex G S a (グループ)
@findex gnus-group-sort-groups-by-alphabet
グループバッファーをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u (グループ)
@findex gnus-group-sort-groups-by-unread
グループバッファーを未読記事の数で並べ替えま
す (@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l (グループ)
@findex gnus-group-sort-groups-by-level
グループバッファーをグループレベルで並べ替えま
す (@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v (グループ)
@findex gnus-group-sort-groups-by-score
グループバッファーをグループのスコアで並べ替えま
す (@code{gnus-group-sort-groups-by-score})。@xref{Group Score}.

@item G S r
@kindex G S r (グループ)
@findex gnus-group-sort-groups-by-rank
グループバッファーをグループのランクで並べ替えま
す (@code{gnus-group-sort-groups-by-rank})。@xref{Group Score}.

@item G S m
@kindex G S m (グループ)
@findex gnus-group-sort-groups-by-method
グループバッファーをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-groups-by-method})。

@item G S n
@kindex G S n (グループ)
@findex gnus-group-sort-groups-by-real-name
グループバッファーを本当の (前に何も付いていない) グループ名でアルファベッ
ト順に並べ替えます (@code{gnus-group-sort-groups-by-real-name})。
@end table

以下のすべての命令はプロセス/接頭引数の習慣に従いま
す (@pxref{Process/Prefix})。

シンボル接頭引数 (@pxref{Symbolic Prefixes}) が与えられたときは、これら
すべての命令は逆順で並び換えます。

また、グループの一部を並べ替えることもできます。

@table @kbd
@item G P a
@kindex G P a (グループ)
@findex gnus-group-sort-selected-groups-by-alphabet
グループをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u (グループ)
@findex gnus-group-sort-selected-groups-by-unread
グループを未読記事の数で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l (グループ)
@findex gnus-group-sort-selected-groups-by-level
グループをグループレベルで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v (グループ)
@findex gnus-group-sort-selected-groups-by-score
グループをグループのスコアで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-score})。
@xref{Group Score}.

@item G P r
@kindex G P r (グループ)
@findex gnus-group-sort-selected-groups-by-rank
グループをグループのランクで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-rank})。@xref{Group Score}.

@item G P m
@kindex G P m (グループ)
@findex gnus-group-sort-selected-groups-by-method
グループをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-selected-groups-by-method})。

@item G P n
@kindex G P n (グループ)
@findex gnus-group-sort-selected-groups-by-real-name
グループを本当の (前に何も付いていない) グループ名でアルファベット順に並
べ替えます (@code{gnus-group-sort-selected-groups-by-real-name})。

@item G P s
@kindex G P s (グループ)
@findex gnus-group-sort-selected-groups
グループを @code{gnus-group-sort-function} に従って並べ替えます。
@end table

最後に、@kbd{C-k} と @kbd{C-y} を使って、手動でグループをあちこちに移動
できることもお忘れなく。

@node Group Maintenance
@section グループの管理
@cindex bogus groups

@table @kbd
@item b
@kindex b (グループ)
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除しま
す (@code{gnus-group-check-bogus-groups})。

@item F
@kindex F (グループ)
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理しま
す (@code{gnus-group-find-new-groups})。一回の @kbd{C-u} の後で押される
と、サーバーに新しいグループを尋ねるために @code{ask-server} の方法を使
います。二回の @kbd{C-u} の後で押されると、サーバーに新しいグループを尋
ねるために最も完全であると思われる方法を用い、新しいグループをゾンビとし
て購読します。

@item C-c C-x
@kindex C-c C-x (グループ)
@findex gnus-group-expire-articles
現在のグループの期限切れ消去可能な記事に対して (もしあれば) すべて期限切
れ消去の処理を行ないます (@code{gnus-group-expire-articles})。これは、そ
のグループにしばらく存在していた期限切れ消去可能なすべての記事を消去する
ということです。(@pxref{Expiring Mail})。

@item C-c C-M-x
@kindex C-c C-M-x (グループ)
@findex gnus-group-expire-all-groups
すべてのグループのすべての期限切れ消去可能な記事に対して、期限切れ消去の
処理を行ないます。(@code{gnus-group-expire-all-groups})。
@end table

@node Browse Foreign Server
@section 外部サーバーの閲覧
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B (グループ)
@findex gnus-group-browse-foreign-server
選択方法とサーバー名を聞かれます。Gnus はこのサーバーに接続し、そこにあ
るグループを閲覧しようとします (@code{gnus-group-browse-foreign-server})。
@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファーが現れます。このバッファー
は @code{gnus-browse-mode} を使用します。このバッファーは通常のグループ
バッファーにちょっと (というか、とっても) 似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです:

@table @kbd
@item n
@kindex n (閲覧)
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p (閲覧)
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item SPACE
@kindex SPACE (閲覧)
@findex gnus-browse-read-group
現在のグループに入り、最初の記事を表示しま
す (@code{gnus-browse-read-group})。

@item RET
@kindex RET (閲覧)
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u (閲覧)
@findex gnus-browse-unsubscribe-current-group
現在のグループを非購読にします。と言うよりは (訳注: このコマンドはトグル
なので)、この場合は購読することになるのでしょうけれ
ど (@code{gnus-browse-unsubscribe-current-group})。

@item l
@itemx q
@kindex q (閲覧)
@kindex l (閲覧)
@findex gnus-browse-exit
閲覧モード (browse mode) を終了します (@code{gnus-browse-exit})。

@item d
@kindex d (閲覧)
@findex gnus-browse-describe-group
現在のグループを購読にします (@code{gnus-browse-describe-group})。

@item ?
@kindex ? (閲覧)
@findex gnus-browse-describe-briefly
閲覧モード (browse mode) を簡単に説明します (まあ、大して説明することも
ないんですけれどね) (@code{gnus-browse-describe-briefly})。
@end table

@node Exiting Gnus
@section Gnus の終了
@cindex exiting Gnus

そう、Gnus は最後 (サイコー) です (訳注: く、苦しい。
原文は ``Yes, Gnus is ex(c)iting.'')。

@table @kbd
@item z
@kindex z (グループ)
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは Gnus を実際には終
了させず、グループバッファー以外のすべてのバッファーを消すだけです。僕は
これのうれしさがよくわかんないんだけど、誰か分かる人います?

@item q
@kindex q (グループ)
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します (@code{gnus-group-exit})。

@item Q
@kindex Q (グループ)
@findex gnus-group-quit
@file{.newsrc} ファイルを保存せずに Gnus を終了しま
す (@code{gnus-group-quit})。ドリブルファイルは保存されますけれ
ど (@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
@vindex gnus-after-exiting-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。
Gnus を終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さら
に Gnus を終了するときの最後とし
て @code{gnus-after-exiting-gnus-hook} が呼び出されます。

Note:

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女のプラスティッ
クの椅子の背越しに、鉛筆で繰り返し線を描くのにつられて、足がしびれて重く
なり、意識が朦朧としてきました。
@end quotation

@node Group Topics
@section Group Topics
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピッ
ク毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックス
のグループをあっちへ、で、残りを (え? グループが二つくらいしかない
の?) 邪魔にならないようにその他のセクションに入れましょう。あるい
は Emacs セックスのグループを Emacs グループ、セックスグループのどちらか
の副トピックとすることさえもできます---あるいは両方に! すんごいでしょう!

@iftex
@iflatex
\gnusfigure{Group Topics}{400}{
\put(75,50){\epsfig{figure=ps/group-topic,height=9cm}}
}
@end iflatex
@end iftex

これが例です:

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t (グループ)
この @emph{素晴らしい} 機能を使うには、@code{gnus-topic} マイナーモード
を (何と!) 単にスイッチオンするだけ---グループバッファーで、@kbd{t} を押
して下さい (これはトグルコマンドです)。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待っ
てるからさ。ララ、タララン@dots{}、いい曲だね、これ@dots{}ラ、ラ、
ラ@dots{}え? 戻ってきた? よし、じゃ次は @kbd{l} を押してみて。ほら。これ
ですべてのグループが @samp{misc} の下に表示されました。興奮してクラクラ
してこない? アツくって、いまいましいくらいでしょ?

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加して下さい。以下の行を @file{~/.gnus.el} ファイルに入れて、ね。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター
@end menu

@node Topic Commands
@subsection トピック命令
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新しく利用
できるようになります。さらに標準キーの中でも、定義がちょっと変わるものが
少しあります。

だいたいにおいて、次のようなトピックの操作が可能です。まず第一に、あなた
はトピックを作ることを望むでしょう。第二に、あなたはグループをトピックに
入れて、それらをあなたの好みの順序になるまで、あちこちに移動することを望
むでしょう。第三に行なう操作は、それらの一切合切を表示したり隠すことでしょ
う。他のグループの概要を見やすくするために、あなたは副トピックやグループ
によっては、トピックが隠れるようにする必要があるかもしれませんね。

ここには、あなたの好むやり方でトピックを設定するために必要になりそうな、
基本的なキーのリストがあります。

@table @kbd
@item T n
@kindex T n (トピック)
@findex gnus-topic-create-topic
新しいトピック名の入力を促し、それを作成しま
す (@code{gnus-topic-create-topic})。

@item T TAB
@itemx TAB
@kindex T TAB (トピック)
@kindex TAB (トピック)
@findex gnus-topic-indent
現在のトピックの ``字下げ'' を行ない、その前のトピックの副トピックにしま
す (@code{gnus-topic-indent})。接頭引数を与えると、反対にそのトピックの
字下げを回復 (un-indent) します。

@item M-TAB
@kindex M-TAB (トピック)
@findex gnus-topic-unindent
現在のトピックの ``字下げ回復'' (un-indent) を行ない、それが現在の親の親
の副トピックになるようにします (@code{gnus-topic-unindent})。
@end table

以下の二つのキーは、グループとトピックをあちこち移動するために使われます。
それらは、よく知られているカット＆ペーストのように動作します。
@kbd{C-k} はカット、@kbd{C-y} はペーストです。もちろん、Emacs ではカット
＆ペーストではなくて kill & yank という用語を使いますが。

@table @kbd
@item C-k
@kindex C-k (トピック)
@findex gnus-topic-kill-group
グループあるいはトピックを kill します (@code{gnus-topic-kill-group})。
トピック内にあったグループもすべて、トピックと一緒に削除されます。

@item C-y
@kindex C-y (トピック)
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank しま
す (@code{gnus-topic-yank-group})。すべてのトピックは、すべてのグループ
の前に yank されることに気を付けて下さい。

ですから、あるトピックをトピックのリストの先頭に移動するには、単にそこ
で @kbd{C-k} を叩きます。これはカット＆ペーストのカットに相当します。そ
うしたらカーソルをバッファーの先頭 (``Gnus'' トピックの真下) に移動して、
@kbd{C-y} を叩いて下さい。これはカット＆ペーストのペーストに相当します。
なあんだ、簡単じゃん。

@kbd{C-k} と @kbd{C-y} はトピックと同様にグループにも使えます。すなわち、
あなたはグループと同じようにトピックの移動もできるのです。
@end table

あなたの望みのままにトピックを使えるようにした後で、あなたはトピックを隠
したり再び見えるようにしようと思うでしょう。そのために以下のキーを用意し
ています。

@table @kbd
@item RET
@kindex RET (トピック)
@findex gnus-topic-select-group
@itemx SPACE
グループを選択するか、あるいはトピックを折りたたみま
す (@code{gnus-topic-select-group})。グループの上でこのコマンドを実行す
ると、通常通りそのグループに入ります。トピック行の上で行なうと、そのトピッ
クは (すでに表示されているときは) 折りたたまれるか、(すでに折りたたまれ
ているときは) 展開されます。つまりトピックに対してはこれはトグルコマンド
です。さらに、数値の接頭引数を与えると、そのレベル (とそれよりも小さいレ
ベル) のグループが表示されます。
@end table

さてお次は、他のコマンドのリストです。順序には特に意味はありません。

@table @kbd
@item T m
@kindex T m (トピック)
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させま
す (@code{gnus-topic-move-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T j
@kindex T j (トピック)
@findex gnus-topic-jump-to-topic
トピックにジャンプします (@code{gnus-topic-jump-to-topic})。

@item T c
@kindex T c (トピック)
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーしま
す (@code{gnus-topic-copy-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T h
@kindex T h (トピック)
@findex gnus-topic-hide-topic
現在のトピックを隠します。接頭引数が与えらると、そのトピックを永久に隠し
ます。

@item T s
@kindex T s (トピック)
@findex gnus-topic-show-topic
現在のトピックを表示します。接頭引数が与えられると、そのトピックを永久に
表示します。

@item T D
@kindex T D (トピック)
@findex gnus-topic-remove-group
グループを現在のトピックから削除します (@code{gnus-topic-remove-group})。
この命令は主にいくつかのトピックに同じグループがあって、それをトピックの
一つから取り除きたいときに役立ちます。あなたはグループをすべてのトピック
から取り除くかもしれませんが、その場合は、Gnus はあなたが次回に Gnus を
起動したときにそれをルートトピックに付け加えます。実際のところ、すべての
新しいグループ (もちろん、それはどのトピックにも属していません) はルート
トピックに現われます。

この命令はプロセス印/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item T M
@kindex T M (トピック)
@findex gnus-topic-move-matching
正規表現に合致するすべてのグループを、あるトピックに移動させま
す (@code{gnus-topic-move-matching})。

@item T C
@kindex T C (トピック)
@findex gnus-topic-copy-matching
正規表現に合致するすべてのグループを、あるトピックにコピーしま
す (@code{gnus-topic-copy-matching})。

@item T H
@kindex T H (トピック)
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えま
す (@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # (トピック)
@findex gnus-topic-mark-topic
現在のトピックにあるグループすべてにプロセス印を付けま
す (@code{gnus-topic-mark-topic})。接頭引数が与えられない場合、このコマ
ンドは副トピックに対して再帰的に働きます。

@item T M-#
@kindex T M-# (トピック)
@findex gnus-topic-unmark-topic
現在のトピックにあるすべてのグループからプロセス印を消しま
す (@code{gnus-topic-unmark-topic})。接頭引数が与えられない場合、このコ
マンドは副トピックに対して再帰的に働きます。

@item C-c C-x
@kindex C-c C-x (トピック)
@findex gnus-topic-expire-articles
(もしあれば) 現在のグループかトピックかのすべての期限切れ消去可能記事を
期限切れ消去します (@code{gnus-topic-expire-articles})。(@pxref{Expiring
Mail})。

@item T r
@kindex T r (トピック)
@findex gnus-topic-rename
トピックの名前を変更します (@code{gnus-topic-rename})。

@item T DEL
@kindex T DEL (トピック)
@findex gnus-topic-delete
空のトピックを削除します (@code{gnus-topic-delete})。

@item A T
@kindex A T (トピック)
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループをすべて表示しま
す (@code{gnus-topic-list-active})。

@item T M-n
@kindex T M-n (トピック)
@findex gnus-topic-goto-next-topic
次のトピックに移動します (@code{gnus-topic-goto-next-topic})。

@item T M-p
@kindex T M-p (トピック)
@findex gnus-topic-goto-previous-topic
前のトピックに移動します (@code{gnus-topic-goto-previous-topic})。

@item G p
@kindex G p (トピック)
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメーターを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}.
@end table

@node Topic Variables
@subsection トピック変数
@cindex topic variables

前の項では、どのトピックを表示するかを Gnus に言う方法を説明しました。
この項では、それぞれのトピックの何を表示するかを Gnus に言う方法を説明し
ます。

@vindex gnus-topic-line-format
トピック行それ自体は、@code{gnus-topic-line-format} 変数の値に従って作成
されます (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックとすべての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック (と副トピック内のグループ) は、トピックレベル数
の @code{gnus-topic-indent-level} 倍の空白分の字下げが行なわれます。ディ
フォルト値は 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファーで呼び出さ
れます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事が無い場
合でもそのトピックを表示するようにします。ディフォルト値は @code{t} です。

@node Topic Sorting
@subsection トピックの並べ替え
@cindex topic sorting

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができます:

@table @kbd
@item T S a
@kindex T S a (トピック)
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-alphabet})。

@item T S u
@kindex T S u (トピック)
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数で並べ替えま
す (@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l (トピック)
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルで並べ替えま
す (@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v (トピック)
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアで並べ替えま
す (@code{gnus-topic-sort-groups-by-score})。@xref{Group Score}.

@item T S r
@kindex T S r (トピック)
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクで並べ替えま
す (@code{gnus-topic-sort-groups-by-rank})。@xref{Group Score}.

@item T S m
@kindex T S m (トピック)
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-method})。

@item T S e
@kindex T S e (トピック)
@findex gnus-topic-sort-groups-by-server
現在のトピックをサーバーの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-server})。

@item T S s
@kindex T S s (トピック)
@findex gnus-topic-sort-groups
現在のトピックを、変数 @code{gnus-group-sort-function} で与えられる関数
に従って並べ替えます (@code{gnus-topic-sort-groups})。
@end table

接頭引数が与えられると、これらすべてのコマンドは逆順の並べ替えを行ないま
す。グループの並べ替えについてのさらなる情報は @ref{Sorting Groups} を参
照して下さい。

@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファーの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があり、その
下に二つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックが
あります (トップレベルトピックは常に一つしかありません)。この構造は、以
下のように表現できます:

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行なうための、変数 @code{gnus-topic-topology} の
値そのものなのです。この変数は @file{.newsrc.eld} ファイルに保存され、手
でいじくり回してはいけません---本当にやりたいときは別ですが。この変数
は @file{.newsrc.eld} ファイルから読み込まれるので、その他のスタートアッ
プファイルの設定にはまったく影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピッ
クが表示されているかを示しています。現在は二つの設定
値---@code{visible} と @code{invisible} が許されています。

@node Topic Parameters
@subsection トピックパラメーター
@cindex topic parameters

トピック内のすべてのグループはグループパラメーターを、その親 (と先祖) の
トピックパラメーターから継承します。グループパラメーターとして正しいもの
はすべて、トピックパラメーターとしても正しいもので
す (@pxref{Group Parameters})。エージェントを使うようにしてあると、すべ
てのエージェントパラメー
ター (@ref{Category Syntax} の Agent Parameters を参照 (訳注: 必要なら
Index を使って)) は有効なトピックパラメーターでもあります。

さらに、以下のパラメーターはトピックパラメーターとしてのみ有効です:

@table @code
@item subscribe
トピックで新しいグループを購読している場
合 (@pxref{Subscription Methods})、@code{subscribe} トピックパラメーター
はどのグループがどのトピックに行くかを指定します。値はそのトピックに行く
グループに合致する正規表現である必要があります。

@item subscribe-level
トピックで新しいグループを購読している場
合 (@code{subscribe} パラメーターを参照)、そのグループの購読度のレベル
は @code{gnus-level-default-subscribed} の代わり
に @code{subscribe-level} トピックパラメーターの値になります。
@end table

グループパラメーターは (もちろん) トピックパラメーターよりも優先され、副
トピックのトピックパラメーターは親トピックのトピックパラメーターよりも優
先されます。分かるよね。ごく普通の継承ルールで
す (ルール (@dfn{Rules}) はここでは名詞であって、動詞の「線を引く」では
ありません。このルールには反対したくなるかもしれないけど、それはご自由に)。

@example
@group
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end group
@end example

@samp{Emacs} トピックはトピックパラメー
ター @code{(score-file . "emacs.SCORE")} を持っています。
@samp{息抜き} トピックはトピックパラメー
ター @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメー
ター @code{(score-file . "emacs.SCORE")} を持っています。
さらに、@samp{alt.religion.emacs} はグループパラメー
ター @code{(score-file . "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グループに入っ
たとき、@file{relief.SCORE} が基本スコアファイルとなります。も
し @samp{Emacs} トピックの同じグループに入ると、@file{emacs.SCORE} が基
本スコアファイルになるでしょう。
@samp{alt.religion.emacs} グループに入れば、@file{religion.SCORE} が基本
スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ? まあ、その通りです。
ですが問題がある場合もあります。特に @code{total-expiry} パラメーターに
関してです。例えばあるメールグループを二つのトピックの中に、一方
は @code{total-expiry} ありで、もう一方はそれなしで持っているとしましょ
う。ここで @kbd{M-x gnus-expire-all-expirable-groups} を実行すると、何が
起こるでしょうか? Gnus は、あなたがどちらのトピックから記事を期限切れ消
去したいのかを知る方法がないため、最悪の事態が発生するかもしれません。実
際、私はこのとき何が起こるのかは「未定義 @dfn{undefined}」である、とここ
に宣言します。この手のことをやりたい場合には十分注意しなければなりません。

@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理
@end menu

@table @kbd
@item ^
@kindex ^ (グループ)
@findex gnus-group-enter-server-mode
サーバーバッファーモードに入ります (@code{gnus-group-enter-server-mode})。
@xref{Server Buffer}.

@item a
@kindex a (グループ)
@findex gnus-group-post-news
メッセージ (ディフォルトはニュース) の作成を開始しま
す (@code{gnus-group-post-news})。接頭引数が与えられると、現在位置のグルー
プに投稿します。もし接頭引数が 1 だったら、どのグループに投稿するかを尋
ねます。この関数の名前から連想されることとは裏腹に、接頭引数でメールグルー
プが指定された場合は、ニュースの代わりにメールの様式が用意されます。
@xref{Composing Messages}.

@item m
@kindex m (グループ)
@findex gnus-group-mail
メールをどこかに送ります (@code{gnus-group-mail})。接頭引数が与えられる
と、現在位置のグループの投稿様式 (posting style) を使います。もし接頭引
数が 1 だったら、どのグループの投稿様式を使うかを尋ねます。
@xref{Composing Messages}.

@item i
@kindex i (グループ)
@findex gnus-group-news
ニュースの作成を開始します (@code{gnus-group-news})。接頭引数が与えられ
ると、現在位置のグループに投稿します。もし接頭引数が 1 だったら、どのグ
ループに投稿するかを尋ねます。@xref{Composing Messages}.

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに ``投稿'' するのに便利です; それらは当のグループに単に直
接保存されます。対応するバックエンドが投稿のためのメソッ
ド (request-post method) を持っていなければなりませんが。
@end table

以下はグループバッファーのための変数です:

@table @code
@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファーが作成された時に呼び出されます。

@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook
グループバッファーが生成されたあとに呼び出されます。これはバッファーを何
か変な、自然ではない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepare-hook
グループバッファーが生成された後の一番最後に呼び出されます。例えばポイン
トをどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現に合致するグループは、それが空であるかどうかに関わらず、常に
グループバッファーに表示されます。

@item gnus-group-name-charset-method-alist
@vindex gnus-group-name-charset-method-alist
グループ名用の選択方法と文字セットの連想リストです。これは英字ではないグ
ループ名を表示するために使います。

例:
@lisp
(setq gnus-group-name-charset-method-alist
    '(((nntp "news.com.cn") . cn-gb-2312)))
@end lisp

@item gnus-group-name-charset-group-alist
@cindex UTF-8 group names
@vindex gnus-group-name-charset-group-alist
グループ名用のグループ名の正規表現と文字セットの連想リストです。これは英
字ではないグループ名を表示するために使います。ディフォルト値は、UTF-8 が
サポートされている場合は @code{((".*" utf-8))}、それ以外の場合
は @code{nil} です。

例:
@lisp
(setq gnus-group-name-charset-group-alist
    '(("\\.com\\.cn:" . cn-gb-2312)))
@end lisp
@end table

@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd
@item g
@kindex g (グループ)
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバーの新着記事をチェックします。数値の接頭引数を使用すると、この命令
は引数 @var{arg} かそれより小さいレベルのグループのみをチェックしま
す (@code{gnus-group-get-new-news})。数値以外の接頭引数を与えると、この
命令はそのバックエンドからアクティブファイルを強制的に全部読み直します。

@item M-g
@kindex M-g (グループ)
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックしま
す (@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこの命令が次のグループ位置
へ移動するかどうかを決めます。ディフォルト値は @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g (グループ)
無条件にすべてのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R (グループ)
@cindex restarting
@findex gnus-group-restart
Gnus を再起動します (@code{gnus-group-restart})。これ
は @file{.newsrc} ファイルをセーブし、すべてのサーバーの接続を閉じ、すべ
ての Gnus ランタイム変数をクリアした後、Gnus をもう一度最初から開始しま
す。
@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニュースをチェックする直前に実行され
ます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニュースをチェックした後に実
行されます。

@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd
@item H f
@kindex H f (グループ)
@findex gnus-group-fetch-faq
@vindex gnus-group-faq-directory
@cindex FAQ
@cindex ange-ftp
現在のグループの @acronym{FAQ} を取得しようとしま
す (@code{gnus-group-fetch-faq})。
Gnus は @acronym{FAQ} を @code{gnus-group-faq-directory} から取得しよう
とします。これは通常リモートマシン上のディレクトリーです。この変数はディ
レクトリーのリストであっても構いません。この場合、このコマンドに接頭引数
を与えることでいくつかのサイトの中から選ぶことができます。ファイルの取得
には @code{ange-ftp} (または @code{efs}) が使用されます。

もし最初のサイトからの取得が失敗した場合、
Gnus は @code{gnus-group-faq-directory} の値をすべて、一つ一つオープンし
てみようとします。

@item H c
@kindex H c (グループ)
@findex gnus-group-fetch-charter
@vindex gnus-group-charter-alist
@cindex charter
現在のグループの憲章を web ブラウザで開こうとしま
す (@code{gnus-group-fetch-charter})。接頭引数が与えられるとグループ名を
尋ねます。

Gnus は @code{gnus-group-charter-alist} を使って憲章の所在を探します。所
在がわからなかったら、Gnus はそのグループのコントロールメッセージを取得
します。それには憲章を含んでいることがありますから。

@item H C
@kindex H C (グループ)
@findex gnus-group-fetch-control
@vindex gnus-group-fetch-control-use-browse-url
@cindex control message
そのグループのコントロールメッセージを @code{ftp.isc.org} の記録庫から取
得します (@code{gnus-group-fetch-control})。接頭引数が与えられるとグルー
プ名を尋ねます。

@code{gnus-group-fetch-control-use-browse-url} が非-@code{nil} だったら、
Gnus は @code{browse-url} を使ってコントロールメッセージを開きます。そう
でない場合は @code{ange-ftp} を使って取得され、一時グループに表示されま
す。

コントロールメッセージは圧縮されていることに注意して下さい。このコマンド
を使うには @code{auto-compression-mode} を on にしておく必要がありま
す (@pxref{Compressed Files, ,Compressed Files, emacs, The Emacs
Editor})。

@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d (グループ)
@kindex C-c C-d (グループ)
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示します (@code{gnus-group-describe-group})。接
頭引数を与えると、説明文をサーバーから強制的に再読み込みします。

@item M-d
@kindex M-d (グループ)
@findex gnus-group-describe-all-groups
すべてのグループの説明を表示しま
す (@code{gnus-group-describe-all-groups})。接頭引数を与えると、説明文ファ
イルをサーバーから強制的に再読み込みします。

@item H v
@itemx V
@kindex V (グループ)
@kindex H v (グループ)
@cindex version
@findex gnus-version
現在の Gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? (グループ)
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えま
す (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i (グループ)
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node})。
@end table

@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利かもしれ
ません。この活動を始めさせるには、
@code{gnus-group-set-timestamp} を @code{gnus-select-group-hook} に追加
して下さい。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行なった後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます---もっとも簡単なのは、グループ行
フォーマットで @samp{%d} 指定を使う方法です:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます:

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp

もっと凝った日付の形式をお望みなら、利用者定義によるフォーマットの仕様を
使うことができます。以下のようなものはうまくいくでしょう:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %ud\n")
(defun gnus-user-format-function-d (headers)
  (let ((time (gnus-group-timestamp gnus-tmp-group)))
    (if time
        (format-time-string "%b %d  %H:%M" time)
      "")))
@end lisp

@node File Commands
@subsection ファイル命令
@cindex file commands

@table @kbd
@item r
@kindex r (グループ)
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行ないます (@code{gnus-init-file}、ディフォ
ルトは @file{~/.gnus.el}) (@code{gnus-group-read-init-file})。

@item s
@kindex s (グループ)
@findex gnus-group-save-newsrc
@cindex saving .newsrc
@file{.newsrc.eld} ファイル (と、もしそうしたければ @file{.newsrc} ファ
イル) をセーブします (@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z (グループ)
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。
@end table

@node Sieve Commands
@subsection Sieve コマンド
@cindex group sieve commands

Sieve はサーバー側で使われるメールフィルター言語です。Gnus では、各グルー
プに適用される sieve の規則を指定する、@code{sieve} グループパラメー
ター (@pxref{Group Parameters}) を使うことができます。guns はそれらすべ
てのグループパラメーターを、サーバーで使うことも可能な正しい Sieve スク
リプトに翻訳する、二つのコマンドを提供します。

@vindex gnus-sieve-file
@vindex gnus-sieve-region-start
@vindex gnus-sieve-region-end
作成された Sieve スクリプトは @code{gnus-sieve-file} (ディフォルト
は @file{~/.sieve}) に置かれます。Gnus が作るコードは二つの区切り記
号 @code{gnus-sieve-region-start} と @code{gnus-sieve-region-end} の間に
置かれるので、これらの区切り記号の外に追加の Sieve コードを書いても、次
回 Sieve スクリプトを再作成するときに消されてしまうことはありません。

@vindex gnus-sieve-crosspost
変数 @code{gnus-sieve-crosspost} は Sieve スクリプトがどのように作られる
かを制御します。もし非-@code{nil} (ディフォルト) だったら記事は規則に合
致するすべてのグループに置かれます。そうでない場合、記事は最初の規則に合
致するグループだけに置かれます。例えばグループパラメーター @samp{(sieve
address "sender" "owner-ding@@hpc.uh.edu")} は、
@code{gnus-sieve-crosspost} が @code{nil} だったら以下の Sieve コードの
断片を作ります。(@code{gnus-sieve-crosspost} が非-@code{nil} だった場合
は、行が含む @code{stop} の呼び出しが削除されること以外は同じです。)

@example
if address "sender" "owner-ding@@hpc.uh.edu" @{
        fileinto "INBOX.ding";
        stop;
@}
@end example

@xref{Top, Emacs Sieve, Top, sieve, Emacs Sieve}.

@table @kbd
@item D g
@kindex D g (グループ)
@findex gnus-sieve-generate
@vindex gnus-sieve-file
@cindex generating sieve script
@code{sieve} グループパラメーターから Sieve スクリプトを再作成して、
@code{gnus-sieve-file} に書き込みます。以前の内容は保存されません。

@item D u
@kindex D u (グループ)
@findex gnus-sieve-update
@vindex gnus-sieve-file
@cindex updating sieve script
@code{sieve} グループパラメーターを元
に @code{gnus-sieve-file} の Gnus が管理している部分を再作成してファイル
にセーブし、@code{sieveshell} プログラムを使ってサーバーにアップロードし
ます。
@end table

@node Summary Buffer
@chapter 概略バッファー
@cindex summary buffer

概略バッファー (summary buffer) ではそれぞれの記事が一行で表示されます。
その中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファーに移る一番普通の方法は、グループバッファーでグループを選択
することです (@pxref{Selecting a Group})。

好きなだけたくさんの概略バッファーを開いておくことができます。

@menu
* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード
@end menu

@node Summary Buffer Format
@section 概略バッファーの様式
@cindex summary buffer format

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{180}{
\put(0,0){\epsfig{figure=ps/summary,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-article,width=7.5cm}}}
}
@end iflatex
@end iftex

@menu
* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする
@end menu

@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を抽出するための関数として使います。すでに定義
されている関数が二つ存在します: ディフォルト
は @code{gnus-extract-address-components} で、とても簡単に割り切った解決
法ですが非常に速く動作します。@code{mail-extract-address-components} は
良く動作しますが遅いです。ディフォルトの関数は 5% の割合で間違った答を返
します。もしこれに我慢ならないのであれば、代わりに他の関数を使って下さい:

@lisp
(setq gnus-extract-address-components
      'mail-extract-address-components)
@end lisp

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は、それを要求す
る書法仕様で使われます。ディフォルトでは @code{""} です。

@node Summary Buffer Lines
@subsection 概略バッファーの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファーの行の様式 (format) を変更することができます。いくつかの拡
張 (@pxref{Formatting Variables}) とともに、普通の @code{format} 文字列
と同じように動作します。

行には常にコロンかポイント位置のマーカーが存在していなければなりません。
操作した後に、カーソルはいつもコロンかポイント位置のマーカーの場所に移動
します。(もちろん、この動作を変えることができないとしたら Gnus にはある
まじきことです。関数 @code{gnus-goto-colon} を、あなたが好きなカーソルの
動きになるように、新たに書けば良いのです。) @xref{Positioning Point}.

ディフォルト値の文字列は @samp{%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n} です。

以下の様式指示文字と拡張様式指示を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。@code{gnus-list-identifiers} の設定によってメーリングリス
トの標識が削除されます。@xref{Article Hiding}.
@item s
スレッド (thread) の元記事であるときか直前の記事が違う表題のときはその表
題で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} のディフォルト値は @code{""}。)
@item F
完全な @code{From} 欄。
@item n
名前 (@code{From} 欄より)。
@item f
名前、@code{To} 欄の内容、または @code{Newsgroups} 欄の内容のどれかで
す (@pxref{To From Newsgroups})。
@item a
名前 (@code{From} 欄より)。これと @code{n} との違いは、これは変
数 @code{gnus-extract-address-components} で指定されている関数を使って名
前を取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前 (@code{From} 欄より)。これは @code{a} と同じように動作します。
@item L
記事の行数。
@item c
記事の文字数。この名前指定子は (nnfolder のような) いくつかの選択方法を
サポートしません。
@item k
整形された記事の文字数; 例えば @samp{1.2k} や @samp{0.4M}。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item B
複雑な trn 様式のスレッド木 (tree)。どのような応答が行なわれたかの記録を
表示します。スレッドはこのように描かれるでしょう:

@example
>
+->
| +->
| | \->
| |   \->
| \->
+->
\->
@end example

以下のオプションで見栄えをカスタマイズすることができます。ディフォルト
の @acronym{ASCII} 文字を線描画用の図案で置き換えることによって、スレッ
ド表示を実に巧妙に見せることができることに気付いて下さい。

@table @code
@item gnus-sum-thread-tree-root
@vindex gnus-sum-thread-tree-root
スレッドの根 (root) に使われます。@code{nil} だったら、代わりに表題を使
います。ディフォルトは @samp{> } です。

@item gnus-sum-thread-tree-false-root
@vindex gnus-sum-thread-tree-false-root
スレッドのにせの根に使われます (@pxref{Loose Threads})。@code{nil} だっ
たら、代わりに表題を使います。ディフォルトは @samp{> } です。

@item gnus-sum-thread-tree-single-indent
@vindex gnus-sum-thread-tree-single-indent
単一のメッセージのスレッドに使われます。@code{nil} だったら、代わりに表
題を使います。ディフォルトは @samp{} です。

@item gnus-sum-thread-tree-vertical
@vindex gnus-sum-thread-tree-vertical
縦線の描画に使われます。ディフォルトは @samp{| } です。

@item gnus-sum-thread-tree-indent
@vindex gnus-sum-thread-tree-indent
行下げ (indenting) に使われます。ディフォルトは @samp{  } です。

@item gnus-sum-thread-tree-leaf-with-other
@vindex gnus-sum-thread-tree-leaf-with-other
兄弟がいる葉っぱに使われます。ディフォルトは @samp{+-> } です。

@item gnus-sum-thread-tree-single-leaf
@vindex gnus-sum-thread-tree-single-leaf
兄弟がいない葉っぱに使われます。ディフォルトは @samp{\-> } です。
@end table

@item T
記事が元記事であれば何も表示せず、そうでない場合はたくさんの空白です (そ
れより後のものをすべて画面の外に追い出してしまいます)。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
(20 - スレッドレベル) 個の空白。
@item U
未読。@xref{Read Articles}.

@item R
この紛らわしい名前指定子は @dfn{第二の印} (the secondary mark) です。こ
の印は記事がすでに返答済みのものか、キャッシュされたものか、あるいは保存
されたものかを表します。@xref{Other Marks}.

@item i
数値としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore でディフォルトのレベルよりも上であれば @samp{+} で、ディフォ
ルトのレベルよりも下であれば @samp{-} です。
@code{gnus-summary-default-score} との差
が @code{gnus-summary-zcore-fuzz} よりも小さいと、この仕様は使われません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}.
@item D
@code{Date}.
@item d
@code{DD-MM} 様式による @code{Date}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS} 様式による @code{Date}。
@item M
@code{Message-ID}.
@item r
@code{References}.
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファーの生成が幾分遅
くなります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item &user-date;
経過時間の様式。いろいろな様式が @code{gnus-user-date-format-alist} で定
義されています。
@item u
利用者定義指定子。フォーマット文字列の中の次の文字は英字でなければなりま
せん。これにより Gnus は関数 @code{gnus-user-format-function-}@var{x} を
呼び出しますが、ここで @var{x} は @samp{%u} の次の文字です。関数には現在
の記事のヘッダーが引数として渡されます。関数は文字列を返さなければなりま
せん。それは他の概略指定と同様に概略に挿入されます。
@end table

@samp{%(} と @samp{%)} の間にあるテキストは、そこにマウスがあるとき
に @code{gnus-mouse-face} でハイライトされます。そういう領域は一つだけで
す。

@samp{%U} (状態), @samp{%R} (返答済み), @samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、Gnus はこれらの文字がどの桁に現れる
かを計算し、『ハード・コード』します。これは、可変長の仕様の後では、これ
らは意味を持たないということです。まぁ、さすがに逮捕はされないでしょうが、
概略バッファーは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。(でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。)

この制限は将来の版では無くなるかもしれません。

@node To From Newsgroups
@subsection To From Newsgroups
@cindex To
@cindex Newsgroups

いくつかのグループ (特にアーカイブグループ) では @code{From} ヘッダーは
あまり興味を引きません。そこのすべての記事はあなたによって書かれたもので
すから。代わりに、@code{To} や @code{Newsgroups} ヘッダーの情報を表示す
るためには、三つのことを決める必要があります: どの情報を集めるか, どこに
表示するか, いつ表示するか。

@enumerate
@item
@vindex gnus-extra-headers
追加のヘッダーの情報は @code{gnus-extra-headers} により制御されます。こ
れはヘッダーのシンボルのリストです。例えば:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups X-Newsreader))
@end lisp

これによって Gnus はこれらの三つのヘッダーを取得しようとし、後の容易な取
得のためにヘッダー構造に保存します。

@item
@findex gnus-extra-header
これらの追加のヘッダーの値は @code{gnus-extra-function} 関数を通じて取得
することができます。これは @code{X-Newsreader} ヘッダーを使う書式行の仕
様です:

@example
"%~(form (gnus-extra-header 'X-Newsreader))@@"
@end example

@item
@vindex gnus-ignored-from-addresses
@code{gnus-ignored-from-addresses} 変数はいつ @samp{%f} 概略行仕様
が @code{To}, @code{Newsreader} や @code{From} ヘッダーを返せば良いかを
決めます。この正規表現が @code{From} ヘッダーの内容と合致すると、
@code{To} や @code{Newsreader} ヘッダーの値が代わりに使用されます。

それらの @code{From} フィールドが入れ替わっている記事と、普通の記事を区
別するために、概略行の @code{To} または @code{Newsgroups} ヘッダーに、あ
る文字列が前置されます。その文字列はディフォルトで、@code{To} に
は @samp{-> } が、@code{Newsgroups} には @samp{=> } が使われますが、
@code{gnus-summary-to-prefix} と @code{gnus-summary-newsgroup-prefix} に
よって、それらの文字列をカスタマイズすることができます。
@end enumerate

@vindex nnmail-extra-headers
関連する変数は @code{nnmail-extra-headers} で、
overview (@acronym{NOV}) ファイルを作る際にいつ追加のヘッダーを含めるか
を制御します。古い overview ファイルがある場合は、この変数を変更した後に
サーバーバッファーに @kbd{^} で入って適切なメールサーバー (例え
ば nnml) で @kbd{g} を押し、再生成する必要があります。

@vindex gnus-summary-line-format
さらに @code{gnus-summary-line-format} 変数の @code{%n} 仕様
を @code{%f} 仕様に変更することによってデータを表示するように、Gnus に指
示する必要があります。

要約すると、普通は以下のようなものを @file{~/.gnus.el} に置くことになり
ます:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups))
(setq nnmail-extra-headers gnus-extra-headers)
(setq gnus-summary-line-format
      "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n")
(setq gnus-ignored-from-addresses
      "Your Name Here")
@end lisp

(上記の値は Gnus のディフォルト値です。あなたの役に立つように変えて下さ
い。)

ニュース管理人、またはニュース管理人を説得してサポートの追加をしてもらお
うと思っている利用者のみなさんへのご注意:

@acronym{NOV} ファイルの生成を制御できるメールグループでは、上記のことは
たいていの場合役立ちます。しかし、管理人を説得して (特に INN の普通の実
装において) 以下のものを @file{overview.fmt} ファイルの最後に追加しても
うらうことができれば、メールグループでの追加ヘッダーのようにそれを使うこ
とができます。

@example
Newsgroups:full
@end example

@node Summary Buffer Mode Line
@subsection 概略バッファーのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます (@pxref{Mode Line
Formatting})。@code{gnus-summary-mode-line-format} を何でも好きなものに
設定して下さい。ディフォルト値は @samp{Gnus: %%b [%A] %Z} です。

以下はあなたが遊ぶことのできる要素たちです:

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item z
現在の記事スコア。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファーに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合の @samp{<%U(+%e) more>}、および未読記事のみの場合
の @samp{<%U more>} のどちらかです。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その概略バッファーで記事を読んだ結果、既読の印が付いた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table

@node Summary Highlighting
@subsection 概略のハイライト

@table @code
@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。@code{gnus-visual} が @code{nil} だっ
たら実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変化したときに呼ばれます。
@code{gnus-visual} が @code{nil} だったら実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファーでの現在の記事をハイライトするために使われるフェー
ス (もしくは、ある人たちが @dfn{フォント} と呼ぶようなもの) です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素
が @code{(@var{form} . @var{face})} の形式のリストです。例えば、印付きの
記事を斜体、高いスコアの記事を太字にしたければ、この変数を次のように設定
することができます。

@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp

ご想像のとおり、@var{form} が @code{nil} でない値を返すと、@var{face} が
その行に適用されます。
@end table

@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、かなり期待どおりに動作する
でしょう。

これらの命令はどれも記事を選択しません。

@table @kbd
@item G M-n
@item M-n
@kindex M-n (概略)
@kindex G M-n (概略)
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移ります (@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p (概略)
@kindex G M-p (概略)
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移ります (@code{gnus-summary-prev-unread-subject})。

@item G g
@kindex G g (概略)
@findex gnus-summary-goto-subject
記事番号を尋ね、その記事を表示せずに、その概略行に行きま
す (@code{gnus-summary-goto-subject})。
@end table

Gnus が次のグループ移動することを確認するためにキー入力を求めた場合、
@kbd{C-n} キーと @kbd{C-p} キーを使うことによって、実際にグループバッファー
に戻らなくても、次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code
@vindex gnus-auto-select-next
@item gnus-auto-select-next
移動命令の一つ (@kbd{n} のような) を発したときに現在の記事の後に未読記事
が無いと、Gnus は次のグループに移動することをうながします。この変数
が @code{t} で次のグループが空っぽだったら、Gnus は概略モードを抜けてグ
ループバッファーに戻ります。この変数が @code{t} でも @code{nil} でもなけ
れば、Gnus はさらに次の未読記事があるグループを選択します。特別な場合と
して、この変数が @code{quietly} だったら、Gnus は確認をせずに次のグルー
プを選択します。この変数が @code{almost-quietly} だった場合は、グループ
の一番最後の記事を読んでいたときに限って同じことが起こります。最後に、も
しこの変数が @code{slightly-quietly} だったら、@kbd{Z n} 命令は確認をせ
ずに次のグループに移ります。@ref{Group Levels} も参照して下さい。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。(@dfn{同じ} はここでは @dfn{大体同じ} という意味かもしれ
ません。詳細は @code{gnus-summary-gather-subject-limit} を見て下さ
い (@pxref{Customizing Threading})。) 同じ表題の記事が無いときは、最初の
未読記事に移動します。

この変数は、スレッド表示を行なっているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
これが @code{nil} ではない場合、すべての『未読』移動命令は、現在の記事が
未読だったら次 (もしくは前) の記事に移動しません。代わりに、それらは現在
の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、Gnus は概略バッファーでのポイントを常に真中に保ちま
す。これをすると、とてもこぎれいになりますが、遅いネットワークに接続して
いたり、この Emacs らしくない流儀が好きになれないのであれば、この変数
を @code{nil} にすることによって、普通の Emacs のスクロールにすることが
できます。これは概略バッファーの水平方向でポイントが真ん中になるようにす
る操作 (horizontal re-centering) も禁止してしまうので、非常に長いスレッ
ドを読むときは不便かもしれません。

この変数は数値でも構いません。その場合は、ウィンドウの先頭からその数の行
だけ下がった位置に常にポイントがあるように制御されます。
@end table

@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数
@end menu

@node Choosing Commands
@subsection 選択命令

以下の移動コマンドはどれも数値接頭引数を受け付けません。それらはすべて、
記事を選択して表示します。

新しい記事を取り込んだり、グループを再表示したいときは @ref{Exiting the
Summary Buffer} を参照して下さい。

@table @kbd
@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
現在の記事、またはそれが既読だった場合は次の未読記事を選択しま
す (@code{gnus-summary-next-page})。

すでに記事ウィンドウを開いているときに再び @kbd{SPACE} を押すと、その記
事はスクロールされます。これによって、ニュースグループ全体
を @kbd{SPACE} だけで便利に通読することができます。
@xref{Paging the Article}.

@item G n
@itemx n
@kindex n (概略)
@kindex G n (概略)
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-next-unread}
次の未読記事に移動します (@code{gnus-summary-next-unread-article})。

@item G p
@itemx p
@kindex p (概略)
@findex gnus-summary-prev-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N (概略)
@kindex G N (概略)
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P (概略)
@kindex G P (概略)
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n (概略)
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G C-p
@kindex G C-p (概略)
@findex gnus-summary-prev-same-subject
同じ表題の前の記事に移動します (@code{gnus-summary-prev-same-subject})。

@item G f
@itemx .
@kindex G f (概略)
@kindex . (概略)
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b (概略)
@kindex , (概略)
@findex gnus-summary-best-unread-article
最高スコアの未読記事に移動しま
す (@code{gnus-summary-best-unread-article})。接頭引数が与えられると、ディ
フォルトのスコアより大きいスコアを持つ最初の未読記事に移動します。

@item G l
@itemx l
@kindex l (概略)
@kindex G l (概略)
@findex gnus-summary-goto-last-article
直前に読んだ記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o (概略)
@findex gnus-summary-pop-article
@cindex history
@cindex article history
概略の履歴 (history) から最後の記事を一つ取り出して選択しま
す (@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、
@kbd{l} が最後の二つの記事の間を移動するだけなのに対して、これは好きなだ
け前の記事を履歴から選び出すことができる点です。これに多少関係することに
ついて、@ref{Article Backlog} を参照して下さい (これらの命令をたくさん使
うのであれば)。

@item G j
@item j
@kindex j (概略)
@kindex G j (概略)
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行きま
す (@code{gnus-summary-goto-article})。
@end table

@node Choosing Variables
@subsection 選ぶための変数

記事の移動と選択に関連するいくつかの変数:

@table @code
@item gnus-auto-extended-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、記事が概略バッファー
に表示されていない場合でも、前 (もしくは次) の記事に移動しようとします。
その際 Gnus はサーバーから記事を取得して、記事バッファーに表示します。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。ディフォルト値
は @code{nil} です。講読するそれぞれの記事をエージェントに保存させたい場
合は、このフックに @code{gnus-agent-fetch-selected-article} を追加すれば
良いでしょう。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。これは記事に既読の印を
付けるために使われることを意図しています。ディフォルト値
は @code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての
読んだ記事の印を @code{gnus-read-mark} に変更します。この関数に影響され
ない記事は、可視、保留、期限切れ消去可能記事だけです。未読記事に既読の印
を付けたいだけであれば、代わり
に @code{gnus-summary-mark-unread-as-read} を使うことができます。
@code{gnus-low-score-mark} や @code{gnus-del-mark} (など) の印はそのまま
残します。
@end table

@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd
@item SPACE
@kindex SPACE (概略)
@findex gnus-summary-next-page
@kbd{SPACE} を押すと、現在の記事を一ページ先にスクロールします。記事の最
後に行き着いた場合は次の記事を選択します (@code{gnus-summary-next-page})。

@vindex gnus-article-boring-faces
@vindex gnus-article-skip-boring
@code{gnus-article-skip-boring} が非-@code{nil} で、かつ記事の残りに引用
と署名しか無い場合、それはスキップされ、代わりに次の記事が表示されます。
@code{gnus-article-boring-faces} で、つまらないと思うものをカスタマイズ
することができます。どんなにうんざりするものでも、@kbd{C-M-v} を使うこと
によって、手動で記事のページを見ることはできます。

@item DEL
@kindex DEL (概略)
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (@code{gnus-summary-prev-page})。

@item RET
@kindex RET (概略)
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします (@code{gnus-summary-scroll-up})。

@item M-RET
@kindex M-RET (概略)
@findex gnus-summary-scroll-down
現在の記事を一行後ろへスクロールします (@code{gnus-summary-scroll-down})。

@item A g
@itemx g
@kindex A g (概略)
@kindex g (概略)
@findex gnus-summary-show-article
@vindex gnus-summary-show-article-charset-alist
現在の記事を (再) 取得します。もし接頭引数が与えられると、現在の記事を取
得しますが、記事をトリートメントする関数は実行しません。これは、サーバー
から来たままの『生の』記事をもたらします。

接頭引数を与えると、手動で文字セットの操作を行なうことができます。
@kbd{C-u 0 g cn-gb-2312 RET} により、メッセージはあたか
も @code{cn-gb-2312} 文字セットでエンコードされたかのようにデコードされ
ます。以下のような設定を用意しておくと、@kbd{C-u 1 g} で同じ効果を得るこ
とができます。

@lisp
(setq gnus-summary-show-article-charset-alist
      '((1 . cn-gb-2312)
        (2 . big5)))
@end lisp

@item A <
@itemx <
@kindex < (概略)
@kindex A < (概略)
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > (概略)
@kindex A > (概略)
@findex gnus-summary-end-of-article
記事の最後までスクロールします (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s (概略)
@kindex s (概略)
@findex gnus-summary-isearch-article
記事バッファーでインクリメンタルサーチ (isearch) を行ないま
す (@code{gnus-summary-isearch-article})。

@item h
@kindex h (概略)
@findex gnus-summary-select-article-buffer
記事バッファーを選択します (@code{gnus-summary-select-article-buffer})。
@end table

@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::
@end menu

@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd
@item S r
@item r
@kindex S r (概略)
@kindex r (概略)
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R (概略)
@kindex S R (概略)
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、元記事を含んだ返答のメールを出しま
す (@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引
数の習慣を使います。

@item S w
@kindex S w (概略)
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をしま
す (@code{gnus-summary-wide-reply})。@dfn{広い返答} とはヘッダー
の @code{To}, @code{From}, (もしくは @code{Reply-to}) と @code{Cc}) のす
べての人に返答をすることです。@code{Mail-Followup-To} があれば、代わりに
それが使われます。

@item S W
@kindex S W (概略)
@findex gnus-summary-wide-reply-with-original
現在の記事に元記事を含んだ広い返答のメールを送りま
す (@code{gnus-summary-wide-reply-with-original})。この命令はプロセス/接
頭引数の習慣を使います。

@item S v
@kindex S v (概略)
@findex gnus-summary-very-wide-reply
現在の記事を書いた人に対して、非常に広い返答 (very wide reply) をしま
す (@code{gnus-summary-very-wide-reply})。@dfn{非常に広い返答} とは、プ
ロセス/接頭引数で指定されたすべての記事のヘッダーの @code{To},
@code{From}, (もしくは @code{Reply-to}) と @code{Cc}) のすべての人に返答
をすることです。この命令はプロセス/接頭引数の習慣を使います。

@item S V
@kindex S V (概略)
@findex gnus-summary-very-wide-reply-with-original
現在の記事に元記事を含んだ非常に広い返答のメールを送りま
す (@code{gnus-summary-very-wide-reply-with-original})。この命令はプロセ
ス/接頭引数の習慣を使います。

@item S B r
@kindex S B r (概略)
@findex gnus-summary-reply-broken-reply-to
現在の記事を書いた人に対して返答をしますが @code{Reply-To} フィールドは
無視します (@code{gnus-summary-reply-broken-reply-to})。メーリングリスト
がそのリストを指す @code{Reply-To} を過って設定するためにこれが必要なの
であれば、おそらくあなたは代わりに @code{broken-reply-to} グループパラメー
ターを設定する必要があります。そうすれば、ものごとは正しく働くようになる
でしょう。@xref{Group Parameters}.

@item S B R
@kindex S B R (概略)
@findex gnus-summary-reply-broken-reply-to-with-original
現在の記事を書いた人に対して元記事を含んだ返答をします
が @code{Reply-To} フィールドは無視しま
す (@code{gnus-summary-reply-broken-reply-to-with-original})。

@item S o m
@itemx C-c C-f
@kindex S o m (概略)
@kindex C-c C-f (概略)
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数が与えられない場合、メッセージ
は @code{message-forward-as-mime} およ
び @code{message-forward-show-mml} の値に従ったやり方で転送されます。接
頭引数が 1 だったら、デコードされたメッセージが直接埋め込まれた転送用の
バッファーが作られます。2 だったら rfc822 形式の @acronym{MIME} パートが
挿入されます。この場合、元のメッセージはデコードされません。3 ではデコー
ドされた rfc822 形式の @acronym{MIME} パートが挿入されます (実際に送信す
る際に再びエンコードされます)。接頭引数 4 では、1 の場合と同じ動作になり
ます。接頭引数がこれら以外の場合には、@code{message-forward-as-mime} の
値を一時的に反転して、接頭引数が与えられなかった場合と同じ動作を行ないま
す。ディフォルトでは、デコードされたメッセージが rfc822 形式
の @acronym{MIME} パートとして生成されます。

@item S m
@itemx m
@kindex m (概略)
@kindex S m (概略)
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
メールを作成します (@code{gnus-summary-mail-other-window})。ディフォルト
では現在のグループの投稿様式 (posting style) を使います。接頭引数が与え
られると、それは使いません。もし接頭引数が 1 だったら、どのグループの投
稿様式を使うかを尋ねます。

@item S i
@itemx i
@kindex i (概略)
@kindex S i (概略)
@findex gnus-summary-news-other-window
ニュースを作成します (@code{gnus-summary-news-other-window})。ディフォル
トでは現在のグループに投稿します。接頭引数が与えられると、現在のグループ
名は使われません。もし接頭引数が 1 だったら、どのグループに投稿するかを
尋ねます。

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに ``投稿'' するのに便利です; それらは当のグループに単に直
接セーブされます。対応するバックエンドが投稿のためのメソッ
ド (request-post method) を持っていなければなりませんが。

@item S D b
@kindex S D b (概略)
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由 (アドレスの間違い、転送の不調) で戻って
きたときに、この命令を使って戻ってきたメールをもう一回送ることができま
す (@code{gnus-summary-resend-bonced-mail})。メールバッファーにそのメー
ルが現れて、そこでもう一度メールを送る前にヘッダーを編集することができま
す。この命令に接頭引数を与えると、戻ってきたメールが何か他のメールへの返
答であった場合に、Gnus はそのメールを取得して、それのヘッダーの精密調査
ができるように画面に表示しようとします。ま、これはとてもよく失敗しますけ
ど。

@item S D r
@kindex S D r (概略)
@findex gnus-summary-resend-message
上の命令と混同しないで下さい。@code{gnus-summary-resend-message} は現在
のメッセージを送る宛先のアドレスの入力を促して、その場所にメールを送りま
す。メッセージのヘッダーは変更されません---しかし @code{Resent-To},
@code{Resent-From} などの、たくさんのヘッダーが付け加えます。これは、(お
そらく) あなた自身を @code{To} 欄に書いた本人にもメールを送ってしまうと
いうことです。これは混乱を招くでしょう。ですから当然、あなたが本当に邪悪
な人でなければ、これは使わないでしょう。

この命令は主に、あなたがいくつかのメールアカウントを持っていて、自分自身
の違ったアカウントにメールを転送したいときに用いられます。(もしあなた
が @code{root} であり、@code{postmaster} でもあり、@code{root} 宛て
に @code{postmaster} へのメールを受け取った場合は、それ
を @code{postmaster} にも再送する必要があるかもしれません。秩序がなけれ
ばなりません! (Ordnung muss sein!))

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S D e
@kindex S D e (概略)
@findex gnus-summary-resend-message-edit
一つ前のコマンドに似ていますが、再送する前にあたかも新しいメッセージのよ
うに編集することができます。

@item S O m
@kindex S O m (概略)
@findex gnus-uu-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその
結果を送ります (@code{gnus-summary-digest-mail-forward})。この命令はプロ
セス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c (概略)
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰なクロスポストへの苦情のメールを送りま
す (@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行しているクロスポストの世界的流行に対して反
撃を行なう手段として提供されています。これは変
数 @code{gnus-crosspost-complaint} を序文にして返答を作成します。この命
令はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれの
メールを送る前に送信するかどうかの確認をします。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニュースの記事を投稿するための命令:

@table @kbd
@item S p
@itemx a
@kindex a (概略)
@kindex S p (概略)
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
投稿するための記事を作成します (@code{gnus-summary-post-news})。ディフォ
ルトでは現在のグループに投稿します。接頭引数が与えられると、現在のグルー
プ名は使われません。もし接頭引数が 1 だったら、代わりに別のどのグループ
に投稿するかを尋ねます。

@item S f
@itemx f
@kindex f (概略)
@kindex S f (概略)
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F (概略)
@kindex F (概略)
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
元記事を取り込んで、現在の記事にフォローアップをしま
す (@code{gnus-summary-followup-with-original})。この命令はプロセス/接頭
引数の習慣を用います。

@item S n
@kindex S n (概略)
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、現在の記事のフォローアップを
ニュースに投稿しま
す (@code{gnus-summary-followup-to-mail})。この命令はプロセス/接頭引数の
習慣を用います。

@item S N
@kindex S N (概略)
@findex gnus-summary-followup-to-mail-with-original
メールのメッセージを受け取っていたとしても、元記事を引用して、現在の記事
のフォローアップをニュースに投稿しま
す (@code{gnus-summary-followup-to-mail-with-original}). この命令はプロ
セス/接頭引数の習慣を用います。

@item S o p
@kindex S o p (概略)
@findex gnus-summary-post-forward
現在の記事をニュースグループに転送しま
す (@code{gnus-summary-post-forward})。接頭引数が与えられない場合、メッ
セージは @code{message-forward-as-mime} およ
び @code{message-forward-show-mml} の値に従ったやり方で転送されます。接
頭引数が 1 だったら、デコードされたメッセージが直接埋め込まれた転送用の
バッファーが作られます。2 だったら rfc822 形式の @acronym{MIME} パートが
挿入されます。この場合、元のメッセージはデコードされません。3 ではデコー
ドされた rfc822 形式の @acronym{MIME} パートが挿入されます (実際に送信す
る際に再びエンコードされます)。接頭引数 4 では、1 の場合と同じ動作になり
ます。接頭引数がこれら以外の場合には、@code{message-forward-as-mime} の
値を一時的に反転して、接頭引数が与えられなかった場合と同じ動作を行ないま
す。ディフォルトでは、デコードされたメッセージが rfc822 形式
の @acronym{MIME} パートとして生成されます。

@item S O p
@kindex S O p (概略)
@findex gnus-uu-digest-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニュースグループに送りま
す (@code{gnus-summary-digest-post-forward})。この命令はプロセス/接頭引
数の習慣を用います。

@item S u
@kindex S u (概略)
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを uuencode して分割し、それらを連続して投稿しま
す (@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@node Summary Message Commands
@subsection 概略メッセージ命令

@table @kbd
@item S y
@kindex S y (概略)
@findex gnus-summary-yank-message
現在の記事を、すでに存在するメッセージ作成バッファーに貼り付けま
す (@code{gnus-summaryyank-message})。この命令は貼り付けたいメッセージバッ
ファーの入力を促し、プロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。
@end table

@node Canceling and Superseding
@subsection 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C (概略)
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけて下さい (取り消すことができるのは自分の記事だけ
です。変なことは試さないで下さい)。そして @kbd{C} か @kbd{S c} を押して
下さい (@code{gnus-summary-cancel-article})。あなたの記事が取り消されま
す---世界中の機械があなたの記事を取り消します。この命令はプロセス/接頭引
数の習慣を用います (@pxref{Process/Prefix})。

しかし注意して欲しいのは、すべてのサイトが取り消しを扱っているわけではな
いことです。ですから、たいていのサイトが問題の記事を取り消しても、あちこ
ちであなたの記事は生き残るかもしれません。

Gnus は取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 @samp{a} を使って下さ
い (@pxref{Symbolic Prefixes})。

Gnus は @code{Cancel-Lock} ヘッダー (@pxref{Canceling News,
,ニュースを取り消す, message-ja, The Message Manual}) を使って、あなただ
けがあなたのメッセージをキャンセルできるようにします。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、
@dfn{代替} (@dfn{superseding}) 記事を投稿して元記事を置き換えることがで
きます。

@findex gnus-summary-supersede-article
@kindex S (概略)
元記事のところへ移動して、@kbd{S s} を押して下さ
い (@code{gnus-summary-supersede-article})。それを普通に送信する前に、記
事を好きなように編集することができます。

代替に関しても、取り消しと同じことが当てはまります。こちらの方がもっとよ
く当てはまるかもしれません: いくつかのサイトは代替を受け付けません。これ
らのサイトでは、ほとんど同じ記事を二回投稿したようになってしまいます。

もしさっき記事を投稿したばかりですぐに変更したくなった場合、記事が最初に
あなたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファー (@code{*sent ... *} のようになっています) に戻って
下さい。そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーがそ
のままあります。@code{Message-ID} ヘッダーを @code{Cancel} もしく
は @code{Supersedes} に変更して下さい。そして、いつもやっているように単
に @kbd{C-c C-c} を押して記事を送信して下さい。前の記事は取り消されるか
置き換えられるでしょう。

ちょっと覚えておいて下さい: 'supersede' (代替) という語の中に 'c' は無い
ということを。

@node Delayed Articles
@section 遅延記事
@cindex delayed sending
@cindex send delayed

ときとして、あなたはメッセージの送信を先延ばしにしたいと思うことはありま
せんか。例えば、あなたが大切なだれかの誕生日を思い出すために、ちょうどそ
の日に届くメッセージを用意したいと思ったとしましょう。
@code{gnus-delay} パッケージはこれにうってつけです。設定は簡単です:

@lisp
(gnus-delay-initialize)
@end lisp

@findex gnus-delay-article
普段はメッセージを送信するのに Message モードで @kbd{C-c C-c} コマンドを
使いますよね。先延ばしにするには、代わりに @kbd{C-c C-j}
(@code{gnus-delay-article}) を使って下さい。そうすると、どのくらい遅らせ
るかを尋ねてきます。可能な返事は次の通りです:

@itemize @bullet
@item
期間。整数と一つの文字で指定します。例えば @code{42d} は 42 日遅らせるこ
とを意味します。使うことができる文字は @code{m} (分)、@code{h} (時)、
@code{d} (日), @code{w} (週), @code{M} (月) および @code{Y} (年) です。

@item
日付。@code{YYYY-MM-DD} のような形式で指定します。メッセージの送信はその
日の特定の時刻 (ディフォルトは 8 時) まで遅らせられます。
@code{gnus-delay-default-hour} も参照して下さい。

@item
時刻。am/pm を含まない 24 時間制の、@code{hh:mm} の形式で与えます。送信
されるのは今日のその時刻ですが、すでにその時刻を過ぎてしまっていた場合は
翌日のその時刻になります。ですから、朝の 10 時に @code{11:15} を指定した
場合は 1時間15分後に送信されることになります。しかし @code{9:20} を指定
した場合は翌日の時刻を意味します。
@end itemize

@code{gnus-delay-article} の動作は、以下の数個の変数に影響されます:

@table @code
@item gnus-delay-default-hour
@vindex gnus-delay-default-hour
特定の日付を指定した場合に、メッセージがその日の何時に送信されるかを与え
ます。可能な値は 0 から 23 までの整数です。

@item gnus-delay-default-delay
@vindex gnus-delay-default-delay
ディフォルトの遅延を与える文字列です。前述のどんな形式でも可能です。

@item gnus-delay-group
@vindex gnus-delay-group
遅延記事は、ドラフトサーバーのこのグループに期限が来るまで保管されます。
たぶんあなたはこれを変更する必要は無いでしょう。ディフォルトの値
は @code{"delayed"} です。

@item gnus-delay-header
@vindex gnus-delay-header
それぞれの記事が送信される日時はヘッダーに記録されます。この変数はヘッダー
名の文字列です。たぶんあなたはこれを変更する必要は無いでしょう。ディフォ
ルトの値は @code{"X-Gnus-Delayed"} です。
@end table

送信の先延ばしはこんなふうに行なわれます: @code{gnus-delay-article} コマ
ンドで、あなたはどのくらい遅らせるかを指定します。Gnus はメッセージを送
信する日時を計算して @code{X-Gnus-Delayed} ヘッダーに記録し、そのメッセー
ジを @code{nndraft:delayed} グループに納めます。

@findex gnus-delay-send-queue
そして、あなたが新着ニュースを取得しようとするときはいつも、Gnus は送信
する期限に達した記事をそのグループで探して、それらを送信します。これには
関数 @code{gnus-delay-send-queue} が使われます。ディフォルトではこの関数
は @code{gnus-get-new-news-hook} に追加されますが、もちろんあなたはこれ
を変更することができます。おそらくあなたは、ドラフトの送信にデーモンを使
いたいと思うのではないでしょうか? それには、デーモンに関
数 @code{gnus-delay-send-queue} を実行せよ、と言うだけで良いのです。

@table @code
@item gnus-delay-initialize
@findex gnus-delay-initialize
ディフォルトではこの関数
は @code{gnus-delay-send-queue} の @code{gnus-get-new-news-hook} への追
加を行ないます。ですが、これは第二オプション引数 @code{no-check} を受け
付けます。もしそれが非-@code{nil} だった
ら @code{gnus-get-new-news-hook} は変更されません。第一オプション引数は
無視されます。

例えば @code{(gnus-delay-initialize nil t)} は何もしないことを意味します。
あなたは遅延記事の送信にデーモンを使いたいのでしょうね。でも、それを設定
することを忘れないで下さいね。:-)
@end table

@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の @dfn{購読度} (うひょーっ、何てすらばやしい造語だ!) を決定する印が
あります。英字でない文字が一般に @dfn{未読} を意味するのに対して、英字の
印は一般に @dfn{既読} を意味します。

加えて、購読度に影響しない印もあります。

@ifinfo
これらの印を操作する過剰なくらいの命令があります:
@end ifinfo

@menu
* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方
@end menu

@node Unread Articles
@subsection 未読記事

以下の印はいろいろな方法で記事に未読の (ような) 印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (ticked) として印を付けます (@code{gnus-ticked-mark})。

@dfn{可視記事} とは常に可視状態である記事のことです。おもしろいと思う記
事があった場合や、読むのを先に延ばしたいときや、後で返答をしたいときに、
普通は可視印を付けます。しかし、記事は期限切れ消去されることもありま
す (ニュースサーバー上の記事を消去するのはニュースサーバーのソフトウェア
で、Gnus 自体は可視記事を期限切れ消去しません) ので、永遠に記事を保存し
ておきたい場合は、その記事を永続にする必要があります (@pxref{Persistent
Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

@dfn{保留記事} はフォローアップがあったときにだけ概略バッファーに現れま
す。フォローアップが無いときも表示させたいときは、@kbd{/ D} 命令を使って
下さい (@pxref{Limiting})。それ以外は (見えるかどうかは別にして)、可視記
事 (ticked) と似たようなものです。

@item SPACE
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

@dfn{未読記事} は今までまったく読まれていない記事のことです。
@end table

@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp
@item r
@vindex gnus-del-mark
利用者が手動で @kbd{d} 命令もしくはそれに類する手段を使って、既読の印を
付けた記事です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は @dfn{古く} なってしまった記事。

@item K
@vindex gnus-killed-mark
削除された印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印がついた記
事 (@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印がついた記
事 (@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印がついた記
事 (@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item F
@vindex gnus-souped-mark
@sc{soup} されている記事 (@code{gnus-souped-mark})。@xref{SOUP}.

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}.

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印のついた記事 (@code{gnus-duplicate-mark})。
@xref{Duplicate Suppression}.
@end table

これらのすべての印は、本当にただ記事が既読として印がついていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります:

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ消去可能として印のついた記事 (@code{gnus-expirable-mark})。

記事を @dfn{期限切れ消去可能} として印を付ける (もしくは、自動的にそのよ
うに印を付ける) ことは、普通のグループではあまり意味がありません---利用
者はニュース記事の期限による削除を制御していません。しかし、例えばメール
グループでは、@dfn{期限切れ消去可能} として印のついた記事は、いつで
も Gnus によって削除されることがあります。
@end table

@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet

@item
現在の記事にしおりを挟むことができます。あなたは猫のおしっこの習慣に関す
る長い論文を読んでいて、それを読み終わる前に晩ご飯を食べに家に帰らなけれ
ばならなかったとしましょう。そんなとき、記事にしおりを挟むことができます。
次にその記事に出くわすと、Gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}.

@item
@vindex gnus-replied-mark
返信したかフォローアップした (つまり、答えた) すべての記事には、二桁目
に @samp{A} の印が付きます (@code{gnus-replied-mark})。

@item
@vindex gnus-forwarded-mark
転送したすべての記事には、二桁目に @samp{F} の印が付きま
す (@code{gnus-forwarded-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は、二桁目に @samp{*} の印が付きま
す (@code{gnus-replied-mark})。@xref{Article Caching}.

@item
@vindex gnus-saved-mark
(何らかの方法によって; 必ずしも宗教的というわけではなく) 『救済された』
(原文は saved==保存された) 記事は、二桁目に @samp{S} の印が付きま
す (@code{gnus-saved-mark})。

@vindex gnus-recent-mark
まだサーバーが利用者に見せていない記事は、二桁目に @samp{N} の印が付きま
す (@code{gnus-recent-mark})。たいていのサーバーはこの印をサポートせず、
その場合は単に表示されません。@code{gnus-unseen-mark} と見比べて下さい。

@item
@vindex gnus-unseen-mark
まだ Gnus で読まれたことがない記事は、二桁目に @samp{.} の印が付きま
す (@code{gnus-unseen-mark})。@code{gnus-recent-mark} と見比べて下さい。

@item
@vindex gnus-downloaded-mark
Gnus エージェント (@pxref{Agent Basics}) を使っているとき、記事
は unplugged (オフライン) で見るためにダウンロードされるかもしれませ
ん。@samp{%O} の仕様を使っていると、それらの記事にはその仕様
に @samp{+} の印が付きます。(変数 @code{gnus-downloaded-mark} でどの文字
を使うかを制御します。)

@item
@vindex gnus-undownloaded-mark
Gnus エージェント (@pxref{Agent Basics}) を使っているとき、いくつかの記
事はダウンロードされていないかもしれません。Unplugged (オフライン) の状
態ではそのような記事を見ることができません。@samp{%O} の仕様を使っている
と、それらの記事にはその仕様に @samp{-} の印が付きます。(変
数 @code{gnus-undownloaded-mark} でどの文字を使うかを制御します。)

@item
@vindex gnus-downloadable-mark
Gnus エージェント (@pxref{Agent Basics}) はいくつかの記事を自動的にダウ
ンロードしますが、自動的にダウンロードされない記事にもダウンロードのため
の明示的な印を付けることは可能です。そのような明示的に印が付けられた記事
には、最初の桁に @samp{%} の印が付きます。(変
数 @code{gnus-downloadable-mark} でどの文字を使うかを制御します。)

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
@samp{%e} の仕様が使われると、スレッドがあるかどうかの印
が @code{gnus-not-empty-thread-mark} また
は @code{gnus-empty-thread-mark} によって、三桁目に付きます。

@item
@vindex gnus-process-mark
最後に @dfn{プロセス印} があります (@code{gnus-process-mark})。いろいろ
な種類の命令が、プロセス印があるとそれに対して実行されます。例え
ば @kbd{X u} (@code{gnus-uu-decode-uu}) は、プロセス印の付いたすべての記
事を uudecode して表示します。プロセス印の付いた記事は二桁目
に @samp{#} があります。
@end itemize

たいていのこれら『購読度と関係無い』印は、ディフォルトでは二桁目に現れる
ことに気付いたでしょう。では、キャッシュされていて、保存されていて、返答
した記事にプロセス印を付けた場合は、どうなるのでしょう?

たいしたことはありません。優先順位は次のようになっています: プロセ
ス → キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入っ
ていて返答されていた場合、キャッシュ印が見えるだけで、返答済み印は見えま
せん。

@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印を付けるための命令は、数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c (概略)
@kindex M-u (概略)
@findex gnus-summary-clear-mark-forward
@cindex mark as unread
現在の記事から、すべての購読度に関する印を消去しま
す (@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を
付けます。

@item M t
@itemx !
@kindex ! (概略)
@kindex M t (概略)
@findex gnus-summary-tick-article-forward
現在の記事に可視記事の印を付けま
す (@code{gnus-summary-tick-article-forward})。@xref{Article Caching}.

@item M ?
@itemx ?
@kindex ? (概略)
@kindex M ? (概略)
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事の印を付けま
す (@code{gnus-summary-mark-as-read-forward})。@xref{Article Caching}.

@item M d
@itemx d
@kindex M d (概略)
@kindex d (概略)
@findex gnus-summary-mark-as-read-forward
現在の記事に既読の印を付けま
す (@code{gnus-summary-mark-as-read-forward})。

@item D
@kindex D (概略)
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動しま
す (@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k (概略)
@kindex M k (概略)
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K (概略)
@kindex C-k (概略)
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けま
す (@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C (概略)
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c (概略)
@findex gnus-summary-catchup-all
グループのすべての記事に---可視記事や保留記事でさえも、既読の印を付けま
す (@code{gnus-summary-catchup-all})。

@item M H
@kindex M H (概略)
@findex gnus-summary-catchup-to-here
現在のグループの、現在位置とそれ以前の記事を既読として印を付けま
す (@code{gnus-summary-catchup-to-here})。

@item M h
@kindex M h (概略)
@findex gnus-summary-catchup-from-here
現在のグループの、現在位置とそれ以降の記事を既読として印を付けま
す (@code{gnus-summary-catchup-from-here})。

@item C-w
@kindex C-w (概略)
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けま
す (@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k (概略)
@findex gnus-summary-kill-below
ディフォルトのスコア (もしくは数値接頭引数) よりも低いスコアの記事を削除
します。

@item M e
@itemx E
@kindex M e (概略)
@kindex E (概略)
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ消去可能として印を付けま
す (@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b (概略)
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B (概略)
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c (概略)
@findex gnus-summary-clear-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つ記事
のすべての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u (概略)
@findex gnus-summary-tick-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つすべ
ての記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m (概略)
@findex gnus-summary-mark-above
印の入力を促し、ディフォルトのスコア (もしくは数値接頭引数) よりも大きな
スコアを持つすべての記事にその印を付けま
す (@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作
がなされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未
読記事に移動します。もし @code{nil} であると、ポイントは一行上か下に行く
だけです。特別な場合として、この変数が @code{never} であると、すべての印
を付ける命令と (@kbd{SPACE} のような) 他の命令は次の記事が未読であろうが
無かろうが次の記事に移動します。ディフォルト値は @code{t} です。

@node Generic Marking Commands
@subsection Generic Marking Commands

記事に可視の印を付ける命令 (@kbd{!}) に、次の記事に移動してもらいたい人
がいます。次の未読記事に移動してもらいたい人もいます。さらに、現在の記事
に留まっていてもらいたい人もいるでしょう。そして、前の (未読の) 記事に行っ
て欲しい人がいるとはまだ聞いたことはありませんが、そうしたいと思う人も間
違いなくいると思います。

この五つの動作を五つの違った印付け命令と掛け算すると、どの命令が何をすべ
きかの非常に複雑な変数の組を持つことになります。

この窮地を脱するために、Gnus はこれらすべての違ったことをする命令を提供
します。これらは概略バッファーの @kbd{M M} マップにあります。すべてを見
るためには @kbd{M M C-h} を入力して下さい---このマニュアルで一覧を出すに
は多過ぎます。

これらの命令を直接使うことはできますが、ほとんどの利用者は概略モードのキー
マップを交換する方を好むでしょう。例えば、@kbd{!} 命令に次の未読記事の代
わりに次の記事に移動して欲しいとすると、このようなことができます:

@lisp
(add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
(defun my-alter-summary-map ()
  (local-set-key "!" 'gnus-summary-put-mark-as-ticked-next))
@end lisp

@noindent
もしくは、

@lisp
(defun my-alter-summary-map ()
  (local-set-key "!" "MM!n"))
@end lisp

@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

プロセス印は概略バッファーに @code{#} として表示され、他のコマンドで処理
させる記事に印を付けるために使われます。例えば、四つの記事に印を付けてか
ら @kbd{*} コマンドを使うと、Gnus はそれら四つの記事をキャッシュに入れま
す。詳しくは @ref{Process/Prefix} をどうぞ。

@table @kbd
@item M P p
@itemx #
@kindex # (概略)
@kindex M P p (概略)
@findex gnus-summary-mark-as-processable
現在の記事にプロセス印を付けま
す (@code{gnus-summary-mark-as-processable})。

@item M P u
@itemx M-#
@kindex M P u (概略)
@kindex M-# (概略)
@findex gnus-summary-unmark-as-processable
もし現在の記事にプロセス印があれば取り除きま
す (@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U (概略)
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きま
す (@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i (概略)
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にしま
す (@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R (概略)
@findex gnus-uu-mark-by-regexp
正規表現に合致する @code{Subject} ヘッダーを持つ記事に印を付けま
す (@code{gnus-uu-mark-by-regexp})。

@item M P G
@kindex M P G (概略)
@findex gnus-uu-unmark-by-regexp
正規表現に合致する @code{Subject} ヘッダーを持つ記事から印を削除しま
す (@code{gnus-uu-unmark-by-regexp})。

@item M P r
@kindex M P r (概略)
@findex gnus-uu-mark-region
領域にある記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P g
@kindex M P g (概略)
@findex gnus-uu-unmark-region
領域にある記事から印を削除します (@code{gnus-uu-unmark-region})。

@item M P t
@kindex M P t (概略)
@findex gnus-uu-mark-thread
現在のスレッド (または副スレッド) のすべての記事に印を付けま
す (@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T (概略)
@findex gnus-uu-unmark-thread
現在のスレッド (または副スレッド) のすべての記事から印を取り除きま
す (@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v (概略)
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けま
す (@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s (概略)
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S (概略)
@findex gnus-uu-mark-sparse
すでにいくつか印の付いた記事を持つ一連の記事群すべてに印を付けま
す (@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a (概略)
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けま
す (@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b (概略)
@findex gnus-uu-mark-buffer
バッファーのすべての記事を現れている順番に印を付けま
す (@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k (概略)
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にしま
す (@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y (概略)
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元しま
す (@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w (概略)
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みま
す (@code{gnus-summary-save-process-mark})。
@end table

そして、記事の本文の内容に基づいてプロセス印を付けるやり方については、
@ref{Searching for Articles} の @kbd{&} 命令を参照して下さい。

@node Limiting
@section 制限をする
@cindex limiting

現在グループにある記事の一部だけを表示するように概略バッファーを制限でき
れば便利なことがあります。多くの制限命令が持つ効果は、概略バッファーから
少し (もしくは多く) の記事を削除することです。

すべての制限命令はサーバーからすでに取得された記事の一部分に作用します。
これらの命令はどれもサーバーに追加の記事を要求しません。

@table @kbd
@item / /
@itemx / s
@kindex / / (概略)
@findex gnus-summary-limit-to-subject
概略バッファーをいくつかの表題と合致するものだけに制限しま
す (@code{gnus-summary-limit-to-subject})。接頭引数が与えられると、合致
する記事を除外します。

@item / a
@kindex / a (概略)
@findex gnus-summary-limit-to-author
概略バッファーを何人かの著者に合致するものだけに制限しま
す (@code{gnus-summary-limit-to-author})。接頭引数が与えられると、合致す
る記事を除外します。

@item / R
@kindex / R (概略)
@findex gnus-summary-limit-to-recipient
概略バッファーをいくつかの受信者に合致する記事だけに制限しま
す (@code{gnus-summary-limit-to-recipient})。接頭引数が与えられると、合
致する記事を除外します。

@item / x
@kindex / x (概略)
@findex gnus-summary-limit-to-extra
``追加'' のヘッダーの一つに合致する記事に概略バッファーを制限しま
す (@pxref{To From Newsgroups}) (@code{gnus-summary-limit-to-extra})。接
頭引数が与えられると、合致する記事を除外します。

@item / u
@itemx x
@kindex / u (概略)
@kindex x (概略)
@findex gnus-summary-limit-to-unread
概略バッファーを既読の印が付いていない記事に制限しま
す (@code{gnus-summary-limit-to-unread})。接頭引数が与えられると、バッ
ファーを完全に未読記事のみに制限します。これは、可視と保留の記事は含まれ
ないということです。

@item / m
@kindex / m (概略)
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いている記事に制限しま
す (@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t (概略)
@findex gnus-summary-limit-to-age
数値を尋ねて、概略バッファーをその日数より古い (もしくは同じ) 記事に制限
します (@code{gnus-summary-limit-to-age})。接頭引数が与えられると、その
数値の日よりも新しい記事に制限します。

@item / n
@kindex / n (概略)
@findex gnus-summary-limit-to-articles
概略バッファーを現在の記事に制限しま
す (@code{gnus-summary-limit-to-articles})。プロセス/接頭引数の習慣を使
います (@pxref{Process/Prefix})。

@item / w
@kindex / w (概略)
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元しま
す (@code{gnus-summary-pop-limit})。接頭引数を与えられると、すべての制限
をスタックから取り出します。

@item / .
@kindex / . (概略)
@findex gnus-summary-limit-to-unseen
概略バッファーをまだ読まれたことが無い記事に制限しま
す (@code{gnus-summary-limit-to-unseen})。

@item / v
@kindex / v (概略)
@findex gnus-summary-limit-to-score
概略バッファーをあるスコアと同じか、それより大きなスコアを持つ記事に制限
します (@code{gnus-summary-limit-to-score})。

@item / p
@kindex / p (概略)
@findex gnus-summary-limit-to-display-predicate
概略バッファーを @code{display} グループパラメーターの述語を満足させるよ
うに制限します (@code{gnus-summary-limit-to-display-predicate})。この述
語に関する詳細は @ref{Group Parameters} を参照して下さい。

@item / r
@kindex / r (概略)
@findex gnus-summary-limit-to-replied
概略バッファーを返信した記事だけに制限しま
す (@code{gnus-summary-limit-to-replied})。接頭引数が与えられると、返信
した記事以外の記事に制限します。

@item / E
@itemx M S
@kindex M S (概略)
@kindex / E (概略)
@findex gnus-summary-limit-include-expunged
すべての消去された記事を制限に含めま
す (@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D (概略)
@findex gnus-summary-limit-include-dormant
すべての保留記事を制限に含めま
す (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * (概略)
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を制限に含めま
す (@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d (概略)
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を制限から除外しま
す (@code{gnus-summary-limit-exclude-dormant})。

@item / M
@kindex / M (概略)
@findex gnus-summary-limit-exclude-marks
すべての印付き記事を除外します (@code{gnus-summary-limit-exclude-marks})。

@item / T
@kindex / T (概略)
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を制限に含めま
す (@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c (概略)
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を制限から除外しま
す (@code{gnus-summary-limit-exclude-childless-dormant})。

@item / C
@kindex / C (概略)
@findex gnus-summary-limit-mark-excluded-as-read
すべての除外された未読の記事に既読の印を付けま
す (@code{gnus-summary-limit-mark-excluded-as-read})。接頭引数が与えられ
ると、可視と保留のみの印の記事も既読として印を付けます。

@item / N
@kindex / N (概略)
@findex gnus-summary-insert-new-articles
すべての新しい記事を概略バッファーに挿入します。
@var{back-end}@code{-get-new-mail} が非-@code{nil} だったら、新しいメー
ルの到来を調べるということです。

@item / o
@kindex / o (概略)
@findex gnus-summary-insert-old-articles
すべての古い記事を概略バッファーに挿入します。数値の接頭引数が与えられる
と、その個数の記事を取り込みます。
@end table

@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus はディフォルトで記事をスレッド表示します。@dfn{スレッドにする} とは、
ある記事への応答を応答した記事の直後に置く---階層的流儀で、ということで
す。

スレッドは記事の @code{References} 欄を調べることによって行なわれます。
理想的な世界では、これだけで木を完成させるのに十分なのですが、不運なこと
に @code{References} 欄はしばしば壊れているか、時には単に無いことがあり
ます。怪しげなニュースの伝搬は問題を悪化させるので、満足な結果を得るため
には他の検出法を採用しなければなりません。過剰な対策法は存在していて、そ
の恐るべき詳細は @ref{Customizing Threading} に詳しく書いてあります。

まず、概念の概観です:

@table @dfn
@item 根本 (root)
スレッドで一番頂点にある記事です；スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 副スレッド (sub-thread)
木のような構造の (より) 小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ消去や、根本がすでに前回のセッションで読まれたことにより概
略バッファーに表示されない、等の理由により、スレッドはしばしば根本を失い
ます。そのようなときには、普通は多くの副スレッドがあって、本当は一つのス
レッドに属しているのですが、根本にはつながっていない、ということになりま
す。こういうスレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
副スレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
そこではたぶんいくつかの記事が失われてしまったのだろうと『推測された』ス
レッドのことで、概略バッファーでは空行で表示されます。
@end table

@menu
* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令
@end menu

@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう@dots{} でもあなたは間違っていた!
@end menu

@node Loose Threads
@subsubsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、Gnus はすべてのつながっていない部分木を一つの
大きな木にして、頂上にみせかけの根本を作ります。(ちょっと待って下さい。
頂上に根元 (root) ですって? ええ、そうなのです。) つながっていない部分木
は本当の根本が期限切れ消去されたか、前回のセッションで根本を読んだり削除
したときにできます。

本当のスレッドが無いときは、Gnus は何かでっち上げをする必要があります。
この変数は Gnus が使うべきごまかしの方法を示しています。値としてとること
ができる四つの候補があります。
@iftex
@iflatex
\gnusfigure{The Summary Buffer}{390}{
\put(0,0){\epsfig{figure=ps/summary-adopt,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-empty,width=7.5cm}}}
\put(0,400){\makebox(0,0)[tl]{\epsfig{figure=ps/summary-none,width=7.5cm}}}
\put(445,400){\makebox(0,0)[tr]{\epsfig{figure=ps/summary-dummy,width=7.5cm}}}
}
@end iflatex
@end iftex

@cindex adopting articles
@table @code
@item 養子 (adopt)
Gnus は孤児になった記事群の最初のものを親にします。この親はすべての他の
記事を養子にします。それらの養子記事は、標準の角括弧 (@samp{[]}) の代わ
りに、先の尖った括弧 (@samp{<>}) で印が付けられます。これがディフォルト
の手段です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
@vindex gnus-summary-make-false-root-always
Gnus は親のふりをするみせかけの概略行を作ります。このみせか
けの行はどの本当の記事にも対応しないので、それを選択することは、
みせかけの記事の後の最初の本当の記事を選択をするだけになります。
みせかけの根本の様式を指定するために、
@code{gnus-summary-dummy-line-format} が使われます。これはたっ
た一つだけのフォーマットの仕様を受け付けます: それは @samp{S} で、
記事の表題です (@pxref{Formatting Variables})。たとえ集めるもの
が無くても、すべてのスレッドにみせかけの根本を持たせたい場合は、
@code{gnus-summary-make-false-root-always} を @code{t} に設定し
て下さい。

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、最初の孤児を除いてすべての孤児の表
題欄を単に空のままにします。(実際は @code{gnus-summary-same-subject} を
表題として使います (@pxref{Summary Buffer Format})。)

@item none
まったくどの記事も親にしません。スレッドを集めて、単に順繰りに表示するだ
けです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変
数が @code{nil} であると、Gnus は無束縛スレッドを一つの大きな超スレッド
に集める前に、無束縛スレッドの表題が完全に一致することを要求します。これ
は、長い表題の行を切り落としてしまう間抜けなニュースリーダーが存在する現
状では、あまりに厳しい要求かもしれません。そう思うのなら、この変数を例え
ば 20 に設定して、表題の最初の 20 文字だけが一致することを要求するように
して下さい。この変数を本当に低い数値に設定すると、目についたもののすべて
を Gnus が一つのスレッドに集めるのを見ることになるでしょう。それはあまり
有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すると、Gnus は表題の文字列を大雑
把に比較するアルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-simplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
正規表現または正規表現のリストのどちらかです。表題の大雑把な比較を行なう
ときに、それらに合致する文字列を表題から取り除きます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-ignored-prefixes
もし @code{gnus-summary-gather-subject-limit} を 10 くらいに低く設定した
ならば、この変数を何か意味のあるものに設定することを考えるでしょう:

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、二つの表題を比較する前に取り除かれま
す。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数
は @code{gnus-summary-gather-subject-limit} よりも優先されます。この変数
は @code{Subject} の文字列に反復して作用させて簡単にするための、関数のリ
ストである必要があります。

このリストに入れて役に立つような関数は次のようなものです:

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
大雑把な比較ができるように簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。

@item gnus-simplify-all-whitespace
@findex gnus-simplify-all-whitespace
すべての空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。

@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題だけで行なわれるので、特
に @samp{} や @samp{(none)} のような良くある表題のときは、多くの間違いを
起こす可能性があります。この状況を少し良くするために、正規表
現 @code{gnus-summary-gather-exclude-subject} を使うことによって、集める
過程においてどんな表題を除外するかを指示することができます。ディフォルト
は @samp{^ *$\\|^(none)$} です。

@item gnus-summary-thread-gathering-function
@vindex gnus-summary-thread-gathering-function
Gnus は @code{Subject} 欄を調べることによってスレッドを集めます。これは、
結果的にまったく関係の無い記事が同じ『スレッド』に含まれるかもしれないこ
とを意味し、混乱の元です。代替手段は、合致するものを見つけるため
に @code{References} 欄にある @code{Message-ID} をすべて調べることです。
これは集められたスレッドが関係の無い記事をまったく含まないことを保証しま
すが、いかれたニュースリーダーで投稿した記事は適切に集められないというこ
とでもあります。ペストかコレラかの選択権はあなたにあります。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を調べます。

@item gnus-gather-threads-by-references
@findex gnus-gather-threads-by-references
この関数は排他的に @code{References} 欄を調べます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます:

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp
@end table

@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、Gnus は古いスレッドをもっと古いヘッダー、すな
わち既読の印が付いている記事のヘッダー、を取得することで構築しようとしま
す。できるだけ少ない概略行を表示したいけれど、できるだけたくさんの無束縛
スレッドをつなげておきたいときは、この変数を @code{some} か数値に設定し
て下さい。もし数値に設定したときは、それより多い追加のヘッダーは取得され
ません。どちらの場合でも、古いヘッダーの取得は、使っているバックエンド
が overview ファイルを使っている場合だけ動作します。それらのバックエンド
は、普通は @code{nntp}, @code{nnspool}, @code{nnml} およ
び @code{nnmaildir} です。スレッドの根本がサーバーによって期限切れ消去さ
れてしまったら、Gnus はどうしようもないことも覚えておいて下さい。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、@kbd{A T} 命令をよく使うのであれば役に立つでしょ
う (@pxref{Finding the Parent})。

@item gnus-fetch-old-ephemeral-headers
@vindex gnus-fetch-old-ephemeral-headers
@code{gnus-fetch-old-headers} と同じですが、一時ニュースグループのために
だけ使われます。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。この変数
を @code{some} に設定することによって、同じような低賃金の効果を得ること
ができます。そうすると、Gnus はすべての記事の完全な @code{References} 欄
を見て、同じスレッドに属する記事をつなごうとします。これは、記事がそのス
レッドから失われていると Gnus が推測したスレッド表示に @dfn{ずれ} を残す
でしょう。(これらのずれは普通の概略行のように見えます。もしずれを選択す
ると、Gnus はその当の記事を取得しようとします。) この変数が @code{t} で
あると、Gnus はスレッドを補完するのに役立つかどうかを考慮せずに、すべて
の『ずれ』を表示します。最後に、この変数が @code{more} であると、Gnus は
どこにもつながっていない枝葉のまばらな節を切り落としません。この変数はディ
フォルトでは @code{nil} です。

@item gnus-read-all-available-headers
@vindex gnus-read-all-available-headers
これはあまり役に立たない、いささかはっきりしない変数です。ニュースではな
いグループにおいて、概略バッファーを作るためにバックエンドが極めて多くの
ものを取り込まなければならず、しかも親記事を辿ることができない場合に使う
ことを想定しています。それは主に @code{nnultimate} グループのような、ウェ
ブに基づいたグループでの場合です。

そんなグループを使わない場合はディフォルトの @code{nil} のままにしておく
のが無難です。使いたい場合はグループ名に合致する正規表現か、すべてのグルー
プが対象になる @code{t} にして下さい。
@end table

@node More Threading
@subsubsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数はまったく効果が無くなります。スレッド作りを止めるとグループの選
択が少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実で
す。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファーが生成された
ときに隠れます。

これは述語指示子であることもできます (@pxref{Predicate Specifiers})。利
用できる述語
は @code{gnus-article-unread-p} と @code{gnus-article-unseen-p} です。

これは例です:

@lisp
(setq gnus-thread-hide-subtree
      '(or gnus-article-unread-p
           gnus-article-unseen-p))
@end lisp

(これはかなりばかげた例です。なぜならすべてのまだ読まれたことが無い記事
は未読でもあるからなのですが、趣旨は汲み取って下さい。)

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数値より少ない総スコア (@code{gnus-thread-score-function} で定義され
た関数を使って算出されます) を持つすべてのスレッドは消去されます。この変
数はディフォルトでは @code{nil} で、これはどのスレッドも消去されないとい
うことです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
スレッドを削除すると、この変数が @code{nil} でない場合、部分木は隠されま
す。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
ときどき誰かがスレッドの途中で表題を変更することがあります。この変数
が @code{nil} でないと (これがディフォルトですが)、表題の変更は無視され
ます。もし @code{nil} だと、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
これは、それぞれの副スレッドがどれくらい字下げ (indent) されるべきかを決
める数値です。ディフォルトは 4 です。

@item gnus-sort-gathered-threads-function
@vindex gnus-sort-gathered-threads-function
とりわけメーリングリストでは、ときとして手元にメールが到着する順番は必ず
しもメーリングリストに到着した順番と同じでは無いことがあります。その結果、
副スレッドをディフォルトの @code{gnus-thread-sort-by-number} で並べ換え
ると、応答の方がそれの元記事より先に現れてしまうことがあります。グルー
プパラメーターや適切なフッ
ク (例えば @code{gnus-summary-generate-hook}) でこの変数を代わりの値 (例
えば @code{gnus-thread-sort-by-date}) に設定することによって、そのような
場合に、より論理的な副スレッドの順番を生成することができます。
@end table

@node Low-Level Threading
@subsubsection 低レベルにおけるスレッド作成

@table @code
@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
この変数の値が @code{nil} ではなくて関数であると、ヘッダー構造 (訳注: 記
事の主要なヘッダーの内容を効率良く保持するための Lisp オブジェクト) を変
更するために呼ばれます。関数は記事ヘッダーのベクトル (訳注: すなわちヘッ
ダー構造) とともに呼ばれ、それが何らかの方法で変更されます。例え
ば @code{Message-ID} を体系的な方法で (接頭語などを付け加えることによっ
て) 変更してしまうメールからニュースへのゲートウェイがある場合、この変数
を設定することによって、その @code{Message-ID} を元の意味のあるものに戻
すことができます。これは一つの例です:

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp

@quotation
訳注: 取得した記事の @code{Message-ID} 欄から、@samp{@@} の前に付加され
た @samp{cygnus.} で始まる文字列を取り除きます。
@end quotation
@end table

@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd
@item T k
@itemx C-M-k
@kindex T k (概略)
@kindex C-M-k (概略)
@findex gnus-summary-kill-thread
現在のスレッド (または副スレッド) のすべての記事に既読の印を付けま
す (@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりに
すべての印を取り除きます。接頭引数が負であると、代わりに記事を可視にしま
す。

@item T l
@itemx C-M-l
@kindex T l (概略)
@kindex C-M-l (概略)
@findex gnus-summary-lower-thread
現在のスレッド (または副スレッド) のスコアを下げま
す (@code{gnus-summary-lower-thread})。

@item T i
@kindex T i (概略)
@kindex gnus-summary-raise-thread
@findex gnus-summary-raise-thread
現在のスレッド (または副スレッド) のスコアを上げま
す (@code{gnus-summary-raise-thread})。

@item T #
@kindex T # (概略)
@findex gnus-uu-mark-thread
プロセス印を現在のスレッド (または副スレッド) に付けま
す (@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# (概略)
@findex gnus-uu-unmark-thread
現在のスレッド (または副スレッド) からプロセス印を取り除きま
す (@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T (概略)
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s (概略)
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示しま
す (@code{gnus-summary-show-thread})。

@item T h
@kindex T h (概略)
@findex gnus-summary-hide-thread
現在のスレッド (または副スレッド) を隠しま
す (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S (概略)
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示しま
す (@code{gnus-summary-show-all-threads})。

@item T H
@kindex T H (概略)
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t (概略)
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直しま
す (@code{gnus-summary-rethread-current})。これは概略バッファーがスレッ
ド表示されていないときでも動作します。

@item T ^
@kindex T ^ (概略)
@findex gnus-summary-reparent-thread
現在の記事を印付きの (もしくは前の) 記事の子記事にしま
す (@code{gnus-summary-reparent-thread})。
@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd
@item T n
@kindex T n (概略)
@itemx C-M-f
@kindex C-M-f (概略)
@itemx M-down
@kindex M-down (概略)
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p (概略)
@itemx C-M-b
@kindex C-M-b (概略)
@itemx M-up
@kindex M-up (概略)
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d (概略)
@findex gnus-summary-down-thread
スレッドを下ります (@code{gnus-summary-down-thread})。

@item T u
@kindex T u (概略)
@findex gnus-summary-up-thread
スレッドを登ります (@code{gnus-summary-up-thread})。

@item T o
@kindex T o (概略)
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、当然ながらいくつかの違った表題
があるスレッドが出来上がります。そし
て @kbd{T k} (@code{gnus-summary-kill-thread}) のような命令を発するとき
に、全体のスレッドを削除するのではなく、現在の記事と同じ表題を持つ部分だ
けを削除したいときがあるかもしれません。もしこの発想が良いと思うのであれ
ば、@code{gnus-thread-operation-ignore-subject} をいじってみて下さい。こ
れが @code{nil} でないと (それがディフォルトですが)、スレッドの命令を実
行しているときに表題は無視されます。これが @code{nil} だったら、同じスレッ
ドにある異なる表題を持つ記事は、そのとき行なう操作の対象に含まれません。
この変数が @code{fuzzy} であると、大雑把な比較によって等しいと判定される
表題を持つ記事だけが対象に含まれます (@pxref{Fuzzy Matching})。

@node Sorting the Summary Buffer
@section 並べ替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-recipient
@findex gnus-thread-sort-by-number
@findex gnus-thread-sort-by-random
@vindex gnus-thread-sort-functions
@findex gnus-thread-sort-by-most-recent-number
@findex gnus-thread-sort-by-most-recent-date
概略でスレッドの表示を使っているのであれば、
@code{gnus-thread-sort-functions} を設定することによってスレッドを並べ替
えることができます。この変数の値は単独の関数、関数のリスト、または関数
と @code{(関数でないもの)} の要素を含むリストであることができます。

ディフォルトでは並べ替えは記事番号に基づいて行なわれます。すでに用意され
ている並べ替え述語関数は @code{gnus-thread-sort-by-number},
@code{gnus-thread-sort-by-author}, @code{gnus-thread-sort-by-recipient},
@code{gnus-thread-sort-by-subject}, @code{gnus-thread-sort-by-date},
@code{gnus-thread-sort-by-score},
@code{gnus-thread-sort-by-most-recent-number},
@code{gnus-thread-sort-by-most-recent-date},
@code{gnus-thread-sort-by-random} およ
び @code{gnus-thread-sort-by-total-score} です。

それぞれの関数は二つのスレッドをとり、最初のスレッドがもう一方より先に並
べ替えられるべきであれば @code{nil} でない値を返します。実際の並べ替えは、
普通それぞれのスレッドの根本だけを調べることによって行なわれることに気を
付けて下さい。

二つ以上の関数を使う場合、並べ替えの第一の鍵はリストの最後の関数でなけれ
ばなりません。並べ替え関数のリストのなるべく先頭に、おそらく常
に @code{gnus-thread-sort-by-number} を含めておくべきでしょう。これは、
他の並べ替えの基準が等しいスレッドが、記事番号の登り順に表示されることを
保証します。

スコアの逆順、表題、そして最後に番号、の順に並べ替えたいのであれば、次の
ようにできます:

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        (not gnus-thread-sort-by-total-score)))
@end lisp

最大のスコアを持つスレッドが、最初に概略バッファーに表示されます。スレッ
ドが同じスコアの場合は、英字順に並びかえられます。同じスコアと表題を持つ
スレッドは番号で並べ替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並べ替えたいのであれば、次のようにできます:

@lisp
(setq gnus-thread-sort-functions
      '((lambda (t1 t2)
          (not (gnus-thread-sort-by-number t1 t2)))
        gnus-thread-sort-by-score))
@end lisp

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function} (ディフォルトは @code{+}) に設定
されている関数は、スレッドの総スコアを計算するために用いられます。役立つ
関数は @code{max}, @code{min}, もしくは二乗、もしくはあなたの好奇心をく
すぐるような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-random
@findex gnus-article-sort-by-number
何か変な理由でスレッド表示を使っていないのなら、変
数 @code{gnus-article-sort-functions} をいじくる必要があります。これ
は @code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較に
は少々違った関数を使います。使用可能な並べ替え述語関数
は @code{gnus-article-sort-by-number},
@code{gnus-article-sort-by-author},
@code{gnus-article-sort-by-subject}, @code{gnus-article-sort-by-date},
@code{gnus-article-sort-by-random} およ
び @code{gnus-article-sort-by-score} です。

スレッドを使っていない概略の表示を表題で並べ替えたいのであれば、次のよう
なことをすることができます:

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp

@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

遠くにある @acronym{NNTP} サーバーからニュースを取得していると、ネットワー
クの遅延が記事を読むことを嫌な仕事にしてしまうかもしれません。@kbd{n} を
押してから次の記事が現れるまで、しばらく待たなければなりませんものね。ど
うして前の記事を読んでいる間に Gnus が先行して記事を取得してくれないので
しょうか? なぜできないんでしょう、本当に。

まず警告しておきましょう。非同期で記事を取得、特に Gnus がそれを行なう場
合には、いくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くて、あなたは
それを読むことには興味が無いとしましょう。Gnus はこのことはわからないの
で、先行して記事 2 を取得します。あなたは記事 3 を読むことにしますが、
Gnus は記事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、Gnus はサーバーに二つ (二まで数えて下さい) の接
続を張ります。これはあまり良いことではないと考える人もいるでしょうが、私
には実際の代替手段が見つからないのです。余分な接続を立ち上げるためにはい
くばくかの時間がかかるので、Gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先行取得を使わないときよりも、あなたのマシンと @acronym{NNTP} サー
バー間の接続にもっと負荷をかけることになるでしょう。サーバー自身にももっ
と負荷がかかるようになります---余分な記事の要求と、余分な接続によって。

はい、本当はこのようなことをすべきで無いことがこれで分かったでしょ
う@dots{} 本当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
やり方です: @code{gnus-asynchronous} を @code{t} に設定して下さい。それ
以外の諸々のことは自動的に行なわれます。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することによって、どれくらいの記
事を先に取得するべきかを操作することができます。これはディフォルトで
は 30 で、グループの記事を読んでいるときに、バックエンドが次の 30 通の記
事を先行取得するということです。この変数が @code{t} であると、バックエン
ドは取得できるすべての記事を際限なく先行取得しようとします。これ
が @code{nil} であると、先行取得は行なわれません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-read-p
おそらく先行取得をしたくない記事がいくつかあるでしょう---例えば既読記事
です。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるか
どうかを制御します。この変数に設定される関数は、問題の記事を先行取得する
のであれば @code{nil} でない値を返さなければなりません。ディフォルトの関
数は @code{gnus-async-read-p} で、これは既読記事には @code{nil} を返しま
す。この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、100 行よりも短い未読記事だけを先に取得したいのであれば、次のよう
にできます:

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれるので、Gnus を遅くしすぎないように、短
く甘美であるのが好ましいです。このようなものをバイトコンパイ
ル (byte-compile) するのは、おそらく良い着想でしょう。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファーから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定します。これは以下の要素を含むリストです:

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。

@c @vindex gnus-use-header-prefetch
@c @code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループから
@c 記事を先に取得します。

@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

@emph{非常に} 遅い @acronym{NNTP} 接続を使っているのならば、記事をキャッ
シュすることを考えても良いでしょう。それをすると、それぞれの記事はあなた
のホームディレクトリーの下にローカルに溜められます。もう感付いたかもしれ
ませんが、これは i ノードを非常に速く食いつぶすだけでなく、
@emph{巨大な} ディスクスペースを食う可能性があります。それはあなたにウォッ
カの中で泳ぐようなめまいを起こさせるでしょう。

でも注意深く使われれば、それは記事を保存する、より楽な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行させるには @code{gnus-use-cache} を @code{t} に設定して
下さい。ディフォルトでは、すべての可視または保留として印の付いている記事
はローカルのキャッシュ (@code{gnus-cache-directory}) に複写されます。こ
のキャッシュが平らな構造か階層的であるかは、通常通り、変
数 @code{gnus-use-long-file-name} で制御されます。

可視記事か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取
得されます。キャッシュにある記事は期限切れ消去されないので、記事をそれら
が属するところに居続けさせている間、それらを保存する方法としてこれは役立
つかもしれません。保存したいすべての記事に保留の印を付けるだけで、後は心
配無用です。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
記事をキャッシュに入れたりキャッシュから削除することは、変
数 @code{gnus-cache-enter-articles} およ
び @code{gnus-cache-remove-articles} によって制御されます。これらは両方
ともシンボルのリストです。前者はディフォルトで
は @code{(ticked dormant)} で、可視記事と保留記事はキャッシュに入れられ
ます。後者はディフォルトでは @code{(read)} で、既読の印が付いた記事はキャッ
シュから削除されます。おそらくこれら二つのリストに含まれるシンボル
は @code{ticked}, @code{dormant}, @code{unread} および @code{read} でしょ
う。

@findex gnus-jog-cache
それでは、大規模な記事の取得と格納は、どこで関係してくるのでしょうか。
@code{gnus-jog-cache} 命令は、すべての購読グループに対して、すべての未読
記事を要求し、スコアを付け、キャッシュに保存します。この命令をいつもいつ
もいつもいつも使うのは、1) @acronym{NNTP} サーバーとの接続が本当に本当に
本当に遅くて、2) 本当に本当に本当に巨大なディスクを持っているときだけに
するべきです。これは真面目に言っています。ダウンロードされる記事の数を控
える一つの方法は、欲しくない記事のスコアを低くして、それらに既読の印を付
けることです。そうすれば、それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
@vindex gnus-cacheable-groups
すべてのグループではキャッシュをしたくないというのは良くあることです。例
えば @code{nnml} のメールがホームディレクトリーにあるのなら、それをホー
ムディレクトリーの別の場所にキャッシュするのは意味がありません。二倍の容
量を使う方が良いと思うのでなければ。

キャッシュを制限するには、@code{gnus-cacheable-groups} を例え
ば @samp{^nntp} のようなキャッシュするグループの正規表現に設定するか、ま
たは正規表現 @code{gnus-uncacheable-groups} を例えば @samp{^nnml} に設定
して下さい。両方とも変数のディフォルト値は @code{nil} です。もしグループ
が両方の変数に合致すると、そのグループはキャッシュされません。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュは、それがどの記事を含んでいるかの情報を、そのアクティブファイ
ル (@code{gnus-cache-active-file}) に格納します。このファイル (もしくは
キャッシュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、
Gnus はものごとを正しくするための二つのコマンドを提供します。
@kbd{M-x gnus-cache-generate-nov-databases} はすべての @acronym{NOV} ファ
イルを (再) 作成し、@kbd{M-x gnus-cache-generate-active} はアクティブファ
イルを (再) 作成します。

@findex gnus-cache-move-cache
@code{gnus-cache-move-cache} コマンドは、すべて
の @code{gnus-cache-directory} をどこか別の場所に移動します。あなたはど
こに移動させるかを尋ねられます。それってかっこいいでしょ?

@node Persistent Articles
@section 永続記事
@cindex persistent articles

記事のキャッシュと近い関係にあるものに、@dfn{永続記事} があります。実際
それはキャッシュを見るための別の方法で、私に言わせればはるかに役に立ちま
す。

例えば、ニュースグループを読んでいて、永久に秘蔵しておく価値のある宝石に
出会ったとしましょう。普通はそれをファイルに保存します (多くの保存命令の
一つを使って)。問題は、単にあの、嫌なだけです。理想的には、記事はグルー
プで見つけた場所に永遠に残っていることが好ましいでしょう。ニュースサーバー
における期限切れ消去には影響されないで。

これが @dfn{永続記事} です---記事は削除されません。それは普通のキャッシュ
命令を使って実装されていますが、永続記事の管理をするために二つの明示的な
命令を使います:

@table @kbd
@item *
@kindex * (概略)
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* (概略)
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

これらの命令は両方ともプロセス/接頭引数の習慣を理解します。

永続記事にだけ興味があるのなら、可視記事 (やその他のもの) がキャッシュに
入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設定する
のが良いでしょう:

@lisp
(setq gnus-use-cache 'passive)
@end lisp

@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog

回線が遅いために、キャッシュを使うという発想があまり魅力的ではないと
き (実際そうなのですが)、@dfn{バックログ} に切り替えることによって状況を
何とかすることができます。これはすでに読んだ記事を再取得しなくても良いよ
うに、すでに読んだ記事を Gnus が一時保存しておくところです。これはもちろ
ん、あなたに最近読んだ記事を再び選択する癖があるときだけ役立ちます。絶対
にそれをしない人にとっては、バックログを on にすることは Gnus を少し遅く
し、メモリーの使用量をいくらか増やすだけのことです。

@vindex gnus-keep-backlog
@code{gnus-keep-backlog} を数値 @var{n} に設定すると、Gnus は最大
で @var{n} 個の古い記事を後の再取得のためにバッファーに溜めておきます。
この変数が @code{nil} ではなく、数値でもない場合、
Gnus は @emph{すべて} の既読記事を蓄えます。それは Emacs が爆発するまで
制限なく膨れ上がって、マシンがあなたもろとも落ちてしまうということです。
私はみなさんがいつも注意を怠らないようにするために、ここに書き加えました。

ディフォルト値は 20 です。

@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存することができます。以下のものは非常に
率直な方法 (すなわち記事が保存する前にほとんど何もなされない) で記事を保
存するための説明です。異なる手続き (uudecode, unshar) のために
は @code{gnus-uu} を使うのが良いでしょう (@pxref{Decoding Articles})。

ここに列挙されているコマンドは対象がファイルです。グループに保存したい場
合は @kbd{B c} (@code{gnus-summary-copy-article}) コマンドを参照して下さ
い (@pxref{Mail Group Commands})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、Gnus は記事を保存す
る前に不要なヘッダーを消去しません。

@vindex gnus-saved-headers
もし上記の変数が @code{nil} であると、正規表
現 @code{gnus-saved-headers} に合致するすべてのヘッダーが残される一方、
残りのものは保存する前に削除されます。

@table @kbd
@item O o
@itemx o
@kindex O o (概略)
@kindex o (概略)
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事を保存する手段を用いて現在の記事を保存しま
す (@code{gnus-summary-save-article})。

@item O m
@kindex O m (概略)
@findex gnus-summary-save-article-mail
現在の記事をメールの様式で保存しま
す (@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r (概略)
@findex gnus-summary-save-article-rmail
現在の記事を Rmail の様式で保存しま
す (@code{gnus-summary-save-article-rmail})。

@item O f
@kindex O f (概略)
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存しま
す (@code{gnus-summary-save-article-file})。

@item O F
@kindex O F (概略)
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b (概略)
@findex gnus-summary-save-article-body-file
現在の記事の本文を普通のファイル様式で保存しま
す (@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h (概略)
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存しま
す (@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v (概略)
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存しま
す (@code{gnus-summary-save-article-vm})。

@item O p
@itemx |
@kindex O p (概略)
@kindex | (概略)
@findex gnus-summary-pipe-output
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしているこ
とは---現在の記事をプロセスにパイプするということで
す (@code{gnus-summary-pipe-output})。シンボル接頭引数 (@pxref{Symbolic
Prefixes}) が与えられると、パイプへの出力に完全なヘッダーを含めます。

@item O P
@kindex O P (概略)
@findex gnus-summary-muttprint
@vindex gnus-summary-muttprint-program
現在の記事を muttprint に保存します。つまり、外部プログラ
ム @uref{http://muttprint.sourceforge.net/, Muttprint} を使って記事を印
刷するということです。プログラム名と使用するオプションは、変
数 @code{gnus-summary-muttprint-program} で指定されます。
(@code{gnus-summary-muttprint})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保
存した場合、それぞれのすべての記事に対してファイル名の入力を要求されるこ
とに飽き飽きするでしょう。入力を求める動作は変
数 @code{gnus-prompt-before-saving} によって制御されます。これはディフォ
ルトでは @code{always} で、あなたが嫌な思いを味わっている、過剰な入力要
求をします。代わりにこの変数を @code{t} に設定すると、保存するそれぞれの
一連の記事に対して一回だけ入力を要求します。本当に Gnus にすべての判断を
任せてしまいたいのであれば、この変数を @code{nil} にすることさえできます。
そうすれば、記事を保存するためのファイルを促されることはありません。
Gnus は単純にすべての記事をディフォルトのファイルに保存します。

@vindex gnus-default-article-saver
Gnus を思い通りに動作させるために、変
数 @code{gnus-default-article-saver} をカスタマイズすることができます。
下の六つの既製の関数を使うことができるし、自分自身の関数を作ることもでき
ます。

@table @code
@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これがディフォルトで、@dfn{Babyl} という様式です。変
数 @code{gnus-ramil-save-name} に設定されている関数を、記事を保存するファ
イルの名前を取得するために使います。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変
数 @code{gnus-mail-save-name} に設定されている関数を、記事を保存するファ
イルの名前を取得するために使います。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
設定されている関数を、記事を保存するファイルの名前を取得するために使いま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-write-to-file
@findex gnus-summary-write-to-file
記事をストレートに通常のファイルに保存します。そのファイルが存在していた
ら上書きされます。変数 @code{gnus-file-save-name} に設定されている関数を、
記事を保存するファイルの名前を取得するために使います。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本文を通常のファイルの後に追加します。変
数 @code{gnus-file-save-name} に設定されている関数を、記事を保存するファ
イルの名前を取得するために使います。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を使って、記事を MH フォルダーに保存し
ます。変数 @code{gnus-folder-save-name} に設定されている関数を、記事を保
存するファイルの名前を取得するために使います。ディフォルト
は @code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も
使うことができて、こちらは先頭が大文字、残りが小文字になった名前を作りま
す。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。
@end table

@vindex gnus-article-save-directory
これらのすべての関数は最後の一つを除いて、環境変数 @env{SAVEDIR} によっ
て初期化される @code{gnus-article-save-directory} に記事を保存します。こ
れはディフォルトでは @file{~/News/} です。

上で述べたように、記事を保存するためのファイルの適切な名前を見つけるため
に、それらは違った関数を用います。以下は名前を生成するために使うことがで
きる関数のリストです:

@table @code
@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。

@item gnus-sender-save-name
@findex gnus-sender-save-name
@file{~/News/larsi} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込むことによって、
Gnus に記事を保存する場所をほのめかすことができます。例えば Gnus に関連
する記事を @file{gnus-stuff} ファイルに、VM に関連する記事
を @file{vm-stuff} ファイルに保存したければ、この変数を以下のようにすれ
ば良いでしょう:

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、二つの要素---@dfn{合致} と @dfn{ファイル} を持つ
リストであるリストであるということがわかります。合致は文字列 (この場合は
記事のヘッダーに合致する正規表現として使われます)、シンボル (グループ名
を引数として、関数として呼ばれます) およびリスト (これは評
価 (@code{eval}) されます) のどれかであることができます。これらの動作の
一つでも @code{nil} でない結果を返すと、入力を求めるときのディフォルトと
して @dfn{ファイル} が使われます。加えて、呼ばれた関数か式が文字列か文字
列のリストを返したときは、演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリス
トを手に入れることになります。(すべての『合致』が使われます。) そして、
実際に名前として使いたいものの入力を促されますが、その際、この変数を適用
して得られた結果が、ファイル名を補完するときの候補になります。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、これ
は Gnus が保存する記事の @code{Archive-name} 行を調べて、それをファイル
名の候補として使います。

これはファイル名を多少きれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるとすると、
保存するためのファイル名を作る前にそれらのグループ名の最初の方を切り落と
す必要があるかもしれません。次の物はまさにそれをします:

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp

@vindex gnus-use-long-file-name
最後に、@code{gnus-use-long-file-name} という変数があります。これ
が @code{nil} であると、すべての上記の関数はグループ名のすべてのピリオ
ド (@samp{.}) をスラッシュ (@samp{/}) で置き換えます---つまり、すべての
ファイルを一番上のディレクトリーに置くのではなく、それらの関数が階層的な
ディレクトリーを生成するということで
す (@file{~/News/alt.andrea-dworkin} ではな
く @file{~/News/alt/andrea-dworkin} のように)。たいていのシステムにおい
て、この変数のディフォルト値は @code{t} です。しかし、歴史的な理由によっ
て Xenix と usg-unix-v マシンでは @code{nil} がディフォルト値になります。

この関数は削除とスコアのファイル名にも影響します。この変数がリストで、そ
のリストが @code{not-score} という要素を含んでいると、長いファイル名はス
コアファイルには使われません。そのリストが @code{not-save} という要素を
含んでいると、保存するときに長いファイル名は使われません。また、そのリス
トが @code{not-kill} という要素を含んでいると、長いファイル名は削除ファ
イルには使われません。

記事をスプールのような階層に保存したい場合は、次のようにして下さい。

@lisp
(setq gnus-use-long-file-name '(not-save)) ; @r{階層にする}
(setq gnus-default-article-saver
      'gnus-summary-save-in-file) ; @r{エンコードしない}
@end lisp

そうしたならば、@kbd{o} で記事を保存するだけです。すると、階層
を @code{nneething} 一時グループによって読むことができます---グループバッ
ファーで @kbd{G D} をタイプして、一番上のディレクト
リー (@file{~/News/}) を引数として渡して下さい。

@node Decoding Articles
@section 記事のデコード
@cindex decoding articles

ときどき利用者は何らかの方法でエンコードされた記事 (もしくは一連の記事群)
を投稿します。Gnus はそれらをデコードすることができます。

@quotation
訳注: この章では、複数に分割して送信された一つの巨大な記事を、再び一つに
まとめ上げてデコードする処理について説明しています。現在では、そのような
分割送信をメールサーバーが受け付けない等の理由によって、ほとんど目にする
ことはありません。分割して送信しないことを確実にするには、以下の設定を行
なって下さ
い (@pxref{Mail Variables, ,メール変数, message-ja, The Message Manual}):

@lisp
(setq message-send-mail-partially-limit nil)
@end lisp
@end quotation

@menu
* Uuencoded Articles::          記事を uuencode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をするか
を見つけるために使います。Gnus は自分自身でどの記事がその群に属している
かを判断し、すべての記事をデコードして、その結果のファイルを展開/表示/保
存することができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します: 表
題は行の最後の二つの数字を除いて (ほとんど) 同じである必要があります。
(空白は大体無視されますが。)

例えば: @samp{cat.gif (2/3)} というような表題を選ぶと、Gnus は正規表
現 @samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけよう
とします。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
表示命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。

@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuencoded articles

@table @kbd
@item X u
@kindex X u (概略)
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U (概略)
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u (概略)
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、表示します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U (概略)
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、表示して保存しま
す (@code{gnus-uu-decode-uu-and-save-view})。
@end table

これらはすべて、プロセス印が付けられた記事に対して反応するということを覚
えておいて下さい。例えばニュースグループ全体をデコードして保存したいので
あれば、例によって @kbd{M P a} (@code{gnus-uu-mark-all}) に続い
て @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) を実行して下さい。

このすべては、白日の下にいちいちキーを打っていた @sc{gnus 4.1} のとき
の @code{gnus-uu} の動作とはまったく違っています。一般にこの版
の @code{gnus-uu} は、何かの方法 (@pxref{Setting Process Marks}) で
記事に印を付け、それから @kbd{X u} を押すことを前提としています。

@vindex gnus-uu-notify-files
注意: 定数 @code{gnus-uu-notify-files} (値
が @samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされ
ています) に合致する名前を持つ記事をデコードしようとすると、あなたが問題
の記事を今まさに見たことをバラすために、@code{gnus-uu} は自動的
に @samp{comp.unix.wizards} に記事を投稿します。この機能を使わないように
することはできません (訳注: そんな Cindy Crawford 嬢の写真がニュースで大
量に流れていた、まだ WWW がロクに普及していなかった時代の産物です)。

@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ (『shar ファイル』) はソースを配布するための人気のある
方法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うため
の命令があります:

@table @kbd
@item X s
@kindex X s (概略)
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S (概略)
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍して保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s (概略)
@findex gnus-uu-decode-unshar-view
現在の群を解凍して表示します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S (概略)
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、表示して保存しま
す (@code{gnus-uu-decode-unshar-and-save-view})。
@end table

@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd
@item X p
@kindex X p (概略)
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P (概略)
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存しま
す (@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p (概略)
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を表示しま
す (@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P (概略)
@findex gnus-uu-decode-postscript-and-save-view
現在のポストスクリプト群を表示して保存しま
す (@code{gnus-uu-decode-postscript-and-save-view})。
@end table

@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o (概略)
@findex gnus-uu-decode-save
現在の群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b (概略)
@findex gnus-uu-decode-binhex
現在の記事を binhex で解凍します (@code{gnus-uu-decode-binhex})。これは
実際には動作しません。
@end table

@node Decoding Variables
@subsection デコードのための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数
@end menu

@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルをどうやって表示するかを決めるために @dfn{規則変数} を使
います。これらの変数はすべて以下のような様式です。

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code
@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを表示するときに最初に調べられます。例えば、も
し @file{.au} 音響ファイルを変換するために @code{sox} を使いたいときは、
次のように設定することができます:

@lisp
(setq gnus-uu-user-view-rules
      (list '("\\\\.au$\" "sox %s -t .aiff > /dev/audio")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は Gnus が利用者とディフォルトの表示規則から合致するものを見つけ
ることができなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使うことができます。
@end table

@node Other Decode Variables
@subsubsection 他のデコードのための変数

@table @code
@vindex gnus-uu-grabbed-file-functions

@item gnus-uu-grabbed-file-functions
これは関数のリストです。すぐにファイルを移動したり表示することを可能にし、
何かができるようになる前にすべてのファイルがデコードされるのを待つ必要が
無いように、それぞれのファイルのデコードに成功した直後にそれらの関数が呼
ばれます。このリストに入れることができる既製の関数は以下の通りです:

@table @code
@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを表示します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します (もし保存関数を使っているのであれば)。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
デコードの最中に異常な状況が起こったときに何をするかを指定します。も
し @code{nil} であると、できるだけ保守的になります。もし @code{t} である
と、動作しないものは無視して、現存するファイルを上書きします。その他の場
合は、それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは表示されません。

@item gnus-uu-ignore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @acronym{MIME} の型を持つファイルは表示されません。
Gnus はファイル名に基づいて型を推測していることに注意して下さい。
@code{gnus-uu} は (まだ) @acronym{MIME} パッケージではないので、これは少々
お行儀が悪いものです。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないと、@code{gnus-uu} は表示するためのファイルを探すために
アーカイブの中身までは見ません。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないと、利用者はファイルを表示した後で常に保存するかどうか
を尋ねられます。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないと、@code{gnus-uu} はディフォルトの表示規則を無視します。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないと、@code{gnus-uu} はディフォルトのアーカイブ展開命令を
無視します。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないと、@code{gnus-uu} は記事からすべてのキャリッジリターン
を取り去ります。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないと、@code{gnus-uu} はデコードに失敗した記事に未読の印を
付けます。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないと、@code{gnus-uu} は後続の空白が削除されてしまっている
uuencode されたファイルを修復しようと @emph{試み} ます。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
メッセージを @code{uudecode} に送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないと、@code{gnus-uu} は規則変数で定義された表示命令を無視
して、ファイル名に基づいた @acronym{MIME} Content-Type をでっちあげます。
その結果は表示のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないと、デコードせずに保存することを指示されたときに、
@code{gnus-uu} は要約 (digest) を保存します。この変数が @code{nil} であ
ると、@code{gnus-uu} は何も加工を施さずにすべてを一つのファイルに保存し
ます。要約の作成は概ね RFC1153 に準拠していますが、意味のある目次を付け
る簡単な方法が見つからなかったので、私はそれらを単に落としました。
@end table

@node Uuencoding and Posting
@subsubsection uuencode と投稿

@table @code
@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないと、@code{gnus-uu} は記事を作成する前にエンコードするファ
イルを尋ねます。この変数が @code{t} であると、@kbd{C-c C-i} によってエン
コードされたファイルを取り込むか、記事を投稿するときに取り込むかのどちら
かをすることができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。エンコードされたファイルは全体のファイルを投稿する
のに必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないと、@code{gnus-uu} はエンコードされたファイルをスレッド
で投稿します。これはあまり賢い方法ではないかもしれません。というのは、今
まで私が見た中で uuencode された記事を集めるのに、スレッドを追っていくこ
とのできる他のデコーダーが存在しないからです。(えーと、私はそれをする一
つのパッケージを見たことがあります---@code{gnus-uu} です。しかしどうも、
それが数のうちに入るとは思えないのです@dots{}) ディフォルト
は @code{nil} です。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないと、説明文は別の記事で投稿されます。最初の記事は普
通 (0/x) のように番号が付けられます。もしこの変数が @code{nil} であると、
利用者の書いた説明分は最初のファイルの始めに取り込まれ、(1/x) の番号が付
けられます。ディフォルトは @code{t} です。
@end table

@node Viewing Files
@subsection ファイルの表示
@cindex viewing files
@cindex pseudo-articles

デコードした後でファイルが何らかのアーカイブである場合、Gnus はアーカイ
ブを展開しようと試み、アーカイブの中に表示できるファイルがあるかどうかを
調べます。例えば、gzip された tar ファイル @file{pics.tar.gz} があって、
ファイル @file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、Gnus は主
ファイルを解凍して tar を展開し、それから二つの絵を表示します。この展開
の過程は再帰的なので、アーカイブにアーカイブのアーカイブがあると、それは
すべて展開されます。

最後に、Gnus は普通はそれぞれの抽出された記事ごとに @dfn{疑似記事} を概
略バッファーに挿入します。これらの『記事』に移動した場合は、実行する命
令 (普通は Gnus が提案をします) を入力するように促され、それからその命令
が実行されます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に表示の終了を待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、Gnus は概略バッファー
に疑似記事を挿入せず、それらをすぐに表示します。この変数
が @code{not-confirm} であると、利用者は表示が済む前に確認さえも求められ
ません。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、表示されるそ
れぞれのファイルにつき一つの疑似記事が作成されます。@code{nil} であると、
同じ表示命令を使うすべての命令がその命令の引数のリストとして渡されます。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、デコードのと
きに疑似記事を挿入します。ディフォルトでは @code{t} です。

さて、あなたはそんなふうに @emph{仮想サーバー} の @emph{仮想グループ} に
ある @emph{疑似記事} を読むことになるわけです。どうしてすべてが現実では
なくなってしまったんでしょうか?  どうしてこんなところに来てしまったんで
しょうか?

@node Article Treatment
@section 記事のトリートメント

この巨大な説明文書を読んできて、人々の著作を読むことがニュースリーダーの
本当の目的だったことを、すっかり忘れてしまったかもしれません。記事を読む
ことです。残念ながら人々は書くことがとても苦手ですが、記事を読みやすくす
るための関数と変数は山のようにあります。

@menu
* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの
@end menu

@node Article Highlighting
@subsection 記事のハイライト
@cindex highlighting

記事バッファーをフルーツサラダのように、いや総天然色のフルーツサラダのよ
うにしたくありませんか。

@table @kbd
@item W H a
@kindex W H a (概略)
@findex gnus-article-highlight
@findex gnus-article-maybe-highlight
現在の記事をもっとハイライトします。この関数は、ヘッダー、引用文、署名を
ハイライトし、本文とヘッダーにボタンを加えます。

@item W H h
@kindex W H h (概略)
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイ
ライトは変数 @code{gnus-header-face-alist} に従って行なわれ、それはそれ
ぞれの要素が @code{(@var{正規表現} @var{名前} @var{内容})} という様式の
リストです。@var{正規表現} はヘッダーに合致する正規表現、@var{名前} はヘッ
ダーの名前をハイライトするのに使われるフェース (@pxref{Faces and Fonts})、
@var{内容} はヘッダーの値をハイライトするフェースです。最初に合致したも
のが使われます。@var{正規表現} の先頭に @samp{^} を付けてはいけないこと
に注意して下さい---Gnus がそれを付け加えます。

@item W H c
@kindex W H c (概略)
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用文のハイライトをカスタマイズする変数は次の通りです:

@table @code
@vindex gnus-cite-parse-max-size
@item gnus-cite-parse-max-size
記事の大きさがこの変数 (ディフォルトでは 25000) より大きい記事は、引用文
のハイライトが行なわれません。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用符の最大の長さです (ディフォルトでは 20 です)。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用文をハイライトするために使われるフェースのリストです (@pxref{Faces
and Fonts})。同じメッセージの中に複数の記事からの引用があると、Gnus はそ
れぞれの記事からの引用をそれ用のフェースで表示しようとします。これにより、
誰が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 著者行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 著者行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用文であると判定する前に調べなければならない引用符の最小の数です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
著者行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
著者行の終りに合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
著者行に使われるフェースです。その著者が書いた文の引用のためのフェースと
融合されます。

@item gnus-cite-ignore-quoted-from
@vindex gnus-cite-ignore-quoted-from
非-@code{nil} だったら、@samp{>From } で始まる行で引用文のハイライトは行
なわれません。それらの行は、エンベロープ From 行と混同しないように、
MTA がクオートした可能性があります。ディフォルト値は @code{t} です。
@end table

@item W H s
@kindex W H s (概略)
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトしま
す (@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後のすべて
のものは署名であると解釈され、@code{gnus-signature-face} でハイライトさ
れます。それはディフォルトでは @code{italic} です。
@end table

記事を自動的にハイライトする方法については @ref{Customizing Articles} を
参照して下さい。

@node Article Fontisizing
@subsection 記事中の文の強調表示
@cindex emphasis
@cindex article emphasis

(訳注: Fontisize == Fontify + Emphasize)

@findex gnus-article-emphasize
@kindex W e (概略)
人々はよくニュースの記事で @samp{_これ_} や @samp{*これ*} また
は @samp{/これ/} のようなものを使って単語を強調します。Gnus は記事
を @kbd{W e} 命令 (@code{gnus-article-emphasize}) にかけることによって素
敵に見えるようにできます。

@vindex gnus-emphasis-alist
強調がどのように処理されるかは変数 @code{gnus-emphasis-alist} によって制
御されます。これは連想リストで、最初の要素は合致するべき正規表現です。二
番目の要素は、正規表現の中のどのグループが強調語全体を見つけるために使わ
れるかを示す数値です。三番目は正規表現のどのグループが表示されハイライト
されるかを決める数値です。(この二つのグループの間にあるテキストは隠され
ます。) 四番目はハイライトさせるためののフェースです。

@lisp
(setq gnus-emphasis-alist
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

(訳注: 上記の変数の値は、ディフォルトのままにしておくのが無難です。)

@cindex slash
@cindex asterisk
@cindex underline
@cindex /
@cindex *

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
ディフォルトでは七つの規則があり、それらは以下のフェースを用います:@*
@code{gnus-emphasis-bold}, @code{gnus-emphasis-italic},
@code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic},
@code{gnus-emphasis-underline-italic},
@code{gnus-emphasis-underline-bold},
@code{gnus-emphasis-underline-bold-italic}。

これらのフェースを変更したいのであれば、
@kbd{M-x customize} か @code{copy-face} を使うことができます。例え
ば @code{gnus-emphasis-italic} が代わりに赤のフェースを使うようにしたい
のならば、次のようにすれば良いでしょう:

@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp

@vindex gnus-group-highlight-words-alist
任意の語を強調表示させたいときは、
@code{gnus-group-highlight-words-alist} 変数を使うことができます。これ
は @code{gnus-emphasis-alist} と同じ構文を使います。
@code{highlight-words} グループパラメー
ター (@pxref{Group Parameters}) を使うこともできます。

記事を自動的に強調表示させるやり方について
は @ref{Customizing Articles} を参照して下さい。

@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

と言うよりはむしろ、記事の中にある特定のものを隠すことです。たいていの記
事には、普通はありすぎるくらいのごみがあります。

@table @kbd
@item W W a
@kindex W W a (概略)
@findex gnus-article-hide
記事バッファーでたくさんのものを隠します (@kbd{gnus-article-hide})。特に
この関数はヘッダー、@acronym{PGP}、引用文、それに署名を隠します。

@item W W h
@kindex W W h (概略)
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。
@xref{Hiding Headers}.

@item W W b
@kindex W W b (概略)
@findex gnus-article-hide-boring-headers
あまり興味の持てないヘッダーを隠しま
す (@code{gnus-article-hide-boring-headers})。@xref{Hiding Headers}.

@item W W s
@kindex W W s (概略)
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。
@xref{Article Signature}.

@item W W l
@kindex W W l (概略)
@findex gnus-article-hide-list-identifiers
@vindex gnus-list-identifiers
@code{gnus-list-identifiers} で指定されているメーリングリストの標識を削
除します。これらはいくつかのメーリングリストのサーバーがすべて
の @code{Subject} ヘッダーの最初に付ける文字列、例え
ば @samp{[zebra 4711]} のようなものです。文字列の初めにあ
る @samp{Re: } は、削除を行なう前に跳び越されます。
@code{gnus-list-identifiers} に @code{\\(..\\)} を含めてはいけません。

@table @code
@item gnus-list-identifiers
@vindex gnus-list-identifiers
表題から削除されるべきメーリングリストの標識に合致する正規表現です。これ
は正規表現のリストであることもできます。
@end table

@item W W P
@kindex W W P (概略)
@findex gnus-article-hide-pem
不要な @acronym{PEM} (privacy enhanced messages (プライバシー拡張メッセー
ジ)) の部分を隠します (@code{gnus-article-hide-pem})。

@item W W B
@kindex W W B (概略)
@findex gnus-article-strip-banner
@vindex gnus-article-banner-alist
@vindex gnus-article-address-banner-alist
@cindex banner
@cindex OneList
@cindex stripping advertisements
@cindex advertisements
@code{banner} グループパラメーターで指定されたバナーを取り除きま
す (@code{gnus-article-strip-banner})。これは主に、いくつかのメーリング
リストや司会者付きのグループがすべての記事に追加する、欝陶しいバナーと/
もしくは署名を隠すために使用されます。この関数を使う方法
は @code{banner} グループパラメーター (@pxref{Group Parameters}) をバナー
を取り除きたいグループに追加することです。パラメーターは、消去されるテキ
ストに合致する正規表現として解釈される文字列か、(最後の) 署名を消去する
ためのシンボル @code{signature}、また
は @code{gnus-article-banner-alist} の正規表現に対応した他のシンボルのい
ずれかであることができます。

グループにかかわらず、記事の送信者
が @code{gnus-article-address-banner-alist} で設定されている特定のメール
アドレスを持っているときだけ、広告のようなものを隠すことができます。

@table @code
@item gnus-article-address-banner-alist
@vindex gnus-article-address-banner-alist
メールアドレスとバナーの連想リストです。それぞれの要素
は @code{(@var{address} . @var{banner})} の形式を持ち、ここ
で @var{address} は From ヘッダーにあるメールアドレスに合致する正規表現
です。また、@var{banner} はシンボル @code{signature}、
@code{gnus-article-banner-alist} の要素、正規表現または @code{nil} のう
ちの一つです。@var{address} が著者のメールアドレスに合致すると、広告のよ
うなものを消します。例えば、送信者が @samp{hail@@yoo-hoo.co.jp} というメー
ルアドレスを持っていて、彼が送信するすべての記事に @samp{Do You
Yoo-hoo!?} のようなものがある場合、以下の要素でそれらを消すことができま
す。

@lisp
("@@yoo-hoo\\.co\\.jp\\'" . "\n_+\nDo You Yoo-hoo!\\?\n.*\n.*\n")
@end lisp
@end table

@item W W c
@kindex W W c (概略)
@findex gnus-article-hide-citation
引用文を隠します (@code{gnus-article-hide-citation})。隠蔽をカスタマイズ
するいくつかの変数は:

@table @code
@item gnus-cited-opened-text-button-line-format
@itemx gnus-cited-closed-text-button-line-format
@vindex gnus-cited-closed-text-button-line-format
@vindex gnus-cited-opened-text-button-line-format
Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式は、以下のフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
が有効です:

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠されたリージョンの文字の数です。
@item n
隠された文の行の数です。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
隠さずに表示しておく、引用文の先頭からの行数です。これは、隠さずに表示す
る先頭からの行と、隠さずに表示する末尾からの行の、それぞれの数の cons セ
ルであることもできます。
@end table

@item W W C-c
@kindex W W C-c (概略)
@findex gnus-article-hide-citation-maybe
以下の二つの変数に依存して、引用文を隠しま
す (@code{gnus-article-hide-citation-maybe}):

@table @code
@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
引用文の割合のパーセンテージが、この変数 (ディフォルト値は 50) より大き
かったら、引用文を隠します。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
隠される前に、引用文は少なくともこの長さ (ディフォルト値は 10) でなけれ
ばまりません。
@end table

@item W W C
@kindex W W C (概略)
@findex gnus-article-hide-citation-in-followups
根本でない記事の引用文を隠しま
す (@code{gnus-article-hide-citation-in-followups})。これは対話的命令と
してはあまり役に立たないかもしれませんが、自動的に実行させるには手軽な関
数でしょう (@pxref{Customizing Articles})。
@end table

これらのすべての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接頭
引数を与えると、それらは前に隠されていたものを表示します。正の接頭引数を
与えれば、それらは常に隠します。

引用文をカスタマイズするためのさらなる変数について、
@ref{Article Highlighting} も参照して下さい。

自動的に記事の要素を隠すための方法は @ref{Customizing Articles} を参照
して下さい。

@node Article Washing
@subsection 記事の洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で『記事の洗濯』(article washing) と呼ん
でいます。@kbd{A} キーは使われていたので、代わりに @kbd{W} キーを使う必
要がありました。

@dfn{洗濯} は『何かの何かを何か別のものに変換する』と定義されますが、普
通はもっと良く見える何かに落ち着きます。もっときれいになります、たぶん。

Gnus が記事を表示するディフォルトのやり方を変えたいとき
は @ref{Customizing Articles} を参照して下さい。

@table @kbd
@item C-u g
これは洗濯ではなくて、その逆です。これをタイプすると、ディスクやサーバー
にあるがままの記事が見えます。

@item g
現在の記事の再表示を強制します (@code{gnus-summary-show-article})。これ
もまた本当の洗濯ではありません。これをタイプすると、以前に適用された対話
的な洗濯機能はご破算にされ、すべてのディフォルトのトリートメントを施され
た記事が表示されます (@pxref{Customizing Articles})。

@item W l
@kindex W l (概略)
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きま
す (@code{gnus-summary-stop-page-breaking})。ページの区切りに付いて
は @ref{Misc Article} を参照して下さい。

@item W r
@kindex W r (概略)
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファーでカエサル変換 (Caesar rotate, rot13) を行ないま
す (@code{gnus-summary-caesar-message})。カエサル変換か rot13 を用いて読
むことを指定する、判読不可能な記事です (典型的には攻撃的な冗談などです。)

普通は ``rot13'' と呼ばれています。それはアルファベットの位置が 13 個回
転するからです。例えば、@samp{B} (2 番目の文字) → @samp{O} (15 番目の文
字)。これは時々『カエサル変換』と呼ばれることもあります。というのは、カ
エサルがこの形式の、えーと、いささか貧弱な暗号化を採用したという噂がある
からです。

@item W m
@kindex W m (概略)
@findex gnus-summary-morse-message
記事バッファーをモールスでデコードしま
す (@code{gnus-summary-morse-message})。

@item W i
@kindex W i (概略)
@findex gnus-summary-idna-message
現在の記事にある IDNA エンコードされたドメイン名をデコードします。
IDNA エンコードされたドメイン名は @samp{xn--bar} のように見えます。これ
を実行した後で文字列がデコードされないままだったら、おそらくそれは不正
な IDNA 文字列でしょう (@samp{xn--bar} は不正です)。このコマンドを動かす
ためには、GNU Libidn (@url{http://www.gnu.org/software/libidn/}) をイン
ストールしていなければなりません。

@item W t
@item t
@kindex W t (概略)
@kindex t (概略)
@findex gnus-summary-toggle-header
記事バッファーにすべてのヘッダーを表示するかどうかを切り替えま
す (@code{gnus-summary-toggle-header})。

@item W v
@kindex W v (概略)
@findex gnus-summary-verbose-headers
記事バッファーにすべてのヘッダーを永続的に表示するかどうかを切り替えま
す (@code{gnus-summary-verbose-headers})。

@item W o
@kindex W o (概略)
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

訳注: 以下のような重ね打ちを指示する文字列を bold や underline で表示し
ます。

@samp{B^HBo^Hol^Hld^Hd}, @samp{U^H_n^H_d^H_e^H_r^H_l^H_i^H_n^H_e^H_}

@item W d
@kindex W d (概略)
@findex gnus-article-treat-dumbquotes
@vindex gnus-article-dumbquotes-map
@cindex Smartquotes
@cindex M****s*** sm*rtq**t*s
@cindex Latin 1
@code{gnus-article-dumbquotes-map} に応じて、マ■■■ソ■
■ sm*rtq**t*s を処理します。この関数は文字が sm*rtq**t* かどうかを推測
するので、対話的にのみ使用されるべきであることに注意して下さい。

Sm*rtq**t*s はもっと多くの引用文字を提供するために、マ■■■ソ■■が勝手
に文字マップを拡張したものです。もし、アポストロフィ (') や引用記
号 (") などがあるべきところに @code{\222} や @code{\264} のようなものが
見えてしまったら、洗濯してみて下さい。

@item W Y f
@kindex W Y f (概略)
@findex gnus-article-outlook-deuglify-article
@cindex Outlook Express
いかれた Outlook (Express) の記事を完全に醜くなくすること (訳
注: de-ugly-fy) (sm*rtq**t*s を処理、行の折り返しを解除、著者行の修復と
引用文の整頓) をします。
(@code{gnus-article-outlook-deuglify-article})。

@item W Y u
@kindex W Y u (概略)
@findex gnus-article-outlook-unwrap-lines
@vindex gnus-outlook-deuglify-unwrap-min
@vindex gnus-outlook-deuglify-unwrap-max
折り返された引用行のように見える行の折り返しを解きます。折り返しが解かれ
た行の最小および最大の長さを表
す @code{gnus-outlook-deuglify-unwrap-min} およ
び @code{gnus-outlook-deuglify-unwrap-max} を調整することによって、どん
な行の折り返しが解かれるかを制御することができます。
(@code{gnus-article-outlook-unwrap-lines})。

@item W Y a
@kindex W Y a (概略)
@findex gnus-article-outlook-repair-attribution
壊れた著者行を修復します。@*
(@code{gnus-article-outlook-repair-attribution})。

@item W Y c
@kindex W Y c (概略)
@findex gnus-article-outlook-rearrange-citation
壊れた引用文を、テキストを整理し直すことによって修復します。
(@code{gnus-article-outlook-rearrange-citation})。

@item W w
@kindex W w (概略)
@findex gnus-article-fill-cited-article
行を折り返します (@code{gnus-article-fill-cited-articles})。

折り返す幅を指定するために、命令に数値接頭引数を与えることができます。

@item W Q
@kindex W Q (概略)
@findex gnus-article-fill-long-lines
長い行を折り返します (@code{gnus-article-fill-mode-lines})。

@item W C
@kindex W C (概略)
@findex gnus-article-capitalize-sentences
それぞれの文の最初の語を大文字にしま
す (@code{gnus-article-capitalize-sentences})。

@item W c
@kindex W c (概略)
@findex gnus-article-remove-cr
CRLF の組 (すなわち、行の最後の @samp{^M}) を LF に変換します (これ
は DOS の行末の世話をします)。そうしてから残りの CR を LF に変換しま
す (これは MAC の行末の世話をします) (@code{gnus-article-remove-cr})。

@kindex W q (概略)
@findex gnus-article-de-quoted-unreadable
Quoted-printable を処理します (@code{gnus-article-de-quoted-unreadable})。
Quoted-Printable は 非-@acronym{ASCII} (すなわち 8-bit) の記事を送るとき
に使われる一般的な @acronym{MIME} エンコーディングです。それは概し
て @samp{d,Aij,A` vu} のようなものを @samp{d=E9j=E0 vu} に見せるので、とても
読み辛くなります。問題の記事が、そのエンコーディングが行なわれたことを示
す @code{Content-Transfer-Encoding} ヘッダーを持っていれば、通常それ
は Gnus によって自動的に行なわれることに注意して下さい。接頭引数が与えら
れると、文字セットが尋ねられます。

@item W 6
@kindex W 6 (概略)
@findex gnus-article-de-base64-unreadable
Base64 をデコードします (@code{gnus-article-de-base64-unreadable})。
Base64 は非-@acronym{ASCII} (すなわち 8-bit) の記事を送るときに使われる、
一般的な @acronym{MIME} エンコーディングです。問題の記事が、そのエンコー
ディングが行なわれたことを示す @code{Content-Transfer-Encoding} ヘッダー
を持っていれば、通常それは Gnus によって自動的に行なわれることに注意して
下さい。接頭引数が与えられると、文字セットが尋ねられます。

@item W Z
@kindex W Z (概略)
@findex gnus-article-decode-HZ
HZ または HZP を処理します。HZ (または HZP) は中国語の記事を伝送するとき
に使われる一般的な符号です。これは @samp{~@{<:Ky2;S@{#,NpJ)l6HK!#~@}} の
ような典型的な文字列を作ります。

@item W A
@kindex W A (概略)
@findex gnus-article-treat-ansi-sequences
@cindex @acronym{ANSI} control sequences
@acronym{ANSI} SGR シーケンスを overlay または extent に変換しま
す (@code{gnus-article-treat-ansi-sequences})。@acronym{ANSI} シーケンス
は中国語のニュースグループで強調表示に使われています。

@item W u
@kindex W u (概略)
@findex gnus-article-unsplit-urls
URL に含まれる改行を削除します。いくつかのメイラーは、行を短くするために
出ていくメールに改行を挿入しますが、これは長い URL を複数の行に分割して
しまいます。改行を削除することによって、それらの URL を復旧させま
す (@code{gnus-article-unsplit-urls})。

@item W h
@kindex W h (概略)
@findex gnus-article-wash-html
@acronym{HTML} を処理します。当該メッセージが @acronym{HTML} であること
を示す @code{Content-Type} ヘッダーを持っていたならば、それは Gnus によっ
て自動的に行なわれることに注意して下さい。

接頭引数が与えられると、文字セットを尋ねられます。

@vindex gnus-article-wash-function
ディフォルトでは @acronym{HTML} の変換に @code{mm-text-html-renderer}
(@pxref{Display Customization, ,表示のカスタマイズ, emacs-mime-ja, The
Emacs MIME Manual}) で設定された関数を使いますが、変
数 @code{gnus-article-wash-function} が設定されていると、記事の洗濯では
それが優先されます。使うことができる、あらかじめ用意された関数は以下の通
りです:

@table @code
@item w3
Emacs/W3 を使います。

@item w3m
@uref{http://emacs-w3m.namazu.org/, emacs-w3m} を使います。

@item links
@uref{http://links.sf.net/, Links} を使います。

@item lynx
@uref{http://lynx.isc.org/, Lynx} を使います。

@item html2text
html2text (シンプルな @acronym{HTML} コンバーターで、Gnus に含まれていま
す) を使います。
@end table

訳注: 例えば @code{mm-text-html-renderer} を @code{w3m} などに設定してあっ
て正しく動作するのならば、@code{gnus-article-wash-function} はディフォル
トの @code{nil} のままにしておいて構いません。

@item W b
@kindex W b (概略)
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}.

@item W B
@kindex W B (概略)
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えま
す (@code{gnus-article-add-buttons-to-head})。

@item W p
@kindex W p (概略)
@findex gnus-article-verify-x-pgp-sig
署名付きコントロールメッセージの認証を行ないま
す (@code{gnus-article-verify-x-pgp-sig})。
@code{newgroup} や @code{checkgroups} といったコントロールメッセージは、
通常そのニュースグループ階層のメインテイナーによって署名されています。認
証を行なうためには、メインテイナーの @acronym{PGP} 公開鍵をあなたのキー
リングに追加しなければなりません。@footnote{多くのニュースグループ階層の
メインテイナーの @acronym{PGP} の鍵
は @uref{ftp://ftp.isc.org/pub/pgpcontrol/README.html} から入手すること
ができます。}

@item W s
@kindex W s (概略)
@findex gnus-summary-force-verify-and-decrypt
署名されたメッセージ (@acronym{PGP}, @acronym{PGP/MIME} また
は @acronym{S/MIME} によって) を検証しま
す (@code{gnus-summary-force-verify-and-decrypt})。@xref{Security}.

@item W a
@kindex W a (概略)
@findex gnus-article-strip-headers-in-body
記事の本文の先頭から @code{X-No-Archive} ヘッダーのようなヘッダーを取り
除きます (@code{gnus-article-strip-headers-in-body})。

@item W E l
@kindex W E l (概略)
@findex gnus-article-strip-leading-blank-lines
記事の先頭にあるすべての空白行を取り除きま
す (@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m (概略)
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換えてから、すべての複数の空行を一つの空行で置
き換えます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t (概略)
@findex gnus-article-remove-trailing-blank-lines
記事の最後にあるすべての空白行を取り除きま
す (@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a (概略)
@findex gnus-article-strip-blank-lines
上の三つの命令をすべて実行します (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A (概略)
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s (概略)
@findex gnus-article-strip-leading-space
記事の本文のすべての行頭にあるすべての空白を取り除きま
す (@code{gnus-article-strip-leading-space})。

@item W E e
@kindex W E e (概略)
@findex gnus-article-strip-trailing-space
記事の本文のすべての行末にあるすべての空白を取り除きま
す (@code{gnus-article-strip-trailing-space})。
@end table

自動的に記事の洗濯を行なわせる方法は @ref{Customizing Articles} を参照し
て下さい (訳注: 実は多くの洗濯がディフォルトで自動的に行なわれます)。

@node Article Header
@subsection 記事ヘッダー

これらのコマンドは記事ヘッダーをいろいろに変形させます。

@table @kbd
@item W G u
@kindex W G u (概略)
@findex gnus-article-treat-unfold-headers
折り返されたヘッダー行を一行にしま
す (@code{gnus-article-treat-unfold-headers})。

@item W G n
@kindex W G n (概略)
@findex gnus-article-treat-fold-newsgroups
@code{Newsgroups} と @code{Followup-To} ヘッダーを折り返しま
す (@code{gnus-article-treat-fold-newsgroups})。

@item W G f
@kindex W G f (概略)
@findex gnus-article-treat-fold-headers
すべてのメッセージヘッダーを折り返しま
す (@code{gnus-article-treat-fold-headers})。

@item W E w
@kindex W E w (概略)
@findex gnus-article-remove-leading-whitespace
すべてのヘッダーから余分な空白を取り除きま
す (@code{gnus-article-remove-leading-whitespace})。
@end table

@node Article Buttons
@subsection 記事のボタン
@cindex buttons

人々はよく記事の中に他の資料を参照するための案内を入れることがありますが、
それらの参照への案内の上で @kbd{RET} を打つか、マウスの真中のボタンを使っ
たときに、彼らが話題にしているのが何であれ、最小限の曖昧さで Gnus が取得
することができれば素敵でしょう。

@vindex gnus-button-man-handler
特定の標準的な参照に、Gnus はディフォルトで @dfn{ボタン} を付けます: ちゃ
んとした URL、メールアドレス、Message-ID、Info へのリンク、man ページ、
それに関連する Emacs または Gnus の参考文献です。これは二つの変数によっ
て制御されていて、その一つは記事の本文を扱い、もう一つは記事のヘッダーを
扱います。

@table @code
@item gnus-button-alist
@vindex gnus-button-alist
それぞれの要素が次のような様式を持つ連想リストです:

@lisp
(@var{regexp} @var{button-par} @var{use-p} @var{function} @var{data-par})
@end lisp

@table @var
@item regexp
この正規表現 (大文字と小文字は区別されません) に合致するすべてのテキスト
は、外部への参照であるとみなされます。これは埋め込まれた URL に合致する
典型的な正規表現です: @samp{<URL:\\([^\n\r>]*\\)>}。これはまた正規表現の
値を持つ変数であってもよく、有用な変数とし
て @code{gnus-button-url-regexp} およ
び @code{gnus-button-mid-or-mail-regexp} があります。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
すべてをハイライトしたいのなら、ここで 0 を使って下さい。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなかったら、これは合致で
あるとみなされます。これは間違った合致を避けるために特別な選別をしたいと
きに役に立ちます。ここではしばしば @code{gnus-button-@var{*}-level} のよ
うな名前の変数が使われますが、@xref{Article Button Levels}, 他のどんな形
式でも使うことができます。

@c @code{use-p} is @code{eval}ed only if @code{regexp} matches.

@item function
この関数が、このボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは部分表現の番号ですが、これは合致のどの
部分が @var{function} にデータとして送られるかを指定します。
@end table

したがって URL をボタンにする完全な要素は、こうなります。

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
これは他の連想リストと同じようなものですが、記事のヘッダーだけに適用され
ることと、それぞれの項目がどのヘッダーにボタンを付けるかを指示するための
追加の要素を持っていることが異なります:

@lisp
(@var{header} @var{regexp} @var{button-par} @var{use-p} @var{function} @var{data-par})
@end lisp

@var{header} は正規表現です。
@end table

@subsubsection 関連する変数と関数

@table @code
@item gnus-button-@var{*}-level
@ref{Article Button Levels} を参照して下さい。

@c Stuff related to gnus-button-browse-level

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。上述の変数のディフォルトの値で
使われます。

@c Stuff related to gnus-button-man-level

@item gnus-button-man-handler
@vindex gnus-button-man-handler
Man ページの表示に使う関数です。少なくとも一つの引数として Man ページの
名前の文字列を受け付けなければなりません。

@c Stuff related to gnus-button-message-level

@item gnus-button-mid-or-mail-regexp
@vindex gnus-button-mid-or-mail-regexp
Message-ID かメールアドレスに合致する正規表現です。

@item gnus-button-prefer-mid-or-mail
@vindex gnus-button-prefer-mid-or-mail
この変数は @samp{foo123@@bar.invalid} のような文字列のボタンが押されたと
きに、何を行なうかを決める変数です。このような文字列は Message-ID かメー
ルアドレスのいずれかです。もし @code{mid} か @code{mail} というシンボル
のうちの一つだったら、Gnus は常にそれぞれ文字列が Message-ID またはメー
ルアドレスであると仮定します。この変数が @code{ask} というシンボルに設定
されると、Gnus はいつも利用者が何をしたいかを尋ねます。それが関数だった
場合、たった一つの文字列を引数として呼ばれます。その関数は @code{mid}、
@code{mail}、@code{invalid} または @code{ask} を返さなければなりません。
ディフォルト値は関数 @code{gnus-button-mid-or-mail-heuristic} です。

@item gnus-button-mid-or-mail-heuristic
@findex gnus-button-mid-or-mail-heuristic
その引数が Message-ID かメールアドレスであるかを推定する関数です。
Message-ID だったら @code{mid} を、メールアドレスだったら @code{mail} を、
不確かだったら @code{ask} を、そして無効な文字列だった
ら @code{invalid} を返します。

@item gnus-button-mid-or-mail-heuristic-alist
@vindex gnus-button-mid-or-mail-heuristic-alist
関数 @code{gnus-button-mid-or-mail-heuristic} で使われる @code{(RATE
. REGEXP)} 対の連想リストです。

@c Stuff related to gnus-button-tex-level

@item gnus-button-ctan-handler
@findex gnus-button-ctan-handler
CTAN リンクの表示に使う関数です。URL 名の文字列を、引数として一つ受け付
けなければなりません。

@item gnus-ctan-url
@vindex gnus-ctan-url
@code{gnus-button-ctan-handler} で使われる CTAN (Comprehensive TeX
Archive Network) アーカイブのディレクトリーです。

@c Misc stuff

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェースです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェースです。
@end table

記事に自動的にボタンを付ける方法は、@ref{Customizing Articles} を参照し
て下さい。

@node Article Button Levels
@subsection Article button levels
@cindex button levels

変数 @code{gnus-button-@var{*}-level} の値が高いほど、より多くのボタンが
現れます。レベルがゼロだったらボタンは表示されません。ディフォルト
値 (それは 5) では、とてもたくさんのボタンをすでに見ているはずです。高い
レベルではより多くのボタンを見ることになりますが、多くの要らないものも現
れるかもしれません。それらを避けるために、特定のグループに対して変
数 @code{gnus-button-@var{*}-level} を設定しても良いでしょ
う (@pxref{Group Parameters})。@code{gnus-parameters} 変数の例です:

@lisp
;; @r{いくつかのグループで @code{gnus-button-*-level} を増やす:}
(setq gnus-parameters
      '(("\\<\\(emacs\\|gnus\\)\\>" (gnus-button-emacs-level 10))
        ("\\<unix\\>"               (gnus-button-man-level 10))
        ("\\<tex\\>"                (gnus-button-tex-level 10))))
@end lisp

@table @code
@item gnus-button-browse-level
@vindex gnus-button-browse-level
Message-ID、メールアドレスおよびニュースの URL を参照する案内の表示を制
御します。関連する変数と関数には @code{gnus-button-url-regexp}、
@code{browse-url} および @code{browse-url-browser-function} があります。

@item gnus-button-emacs-level
@vindex gnus-button-emacs-level
Emacs または Gnus への参照の表示を制御します。関連する関数は、
@code{gnus-button-handle-custom},
@code{gnus-button-handle-describe-function},
@code{gnus-button-handle-describe-variable},
@code{gnus-button-handle-symbol},
@code{gnus-button-handle-describe-key},
@code{gnus-button-handle-apropos},
@code{gnus-button-handle-apropos-command},
@code{gnus-button-handle-apropos-variable},
@code{gnus-button-handle-apropos-documentation} およ
び @code{gnus-button-handle-library} です。

@item gnus-button-man-level
@vindex gnus-button-man-level
(Unix の) man ページへの参照の表示を制御します。
@code{gnus-button-man-handler} を見て下さい。

@item gnus-button-message-level
@vindex gnus-button-message-level
Message-ID、メールアドレスおよびニュースの URL の表示を制御します。関連
する変数と関数に
は @code{gnus-button-mid-or-mail-regexp},
@code{gnus-button-prefer-mid-or-mail},
@code{gnus-button-mid-or-mail-heuristic} およ
び @code{gnus-button-mid-or-mail-heuristic-alist} があります。

@item gnus-button-tex-level
@vindex gnus-button-tex-level
@TeX{} または LaTex への参照、例えば CTAN の URL の表示を制御します。変
数 @code{gnus-ctan-url},
@code{gnus-button-ctan-handler},
@code{gnus-button-ctan-directory-regexp} および
@code{gnus-button-handle-ctan-bogus-regexp} を見て下さい。
@end table

@node Article Date
@subsection 記事の日付

日付は聞いたことの無い何か辺鄙なタイムゾーンで作成されていることが良くあ
るので、記事が送られたときに何時だったかを知ることができるのはとても良い
ことです。

@table @kbd
@item W T u
@kindex W T u (概略)
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i (概略)
@findex gnus-article-date-iso8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示しま
す (@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l (概略)
@findex gnus-article-date-local
日付をローカル・タイムゾーンで表示しま
す (@code{gnus-article-date-local})。

@item W T p
@kindex W T p (概略)
@findex gnus-article-date-english
日付を英語で楽に発音できる形式で表示しま
す (@code{gnus-article-date-english})。

@item W T s
@kindex W T s (概略)
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定される、
@code{format-time-string} に渡される文字列です。指定することができる様式
の一覧は、変数の説明文を見て下さい。

@item W T e
@kindex W T e (概略)
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示しま
す (@code{gnus-article-date-lapsed})。こんなふうに。

@example
X-Sent: 6 weeks, 4 days, 1 hour, 3 minutes, 8 seconds ago
@end example

@vindex gnus-article-date-lapsed-new-header
@code{gnus-article-date-lapsed-new-header} の値で、このヘッダーを既存
の Date の下に追加するか、置き替えるかを指定します。

Gnus でメールを読むことの利点は、それが単純なバグを素晴らしい不条理に置
き換えることです。

この行が連続して更新されるようにしたいのであれば、

@lisp
(gnus-start-date-timer)
@end lisp

を @file{~/.gnus.el} ファイルに入れるか、それを何かのフックで実行するよ
うにすることができます。タイマーを止めたい場合は、
@code{gnus-stop-date-timer} 命令を使って下さい。

@item W T o
@kindex W T o (概略)
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなた
が普段は他の変換関数を使っていて、それが完全に間違ったことをしているので
はないかと心配になったときに役に立ちます。例えば、記事が 1854年に投稿さ
れたと主張したとしましょう。しかし、そのようなことは @emph{完全に } 不可
能です。私が信用できませんか? *くすくす*
@end table

好みの書式で自動的に日付を表示する方法は @ref{Customizing Articles} を参
照して下さい。

@node Article Display
@subsection Article Display
@cindex picons
@cindex x-face
@cindex smileys

これらのコマンドは、いろんな取るに足らないギミック (gimmicks) の表示を、
それらをサポートしている Emacs の記事バッファーに追加します。

@code{X-Face} ヘッダーは小さな白黒画像で、メッセージヘッダーから持ってき
ます (@pxref{X-Face})。

@code{Face} ヘッダーは小さなカラー画像で、メッセージヘッダーから持ってき
ます (@pxref{Face})。

スマイリーは、人々がメッセージに散らかしたがる小さな @samp{:-)} シンボル
です。

一方 Picon はあなた自身のシステムに依存し、Gnus はヘッダーに合致するあな
たの持ち物を探してみます (@pxref{Picons})。

これらすべての機能はトグルです。もしすでにそれらが存在していたならば、そ
れらは削除されます。

@table @kbd
@item W D x
@kindex W D x (概略)
@findex gnus-article-display-x-face
@code{X-Face} を @code{From} ヘッダーに表示しま
す (@code{gnus-article-display-x-face})。

@item W D d
@kindex W D d (概略)
@findex gnus-article-display-face
@code{Face} を @code{From} ヘッダーに表示しま
す (@code{gnus-article-display-face})。

@item W D s
@kindex W D s (概略)
@findex gnus-treat-smiley
スマイリーを表示します (@code{gnus-treat-smiley})。

@item W D f
@kindex W D f (概略)
@findex gnus-treat-from-picon
@code{From} ヘッダーを Picon 化します (@code{gnus-treat-from-picon})。

@item W D m
@kindex W D m (概略)
@findex gnus-treat-mail-picon
すべてのメールヘッダー (すなわち @code{Cc}、@code{To}) を Picon 化しま
す (@code{gnus-treat-mail-picon})。

@item W D n
@kindex W D n (概略)
@findex gnus-treat-newsgroups-picon
すべてのニュースヘッダー (すなわ
ち @code{Newsgroups} と @code{Followup-To}) を Picon 化しま
す (@code{gnus-treat-newsgroups-picon})。

@item W D D
@kindex W D D (概略)
@findex gnus-article-remove-images
記事バッファーからすべての画像を削除しま
す (@code{gnus-article-remove-images})。
@end table

@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は二つの部分に分けられます---ヘッダーと本文です。本文は署
名部分と文章部分に分けることができます。どれが署名とみなされるかを決める
変数は @code{gnus-signature-separator} です。これは普通は son-of-RFC
1036 で規定されている標準の @samp{^-- $} です。しかし、多くの人が標準で
はない署名セパレーターを使うので、この変数は一つ一つ試される、正規表現の
リストであることもできます。(探索は本文の最後から始めへとなされま
す。) よくありそうな値は:

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; @r{標準}
        "^-- *$"        ; @r{普通の崩し方}
        "^-------*$"    ; @r{多くの人は長ーーい横棒の}
                        ; @r{行を使います。みっともない!}
        "^ *--------*$" ; @r{二倍みっともない!}
        "^________*$"   ; @r{下線も人気があります}
        "^========*$")) ; @r{邪道!}
@end lisp

あなたが寛容であればあるほど、間違った結果を得ることになるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} は記事を表示するときにどれが署名とみなされる
かへの制限を提供します。

@enumerate
@item
これが整数であれば、署名はこの整数より (文字数で) 長くなっていてはいけま
せん。
@item
これが浮動小数点数であれば、署名はその数値より (行数で) 長くなっていては
いけません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、そのバッファーには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、当のその文字列は署名ではありません。
@end enumerate

この変数は、要素が上に列挙された型のリストであることもできます。例です:

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名セパレーターの後に 200 を超える行があるか、セパレーターの後の
テキストが正規表現 @samp{^---*Forwarded article} に合致すれば、結局それ
は署名ではないということです。

@node Article Miscellanea
@subsection 記事いろいろ

@table @kbd
@item A t
@kindex A t (概略)
@findex gnus-article-babel
記事をある言語から別のものへ変換します (@code{gnus-article-babel})。
@end table

@node MIME Commands
@section MIME コマンド
@cindex MIME decoding
@cindex attachments
@cindex viewing attachments

以下のコマンドはすべて数値接頭引数を理解します。例えば @kbd{3 K v} は
「三番目の @acronym{MIME} パートを表示する」という意味です。

@table @kbd
@item b
@itemx K v
@kindex b (概略)
@kindex K v (概略)
@acronym{MIME} パートを表示します。

@item K o
@kindex K o (概略)
@acronym{MIME} パートを保存します。

@item K O
@kindex K O (概略)
ファイル名の入力を求めてから @acronym{MIME} パートを保存し、それを記事か
ら取り除きます。取り除かれた @acronym{MIME} オブジェクト
は message/external-body 型の @acronym{MIME} 形式として参照されるように
なります。

@item K r
@kindex K r (概略)
@acronym{MIME} パートを外部にある本体で置き換えます。

@item K d
@kindex K d (概略)
@acronym{MIME} パートを削除して、削除したことの案内を追加します。

@item K c
@kindex K c (概略)
@acronym{MIME} パートをコピーします。

@item K e
@kindex K e (概略)
@acronym{MIME} パートを外部コマンドで表示します。

@item K i
@kindex K i (概略)
@acronym{MIME} パートをバッファー内に表示します。

@item K |
@kindex K | (概略)
@acronym{MIME} パートを外部コマンドにパイプします。
@end table

以降の @acronym{MIME} コマンドの残りは、数値接頭引数を同じやり方では使い
ません:

@table @kbd
@item K b
@kindex K b (概略)
すべての @acronym{MIME} パートの先頭にボタンを付加します。埋め込まれたパー
トをセーブ (または他の動作を実行) しようとするときに、たいてい便利です。

@item K m
@kindex K m (概略)
@findex gnus-summary-repair-multipart
ときたま、ヘッダーが無かったり間違ったヘッダーを持つマルチパートのメッセー
ジが送信されてきます。このコマンドは、それらのメッセージがより快適に表示
されるように「修復」を試みます (@code{gnus-summary-repair-multipart})。

@item X m
@kindex X m (概略)
@findex gnus-summary-save-parts
@acronym{MIME} タイプに合致するすべてのパートを、ディレクトリーにセーブ
します (@code{gnus-summary-save-parts})。プロセス/接頭引数の習慣を理解し
ます (@pxref{Process/Prefix})。

@item M-t
@kindex M-t (概略)
@findex gnus-summary-toggle-display-buttonized
記事バッファーにボタンを表示するかしないかを切り替えまま
す (@code{gnus-summary-toggle-display-buttonized})。

@item W M w
@kindex W M w (概略)
@findex gnus-article-decode-mime-words
記事ヘッダーにある RFC 2047 でエンコードされた語をデコードしま
す (@code{gnus-article-decode-mime-words})。

@item W M c
@kindex W M c (概略)
@findex gnus-article-decode-charset
エンコードされた記事の本文を、文字セットでデコードしま
す (@code{gnus-article-decode-charset})。

このコマンドは、文字セットを決めるために @code{Content-Type} ヘッダーを
調べます。記事にそんなヘッダーが無い場合でも、接頭引数を与えることによっ
て、デコードするための文字セットを入力することは可能です。ある共通のエン
コーディングを使って (でも @acronym{MIME} ヘッダーは含めずに) 人々が記事
を投稿する地域的なグループでは、@code{charset} グループ/トピック・パラメー
ターに必要な文字セットを設定すれば良いでしょう (@pxref{Group
Parameters})。

@item W M v
@kindex W M v (概略)
@findex gnus-mime-view-all-parts
現在の記事にある、すべての @acronym{MIME} パートを表示しま
す (@code{gnus-mime-view-all-parts})。
@end table

関連する変数:

@table @code
@item gnus-ignored-mime-types
@vindex gnus-ignored-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプは、Gnus によって完全に無視されます。ディフォル
ト値は @code{nil} です。

すべての Vcard を無視させるには、こんなふうにして下さい:

@lisp
(setq gnus-ignored-mime-types
      '("text/x-vcard"))
@end lisp

@item gnus-article-loose-mime
@vindex gnus-article-loose-mime
非-@code{nil} だったら、Gnus は記事を @acronym{MIME} メッセージとして解
読する前に、@samp{MIME-Version} があることを必要としません。これは、ある
壊れたメール・ユーザー・エージェントからのメッセージを読むときに役立ちま
す。ディフォルト値は @code{nil} です。

@item gnus-article-emulate-mime
@vindex gnus-article-emulate-mime
@acronym{MIME} ではない別のエンコーディングの手法があります。最も一般的
なのは @samp{uuencode} ですが、yEncode も普及してきています。この変数が
非-@code{nil} になっていると、Gnus はメッセージの本文にそれらのエンコー
ディングが見つかるかどうかを調べ、もしあったならば、それらを Gnus の
@acronym{MIME} 機構で処理します。ディフォルト値は @code{t} です。

@item gnus-unbuttonized-mime-types
@vindex gnus-unbuttonized-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプには、ボタンが付加されません。ただし、それらが表
示されないか、@code{gnus-buttonized-mime-types} 変数の方が優先される場合
を除いて、ですが。ディフォルト値は @code{(".*/.*")} です。この変数
は @code{gnus-inhibit-mime-unbuttonizing} が @code{nil} のときだけ使われ
ます。

@item gnus-buttonized-mime-types
@vindex gnus-buttonized-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプには、それらが表示されない場合を除いて、ボタンが
付加されます。この変数は @code{gnus-unbuttonized-mime-types} よりも優先
されます。ディフォルト値は @code{nil} です。この変数
は @code{gnus-inhibit-mime-unbuttonizing} が @code{nil} のときだけ使われ
ます。

例えば、セキュリティーのボタンだけを表示して、他のボタンを表示しないよう
にするには、この変数を @code{("multipart/signed")} に設定して、
@code{gnus-unbuttonized-mime-types} はディフォルト値のままにしておいて下
さい。

@item gnus-inhibit-mime-unbuttonizing
@vindex gnus-inhibit-mime-unbuttonizing
これが非-@code{nil} だと、すべての @acronym{MIME} パートにボタンを付加し
ます。ディフォルト値は @code{nil} です。

@item gnus-article-mime-part-function
@vindex gnus-article-mime-part-function
それぞれの @acronym{MIME} パートに対して、この関数が @acronym{MIME} ハン
ドル (訳注: パートのタイプや内容物を表現するために、Gnus の内部で使われ
るデータの構造体) を引数にして呼ばれます。この関数は、利用者が記事から情
報を集め (例えば Vcard の情報を bbdb のデータベースに加え) たり、パート
に基づいて何かを起動 (例えば、すべての jpeg をあるディレクトリーにセー
ブ) するために使われることが意図されています。

後者を行なう関数の例です:

@lisp
(defun my-save-all-jpeg-parts (handle)
  (when (equal (car (mm-handle-type handle)) "image/jpeg")
    (with-temp-buffer
      (insert (mm-get-part handle))
      (write-region (point-min) (point-max)
                    (read-file-name "Save jpeg to: ")))))
(setq gnus-article-mime-part-function
      'my-save-all-jpeg-parts)
@end lisp

@vindex gnus-mime-multipart-functions
@item gnus-mime-multipart-functions
@acronym{MIME} マルチパートの型と、それらを扱う関数の連想リストです。

@vindex gnus-mime-display-multipart-alternative-as-mixed
@item gnus-mime-display-multipart-alternative-as-mixed
"multipart/alternative" のパートを "multipart/mixed" であるものとして表
示します。

@vindex gnus-mime-display-multipart-related-as-mixed
@item gnus-mime-display-multipart-related-as-mixed
"multipart/related" のパートを "multipart/mixed" であるものとして表示し
ます。

もし "text/html" を表示するのが気に入らないのなら、@xref{Display
Customization, ,表示のカスタマイズ, emacs-mime-ja, The Emacs MIME
Manual}, にある @code{mm-discouraged-alternatives} を参照して下さい。た
だし (それで "text/html" を表示しないように設定して、かつ) この変数
が @code{nil} だと、"multipart/related" パートの中にある画像や他の資料を
見逃してしまうかもしれません。

@vindex gnus-mime-display-multipart-as-mixed
@item gnus-mime-display-multipart-as-mixed
"multipart" のパートを "multipart/mixed" であるものとして表示します。も
し @code{t} だと、
@code{gnus-mime-display-multipart-alternative-as-mixed} およ
び @code{gnus-mime-display-multipart-related-as-mixed} が @code{nil} で
あっても、この設定の方が優先されます。

@vindex mm-file-name-rewrite-functions
@item mm-file-name-rewrite-functions
@acronym{MIME} パートのファイル名を書き換えるために使われる関数のリスト
です。それぞれの関数はファイル名を受け取って、ファイル名を返します。

出来合いの関数は@*
@code{mm-file-name-delete-whitespace},
@code{mm-file-name-trim-whitespace},
@code{mm-file-name-collapse-whitespace} およ
び @code{mm-file-name-replace-whitespace} です。最後のものはファイル名に
含まれるそれぞれの空白文字を、変
数 @code{mm-file-name-replace-whitespace} の値で置き換えます。ディフォル
ト値は @code{"_"} (単一の下線) です。
@findex mm-file-name-delete-whitespace
@findex mm-file-name-trim-whitespace
@findex mm-file-name-collapse-whitespace
@findex mm-file-name-replace-whitespace
@vindex mm-file-name-replace-whitespace

標準の関数である @code{capitalize}, @code{downcase}, @code{upcase} およ
び @code{upcase-initials} も、役に立つでしょう。

ファイル名に含まれる空白文字が害をもたらすことは、みんなが知っています。
ただし、気にかけない人たちを除いて、ですが。そんな蒙昧の人たちから、たく
さんの添付ファイルを受け取るのであれば、こんなものを @file{~/.gnus.el}
ファイルに追加することによって、安寧な生活を送ることができるでしょう。

@lisp
(setq mm-file-name-rewrite-functions
      '(mm-file-name-trim-whitespace
        mm-file-name-collapse-whitespace
        mm-file-name-replace-whitespace))
@end lisp
@end table

@node Charsets
@section 文字セット
@cindex charsets

人々はいろいろな文字セットを使いますが、私たちは彼らが何の文字セットを使っ
ているかを教えてくれる @acronym{MIME} を持っています。あるいはもっと正確
に言えば、持っていたらいいなあと思います。多くの人たち
が @acronym{MIME} を利用しないか理解しないニュースリーダーとメイラーを使っ
て、何の文字セットを使うかを言わずに、単にメッセージを送出するのですが、
これを少しばかり救済するために、いくつかの地域的なニュース階層には、何の
文字セットがディフォルトであるかを宣言する取り決めがあります。例え
ば @samp{fj} 階層では @code{iso-2022-jp} を使っています。

@vindex gnus-group-charset-alist
この知識は @code{gnus-group-charset-alist} 変数にエンコードされています。
これは正規表現 (グループのフルネームに合致した最初の項目を使います) と、
それらのグループを講読するときに使われるディフォルトの文字セットの、連想
リストです。

@vindex gnus-newsgroup-ignored-charsets
加えて、人々のいくらかは @acronym{MIME} を意識していると自
称 (soi-disant) しているくせに、実はそうではないエージェントを使っていま
す。それらは、実際にはメッセージが @code{koi-8} なの
に @code{iso-8859-1} だと、陽気にメッセージに刻印するのです。ここでは救
済のために @code{gnus-newsgroup-ignored-charsets} 変数を使うことができま
す。そのリストに連ねられた文字セットは無視されます。この変数は、グループ
パラメーター (@pxref{Group Parameters}) を使って、グループ毎に設定するこ
とができます。ディフォルト値は @code{(unknown-8bit x-unknown)} で、それ
はいくつかのエージェントが内蔵し、主張する値を含んでいます。

@vindex gnus-group-posting-charset-alist
投稿する場合に、@acronym{MIME} でエンコードしてはいけない文字セットを判
定するために、@code{gnus-group-posting-charset-alist} が使われます。例え
ばいくつかの階層では、quoted-printable でヘッダーをエンコードすることは
嫌われます。

この変数は正規表現と、投稿に際してエンコードしなくても良いことを許され
た (またはエンコードすることが嫌われる) 文字セットの連想リストです。それ
ぞれの要素は @code{(}@var{test header body-list}@code{)} の形式であり、
それらは次の意味を持ちます。

@table @var
@item test
Newsgroups ヘッダーに合致する正規表現、または変数シンボルのどちらかです。
後者の場合は、その値を調べた結果が非-@code{nil} だったら、その要素が採用
されることになります。
@item header
ヘッダーをエンコードしなくても良い文字セットです (@code{nil} は、すべて
の文字セットをエンコードすることを意味します)。
@item body-list
「Content-Transfer-Encoding: 8bit」でもって本文をエンコードしても良
い (または quoted-printable や base64 でエンコードすることが嫌われる) 文
字セットのリスト、または特別な値の一つである @code{nil} (常
に quoted-printable でエンコードする)、または @code{t} (常に
「Content-Transfer-Encoding: 8bit」を使う) です。
@end table

@cindex Russian
@cindex koi8-r
@cindex koi8-u
@cindex iso-8859-5
@cindex coding system aliases
@cindex preferred charset
メッセージを送信するときに何の文字セットが使われるかを制御する付加的な変
数については、@xref{Encoding Customization,
,エンコーディングのカスタマイズ, emacs-mime-ja, The Emacs MIME
Manual}, を参照して下さい (訳注: 特に日本語のメッセージの文字セットにつ
いては、例えば変数 @code{mm-coding-system-priorities} を参照して下さい)。

Gnus 固有ではないけれど、役に立つかもしれない文字セットに関する他の秘訣:

もし、同一の Emacs の文字セットをエンコードする @acronym{MIME} の文字セッ
トが複数あるのならば、以下の宣言を使うことによって、使う文字セットを選択
することができます:

@lisp
(put-charset-property 'cyrillic-iso8859-5
                      'preferred-coding-system 'koi8-r)
@end lisp

これは、ロシア語がディフォルトの @code{iso-8859-5} @acronym{MIME} 文字セッ
トの代わりに、@code{koi8-r} でエンコードされることを意味します。

メッセージを @code{koi8-u} で読みたいのであれば、以下のように騙すことが
できます。

@lisp
(define-coding-system-alias 'koi8-u 'koi8-r)
@end lisp

これは、ほとんど正しいことをするでしょう。

そして最後に、@code{windows-1251} のような文字セットを読むには、次のよう
に宣言すれば良いでしょう (訳注: Emacs の版によっては、
@code{windows-1251} が最初から実装されています)。

@lisp
(codepage-setup 1251)
(define-coding-system-alias 'windows-1251 'cp1251)
@end lisp

@node Article Commands
@section 記事命令

@table @kbd
@item A P
@cindex PostScript
@cindex printing
@kindex A P (概略)
@vindex gnus-ps-print-hook
@findex gnus-summary-print-article
記事バッファーのポストスクリプト (PostScript) イメージを作成して印刷しま
す (@code{gnus-summary-print-article})。@code{gnus-ps-print-hook} がバッ
ファーを印刷する直前に実行されます。他に Muttprint を使って印刷すること
もできます (@pxref{Saving Articles})。
@end table

@node Summary Sorting
@section 概略の並べ替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファーを並べ替えることができます。

@table @kbd
@item C-c C-s C-n
@kindex C-c C-s C-n (概略)
@findex gnus-summary-sort-by-number
記事番号によって並べ替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a (概略)
@findex gnus-summary-sort-by-author
著者によって並べ替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-t
@kindex C-c C-s C-t (概略)
@findex gnus-summary-sort-by-recipient
受信者によって並べ替えます (@code{gnus-summary-sort-by-recipient})。

@item C-c C-s C-s
@kindex C-c C-s C-s (概略)
@findex gnus-summary-sort-by-subject
表題によって並べ替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d (概略)
@findex gnus-summary-sort-by-date
日付によって並べ替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l (概略)
@findex gnus-summary-sort-by-lines
行数によって並べ替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-c
@kindex C-c C-s C-c (概略)
@findex gnus-summary-sort-by-chars
記事の長さ (文字数) で並べ替えます (@code{gnus-summary-sort-by-chars})。

@item C-c C-s C-i
@kindex C-c C-s C-i (概略)
@findex gnus-summary-sort-by-score
スコアによって並べ替えます (@code{gnus-summary-sort-by-score})。

@item C-c C-s C-r
@kindex C-c C-s C-r (概略)
@findex gnus-summary-sort-by-random
ランダムに並べ替えます (@code{gnus-summary-sort-by-random})。

@item C-c C-s C-o
@kindex C-c C-s C-o (概略)
@findex gnus-summary-sort-by-original
ディフォルトの方法で並べ替えます (@code{gnus-summary-sort-by-original})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者では、すべての概略行が一行一行並べ替えられます。前者では根本だけ
に基づいて並べ替えられ、それはあなたが求めていることとは異なっているかも
しれません。スレッドを使うかどうかを切り替えるには @kbd{T T} を打って下
さい (@pxref{Thread Commands})。

@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ (概略)
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたいのに、それが概略バッファーに表示されていなく
ても、おそらくそれは可能でしょう。というのは、現在のグループ
が @acronym{NNTP} で取得されていて、親がまだ期限切れ消去されていない上、
現在の記事の @code{References} がぶち壊されていなければ、た
だ @kbd{^} か @kbd{A r} を押せば良いだけで
すから (@code{gnus-summary-refer-parent-article})。すべてがうまくいけば、
親記事を取得できるでしょう。もし親記事がすでに概略バッファーに表示されて
いるのであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられると、その数の祖先たちを遡って取得します。負の
数値接頭引数が与えられた場合は、その数の世代だけ前の祖先の記事のみを取得
します。ですから @kbd{3 ^} とすれば、Gnus は現在の記事の親と祖父母と曾祖
父母を取得します。@kbd{-3 ^} とすれば、Gnus は現在の記事の曾祖父母だけを
取得します。

@item A R (概略)
@findex gnus-summary-refer-references
@kindex A R (概略)
記事の @code{References} 欄にあるすべての記事を取得しま
す (@code{gnus-summary-refer-references})。

@item A T (概略)
@findex gnus-summary-refer-thread
@kindex A T (概略)
現在の記事があるスレッドの、全部の記事を表示しま
す (@code{gnus-summary-refer-thread})。この命令は動作するために現在のグ
ループのすべてのヘッダーを取得しなければならないので、普通は少し時間がか
かります。これをしばしば行なうのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くします。もちろんグループに入
るのはいくらか遅くなりますが。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい
古い (すなわち、現在のグループで最初に表示されたものよりも前の記事の) ヘッ
ダーを取得するかを指定します。ディフォルトは 200 です。もし @code{t} で
あれば、取得可能なすべてのヘッダーを取得します。@code{A T} 命令に数値接
頭引数を与えると、代わりにそれが使われます。

@item M-^ (概略)
@findex gnus-summary-refer-article
@kindex M-^ (概略)
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を Gnus に要求することが
できます。
@kbd{M-^} (@code{gnus-summary-refer-article}) は @code{Message-ID}、つま
りあの長くてなかなか読むことのできな
い @samp{<38o6up$6f2@@hymir.ifi.uio.no>} のようなものをあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。

Gnus はすでに取得してあるヘッダーたちの中で @code{Message-ID} を探します
が、見つからなかったら @code{gnus-refer-article-method} に設定されている
すべての選択方法を試してもみます。
@end table

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良く
できないようなバックエンド (@code{nnspool} など) であるのなら、
@code{gnus-refer-article-method} を @acronym{NNTP} の選択方法に設定すれ
ば良いでしょう。おそらく、あなたが問い合わせる @acronym{NNTP} サーバーが
あなたの読んでいるスプールを更新していると最も良いでしょう。しかし、それ
はどうしても必要なわけではありません。

それは選択方法のリストのみならず、現在の選択方法を意味する特別なシンボル
@code{current} であることもできます。Gnus は合うものを発見するまでそれら
すべての方法を試します。

これは現在の選択方法を試して、それが失敗した場合には Google に訊く設定の
例です:

@lisp
(setq gnus-refer-article-method
      '(current
        (nnweb "google" (nnweb-type google))))
@end lisp

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox},
@code{nnbabyl}, @code{nnmaildir} および @code{nnml} がどのグループからで
も記事を捜索できるのに対して、@code{nnfolder} と @code{nnimap} は現在の
グループに投稿された記事しか探すことができません。(その他のものは時間が
かかりすぎます。) @code{nnmh} ではまったく不可能です。

@node Alternative Approaches
@section 代替手段

ニュースを読む方法の好みは人それぞれです。これは Gnus なのですから、概略
バッファーのためのマイナーモードに少しばかり選択肢を設けます。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする
@end menu

@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニュースリーダー (@code{nn} や、ええ
と VM/CMS の @code{Netnews} など) は二段階の講読インターフェースを使いま
す。利用者はまず概略バッファーで読みたい記事に印を付けます。それから、記
事バッファーだけを表示して記事を読みます。

@findex gnus-pick-mode
@kindex M-x gnus-pick-mode
Gnus はこれをするための概略バッファーマイナーモードを提供しま
す---@code{gnus-pick-mode} です。これは、基本的には簡単に印を付けられる
ように少数のプロセス印命令を一個のキーだけで済む命令にして、概略バッファー
へ切り替えるための追加の命令を一つ提供します。

@quotation
訳注: Pick マイナーモードを有効にするには、以下のフックを使って下さい:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

そうせずに、概略バッファーに入ってから @kbd{M-x gnus-pick-mode} を実行し
ても、うまくいかないようです。
@end quotation

これらが pick mode で使うことができるキーです:

@table @kbd
@item .
@kindex . (選択)
@findex gnus-pick-article-or-thread
現在の行の記事かスレッドを選択しま
す (@code{gnus-pickd-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が非-@code{nil} だったら、このキーが
スレッドの最初の記事で使われるとスレッド全体を選択します。そうでなければ、
その記事だけを選択します。もし数値接頭引数を与えられると、その番号のスレッ
ドか記事に移動して、それを選択します。(普通は行番号が概略行の最初に表示
されます。)

@item SPACE
@kindex SPACE (選択)
@findex gnus-pick-next-page
概略バッファーを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファーの最後であれば、選択した記事を読み始めます。

@item u
@kindex u (選択)
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にしま
す (@code{gnus-pick-unmark-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が非-@code{nil} だったら、このキーが
スレッドの最初で使われるとそのスレッドを未選択にします。そうでなければ、
その記事だけを未選択にします。その行にあるスレッドか記事を未選択にする
ために、このキーに数値接頭引数を与えることができます。

@item RET
@kindex RET (選択)
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
が与えられると、最初にすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファー
は読んでいる間も表示されます。
@end table

すべての普通の概略モード命令は pick-mode でも使用可能ですが、@kbd{u} は
例外です。それでも、同じ関数 @code{gnus-summary-tick-article-forward} に
割り当てられている @kbd{!} を使うことができます。

これが良さそうだと思ったら、次のようにして下さい:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードのバッファーで実
行されます。

@vindex gnus-mark-unpicked-articles-as-read
@code{gnus-mark-unpicked-articles-as-read} が非-@code{nil} だったら、選
択されなかったすべての記事に既読の印を付けます。ディフォルト値
は @code{nil} です。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。Pick モードの行の様式は変
数 @code{gnus-summary-pick-line-format} で制御されま
す (@pxref{Formatting Variables})。これ
は @code{gnus-summary-line-format} と同じ様式指定を受け付けま
す (@pxref{Summary Buffer Lines})。

@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
@kindex M-x gnus-binary-mode
多くの時間をバイナリーグループで過ごしているのなら、いつも @kbd{X u},
@kbd{n}, @kbd{RET} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は、単に記事を普通の方法で表示する代わりに、
記事を選択するための普通の Gnus の関数を、一連の記事を uudecode してその
結果を表示するように変更する、概略バッファーのためのマイナーモードです。

@kindex g (バイナリー)
@findex gnus-binary-show-article
現実には、このモードにしたときに、実際に記事を見るための唯一の命令
が @kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードのバッファーで呼
ばれます。

@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の Gnus の概略表示を好きでないならば、
@code{gnus-use-trees} を @code{t} に設定してみると良いかもしれません。こ
れは (ディフォルトで) 追加の @dfn{木バッファー} (tree buffer) を作成しま
す。木バッファーではすべての概略モード命令を実行することができます。

もちろん、木表示をカスタマイズする変数が少しあります:

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードのバッファーで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードのバッファーにおけるモード行のためのフォーマット文字列で
す (@pxref{Mode Line Formatting})。ディフォルト
は @samp{Gnus: %%b %S %Z} です。使用可能な指定
は @ref{Summary Buffer Mode Line} を参照して下さい。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファーで選択された記事をハイライトするために使われるフェースです。
ディフォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこれは少し誤った名称です---そ
れは行ではなく、ただ節を定義するだけです。ディフォルトの値
は @samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の三文字を表示します。
すべての節が同じ長さであることが重要なので、@samp{%4,4n} のような指定
を @emph{使わなければなりません}。

有効な指定は:

@table @samp
@item n
投稿者の名前。
@item f
@code{From} 欄。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}.

表示に関連した変数は:

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは『本当の』記事と『まばら』な記事に違いを付けるために使われます。様
式は

@example
((@var{本当の開} . @var{本当の閉})
 (@var{まばら開} . @var{まばら閉})
 (@var{偽の開} . @var{偽の閉}))
@end example

となっていて、ディフォルト
は @code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-edges
@vindex gnus-tree-parent-child-edges
これは親の節を子に接続するために使われる文字を含むリストです。ディフォル
トは @code{(?- ?\\ ?|)} です。
@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-window
もしこの変数が @code{nil} でないと、他の Gnus ウィンドウがもっと場所を取
れるように Gnus は木バッファーをできるだけ小さくします。もしこの変数が数
値であると、木バッファーの高さはその数値より大きくなることはありません。
ディフォルトは @code{t} です。フレームでいくつかのウィンドウが横に並んで
表示されていて、木バッファーがそのうちの一つである場合、木ウィンドウを最
小化することはその隣に表示されているすべてのウィンドウの大きさをも変更す
ることに注意して下さい。

以下のフックを追加して、いつでも木ウィンドウを最小化するようにしても良い
でしょう。

@lisp
(add-hook 'gnus-configure-windows-hook
          'gnus-tree-perhaps-minimize)
@end lisp

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。二つの定義済みの関
数 @code{gnus-generate-horizontal-tree} およ
び @code{gnus-generate-vertical-tree} (これがディフォルトです) が利用可
能です。
@end table

水平木バッファー (horizontal tree buffer) の例です:

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファー (vertical tree buffer) で表示されたもので
す:

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファーで木を隣り合わせで表示できれ
ば嬉しいでしょう。次のようなものを @file{~/.gnus.el} ファイルに加えるこ
とができます:

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Window Layout}.

@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループでのみ意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

これらすべての命令は (期限切れ消去と編集命令は除く) プロセス/接頭引数の
習慣を使います (@pxref{Process/Prefix})。

@table @kbd
@item B e
@kindex B e (概略)
@findex gnus-summary-expire-articles
現在のグループのすべての期限切れ消去可能な記事について、期限切れ消去の処
理 (@code{gnus-summary-expire-articles}) を行ないます。これは、そのグルー
プにしばらく存在していた期限切れ消去可能なすべての記事を消去するというこ
とです。(@pxref{Expiring Mail})。

@item B C-M-e
@kindex B C-M-e (概略)
@findex gnus-summary-expire-articles-now
グループのすべての期限切れ消去可能な記事を削除しま
す (@code{gnus-summay-expire-articles-now})。これは、現在のグループにあ
る @strong{すべて} の期限切れ消去可能な記事が、永遠に空の大き
な @file{/dev/null} へ消え去るということです。

@item B DEL
@kindex B DEL (概略)
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは『あなたのディスクから永久に削除して二度と
戻らない』の意味の『削除』です。注意して使って下さ
い (@code{gnus-summary-delete-article})。

@item B m
@kindex B m (概略)
@cindex move mail
@findex gnus-summary-move-article
@vindex gnus-preserve-marks
あるメールグループから別のメールグループへ記事を移動しま
す (@code{gnus-summary-move-article})。@code{gnus-preserve-marks} の値
が @code{nil} でなければ (これがディフォルト値ですが)、マークは保存され
ます。

@item B c
@kindex B c (概略)
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ (メールグループや他のもの) からメールグループに記事をコピー
します (@code{gnus-summary-copy-article})。@code{gnus-preserve-marks} の
値が @code{nil} でなければ (これがディフォルト値ですが)、マークは保存さ
れます。

@item B B
@kindex B B (概略)
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストしま
す (@code{gnus-summary-crosspost-article})。これは他のグループの記事の新
しい複製を作成し、記事の Xref 欄も適切に更新されます。

@item B i
@kindex B i (概略)
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みま
す (@code{gnus-summary-import-article})。あなたはファイル名と、
@code{From} 欄と @code{Subject} 欄の入力を促されます。

@item B I
@kindex B I (概略)
@findex gnus-summary-create-article
空の記事を現在のメールグループに作りま
す (@code{gnus-summary-create-article})。@code{From} ヘッダー
と @code{Subject} ヘッダーの内容を尋ねられます。

@item B r
@kindex B r (概略)
@findex gnus-summary-respool-article
@vindex gnus-summary-respool-default-method
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで
は @code{nil} で、その場合は現在のグループの選択方法が代わりに使われます。
@code{gnus-preserve-marks} の値が @code{nil} でなければ (これがディフォ
ルト値ですが)、マークは保存されます。

訳注: 「スプールし直す」というのはメールの分
割 (@ref{Splitting Mail} または @ref{Fancy Mail Splitting}) の規則に基づ
いて、メールを適切なグループに入れ直すことです。そのグループに間違って入っ
てしまったメールを、分割の規則を修正した後で、正しいグループに移動させる
場合などに使います。この章の @kbd{B q} と @kbd{B t} も見て下さい。

@item B w
@itemx e
@kindex B w (概略)
@kindex e (概略)
@findex gnus-summary-edit-article
@kindex C-c C-c (記事)
@findex gnus-summary-edit-article-done
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を固定するに
は @kbd{C-c C-c} (@code{gnus-summary-edit-article-done}) を打ちます。も
し @kbd{C-c C-c} 命令に接頭引数を与えると、Gnus は記事を再ハイライトしま
せん。

訳注: 変更しないで編集を終るには、@kbd{C-c C-k} をタイプして下さい。

@item B q
@kindex B q (概略)
@findex gnus-summary-respool-query
記事を再スプールするときは、再スプールをする前にどのグループに記事が移る
かを知りたいでしょう。この命令でそれがわかりま
す (@code{gnus-summary-respool-query})。

@item B t
@kindex B t (概略)
@findex gnus-summary-respool-trace
同様に、この命令は再スプールするときに使われるすべての特級分割方式を、も
しあれば表示します (@code{gnus-summary-respool-trace})。

@item B p
@kindex B p (概略)
@findex gnus-summary-article-posted-p
一部の人たちには、あなたが投稿した記事にフォローアップするときに、「親切
な」複製を送る傾向があります。これらは普通はそこに @code{Newsgroups} ヘッ
ダーが付いているのですが、いつもそうであるとは限りません。この命
令 (@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニュース
サーバーから (というよりは、むし
ろ @code{gnus-refer-article-method} や @code{gnus-select-method} か
ら) 取得しようとして、記事を発見できたかどうかを報告します。それが記事を
発見しなかったとしても、それはとにかく投稿されているかもしれません---メー
ルの伝達はニュースの伝達よりもずっと速いので、ニュースの複製がまだ到着し
ていないだけかもしれないのです。

訳注: その「親切な」複製が、概略バッファーで独立した記事として見えていな
いと検査することができないので、そうするために @kbd{A D} また
は @kbd{C-d} 命令 (@pxref{Really Various Summary Commands}) を使う必要が
あるかもしれません。この命令はとにかくすべての選択方法を試すので、特にそ
れらに遅いものが含まれているときは、注意して使って下さい。

@item K E
@kindex K E (概略)
@findex gnus-article-encrypt-body
@vindex gnus-article-encrypt-protocol
記事の本文を暗号化します (@code{gnus-article-encrypt-body})。本文は、変
数 @code{gnus-article-encrypt-protocol} で指定されたプロトコルで暗号化さ
れます。
@end table

@vindex gnus-move-split-methods
@cindex moving articles
いつも記事をどこかに移動 (もしくは複製) することを習慣にしているのならば、
記事をどこに入れれば良いかを Gnus に提案してもらいたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文を
使う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案を
するようにその変数をカスタマイズすることができます。
(@code{gnus-split-methods} がファイル名を使うのに対し
て @code{gnus-move-split-methods} はグループ名を使うことに注意して下さ
い。)

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp

@node Various Summary Stuff
@section 概略のいろいろなもの

@menu
* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令
@end menu

@table @code
@vindex gnus-summary-display-while-building
@item gnus-summary-display-while-building
非-@code{nil} だったら、構築中の概略バッファーを更新しながら表示します。
@code{t} だった場合は、行が挿入される度に毎回バッファーを更新します。値
が整数 @var{n} であった場合は、@var{n} 行毎に表示を更新します。ディフォ
ルトは @code{nil} です。

@vindex gnus-summary-display-arrow
@item gnus-summary-display-arrow
非-@code{nil} だったら、現在の記事を指し示すためにフリンジに矢印を表示し
ます。(訳注: フリンジとは Emacs 21 以上でウィンドウの左右に現れる余白の
ことです。)

@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードのバッファーを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファー作成の前に実行する最後のものとして呼ば
れます。これはニュースグループの持っているデータに基づいてスレッドの変数
をカスタマイズするのに非常に便利です。このフックはほとんどの概略バッファー
変数が設定された後に概略バッファーから呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
これは概略バッファーが作成された後に呼ばれます。例えば、これを何かしら神
をも畏れぬ方法で行をハイライトしたり、バッファーの見え方を修正したりする
のに使ったりするかもしれません。

@vindex gnus-summary-prepared-hook
@item gnus-summary-prepared-hook
概略バッファーが作成された後で一番最後に呼ばれるフックです。

@vindex gnus-summary-ignore-duplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ二つの記事を発見したときは、何か思い
切ったことをしなければなりません。別の記事が同じ @code{Message-ID} を持
つことは許されていませんが、それは何らかのソースからメールを読んでいると
きに起こるかもしれません。この変数によって Gnus が何をするかをカスタマイ
ズできるようになっています。@code{nil} だったら (それがディフォルトです)、
Gnus は @code{Message-ID} を付け替えて (表示のためだけに) その記事を他の
記事と同じように表示します。@code{t} にすると、それは記事を表示しませ
ん---最初から存在しなかったかのように。

@vindex gnus-alter-articles-to-read-function
@item gnus-alter-articles-to-read-function
この変数に設定した関数で、選択する記事のリストを変更することができます。
関数は二つの引数 (グループ名と選択する記事のリスト) を受け付けます。

例えば以下の関数は、キャッシュされた記事のリストを、あるグループのリスト
だけに追加します。

@lisp
(defun my-add-cached-articles (group articles)
  (if (string= group "some.group")
      (append gnus-newsgroup-cached articles)
    articles))
@end lisp

@vindex gnus-newsgroup-variables
@item gnus-newsgroup-variables
ニュースグループ (その概略バッファーの) のローカル変数、または変数とそれ
らの評価されるディフォルトの表現 (ディフォルト値が @code{nil} でない場
合) の cons セルのリストで、その概略バッファーが活きている間はグローバル
変数になります。(訳注: いわゆるバッファーローカル変数ではありません。)

注: ディフォルトの表現は単にローカル変数に設定されるのではなく、その前
に (@code{eval} 関数を使って) 評価されます。ディフォルトの表現
が @code{global} というシンボルだった場合は評価されず、代わりにそのロー
カル変数のグローバル値が使われます。

これらグループパラメーターの値が他のバッファーで行なわれる処理に影響する
ようになっていても、(訳注: その概略バッファーの) グループパラメーターを
設定するために使うことができます。例です:

@lisp
(setq gnus-newsgroup-variables
     '(message-use-followup-to
       (gnus-visible-headers .
         "^From:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^To:")))
@end lisp

@ref{Group Parameters} も参照して下さい。

訳注: もっと良い例が必要です。@code{gnus-newsgroup-variables} およ
び @code{gnus-parameters} (@pxref{Group Parameters}) の値を次のように設
定したとしましょう:

@lisp
(setq gnus-newsgroup-variables '((@var{var} . @var{foo})))
(setq gnus-parameters
      '(("^fj\\." (@var{var} . @var{bar}))
        ("^japan\\." (@var{var} . @var{baz}))))
@end lisp

こうしておくと変数 @var{var} の値が、@samp{fj} 階層のニュースグルー
プ (の概略バッファー) に入ると @var{bar} になり、@samp{japan} 階層のグルー
プに入ると @var{baz} になります。グループを抜けても変数 @var{var} の値は
変化しませんが、@samp{fj} または @samp{japan} 階層以外のグループに入ると
変数 @var{var} の値は @var{foo} になります (正確には、@var{foo},
@var{bar} または @var{baz} の値は、本編で説明されているよう
に @code{eval} した結果が使われます)。

通常のグループパラメーターは、そのグループの概略バッファでだけ値を知るこ
とができるのに対して、@code{gnus-newsgroup-variables} で設定した変数は、
同じ Emacs のどのバッファーでも、現在選択されているグループ固有の値を持
つ点が違います。異なる複数のグループの概略バッファーを使う場合には、注意
する必要があります。

特別な場合として @var{foo} が @code{nil} で良い場合は、次のように記述す
ることができます:

@lisp
(setq gnus-newsgroup-variables '(@var{var}))
(setq gnus-parameters
      '(("^fj\\." (@var{var} . @var{bar}))
        ("^japan\\." (@var{var} . @var{baz}))))
@end lisp

@code{gnus-newsgroup-variables} および @code{gnus-parameters} はどちらも
リストなので、@code{setq} よりはむし
ろ @code{add-to-list} や @code{push} などを使って、値を「追加」した方が
便利かもしれません。
@end table

@node Summary Group Information
@subsection 概略グループ情報

@table @kbd
@item H f
@kindex H f (概略)
@findex gnus-summary-fetch-faq
@vindex gnus-group-faq-directory
現在のグループの @acronym{FAQ} (frequently asked questions (頻繁にされる
質問) のリスト) を取得しようとします (@code{gnus-summary-fetch-faq})。
Gnus は @code{gnus-group-faq-directory} (通常これは遠隔マシンのディレク
トリー) から @acronym{FAQ} を取得しようとします。この変数はディレクトリー
のリストであることもできます。その場合、この命令に接頭引数を与えることに
よっていろいろなサイトから選ぶことができます。おそら
く @code{ange-ftp} もしくは @code{efs} がファイルの取得に使われるでしょ
う。

@item H d
@kindex H d (概略)
@findex gnus-summary-describe-group
現在のグループの簡潔な説明を表示しま
す (@code{gnus-summary-describe-group})。接頭引数が与えられると、サーバー
から強制的に説明の再読み込みをします。

@item H h
@kindex H h (概略)
@findex gnus-summary-describe-briefly
最も重要な概略コマンドの、非常に簡潔な説明を表示しま
す (@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i (概略)
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table

@node Searching for Articles
@subsection 記事を探す

@table @kbd
@item M-s
@kindex M-s (概略)
@findex gnus-summary-search-article-forward
それ以降のすべての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r (概略)
@findex gnus-summary-search-article-backward
それ以前のすべての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-backward})。

@item &
@kindex & (概略)
@findex gnus-summary-execute-command
この命令は、ヘッダー、そのヘッダーの内容に合致する正規表現、および合致し
たときに実行されるコマンドの入力を要求しま
す (@code{gnus-summary-execute-command})。ヘッダーが空文字列だったら、記
事全体で合致するものを探します。接頭引数を与えられると、代わりに後ろ向き
に探します。

例えば @kbd{& RET 何かの.*文字列 RET #} は、ヘッダーか本文
に @samp{何かの.*文字列} を持つすべての記事にプロセス印を付けます。

@item M-&
@kindex M-& (概略)
@findex gnus-summary-universal-argument
この命令に続けて入力する命令を、プロセス印が付けられているすべての記事で
実行します (@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd
@item Y g
@kindex Y g (概略)
@findex gnus-summary-prepare
現在の概略バッファーを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c (概略)
@findex gnus-summary-insert-cached-articles
(現在のグループのために) キャッシュされたすべての記事を概略バッファーに
挿入します (@code{gnus-summary-insert-cached-articles})。

@item Y d
@kindex Y d (概略)
@findex gnus-summary-insert-dormant-articles
(現在のグループのための) すべての保留記事を概略バッファーに挿入しま
す (@code{gnus-summary-insert-dormant-articles})。
@end table

@node Really Various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd
@item A D
@itemx C-d
@kindex C-d (概略)
@kindex A D (概略)
@findex gnus-summary-enter-digest-group
現在の記事が別の記事を寄せ集めたもの (例えばダイジェスト) であるならば、
それらの記事でできているグループに入るためにこの命令を使うことができま
す (@code{gnus-summary-enter-digest-group})。この命令に接頭引数を与えな
いと Gnus はどのような型の記事が現在表示されているかを推測しようとし、実
際にはそれが『ダイジェスト』であるものとして強引に解釈します。基本的に、
ある様式で寄せ集められた別のメッセージを見るときはいつでも、@kbd{C-d} を
使うことによって、もっと便利なやり方でそれらのメッセージを読むことができ
ます。

@item C-M-d
@kindex C-M-d (概略)
@findex gnus-summary-read-document
この命令は上のものによく似ていますが、いくつかの文書を一つのおおーきなグ
ループに集めます (@code{gnus-summary-read-read-document})。それを実現す
るために、この命令はそれぞれの文書のための @code{nndoc} グループを開いて
から、それら複数の @code{nndoc} グループのてっぺんで @code{nnvirtual} グ
ループを開きます。この命令はプロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。

@item C-t
@kindex C-t (概略)
@findex gnus-summary-toggle-truncation
長い概略行を切り詰めるかどうかを切り替えま
す (@code{gnus-summary-toggle-truncation})。これはおそらく概略バッファー
で行を中央に表示する機能を混乱させるので、記事を読んでいるときに行の切り
詰めを off にするのは良い考えではないでしょう。

@item =
@kindex = (概略)
@findex gnus-summary-expand-window
概略バッファーのウィンドウを拡大しま
す (@code{gnus-summary-expand-window})。接頭引数を与えられると、記事バッ
ファーのためのウィンドウの配置の設定を強制します (訳注: ディフォルトでは
記事バッファーのためのウィンドウの配置の設定には概略バッファーを表示する
ことも含まれているので、普通に記事を読んでいるときと同じになるでしょう)。

@item C-M-e
@kindex C-M-e (概略)
@findex gnus-summary-edit-parameters
現在のグループのグループパラメーター (@pxref{Group Parameters}) を編集し
ます (@code{gnus-summary-edit-parameters})。

@item C-M-a
@kindex C-M-a (概略)
@findex gnus-summary-customize-parameters
現在のグループのグループパラメーター (@pxref{Group Parameters}) をカスタ
マイズします (@code{gnus-summary-customize-parameters})。
@end table

@node Exiting the Summary Buffer
@section 概略バッファーを抜ける
@cindex summary exit
@cindex exiting groups

概略バッファーから抜けると、普通はグループのすべての情報を更新してグルー
プバッファーに戻ります。

@table @kbd
@item Z Z
@itemx Z Q
@itemx q
@kindex Z Z (概略)
@kindex Z Q (概略)
@kindex q (概略)
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@vindex gnus-group-no-more-groups-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループのすべての情報を更新しま
す (@code{gnus-summary-exit})。抜け出るための多くの処理を行なう前
に @code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルト
で @code{gnus-summary-expire-articles} を呼びます。抜け出るための処理を
終えた後で @code{gnus-summary-exit-hook} が呼ばれます。グループモードに
戻るときに (未読の) グループが残っていなかった
ら @code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q
@kindex Z E (概略)
@kindex Q (概略)
@findex gnus-summary-exit-no-update
グループのどんな情報も更新せずに現在のグループを抜け出ま
す (@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c (概略)
@kindex c (概略)
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループのすべての可視ではない (unticked) 記事に既読の印を付けてから抜け
ます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C (概略)
@findex gnus-summary-catchup-all-and-exit
可視記事さえも含むすべての記事に既読の印を付けてから抜けま
す (@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n (概略)
@findex gnus-summary-catchup-and-goto-next-group
すべての記事に既読の印を付けて次のグループへ移動しま
す (@code{gnus-summary-catchup-and-goto-next-group})。

@item Z R
@itemx C-x C-s
@kindex Z R (概略)
@kindex C-x C-s (概略)
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直しま
す (@code{gnus-summary-reselect-current-group})。接頭引数が与えられると、
既読と未読の両方のすべての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G (概略)
@kindex M-g (概略)
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、そのグループの新しい記事を調べてから、再びそのグループを
選択します (@code{gnus-summary-rescan-group})。接頭引数が与えられると、
既読と未読の両方のすべての記事を選択します。

@item Z N
@kindex Z N (概略)
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動しま
す (@code{gnus-summary-next-group})。

@item Z P
@kindex Z P (概略)
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動しま
す (@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s (概略)
@findex gnus-summary-save-newsrc
現在の既読と印付き記事の数をドリブルバッファー (dribble buffer) に保存し、
それからドリブルバッファーを保存します (@code{gnus-summary-save-newsrc})。
接頭引数が与えられると @file{.newsrc} ファイル (と @file{.newsrc.eld} ファ
イル) も保存します。この命令を使うと、更新なしで抜け出ること (@kbd{Q} 命
令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
グループのすべての情報を「更新」して現在のグループを抜けるとき
に @code{gnus-exit-group-hook} が呼ばれます。例え
ば @kbd{Q} 命令 (@code{gnus-summary-exit-no-update}) はこのフックを呼び
ません。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
グループを抜けた後でそれを後悔する癖があるのなら、
@code{gnus-kill-summary-on-exit} を @code{nil} に設定と良いかもしれませ
ん。そうすると Gnus は抜け出るときに概略バッファーを削除しません。(何と
いう驚き!) 代わりに、それはバッファーの名前
を @samp{*Dead Summary ... *} のようなものに変更して、
@code{gnus-dead-summary-mode} というマイナーモードを導入します。今やその
バッファーに切り替えると、すべてのキーが関
数 @code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付く
でしょう。死んだ概略バッファー (dead summary buffer) でどんなキーでも叩
くと、それは生きた普通の概略バッファーになります。

死んだ概略バッファーは同時に一つしか存在することはできません。

@vindex gnus-use-cross-reference
概略バッファーを抜け出ると、現在のグループのデータは更新されます (どの記
事を読んで、どの記事に返答したか、などなど。) もし変
数 @code{gnus-use-cross-reference} が @code{t} であると (それがディフォ
ルトです)、そのグループに相互参照された (cross referenced) 記事には、そ
れがクロスポストされた他の購読しているグループにあっても、既読の印が付き
ます。この変数が @code{nil} でも @code{t} でもなければ、記事には購読して
いるグループと購読していないグループの両方で既読の印が付きま
す (@pxref{Crosspost Handling})。

@node Crosspost Handling
@section クロスポストの扱い

@cindex velveeta
@cindex spamming
クロスポストされた記事に既読の印を付けることによって、同じ記事を二回以上
読まないで済むことを保証します。もちろん、だれかがそれを複数のグループに
別々に投稿しない限りは。同じ記事を複数のグループに (クロスポストではでは
なく) 投稿することは @dfn{spamming} と呼ばれ、あなたはそのような憎むべき
犯罪を行なうものに対して、法律によって不快な記事を送ることが義務づけられ
ています。spam を振い落すために、NoCeM で処理することを試してみる必要が
あるかもしれません (@pxref{NoCeM})。

覚えておいて下さい: クロスポストはまあ構いませんが、同じ記事を別々に複数
のグループに投稿するのは許されません。大量のクロスポス
ト (@dfn{velveeta} として知られているもの) は何としても避けられるべきで、
過剰なクロスポストに対して不満を言うため
に @code{gnus-summary-mail-crosspost-complaint} 命令を使うことさえできま
す。

@cindex cross-posting
@cindex Xref
@cindex @acronym{NOV}
Gnus にクロスポストを正しく扱えなくさせる原因の一つは、@sc{xover} (これ
は非常に良いです、というのはそれは速度をとても速くするからです) をサポー
トしているけれども @acronym{NOV} 行に @code{Xref} 欄を含めな
い @acronym{NNTP} サーバーを使っていることです。これは害悪です。でも、
あぁ、悲しいかな、非常に良くあることなのです。Gnus はあなたが読んだすべ
ての記事に @code{Xref} 行を記録することによって The Right Thing (正しい
こと) をしようとしますが、記事を削除したり単に読まないで既読の印を付ける
と、Gnus がこれらの記事の @code{Xref} 行をのぞきまわる機会が無くなってし
まうので、相互参照 (cross reference) の機構を使えなくなってしまいます。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @acronym{NNTP} サーバーがその概観ファイ
ル (overview file) に @code{Xref} 欄を含めるかどうかを調べるには、
@samp{telnet your.nntp.server nntp} をタイプして、@code{inn} サーバーで
は @samp{MODE READER} コマンドを与えてから、@samp{LIST overview.fmt} を
試して下さい。これは動作しないかもしれません。しかし、もし動作して、取得
した最後の行が @samp{Xref:full} でないならば (訳注: 最後の行ではないかも
しれません)、ニュースの管理者が概観ファイルに @code{Xref} 欄を含めるよう
にしてくれるまで、彼女に向かって叫び、泣き付くべきでしょう。

@vindex gnus-nov-is-evil
Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{gnus-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。

ま、人生はそのようなものです。

代替手段に付いては @ref{Duplicate Suppression} を参照して下さい。

@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは Gnus はクロスポスト機構を利用することによって、同じ記事
を二回以上読まないようにしようとします (@pxref{Crosspost Handling})。し
かし、その単純で効果的な方法は、いろいろな理由により、満足する結果をもた
らさないかもしれません。

@enumerate
@item
@acronym{NNTP} サーバーは @code{Xref} 欄の生成に失敗するかもしれません。
これは悪いことで、あまり起こりません。

@item
@acronym{NNTP} サーバーは @file{.overview} データベースに @code{Xref} 欄
を含めるのに失敗するかもしれません。これは悪いことで、非常に良くあること
です、あぁ悲しい。

@item
同じグループ (もしくはいくつかの関連したグループ) を違っ
た @acronym{NNTP} サーバーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は確かに他にもありますが、これら四つが最
も良くある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、@dfn{重複抑制} に切り
替えることを考慮する必要があるかもしれません。そうすれば、Gnus はあなた
が読んだすべての記事、あるいは既読の印を付けたすべての記事
の @code{Message-ID} を記憶し、そしてまるで魔法のように、以後それらを読
むときはいつでも既読の印が付いているようにします---@emph{すべて} のグルー
プで。この機構を使うのは何だかとても非効率になりそうですが、過度に非効率
なわけではありません。同じ記事を二回以上読むよりは、間違い無く望ましいで
す。

重複抑制はあまり精密な道具ではありません。どちらかというと大槌のようなも
のです。それは非常に単純なやり方で動作しています---あなたが記事に既読の
印を付けると、その Message-ID をキャッシュに加えます。次にそ
の Message-ID に出会うと、@samp{M} 印によって記事に既読の印を付けます。
その記事をどのグループで見たかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と
終了の時間を長くするので、ディフォルト値は @code{nil} です。しかし、これ
は Gnus を一回実行したときに読まれた重複記事だけが抑制されるということで
す。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかを決定します。ディフォルトは 10000 です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを格納しておくファイルの名前です。ディフォルト
は @file{~/News/suppression} です。
@end table

何度も Gnus を終了して起動する傾向があるのであれば、おそら
く @code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょ
う。もし Gnus を続けて何週間も走らせておくのであれば、それ
を @code{nil} にした方が良いかもしれません。一方、リストを保存することは
起動と終了をずっと遅くするので、頻繁に Gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきです。うーむ。
私はあなたがどうするかに任せようと思います。

@node Security
@section セキュリティー

Gnus は署名されたメッセージを検証したり、暗号化されたメッセージをデコー
ドすることができます。@acronym{PGP}, @acronym{PGP/MIME} およ
び @acronym{S/MIME} の形式をサポートしますが、それらを動作させるためには、
いくつかの外部プログラムを必要とします:

@enumerate
@item
@acronym{PGP} と @acronym{PGP/MIME} のメッセージを扱うには、OpenPGP の実
装である GnuPG のようなものをインストールしなければなりません。Gnus に含
まれている GnuPG へのインターフェースは PGG というもの (@pxref{Top,
,PGG, pgg-ja, PGG Manual}) ですが、Mailcrypt と gpg.el もサポートします。

@item
@acronym{S/MIME} のメッセージを扱うには、OpenSSL をインストールする必要
があります。OpenSSL 0.9.6 か、それより新しいものがお勧めです。
@end enumerate

それらをどうやって設定するかについてのもっと詳しい情報が、message マニュ
アル (@pxref{Security, ,セキュリティー, message-ja, The Message
Manual}) で見つかるでしょう。

@table @code
@item mm-verify-option
@vindex mm-verify-option
署名されたパートを検証するためのオプション。@code{never} は検証しない、
@code{always} はいつも検証する、@code{known} は知られたプロトコルの場合
だけ検証する、の意味です。それら以外の場合は、どうするかを利用者に尋ねま
す。

@item mm-decrypt-option
@vindex mm-decrypt-option
暗号化されたパートをデコードするためのオプション。@code{never} はデコー
ドしない、@code{always} はいつもデコードする、@code{known} は知られたプ
ロトコルの場合だけデコードする、の意味です。それら以外の場合は、どうする
かを利用者に尋ねます。

@item mml1991-use
@vindex mml1991-use
@acronym{PGP} のメッセージのための、OpenPGP の実装への elisp インターフェー
スを示すシンボルです。ディフォルトは @code{pgg} ですが、反論があるもの
の @code{mailcrypt} と @code{gpg} もサポートします。

@item mml2015-use
@vindex mml2015-use
@acronym{PGP/MIME} のメッセージのための、OpenPGP の実装への elisp インター
フェースを示すシンボルです。ディフォルトは @code{pgg} ですが、反論がある
ものの @code{mailcrypt} と @code{gpg} もサポートします。
@end table

@cindex snarfing keys
@cindex importing PGP keys
@cindex PGP key ring import
メニュー項目やコマンドから OpenPGP の鍵を取得 (snarf) する (すなわち、記
事から鍵を鍵束に輸入 (import) する) 機能は、明示的にはサポートされません。
というよりはむしろ、あなたが適切だと思うどんな動作をも通常
の @acronym{MIME} の機構を介して指定できるように、
Gnus は @samp{application/pgp-keys} として鍵を検出し、ラベルを付けます。
@acronym{MIME} ボタンをクリック (@pxref{Using MIME}) したときに、GNU
Privacy Guard を使って鍵を輸入してくれるようにするには、以下のような行
を @file{~/.mailcap} ファイル (@pxref{mailcap, ,mailcap, emacs-mime-ja,
The Emacs MIME Manual}) に記入して下さい。

@example
application/pgp-keys; gpg --import --interactive --verbose; needsterminal
@end example

これは、たまたま @code{mailcap-mime-data} ですでに定義されている、ディフォ
ルトの動作でもあります。

@node Mailing List
@section メーリングリスト
@cindex mailing list
@cindex RFC 2396

@kindex A M (概略)
@findex gnus-mailing-list-insinuate
Gnus は RFC 2369 で既定された各種のメーリングリストで使われるフィールド
を理解します。これを有効にするには概略バッファー
で @kbd{A M} (@code{gnus-mailing-list-insinuate}) を使うなどして、
@code{to-list} グループパラメーター (@pxref{Group Parameters}) を追加し
て下さい。

これによって概略バッファーでの以下の命令が使えるようになります。

@table @kbd
@item C-c C-n h
@kindex C-c C-n h (概略)
@findex gnus-mailing-list-help
List-Help フィールドがあったら、メーリングリストのヘルプを取り寄せるため
のメッセージを送信します。

@item C-c C-n s
@kindex C-c C-n s (概略)
@findex gnus-mailing-list-subscribe
List-Subscribe フィールドがあったら、メーリングリストの講読を始めるため
のメッセージを送信します。

@item C-c C-n u
@kindex C-c C-n u (概略)
@findex gnus-mailing-list-unsubscribe
List-Unsubscribe フィールドがあったら、メーリングリストの講読をやめるた
めのメッセージを送信します。

@item C-c C-n p
@kindex C-c C-n p (概略)
@findex gnus-mailing-list-post
List-Post フィールドがあったら、メーリングリストに投稿します。

@item C-c C-n o
@kindex C-c C-n o (概略)
@findex gnus-mailing-list-owner
List-Owner フィールドがあったら、メーリングリストの管理者宛てにメッセー
ジを送信します。

@item C-c C-n a
@kindex C-c C-n a (概略)
@findex gnus-mailing-list-archive
List-Archive フィールドがあったら、メーリングリストのアーカイブを閲覧し
ます。
@end table

@node Article Buffer
@chapter 記事バッファー
@cindex article buffer

記事は一つしかない記事バッファーに表示されます。すべての概略バッファー
は (Gnus に指示しない限り) 同じ記事バッファーを共有します。

@menu
* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を @acronym{MIME} に通す
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他
@end menu

@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー (@dfn{head}) と呼ばれます。(残りの部分はボ
ディー (@dfn{body}) です。すでにお気づきでしょうが。)

@vindex gnus-show-all-headers
ヘッダーにはたくさんの有益な情報が含まれています。記事を書いた人の名前、
それが書かれた日付、および記事の表題です。これはとても良いのですが、ヘッ
ダーには大部分の人にとっては見たくもない情報---記事があなたのところに着
くまでにどんなシステムを経由してきたか、@code{Message-ID}、
@code{References} などなど…もううんざりするくらい---たくさん含まれてい
ます。たぶんあなたはこれらの行のいくつかは取り除いてしまいたいと思うでしょ
う。もしこれらの行をすべて記事バッファー内に残しておきたければ、
@code{gnus-show-all-headers} を @code{t} に設定して下さい。

Gnus はヘッダーを選り分けるために二つの変数を用意しています:

@table @code
@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファーに残した
いかを指定する正規表現であるとみなされます。この変数に合致しないヘッダー
はすべて隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します:

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーに合致する正規表現をリストで指定すること
もできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設定されて
いれば (かつ @code{gnus-visible-headers} が @code{nil} であれば)、これは
隠したいヘッダー行すべてに合致する正規表現であるとみなされます。この変数
に合致しないすべてのヘッダー行が表示されます。

例えば、単に @code{References} 欄と @code{Xref} 欄のみを消し去りたければ、
以下のようにします:

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーに合致する正規表現のリストでも構いません。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、この変数に
は効果が無いことに注意して下さい。
@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え (sort) も行ないます (これはディフォルトで行な
われます)。この並べ替えは @code{gnus-sorted-header-list} 変数を設定する
ことで制御することができます。これはヘッダーをどういう順序で表示するかを
指定する正規表現のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風になるで
しょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないものは、この
変数に指定されているすべてのヘッダーの後に、適当な順序で表示されるでしょ
う。

@findex gnus-article-hide-boring-headers
@vindex gnus-boring-article-headers
@code{gnus-treat-hide-boring-headers} を @code{head} に設定することによっ
て、もっとつまらないヘッダーを隠すことができます。この関数が何をするか
は @code{gnus-boring-article-headers} 変数に依存します。この変数はリスト
ですが、このリストには実際のヘッダーの名前が入るのではありません。代わり
に Gnus がチェックして視界から消し去るためのさまざまな「つまらない条件」
(@dfn{boring conditions}) のリストを指定します。

この条件には以下のようなものがあります。

@table @code
@item empty
空のヘッダーをすべて消去します。
@item followup-to
@code{Followup-To} 欄が @code{Newsgroups} 欄と同一である場合には消去しま
す。
@item reply-to
@code{Reply-To} 欄が @code{From} 欄と同じアドレスを示しているか、
@code{broken-reply-to} グループパラメーターが設定されている場合には消去
します。
@item newsgroups
@code{Newsgroups} 欄が現在のグループ名しか含んでいない場合には消去します。
@item to-address
@code{To} 欄が現在のグループの @code{to-address} パラメーターと同じもの
しか含んでいない場合には消去します。
@item to-list
@code{To} 欄が現在のグループの @code{to-list} パラメーターと同じものしか
含んでいない場合には消去します。
@item cc-list
@code{CC} 欄が現在のグループの @code{to-list} パラメーターと同じものしか
含んでいない場合には消去します。
@item date
その記事が過去三日以内のものであれば、@code{Date} 欄を消去します。
@item long-to
@code{To} 欄があまりにも長い場合には消去します。
@item many-to
@code{To} 欄が一つよりも多ければ、それらをすべて消去します。
@end table

これらのうちの三つの要素を入れたければ、こんな風になります:

@lisp
(setq gnus-boring-article-headers
      '(empty followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。

@node Using MIME
@section MIME を使う
@cindex @acronym{MIME}

パントマイム (mime) は、観客があくびをしながらぼんやりしているのにもかか
わらず、意味も無く空中で手を振るものの標準として広く知られています。

一方 @acronym{MIME} は、そのためにすべてのニュースリーダが恐怖で死んでし
まうのにもかかわらず、意味も無く記事をエンコードする標準です。

@acronym{MIME} は記事がどんな文字セットを使うか、文字をどうエンコードす
るかを指定することができ、さらには絵やその他のみだらなものを無邪気な格好
の記事に埋め込むことさえ可能にします。

@vindex gnus-display-mime-function
@findex gnus-display-mime
Gnus は @acronym{MIME} パートを表示するために、
@code{gnus-display-mime-function} によって @acronym{MIME} 記事を処理しま
す。これはディフォルトでは @code{gnus-display-mime} で、
@acronym{MIME} オブジェクトを表示し、セーブし、かつ操作するために使うこ
とができる、ひとかたまりのクリック可能なボタンを作成します。

@acronym{MIME} ボタンの上にポイントを置いたならば、以下のコマンドが利用
できます:

@table @kbd
@findex gnus-article-press-button
@item RET (記事)
@kindex RET (記事)
@itemx BUTTON-2 (記事)
@acronym{MIME} オブジェクトの表示をトグルで切り替えま
す (@code{gnus-article-press-button})。そのオブジェクトを内蔵のビューワー
で表示できないときは、Gnus は @file{mailcap} ファイルにある外部のビュー
ワーに助けを求めます。ビューワーが @samp{copiousoutput} 仕様になっている
場合は、オブジェクトはインラインで (訳注: Emacs の表示に埋め込まれて) 表
示されます。

@findex gnus-mime-view-part
@item M-RET (記事)
@kindex M-RET (記事)
@itemx v (記事)
手段を尋ね、その手段を使って @acronym{MIME} オブジェクトを表示しま
す (@code{gnus-mime-view-part})。

@findex gnus-mime-view-part-as-type
@item t (記事)
@kindex t (記事)
@acronym{MIME} オブジェクトを、異なる @acronym{MIME} メディア・タイプで
あるかのように表示します (@code{gnus-mime-view-part-as-type})。

@findex gnus-mime-view-part-as-charset
@item C (記事)
@kindex C (記事)
文字セットを尋ね、その文字セットを使って @acronym{MIME} オブジェクトを表
示します (@code{gnus-mime-view-part-as-charset})。

@findex gnus-mime-save-part
@item o (記事)
@kindex o (記事)
ファイル名を尋ねて @acronym{MIME} オブジェクトをセーブしま
す (@code{gnus-mime-save-part})。

@findex gnus-mime-save-part-and-strip
@item C-o (記事)
@kindex C-o (記事)
ファイル名を尋ね、@acronym{MIME} オブジェクトをセーブして、それを記事か
ら取り外します (記事を編集することによって行なわれます)。取り外され
た @acronym{MIME} オブジェクトは message/external-body @acronym{MIME} タ
イプとして参照されるようになりま
す (@code{gnus-mime-save-part-and-strip})。

@findex gnus-mime-replace-part
@item r (記事)
@kindex r (記事)
ファイル名の入力を求めて、@acronym{MIME} オブジェクト
を message/external-body 型の @acronym{MIME} 形式のファイルとして参照さ
れる外部にある本体で置き換えます。(@code{gnus-mime-replace-part})。

@findex gnus-mime-delete-part
@item d (記事)
@kindex d (記事)
記事から @acronym{MIME} オブジェクトを取り外し、取り外したことを表す告知
で置き換えます (@code{gnus-mime-delete-part})。

@c FIXME: gnus-auto-select-part はここで説明されるべきです。

@findex gnus-mime-copy-part
@item c (記事)
@kindex c (記事)
@acronym{MIME} オブジェクトを新たに作ったバッファーにコピーして、それを
表示します (@code{gnus-mime-copy-part})。接頭引数が与えられると、デコー
ドせずに生の内容物をコピーします。数値の接頭引数を与えると、文字セットに
よるデコードを半手動で切り替えることができます (@ref{Paging the Article}
で述べられている @code{gnus-summary-show-article-charset-alist} を参照し
て下さい)。@code{auto-compression-mode} (@pxref{Compressed Files,
,Accessing Compressed Files, emacs, The Emacs Editor}) が設定されている
と、@file{.gz} や @file{.bz2} のような圧縮されたファイルを自動的に解凍し
ます。

@findex gnus-mime-print-part
@item p (記事)
@kindex p (記事)
@acronym{MIME} オブジェクトを印刷します (@code{gnus-mime-print-part})。
このコマンドは @file{.mailcap} ファイルで定義された @samp{print=} 仕様に
従います。

@findex gnus-mime-inline-part
@item i (記事)
@kindex i (記事)
@acronym{MIME} オブジェクトの内容物を、その記事バッファー
に text/plain として挿入します (@code{gnus-mime-inline-part})。接頭引数
が与えられると、デコードせずに生の内容物を挿入します。数値の接頭引数を与
えると、文字セットによるデコードを半手動で切り替えることができま
す (@ref{Paging the Article} で述べられてい
る @code{gnus-summary-show-article-charset-alist} を参照して下さい)。
@code{auto-compression-mode} (@pxref{Compressed Files, ,Accessing
Compressed Files, emacs, The Emacs Editor}) の
設定とは無関係に、@file{.gz} や @file{.bz2} のような圧縮されたファイル
を @code{jka-compr} を使って自動的に解凍します。

@findex gnus-mime-view-part-internally
@item E (記事)
@kindex E (記事)
内部ビューワーで @acronym{MIME} オブジェクトを表示します。内部ビューワー
が使えないときは、外部ビューワーを使いま
す (@code{gnus-mime-view-part-internally})。

@findex gnus-mime-view-part-externally
@item e (記事)
@kindex e (記事)
外部ビューワーで @acronym{MIME} オブジェクトを表示しま
す (@code{gnus-mime-view-part-externally})。

@findex gnus-mime-pipe-part
@item | (記事)
@kindex | (記事)
@acronym{MIME} オブジェクトをプロセスに出力しま
す (@code{gnus-mime-pipe-part})。

@findex gnus-mime-action-on-part
@item . (記事)
@kindex . (記事)
@acronym{MIME} オブジェクトをどう処理するかを、対話的に決めて実行しま
す (@code{gnus-mime-action-on-part})。
@end table

Gnus はいくつかの種類の @acronym{MIME} オブジェクトを自動的に表示します。
どのパートに対してそうするかを Gnus が決めるやり方については、
Emacs @acronym{MIME} マニュアルで述べられています。

不愉快なものでびっくりさせられるのを避けるには、トグルで切り替える関数を
使うのが最も良いでしょう。 (例えば、@samp{alt.sing-a-long} グループに入
ると、あなたの気づかないうちに @acronym{MIME} は記事中のサウンドファイル
をデコードして、何やら怪しげな長い長い歌があなたのスピーカーから大音響で
流れ出し、あなたはボリュームボタンを見つけられず、というのはそんなものは
もともと付いていないからで、みんなはあなたの方を睨みはじめ、あなたはプロ
グラムを止めようとするけれどもできなくて、ボリュームを制御するプログラム
も見つけられなくて、そして部屋中の全員は突然あなたのことを軽蔑の眼差しで
見るようになってしまい、あなたはちょっと面白くない思いをする、とか)。

現実の出来事と実在の人物に類似しているかもしれませんが、これはすべてホン
トのことです。げほげほ。

@ref{MIME Commands} も見て下さい。

@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

記事をどのように見せるかをカスタマイズするためのたくさんの関数が存在して
います。これらの関数を対話的に呼ぶこともできる
し (@pxref{Article Washing})、記事を選択したときに自動的に選択することも
できます。

自動的に呼ばれるようにするためには、対応するトリートメント変数を設定しな
ければなりません。例えばヘッダーを隠すためには、
@code{gnus-treat-hide-headers} を設定します。以下は設定できる変数の一覧
ですが、まずこれらの変数の取り得る値について話しましょう。

注意: いくつかの値は、有効な値であってもほとんど意味を無しません。実用的
な値は下の一覧を調べて下さい。

@enumerate
@item
@code{nil}: このトリートメントをしません。

@item
@code{t}: このトリートメントをすべての本文のパートで行ないます。

@item
@code{head}: ヘッダーでそのトリートメントをします。

@item
@code{last}: このトリートメントを最後のパートで行ないます。

@item
整数: このトリートメントをこの数値より短いすべての本文のパートで行ないま
す。

@item
文字列のリスト: このリストに含まれている正規表現に合致する名前のグループ
で読まれた記事の、すべての本文のパートでこのトリートメントを行ないます。

@item
最初の要素が文字列でないリストです:

リストは再帰的に評価されます。リストの最初の要素は述語です。以下の述語が
認識されます: @code{or}, @code{and}, @code{not}, @code{typep}。例です:

@lisp
(or last
    (typep "text/x-vcard"))
@end lisp

@end enumerate

ここで @dfn{パート} という語が使われていることに気付いたと思います。これ
はメッセージには @acronym{MIME} マルチパート記事があり、いくつかのパート
に分割されているかもしれないという事実に関連しています。マルチパートでな
い記事は一つのパートのみであるとみなされます。

@vindex gnus-article-treat-types
このトリートメントはすべてのマルチパートのパートたちに適用されるのでしょ
うか?  はい、そうしたければそうなります。ですが、ディフォルトで
は @samp{text/plain} パートだけにトリートメントが施されます。これ
は @code{gnus-article-treat-types} 変数で制御され、これはパートの型に合
致する正規表現のリストです。制御変数の値が、上で説明されているように述語
のリストであるときは、この変数は無視されます。

以下のトリートメントのオプションが使用可能です。これをカスタマイズするた
めの最も簡単な方法は @code{gnus-article-treat} カスタマイズグループを調
査することです。丸括弧の中の値は提案されている意味のある値です。他のもの
も可能ですが、ほとんどの人にとってはおそらくここに一覧表示されているもの
で十分でしょう。

@table @code
@item gnus-treat-buttonize (t, integer)
@item gnus-treat-buttonize-head (head)

@xref{Article Buttons}.

@item gnus-treat-capitalize-sentences (t, integer)
@item gnus-treat-overstrike (t, integer)
@item gnus-treat-strip-cr (t, integer)
@item gnus-treat-strip-headers-in-body (t, integer)
@item gnus-treat-strip-leading-blank-lines (t, integer)
@item gnus-treat-strip-multiple-blank-lines (t, integer)
@item gnus-treat-strip-pem (t, last, integer)
@item gnus-treat-strip-trailing-blank-lines (t, last, integer)
@item gnus-treat-unsplit-urls (t, integer)
@item gnus-treat-wash-html (t, integer)

@xref{Article Washing}.

@item gnus-treat-date-english (head)
@item gnus-treat-date-iso8601 (head)
@item gnus-treat-date-lapsed (head)
@item gnus-treat-date-local (head)
@item gnus-treat-date-original (head)
@item gnus-treat-date-user-defined (head)
@item gnus-treat-date-ut (head)

@xref{Article Date}.

@item gnus-treat-from-picon (head)
@item gnus-treat-mail-picon (head)
@item gnus-treat-newsgroups-picon (head)

@xref{Picons}.

@item gnus-treat-display-smileys (t, integer)

@item gnus-treat-body-boundary (head)

@vindex gnus-body-boundary-delimiter
ヘッダーと本文の間に境界線を追加します。境界線に
は @code{gnus-body-boundary-delimiter} に設定された文字列が使われます。

@xref{Smileys}.

@item gnus-treat-display-x-face (head)

@xref{X-Face}.

@item gnus-treat-display-face (head)

@xref{Face}.

@item gnus-treat-emphasize (t, head, integer)
@item gnus-treat-fill-article (t, integer)
@item gnus-treat-fill-long-lines (t, integer)
@item gnus-treat-hide-boring-headers (head)
@item gnus-treat-hide-citation (t, integer)
@item gnus-treat-hide-citation-maybe (t, integer)
@item gnus-treat-hide-headers (head)
@item gnus-treat-hide-signature (t, last)
@item gnus-treat-strip-banner (t, last)
@item gnus-treat-strip-list-identifiers (head)

@xref{Article Hiding}.

@item gnus-treat-highlight-citation (t, integer)
@item gnus-treat-highlight-headers (head)
@item gnus-treat-highlight-signature (t, last, integer)

@xref{Article Highlighting}.

@item gnus-treat-play-sounds
@item gnus-treat-translate
@item gnus-treat-ansi-sequences (t)
@item gnus-treat-x-pgp-sig (head)

@item gnus-treat-unfold-headers (head)
@item gnus-treat-fold-headers (head)
@item gnus-treat-fold-newsgroups (head)
@item gnus-treat-leading-whitespace (head)

@xref{Article Header}.
@end table

@vindex gnus-part-display-hook
もちろん、@code{gnus-part-display-hook} から呼ばれる自分用の関数を書く
こともできます。関数はそのパートに範囲が狭められた状態で呼ばれ、ほとんど
なんでも好きなことができます。バッファーに保存しておかなければならない情
報はありません---何でも変えることができます。

@node Article Keymap
@section 記事のキーマップ

概略バッファーにおけるキー操作のほとんどは記事バッファーでも使用できます。
これらは概略バッファーでそれらを押したかのように動作するはずです。つまり
記事を読んでいる間、実際に概略バッファーを表示させておく必要がありません。
すべての操作は記事バッファーから行なうことができるのです。

他にもいくつかのキーが利用できます。

@table @kbd
@item SPACE
@kindex SPACE (記事)
@findex gnus-article-next-page
記事を一ページ先にスクロールします。(@code{gnus-article-next-page})。
@kbd{h SPACE h} とまったく同じです。

@item DEL
@kindex DEL (記事)
@findex gnus-article-prev-page
記事を一ページ前にスクロールします (@code{gnus-article-prev-page})。
@kbd{h DEL h} とまったく同じです。

@item C-c ^
@kindex C-c ^ (記事)
@findex gnus-article-refer-article
カーソルが @code{Message-ID} の近辺にあるときに @kbd{C-c ^} を押すと、
Gnus はサーバーからその記事を取ってこようとしま
す (@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m (記事)
@findex gnus-article-mail
カーソルの近くにあるアドレスに返信を送ります (@code{gnus-article-mail})。
接頭引数を与えると、そのメールを引用します。

@item s
@kindex s (記事)
@findex gnus-article-show-summary
バッファーを再配置して、概略バッファーが見えるようにしま
す (@code{gnus-article-show-summary})。

@item ?
@kindex ? (記事)
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出しま
す (@code{gnus-article-describe-briefly})。

@item TAB
@kindex TAB (記事)
@findex gnus-article-next-button
次のボタンがあればそこに移動します (@code{gnus-article-next-button})。こ
れは記事にボタンを付ける機能をオンにしているときのみ意味を持ちます。

@item M-TAB
@kindex M-TAB (記事)
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します (@code{gnus-article-prev-button})。

@item R
@kindex R (記事)
@findex gnus-article-reply-with-original
現在の記事に元記事を含んだ返答のメールを送りま
す (@code{gnus-article-reply-with-original})。接頭引数を与えると広い返
答 (wide reply) になります。もし領域が活性化されていたならば、その領域に
あるテキストだけを yank します。

@item F
@kindex F (記事)
@findex gnus-article-followup-with-original
現在の記事に元記事を含んでフォローアップをしま
す (@code{gnus-article-followup-with-original})。接頭引数を与えると広い
返答 (wide reply) になります。もし領域が活性化されていたならば、その領域
にあるテキストだけを yank します。
@end table

@node Misc Article
@section 記事のその他

@table @code
@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@code{nil} 以外であれば、すべてのグループに対して同じ記事バッファーを使
用します (これはディフォルトです)。@code{nil} であれば、各グループ毎の固
有の記事バッファーを持つようになります。

@vindex gnus-article-decode-hook
@item gnus-article-decode-hook
@cindex @acronym{MIME}
@acronym{MIME} 記事をデコードするときに使用されるフックです。ディフォル
ト値は @code{(article-decode-charset article-decode-encoded-words)} です。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファーに挿入された直後に呼び出されます。これは
主に、何か記事の内容に依存する処理をする関数のために用意されています。記
事バッファーの内容を変更するような目的で使うべきではないでしょう。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードのバッファーで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファーで用いられるシンタックステーブルです。これ
は @code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-over-scroll
@item gnus-article-over-scroll
非-@code{nil} にすることによって、それ以上スクロールする新しいテキストが
無くても記事バッファーをスクロールすることを可能にします。ディフォルト
は @code{nil} です。(訳注: 記事の最下行が見えているときに、@code{nil} だ
と @kbd{RET} キーでそれ以上スクロールしませんが、非-@code{nil} にすると
記事が見えなくなるまでスクロールします。)

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ仕様に沿った様式文
字列です (@pxref{Summary Buffer Mode Line})。これは、その変数と同じ様式
指定および二つの拡張を受付けます。

@table @samp
@item w
記事の「洗濯状態」(@dfn{wash status})。これは記事に対して行なわれたであ
ろう洗濯操作を、それぞれ一文字で示す短い文字列になります。文字とそれらの
意味は次の通りです:

@table @samp
@item c
記事バッファーにおいて、引用された文が隠されているかもしれない場合に表示
されます。

@item h
記事バッファーにおいて、ヘッダーが隠されている場合に表示されます。

@item p
記事が電子署名または暗号化されていて、Gnus がセキュリティーのためのヘッ
ダーを隠していると表示されます。(注: 署名が正しいか間違っているかを表す
ものではありません。)

@item s
記事バッファーにおいて、署名が隠されている場合に表示されます。

@item o
記事バッファーにおいて、Gnus が重ね打ち文字のトリートメントを行なった場
合に表示されます。

@item e
記事バッファーにおいて、Gnus が強調された文字のトリートメントを行なった
場合に表示されます。
@end table

@item m
記事の @acronym{MIME} パートの数です。
@end table

@vindex gnus-break-pages
@item gnus-break-pages
改ページ (@dfn{page breaking}) を行なうかどうかを制御します。この変数
が @code{nil} 以外であれば、記事中にページ区切り文字が現れるごとにページ
分割をします。この変数が @code{nil} であればページ分けは行なわれません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォームフィー
ド) です。

@cindex IDNA
@cindex internationalized domain names
@vindex gnus-use-idna
@item gnus-use-idna
この変数は @samp{From:}、@samp{To:} および @samp{Cc:} ヘッダーにある国際
化ドメイン名を、Gnus が IDNA デコードするかどうかを制御します。そのよう
なメッセージの作り方について
は @xref{IDNA, ,国際化ドメイン名, message-ja, The Message Manual}, を参
照して下さい。これに
は @uref{http://www.gnu.org/software/libidn/, GNU Libidn} が必要で、この
変数はそれをインストールしてある場合だけ有効になります。
@end table

@node Composing Messages
@chapter メッセージの作成
@cindex composing messages
@cindex messages
@cindex mail
@cindex sending mail
@cindex reply
@cindex followup
@cindex post
@cindex using gpg
@cindex using s/mime
@cindex using smime

@kindex C-c C-c (投稿)
すべての投稿とメールを送るためのコマンドは、あなたをメッセージバッファー
に導きます。そこでは @kbd{C-c C-c} を押すことによって記事を送信する前に、
記事を好きなように編集することができます。@xref{Top, ,Overview, message,
Message Manual}.  メッセージはあなたの設定に基づいて投稿またはメールとし
て送信されます (@pxref{Posting Server})。

@menu
* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?
@end menu

投稿するべきでなかった記事を削除するための情報について @ref{Canceling
and Superseding} も参照して下さい。

@node Mail
@section メール

出て行くメールをカスタマイズする変数です:

@table @code
@item gnus-uu-digest-headers
@vindex gnus-uu-digest-headers
要約メッセージ (digested message) に含まれるヘッダーに合致する正規表現の
リストです。ヘッダーは合致した順に取り込まれます。@code{nil} だったら、
すべてのヘッダーを含みます。

@item gnus-add-to-list
@vindex gnus-add-to-list
@code{nil} でなければ、@kbd{a} を押したときに、@code{to-list} グループパ
ラメーターをそれの無いメールグループに付け加えます。

@item gnus-confirm-mail-reply-to-news
@vindex gnus-confirm-mail-reply-to-news
非-@code{nil} だったら、あなたがニュース記事への返答をメールでしようとす
ると Gnus は確認を求めます。@code{nil} ならば、あなたがやりたいことに何
も口出ししません。これは関数か正規表現であることもできます。関数は唯一の
パラメーターとしてグループ名を受け取り、確認する必要がある場合に
非-@code{nil} を返します。これを正規表現にすると、それに合致する名前のグ
ループで確認を求めます。

メールで返信する気は無いのに時たまぞんざいに R を押してしまう癖があるな
らば、この変数はそんなあなたのためにあります。

@item gnus-confirm-treat-mail-like-news
@vindex gnus-confirm-treat-mail-like-news
非-@code{nil} だったら、Gnus はメールに返信する時に
も @code{gnus-confirm-mail-reply-to-news} に基づいた確認を求めます。これ
はメーリングリストをニュースグループのように扱うのに便利です。
@end table

@node Posting Server
@section 投稿するサーバー

最新の (もちろん、非常に知的な) 記事を送り出すために、あの魔法のよう
な @kbd{C-c C-c} キーを押した時、それはどこにいくのでしょう?

尋ねてくれてありがとう。あなたを恨みます。

それは非常に複雑になり得ます。

@vindex gnus-post-method
ニュースを投稿するとき、通常 Message は @code{message-send-news} を呼び
出します (@pxref{News Variables, ,ニュース変数, message-ja, The Message
Manual})。普通は、Gnus は講読用と同じ選択方法を使って投稿します (このこ
とは、あなたがたくさんのグループを異なったサーバーで講読している場合に、
たぶん都合が良いのです)。しかし、あなたが講読しているそのサーバーが投稿
を許可せず、読むことのみを許可しているのならば、おそらくあなたの (非常に
知的でとんでもなく興味深い) 記事を投稿するために、他のサーバーを使いたい
と思うでしょう。そうならば @code{gnus-post-method} を他の方法に設定する
ことができます:

@lisp
(setq gnus-post-method '(nnspool ""))
@end lisp

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが落
ちていたりしたら、どうしたらよいのでしょう? この変数よりも優先させるため
に @kbd{C-c C-c} 命令にゼロでない数の接頭引数を与えることによって、投稿
に ``current'' (現在の) サーバーを使わせること、すなわちディフォルトの動
作 (訳注: @code{gnus-post-method} のディフォルト値は @code{current}) に
戻すことができます。

もし、ゼロを接頭引数としてその命令に与えたなら (すなわち、@kbd{C-u 0 C-c
C-c})、Gnus は投稿にどの方法を使うかをあなたに尋ねます。

@code{gnus-post-method} を選択方法のリストにすることもできます。その場合
は、Gnus は常に投稿にどの方法を使うかをあなたに尋ねます。

最後に、あなたがいつでも基本の選択方法を使って投稿したいのならば、この変
数を @code{native} にして下さい。

メールを送信するときに、Message は @code{message-send-mail-function} を
呼び出します。ディフォルトの関
数 @code{message-send-mail-with-sendmail} は記事を順番待ちに入
れ (queuing) たり送信するために、記事を @code{sendmail} コマンドにパイプ
します。ローカルシステムが @code{sendmail} でメールを送信するように設定
されていなくても、あなたが遠隔 @acronym{SMTP} サーバーに接続する権利を持っ
ているならば、
@code{message-send-mail-function} を @code{smtpmail-send-it} に設定する
ことができます。@code{smtpmail} パッケージを使うために正しい設定がなされ
ているかどうか確認して下さい。例です:

@lisp
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-default-smtp-server "YOUR SMTP HOST")
@end lisp

これと似たものに @code{message-smtpmail-send-it} があります。
ISP が @acronym{POP}-before-@acronym{SMTP} の認証を要求している場合に有
用です。@xref{POP before SMTP}.

他の可能な @code{message-send-mail-function} の選択肢に
は @code{message-send-mail-with-mh},
@code{message-send-mail-with-qmail} および @code{feedmail-send-it} があ
ります。

@node POP before SMTP
@section POP before SMTP
@cindex pop before smtp
@findex message-smtpmail-send-it
@findex mail-source-touch-pop

あなたの @acronym{ISP} は @acronym{POP}-before-@acronym{SMTP} 認証を要求
しますか? それは、メールを送信する前の一定時間以内に @acronym{POP} メー
ルサーバーに接続しなければならないかどうかです。もしそうならば、便利な手
があります。それには @file{~/.gnus.el} ファイルに以下の行を入れて下さい:

@lisp
(setq message-send-mail-function 'message-smtpmail-send-it)
(add-hook 'message-send-mail-hook 'mail-source-touch-pop)
@end lisp

@noindent
これは、メールを送信するときはいつでも Gnus に前もって @acronym{POP} メー
ルサーバーに接続させることを意味します。関
数 @code{mail-source-touch-pop} は、メールを送信する直前に、メールを取得
せずに @code{mail-sources} の値に従って @acronym{POP} 認証だけを行ないま
す。@code{smtpmail-send-it} ではなくて、@code{message-send-mail-hook} を
実行する @code{message-smtpmail-send-it} を使わなければならないことと、
@acronym{POP} 接続のために @code{mail-sources} の値を正しく設定しなけれ
ばならないことに注意して下さい。@xref{Mail Sources}.

もし @code{mail-sources} に二つ以上の @acronym{POP} メールサーバーを設定
しているならば、それらの一つを @acronym{POP}-before-@acronym{SMTP} 認証
に使われる @acronym{POP} メールサーバーとし
て @code{mail-source-primary-source} に設定する必要があるでしょう。それ
が第一 @acronym{POP} メールサーバーならば (すなわち、主にそのサーバーか
らメールを取得しているならば)、それを以下のように恒久的に設定することが
できます:

@lisp
(setq mail-source-primary-source
      '(pop :server "pop3.mail.server"
            :password "secret"))
@end lisp

@noindent
さもなければ、@acronym{POP}-before-@acronym{SMTP} 認証を行なうときだけ、
それを以下のように動的に束縛して下さい:

@lisp
(add-hook 'message-send-mail-hook
          (lambda ()
            (let ((mail-source-primary-source
                   '(pop :server "pop3.mail.server"
                         :password "secret")))
              (mail-source-touch-pop))))
@end lisp

@node Mail and Post
@section メールと投稿

これはメールの送信とニュースの投稿の両方に関連する変数のリストです:

@table @code
@item gnus-mailing-list-groups
@findex gnus-mailing-list-groups
@cindex mailing lists
あなたのニュースサーバーが、本当にメーリングリストの記事
を @acronym{NNTP} サーバーに流し込むゲートウェイによって、それらがニュー
スグループの記事として見えるようにしているのであれば、それらのグループは
問題なく読めるでしょう。しかしいくらか面倒なことを克服すること無しに、そ
れらに投稿またはフォローアップすることはできません。一つの解決法は、グルー
プパラメーター (@pxref{Group Parameters}) に @code{to-address} を加える
ことです。簡単にできるのは、@code{gnus-mailing-list-groups} を、本当はメー
リングリストであるグループに合致する正規表現に設定することです。そうすれ
ば、少なくともメーリングリストへのフォローアップはたいていのときに行なう
ことができるでしょう。これらのグループに投稿すること (@kbd{a}) は、それ
でも苦痛を引き起こすでしょうけれど。

@item gnus-user-agent
@vindex gnus-user-agent
@cindex User-Agent
この変数は、どの情報が User-Agent ヘッダーに陳列されるかを制御します。
それは次のシンボルまたは文字列のうちのどれかであることができます:
@code{gnus} (Gnus のバージョンのみ)、
@code{emacs-gnus} (Emacs と Gnus のバージョンだけ)、
@code{emacs-gnus-config} (@code{emacs-gnus} と同じ＋システム構成)、
@code{emacs-gnus-type} (@code{emacs-gnus}) と同じ＋システムタイプ) また
は好みの文字列。これを文字列にするときは、正しいフォーマットになっている
ことを確かめて下さい (RFC2616 参照)。
@end table

あなたは自分が送るメッセージで、綴りをチェックしたいかもしれません。もし
くは手で綴りのチェックをしたくないのであれば、自動綴りチェック
を @code{ispell} パッケージを使うことによって付け加えることができます:

@cindex ispell
@findex ispell-message
@lisp
(add-hook 'message-send-hook 'ispell-message)
@end lisp

@code{ispell} の辞書をグループに応じて切り替えたいならば、以下のようにす
れば良いでしょう。

@lisp
(add-hook 'gnus-select-group-hook
          (lambda ()
            (cond
             ((string-match
               "^de\\." (gnus-group-real-name gnus-newsgroup-name))
              (ispell-change-dictionary "deutsch"))
             (t
              (ispell-change-dictionary "english")))))
@end lisp

あなたの必要に応じて変更して下さい。

@node Archived Messages
@section メッセージの保管
@cindex archived messages
@cindex sent messages

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った
方法を提供します。ディフォルトの方法はメッセージを保存するため
に @dfn{アーカイブ仮想サーバー} を使うことです。これを完全に禁止したいの
であれば、変数 @code{gnus-message-archive-group} を @code{nil} にしなけ
ればなりません。それがディフォルトです。

グループで読んだ興味のあるメッセージの保存については、@kbd{B c}
(@code{gnus-summary-copy-article}) コマンドを参照して下さ
い (@pxref{Mail Group Commands})。

@vindex gnus-message-archive-method
@code{gnus-message-archive-method} は、送ったメッセージを蓄積するために
どの仮想サーバーを Gnus が使うかを指定します。ディフォルトは:

@lisp
(nnfolder "archive"
          (nnfolder-directory   "~/Mail/archive")
          (nnfolder-active-file "~/Mail/archive/active")
          (nnfolder-get-new-mail nil)
          (nnfolder-inhibit-expiry t))
@end lisp

しかし、どのメール選択方法でも使うことができま
す (@code{nnml}, @code{nnmbox} などなど)。しかし @code{nnfolder} はこの
ようなことをするのにとても好ましい選択方法です。ディフォルトで選択される
ディレクトリーを好きでないならば、次のようにできます:

@lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
                 (nnfolder-inhibit-expiry t)
                 (nnfolder-active-file "~/News/sent-mail/active")
                 (nnfolder-directory "~/News/sent-mail/")))
@end lisp

訳注: 上記のような例は「意図した通りに動作しない」FAQ のネタになりつつあ
り、不具合の原因が特定できない事例が少なくありません。例えば、同
じ "archive" という名前の仮想サーバーを過去に使ったことがあると、それ
が @file{~/.newsrc.eld} ファイルの中で @code{gnus-server-alist} 変数に登
録されているかもしれません。それを削除するには @file{~/.newsrc.eld} ファ
イルを手作業で書き換えなければなりませんが、かなり危険です。あるいは単に、
同名の仮想サーバーを現在も使っているかもしれません。そのような場合は、別
の名前を使う必要があります。

@vindex gnus-message-archive-group
@cindex Gcc
Gnus は外へ出て行くすべてのメッセージに、
@code{gnus-message-archive-method} で指定されたアーカイブ仮想サーバーに
ある (あるいはそれ以外のサーバーにある) 一つかそれ以上のグループに保存す
ることを意図した @code{Gcc} 欄を挿入します。どのグループを使うかは変
数 @code{gnus-message-archive-group} によって決まります。

この変数 (@code{gnus-message-archive-group}) は次のようなことをするため
に使うことができます:

@table @asis
@item 文字列
メッセージはそのグループに保存されます。

グループ名に選択方法を含めることができますが、そうするとそのメッセージ
は @code{gnus-message-archive-method} で指定した選択方法ではなくて、代わ
りにグループ名の選択方法で保存されることに注意しましょう。
@code{gnus-message-archive-method} は、上に示したようなディフォルト値を
持つためものであると考えて下さい。ですか
ら @code{gnus-message-archive-group} を @code{"foo"} にしておけば、外へ
出て行くメッセージは @samp{nnfolder+archive:foo} に保存されますが、
@code{"nnml:foo"} という値を使うと、外へ出て行くメッセージ
は @samp{nnml:foo} に保存されるでしょう。

@item 文字列のリスト
メッセージはそれらのすべてのグループに保存されます。

@item 正規表現、関数、Lisp フォームの連想リスト
キーが『合致』すると、その結果が使われます。

訳注: 正確には以下の三種類です。
@itemize @bullet
@item
正規表現とグループ名 (または複数のグループ名リスト) の連想リスト。最初に
正規表現が合致した要素のグループ名 (またはグループ名のリスト) が使われま
す。
@item
関数のリスト。それぞれの関数には現在のグループ名が引数として与えられ、最
初に返ってきた @code{nil} 以外の値が使われます。
@item
Lisp フォームのリスト。それぞれのフォームが評価され、最初に返ってき
た @code{nil} 以外の値が使われます。
@end itemize

@item @code{nil}
メッセージの保存は行なわれません。これがディフォルトです。
@end table

例をあげてみましょう:

@samp{MisK} という単一のグループに保存するだけならば:
@lisp
(setq gnus-message-archive-group "MisK")
@end lisp

二つのグループ、@samp{MisK} と @samp{safe} に保存するならば:
@lisp
(setq gnus-message-archive-group '("MisK" "safe"))
@end lisp

どのグループにいるかによって違ったグループに保存するなら:
@lisp
(setq gnus-message-archive-group
      '(("^alt" "sent-to-alt")
        ("mail" "sent-to-mail")
        (".*" "sent-to-misc")))
@end lisp

もっと複雑なもの:
@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          "misc-mail")))
@end lisp

すべてのニュースメッセージを一つのファイルに保存して、メールメッセージを
一月につき一つのファイルに保存するというのはどうでしょう:

@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          (concat "mail." (format-time-string
                           "%Y-%m" (current-time))))))
@end lisp

さあ、メッセージを送ると適切なグループに保存されるようになりました。(も
し特定のメッセージを保存をしたくないのであれば、挿入された @code{Gcc} 欄
を取り除いて下さい。)  保管グループは次に Gnus を起動したときか、次にグ
ループバッファーで @kbd{F} を押したときにグループバッファーに現れます。
他のグループと同じように、そのグループに入って記事を読むことができます。
そのグループが本当に大きくて悩ましくなったら、なにか良いものにその名前を
変更することができます (グループバッファーで @kbd{G r} を使うことによっ
て)---@samp{misc-mail-september-1995} その他何でも。新しいメッセージは古
い (今は空になった) グループに溜められます。

以上が送ったメッセージを保管するディフォルトの方法です。Gnus はディフォ
ルトの方法を好きではない人には違ったやり方を勧めています。そのような場合
は、@code{gnus-message-archive-group} を @code{nil} に設定するべきです。
これは保管をしないようにします。

@table @code
@item gnus-outgoing-message-group
@vindex gnus-outgoing-message-group
すべての外にいくメッセージはこのグループに入れられます。もしすべての外に
行くメールと記事を @samp{nnml:archive} グループに保管したいのであれば、
この変数をその値に設定して下さい。この変数はグループ名のリストであること
もできます。

もしそれぞれのメッセージをどのグループに入れるかをもっと制御したいのであ
れば、この変数を現在のニュースグループ名を調べて、適切なグループ名 (もし
くは名前のリスト) を返す関数に設定することができます。

この変数は @code{gnus-message-archive-group} の代わりに使うことができま
すが、後者の方が好ましい方法です。

(訳注:「後者」とは @code{gnus-message-archive-group} のこと。前者より四ヶ
月遅れて、1996年1月に新設されました。)

@item gnus-gcc-mark-as-read
@vindex gnus-gcc-mark-as-read
もし非-@code{nil} なら、@code{Gcc} の記事に既読の印を付けます。

@item gnus-gcc-externalize-attachments
@vindex gnus-gcc-externalize-attachments
@code{nil} だったら、ファイルを通常のパートとして Gcc で保存する記事のコ
ピーに添付します。それが正規表現で Gcc のグループ名に合致する場合は、外
部パートとしてファイルを添付します。@code{all} だったらローカルファイル
を参照する外部パートとして添付します。それが別の非-@code{nil} だった場合
の動作は @code{all} のときと同じですが、将来は変わるかもしれません。

(訳注: 送信したメッセージと同じものを Gcc で保存する代わりに、添付ファイ
ルをメッセージから切り離して、別にセーブするかどうかを制御する変数です。)
@end table

@node Posting Styles
@section 投稿様式
@cindex posting styles
@cindex styles

それらはすべて変数で、私の頭をくらくらさせます。

投稿するグループによって違った @code{Organization} と署名を付けたいんで
すか?  そして、家のマシンと職場のマシンの両方から投稿するけれども、違っ
た @code{From} 行などを使いたいんですか?  そんなこと、どうでもいいじゃあ
りませんか。

@vindex gnus-posting-styles
そのようなことをする方法の一つは、変更する必要のある変数を変更する賢いフッ
クを書くことです。それは少し退屈なので、利用者にこれらのことを手軽な連想
リストで指定するというすばらしい着想にたどり着いた人がいました。これが変
数 @code{gnus-posting-styles} の例です:

@lisp
((".*"
   (signature "Peace and happiness")
   (organization "What me?"))
 ("^comp"
  (signature "Death to everybody"))
 ("comp.emacs.i-love-it"
  (organization "Emacs is it")))
@end lisp

この例から推測されるように、この連想リストはいくつか
の @dfn{様式} (style) からなっています。それぞれの様式は最初の要素が何ら
かの形で ``合致'' したときに適用されます。連想リスト全体は最初から最後ま
で反復して実行され、それぞれの合致が適用されます。これは、後の様式の属性
が前に合致した様式の属性よりも優先されるということです。ですか
ら @samp{comp.programming.literate} は、@samp{Death to everybody} という
署名と @samp{What me?} という @code{Organization} ヘッダーを持ちます。

それぞれの様式の最初の要素は @code{マッチ} (match) と言います。もしそれ
が文字列であれば、Gnus はそれを正規表現であるものとして、グループ名に合
致するかどうかを調べます。@code{(header @var{合致} @var{正規表現})} とい
う形式であれば、Gnus は元記事の中からその名前が @var{合致} であるヘッダー
を探し、それを @var{正規表現} と比較します。
@var{合致} と @var{正規表現} は文字列です。(元記事とは、あなたがそれに対
して返信またはフォローアップしようとしている対象の記事です。返信あるいは
フォローアップを作成していなければ、合致するものは何もありません。) も
し @code{マッチ} が関数のシンボルであれば、その関数が引数無しで呼ばれま
す。それが変数のシンボルであれば、その変数が参照されます。それがリストで
あれば、そのリストが @code{評価} されます。どの場合でも、これ
が @code{nil} でない値を返せば、様式は @code{合致した} と言います。

それぞれの様式は任意の量の @dfn{属性} を持つことができます。それぞれの属
性は @code{(@var{name} @var{value})} の対により成り立っています。加え
て @code{(@var{name} :file @var{value})} の形式
か @code{(@var{name} :value @var{value})} の形式を使うこともできます。こ
こで @code{:file} は @var{value} がファイル名を表して、その内容が属性値
として使用されるべきであることを示し、@code{:value} は @var{value} がファ
イル名を表わさないことを明示的に示します。属性名 (@var{name}) は、以下の
どれかであることができます。

@itemize @bullet
@item @code{signature}
@item @code{signature-file}
@item @code{x-face-file}
@item @code{address} (@code{user-mail-address} よりも優先されます)
@item @code{name} (@code{(user-full-name)} よりも優先されます)
@item @code{body}
@end itemize

属性名は文字列またはシンボルであることもできます。その場合それはヘッダー
名として使われ、その値が記事のヘッダーに挿入されます。もし属性名
が @code{nil} だったら、そのヘッダー名は削除されます。もし属性名
が @code{eval} だったらその様式が評価され、結果は捨てられます。

属性値は文字列 (そのまま使われます)、引数の無い関数 (返り値が使われます)、
変数 (その値が使われます) またはリスト (それは @code{評価} されて、返り
値が使われます) であることができます。関数と S式 (sexp) はセットアップさ
れつつあるメッセージバッファーで呼ばれるか評価されます。現在の記事のヘッ
ダー群は変数 @code{message-reply-headers} から得られます。これは number
subject from date id references chars lines xref extra の各ヘッダーから
成るベクトルです。

@vindex message-reply-headers
作成しようとしているメッセージがニュース記事かメールメッセージであるかを
調べたいときは、関
数 @code{message-news-p} と @code{message-mail-p} の戻り値を調べて下さい。

@findex message-mail-p
@findex message-news-p
そして、これは例です:

@lisp
(setq gnus-posting-styles
      '((".*"
         (signature-file "~/.signature")
         (name "User Name")
         ("X-Home-Page" (getenv "WWW_HOME"))
         (organization "People's Front Against MWM"))
        ("^rec.humor"
         (signature my-funny-signature-randomizer))
        ((equal (system-name) "gnarly")  ;; @r{様式}
         (signature my-quote-randomizer))
        (message-news-p        ;; @r{関数シンボル}
         (signature my-news-signature))
        (window-system         ;; @r{変数シンボル}
         ("X-Window-System" (format "%s" window-system)))
        ;; @r{Lars さんに返事をするときは}
        ;; @r{Organization ヘッダーを付けよう。}
        ((header "to" "larsi.*org")
         (Organization "Somewhere, Inc."))
        ((posting-from-work-p) ;; @r{利用者が定義した関数}
         (signature-file "~/.work-signature")
         (address "user@@bar.foo")
         (body "You are fired.\n\nSincerely, your boss.")
         (organization "Important Work, Inc"))
        ("nnml:.*"
         (From (save-excursion
                 (set-buffer gnus-article-buffer)
                 (message-fetch-field "to"))))
        ("^nn.+:"
         (signature-file "~/.mail-signature"))))
@end lisp

@samp{nnml:.*} の規則は、あなたが出すすべての返事の @code{To} アドレス
を @code{From} アドレスとして使うことを意味します。これは、あなたがたく
さんのメーリングリストに参加している場合に便利でしょう。

@node Drafts
@section 下書き
@cindex drafts

メッセージ (メールもしくはニュース) を書いているときに、オーブンにステー
キが入っている (もしくはあなたがとーってもすごい菜食主義者で、何かのペー
ストがフードプロセッサーに入っている) ことを突然思い出したなら、書いてい
るメッセージを保存する方法があれば良いと思うでしょう。いつか別の日に編集
を続けることができ、それが完成したと思ったときに送ることができるように。

えぇ、心配しないで下さい。メールかニュースを送信するための Gnus の命令を
使って何らかのメッセージを書き始めたときにあなたが手にするバッファーは、
自動的に特別な @dfn{draft} グループに関連付けられます。普通の方法  (例え
ば @kbd{C-x C-s}) でバッファーを保存すれば、その記事はそこに保存されます。
(自動保存 (auto-save) ファイルも下書きグループ (draft group) に行きます。)

@cindex nndraft
@vindex nndraft-directory
下書きグループは @samp{nndraft:drafts} と呼ばれる特別なグループです (あ
なたが絶対に知っていなければならないのであれば、それは @code{nndraft} グ
ループとして実装されています)。変
数 @code{nndraft-directory} は @code{nndraft} がそのファイルをどこに保管
するかを指定します。このグループを特別なものにしているのは、その中の記事
に可視や既読の印を付けることができないことです---そのグループのすべての
記事は永久に未読です。

もしグループが存在しないと、それは作成され、購読させられます。グループバッ
ファーからそれを消し去る唯一の方法は、それを購読しないようにすることです。
下書きグループの特別の特性はグループの特性 (@pxref{Group Parameters}) に
よって生じ、それが失われてしまうと他のグループのように振る舞うようになり
ます。これは (グループの特性を消してしまうことは) 以下のコマンドが使えな
いことを意味します。そのグループの特別の特性を復活させる最も簡単な方法は、
@kbd{C-k} でそのグループを削除してから Gnus を再起動することです。そのグ
ループの内容物は失われません。

@c @findex gnus-dissociate-buffer-from-draft
@c @kindex C-c M-d (Mail)
@c @kindex C-c M-d (Post)
@c @findex gnus-associate-buffer-with-draft
@c @kindex C-c C-d (Mail)
@c @kindex C-c C-d (Post)
@c If you're writing some super-secret message that you later want to
@c encode with PGP before sending, you may wish to turn the auto-saving
@c (and association with the draft group) off.  You never know who might be
@c interested in reading all your extremely valuable and terribly horrible
@c and interesting secrets.  The @kbd{C-c M-d}
@c (@code{gnus-dissociate-buffer-from-draft}) command does that for you.
@c If you change your mind and want to turn the auto-saving back on again,
@c @kbd{C-c C-d} (@code{gnus-associate-buffer-with-draft} does that.
@c
@c @vindex gnus-use-draft
@c To leave association with the draft group off by default, set
@c @code{gnus-use-draft} to @code{nil}.  It is @code{t} by default.
@c
@findex gnus-draft-edit-message
@kindex D e (下書き)
記事の編集を続けたいときは、下書きグループに入っ
て @kbd{D e} (@code{gnus-draft-edit-message}) を押すだけです。編集を中断
したときの状態のバッファーに移動します。

送信を拒否された記事も、この下書きグループに入れられま
す (@pxref{Rejected Articles})。

@findex gnus-draft-send-all-messages
@kindex D s (Draft)
@findex gnus-draft-send-message
@kindex D S (Draft)
送信を拒否されたメッセージがたくさんあって、それ以上編集せずにそれらを送
信したい場合は、@kbd{D s} 命令を使うことができます。この命令はプロセス/
接頭引数の習慣を理解します (@pxref{Process/Prefix})。@kbd{D S} 命
令 (@code{gnus-draft-send-all-messages}) はバッファーのすべてのメッセー
ジを送り出します。

@findex gnus-draft-toggle-sending
@kindex D t (Draft)
送りたくないメッセージがいくつかあるのであれば、@kbd{D t} 命
令 (@code{gnus-draft-toggle-sending}) を使ってメッセージに送信不可の印を
付けることができます。これは切り替え命令です。

@node Rejected Articles
@section 拒否された記事
@cindex rejected articles

時々ニュースサーバーは記事を送信することを拒否します。おそらくサーバーは
あなたの顔を好きではないのでしょう。おそらく落ち込んでいるのでしょう。お
そらく @emph{悪魔 (demon) がいるのでしょう}。おそらく引用文を入れすぎた
のでしょう。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落
ちていたのでしょう。

もちろんこれらの状況は完全に Gnus の扱える範囲外です。(もちろん Gnus は
あなたの風貌を愛しているし、いつも機嫌が良いし、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちたり
しません。) ですから Gnus はこれらの記事を後でサーバーの機嫌が良くなる
まで保存します。

拒否された記事は自動的に特別な下書きグループ (@pxref{Drafts}) に入れられ
ます。サーバーが復旧した暁には、普通あなたはそのグループに入って、すべて
の記事を送ることになるでしょう。

@node Signing and encrypting
@section 署名と暗号化
@cindex using gpg
@cindex using s/mime
@cindex using smime

素の @acronym{PGP} 形式、@acronym{PGP/MIME} または @acronym{S/MIME} を使っ
て、Gnus はメッセージに電子署名したり暗号化することができます。そのよう
なメッセージのデコードに関しては、@code{mm-verify-option} オプションおよ
び @code{mm-decrypt-option} オプション (@pxref{Security}) を参照して下さ
い。

@vindex gnus-message-replysign
@vindex gnus-message-replyencrypt
@vindex gnus-message-replysignencrypted
署名したメッセージを送ってきた人たちに、署名した返信を返したいことはしば
しばあります。さらに暗号化されたメッセージへの返信を暗号化したいことは、
もっとたびたびあるかもしれません。Gnus は前者のため
に @code{gnus-message-replysign} の機能を、後者のため
に @code{gnus-message-replyencrypt} の機能を提供します。さら
に @code{gnus-message-replysignencrypted} を設定することによって (ディフォ
ルトで on になっています)、暗号化したメッセージに自動的に署名もします。

@acronym{MIME} パートに対してセキュリティーの操作を行なうため
の @acronym{MML} への指示は、以下のように署名の場合は @kbd{C-c C-m s} キー
マップを使って、暗号化の場合は @kbd{C-c C-m c} キーマップを使って行ない
ます。

@table @kbd
@item C-c C-m s s
@kindex C-c C-m s s (Message)
@findex mml-secure-message-sign-smime

@acronym{S/MIME} を使って現在のメッセージに電子署名します。

@item C-c C-m s o
@kindex C-c C-m s o (Message)
@findex mml-secure-message-sign-pgp

@acronym{PGP} を使って現在のメッセージに電子署名します。

@item C-c C-m s p
@kindex C-c C-m s p (Message)
@findex mml-secure-message-sign-pgp

@acronym{PGP/MIME} を使って現在のメッセージに電子署名します。

@item C-c C-m c s
@kindex C-c C-m c s (Message)
@findex mml-secure-message-encrypt-smime

@acronym{S/MIME} を使って現在のメッセージを電子暗号化します。

@item C-c C-m c o
@kindex C-c C-m c o (Message)
@findex mml-secure-message-encrypt-pgp

@acronym{PGP} を使って現在のメッセージを電子暗号化します。

@item C-c C-m c p
@kindex C-c C-m c p (Message)
@findex mml-secure-message-encrypt-pgpmime

@acronym{PGP/MIME} を使って現在のメッセージを電子暗号化します。

@item C-c C-m C-n
@kindex C-c C-m C-n (Message)
@findex mml-unsecure-message
メッセージから、セキュリティー関連の @acronym{MML} タグを外します。
@end table

もっと詳しいことは @xref{Security, ,セキュリティー, message-ja, The
Message Manual}, を参照して下さい。

@node Select Methods
@chapter 選択方法
@cindex foreign groups
@cindex select methods

@dfn{外部グループ} (foreign group) とは、普通 (もしくはディフォルト) の
方法で読まれないグループのことです。例えばそれは別の @acronym{NNTP} サー
バーのグループであったり、仮想グループであったり、個人的なメールグループ
であったりするでしょう。

外部グループ (あるいは実際にどんなグループで
も) は @dfn{名前} と @dfn{選択方法} で指定されます。先に後者を例に出すと、
選択方法はリストで、最初の要素がどのバックエンドを使うか (例え
ば @code{nntp}, @code{nnspool}, @code{nnml}) を、二つめの要素
が @dfn{サーバー名} を表します。選択方法には、その当のバックエンドにとっ
て特別の意味を持つ値である追加の要素があるかもしれません。

選択方法とは @dfn{仮想サーバー} を定義することだ、と言うことができま
す---ですから私たちはまさにそれをしました (@pxref{Server Buffer})。

グループの @dfn{名前} は、バックエンドがそのグループを認識する名前です。

例えば @samp{some.where.edu} という @acronym{NNTP} サーバーにあ
る @samp{soc.motss} グループは、名前 @samp{soc.motss} と選択方
法 @code{(nntp "some.where.edu")} を持ちます。@code{nntp} バックエンドは
このグループを @samp{soc.motss} として知っているだけですが、Gnus はこの
グループを @samp{nntp+some.where.edu:soc.motss} と呼びます。

もちろん、違った方法はすべてそれ特有の要素を持っています。

@menu
* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* IMAP::                        Gnus を @acronym{IMAP} のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケットを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む
@end menu

@node Server Buffer
@section サーバーバッファー

伝統的に、@dfn{サーバー} は誰かがそれに接続して、それからの情報を要求す
るマシンかソフトウェアの断片です。Gnus は実際のどんなサーバーにも直接に
は接続せず、バックエンドまたは他のものを通してすべての処理を行ないます。
しかしそれはまさしく実際の媒体と Gnus の間に一つ以上の階層を置くことであっ
て、ちょうどそれぞれのバックエンドが疑似的なサーバーに相当すると言っても
良いでしょう。

例えば @code{nntp} バックエンドは、複数の別々に実在す
る @acronym{NNTP} サーバー、あるいは実在する同じ @acronym{NNTP} サーバー
の異なるポートに接続するために用いられます。あなたはどのバックエンドを使
うか、そしてどんなパラメーターを設定するかを選択方
法 (@dfn{select method}) に設定して Gnus に指示します。

選択方法の指定は、ときに極めて面倒なものになります---えーと、例え
ば @samp{news.funet.fi} という @acronym{NNTP} サーバーのポート 13 を読み
たいのだけれど、@acronym{NOV} ヘッダーを取り寄せようとすると固まってしま
うし、間違った記事を選択してしまうような場合です。うおっほん。とにかくこ
のサーバーを使うそれぞれのグループについてそういうことを設定しなければな
らないとしたら、大変な作業になってしまうでしょう。そこで Gnus は、そうい
う作業をサーバーバッファーで行なうために、選択方法に名前を付ける手段を設
けているのです。

サーバーバッファーに入るためには、グループバッファー
で @kbd{^} (@code{gnus-group-enter-server-mode}) コマンドを使って下さい。

@menu
* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない
@end menu

@vindex gnus-server-mode-hook
サーバーバッファーを作成するときに @code{gnus-server-mode-hook} が実行さ
れます。

@node Server Buffer Format
@subsection サーバーバッファーの表示様式
@cindex server buffer format

@vindex gnus-server-line-format
サーバーバッファーの行の外見を、変数 @code{gnus-server-line-format} 変数
を変更することによって変えることができます。これは @code{format} のよう
な変数で、少しばかり単純な拡張がなされています:

@table @samp
@item h
どのようにニュースが取得されるか---バックエンドの名前。

@item n
サーバーの名前。

@item w
どこからニュースが取得されるか---アドレス。

@item s
サーバーの接続の 開いた/閉じた/拒否された 状態。

@item a
そのサーバーがエージェント化されているかどうか。
@end table

@vindex gnus-server-mode-line-format
モード行も変数 @code{gnus-server-mode-line-format} を使うことによってカ
スタマイズすることができます (@pxref{Mode Line Formatting})。

[訳注: 現在この変数は使われていません。]

以下の仕様が理解されます:

@table @samp
@item S
サーバー名。

@item M
サーバーの選択方法。
@end table

@ref{Formatting Variables} も参照して下さい。

@node Server Commands
@subsection サーバー命令
@cindex server commands

@table @kbd
@item a
@kindex a (サーバー)
@findex gnus-server-add-server
新しいサーバーを追加します (@code{gnus-server-add-server})。

@item e
@kindex e (サーバー)
@findex gnus-server-edit-server
サーバーを編集します (@code{gnus-server-edit-server})。

@item SPACE
@kindex SPACE (サーバー)
@findex gnus-server-read-server
現在のサーバーを眺めます (@code{gnus-server-read-server})。

訳注: 実際には @code{gnus-server-read-server-in-server-buffer} 命令を呼
びますが、@code{gnus-server-browse-in-group-buffer} の値がディフォルト
の @code{nil} であれば @code{gnus-server-read-server} と同じです。
@code{gnus-server-browse-in-group-buffer} を @code{nil} 以外の値にするこ
とはまったくお勧めできませんが、あなたが何をするのも自由です。詳細はソー
スコードを読むか、実際に試して痛い目に会って下さい。;-p

@item q
@kindex q (サーバー)
@findex gnus-server-exit
グループバッファーに戻ります (@code{gnus-server-exit})。

@item k
@kindex k (サーバー)
@findex gnus-server-kill-server
現在のサーバーを切り取ります (kill します)
(@code{gnus-server-kill-server})。

@item y
@kindex y (サーバー)
@findex gnus-server-yank-server
先ほど切られた (killed) サーバーを貼り付けます (yank します)
(@code{gnus-server-yank-server})。

@item c
@kindex c (サーバー)
@findex gnus-server-copy-server
現在のサーバーを複写します (@code{gnus-server-copy-server})。

@item l
@kindex l (サーバー)
@findex gnus-server-list-servers
すべてのサーバーの一覧を表示します (@code{gnus-server-list-servers})。

@item s
@kindex s (サーバー)
@findex gnus-server-scan-server
サーバーにそのソースから新しい記事を調べるように要求しま
す (@code{gnus-server-scan-server})。主にメールサーバーが意味のある動作
をします。

@item g
@kindex g (サーバー)
@findex gnus-server-regenerate-server
サーバーにすべてのデータ構造を再作成させま
す (@code{gnus-server-regenerate-server})。これは同期が外れてしまったメー
ルバックエンドがあるときに役に立ちます。
@end table

@node Example Methods
@subsection 方法の例

ほとんどの選択方法は、説明する必要が無いくらいにかなり単純です:

@lisp
(nntp "news.funet.fi")
@end lisp

直接スプールから読むのはもっと単純です:

@lisp
(nnspool "")
@end lisp

見ての通り、選択方法の最初の要素はバックエンドの名前で、二番目
は @dfn{アドレス} (address)、もしくはそう呼びたいのであれ
ば @dfn{名前} です。

これらの二つの要素の後には、任意の数
の @code{(@var{変数} @var{様式})} の対を置くことができます。

最初の例に戻りましょう---そのマシンのポート 15 から読みたいのだと思って
下さい。これがその時に、そうなるはずの選択方法です:

@lisp
(nntp "news.funet.fi" (nntp-port-number 15))
@end lisp

どの変数が関連するかを見つけ出すために、それぞれのバックエンドの説明文書
を読むべきでしょうが、これは @code{nnmh} の例です。

@code{nnmh} はスプールのような構造を読むためのメールバックエンドです。例
えばアクセスしたい二つの構造があるとしましょう: 一つはあなたの私的なメー
ルスプールで、他方は公的なものです。これは私的なメールのために使うことが
できる指定です:

@lisp
(nnmh "private" (nnmh-directory "~/private/mail/"))
@end lisp

(それでこのサーバーは @samp{private} と呼ばれますが、あなたはすでに推測
していたかもしれませんね。)

これは公的なスプールのための方法です:

@lisp
(nnmh "public"
      (nnmh-directory "/usr/information/spool/")
      (nnmh-get-new-mail nil))
@end lisp

@cindex proxy
@cindex firewall
あなたが防壁 (firewall) の中にいて、防壁マシンを通して @acronym{NNTP} サー
バーに接続するしかないのであれば、防壁マシンに @code{rlogin} して、そこ
から @acronym{NNTP} サーバーに telnet をするように Gnus に指示することが
できます。こんなことをするのはいささかばかげているのですが、でも仮想サー
バーの定義はおそらくこのようなものになるはずです:

@lisp
(nntp "firewall"
      (nntp-open-connection-function nntp-open-via-rlogin-and-telnet)
      (nntp-via-address "the.firewall.machine")
      (nntp-address "the.real.nntp.host")
      (nntp-end-of-line "\n"))
@end lisp

あの素敵な @code{ssh} プログラムを、モデムを経由する通信を圧縮するために
使いたいのならば、上記の例に以下の設定を加えることができます。

@lisp
      (nntp-via-rlogin-command "ssh")
@end lisp

@code{nntp-via-rlogin-command-switches} も参照して下さい。

防壁の中にいたとしても "runsocks" のようなラッパーコマンドを通して外の世
界に直接アクセスできるのならば、以下のように socks 化された telnet でニュー
スサーバーに接続することができるでしょう:

@lisp
(nntp "outside"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-via-telnet)
      (nntp-address "the.news.server")
      (nntp-end-of-line "\n"))
@end lisp

もちろん、自動認証を行なわせるためには @code{ssh-agent} を適切に設定しな
ければなりません。加えて、通信内容を圧縮するために
は、@code{ssh} の @file{config} ファイルに @samp{Compression} オプション
が存在しなければなりません。

@node Creating a Virtual Server
@subsection 仮想サーバーを作成する

永続記事を使ってたくさんの記事をキャッシュに保存しているのであれば、キャッ
シュを読むための仮想サーバーを作る必要があるでしょう。

最初に新しいサーバーを追加する必要があります。それをするのは @kbd{a} 命
令です。おそらくキャッシュを読むためには @code{nnml} を使うのが一番良い
でしょう。@code{nnspool} や @code{nnmh} も使えるでしょうれけど。

@kbd{a nnml RET cache RET} とタイプして下さい。

今やあなたは真新しい @samp{cache} という @code{nnml} の仮想サーバーを手
に入れたはずです。次はそれを編集して、正しい定義を与えましょう。サーバー
を編集するには @kbd{e} をタイプして下さい。あなたは以下のものを含むバッ
ファーに入ります:

@lisp
(nnml "cache")
@end lisp

それを次のように変更して下さい:

@lisp
(nnml "cache"
      (nnml-directory "~/News/cache/")
      (nnml-active-file "~/News/cache/active"))
@end lisp

サーバーバッファーに戻るには @kbd{C-c C-c} をタイプして下さい。今ではこ
の仮想サーバーで @kbd{RET} を押すと、閲覧バッファーに入って、表示されて
いるどのグループにでも入ることができるはずです。

@node Server Variables
@subsection サーバー変数
@cindex server variables
@cindex server parameters

変数を (バックエンドと Emacs 一般の両方で) 定義する際の一つのやっかいな
点は、いくつかの変数は、概してその変数の定義がロードされるときに他の変数
で初期化されることです。「基」になる変数がロードされた後でそれを変更して
も、「派生」した変数は変更されません。

これは一般にディレクトリーやファイルの変数に影響します。例え
ば @code{nnml-directory} はディフォルトでは @file{~/Mail/} で、また、す
べての @code{nnml} ディレクトリー変数はその変数によって初期化されるので、
@code{nnml-active-file} は @file{~/Mail/active} になります。新し
い @code{nnml} 仮想サーバーを定義する場合、@code{nnml-directory} を設定
するだけでは十分では @emph{ありません}---あなたはすべてのファイル変数を、
そうしたいと望んだ値に明示的に設定しなければなりません。それぞれのバック
エンドのための完全な変数のリストを見るには、このマニュアルの後に続くそれ
ぞれのバックエンドの部分を読んで下さい。でも @code{nnml} の定義の例はこ
こにあります:

@lisp
(nnml "public"
      (nnml-directory "~/my-mail/")
      (nnml-active-file "~/my-mail/active")
      (nnml-newsgroups-file "~/my-mail/newsgroups"))
@end lisp

サーバー変数はしばしば @dfn{サーバーパラメーター} と呼ばれます。

@node Servers and Methods
@subsection サーバーと選択方法

普通に選択方法を使う (例えば外部サーバーから記事を読むときにグループを選
択する手段として @code{gnus-secondary-select-method} 使う) 場面ではどこ
でも、代わりに仮想サーバーの名前を使うことができます。これによって、たく
さんキーボードを叩かなくて済むかもしれません。そして、どんなときでもその
方が良いです。

@node Unavailable Servers
@subsection 使用不可能なサーバー

あるサーバーに接続することができないように見えるとき、Gnus はそのサーバー
に拒否された (@code{denied}) ことを記録します。その後でそのサーバーと接
続しようとするどんな試みも、単に無視されます。実際にそうかどうかを少しも
確かめずに、Gnus は「接続を開くことができません」と (英語で) 告げます。

それはずいぶんお行儀が悪いと思うかもしれませんが、たいていの場合は有意義
なのです。例えば @samp{nephelococcdyia.com} というサーバーで十個のグルー
プを購読しているとしましょう。サーバーはどこかとても遠いところにあって、
そのマシンはとても遅いので、今日それが接続を拒否するかどうかを調べるだけ
でも一分かかります。もし Gnus がそれを十回試すようになっていたとすると、
とても煩わしいでしょう。ですから Gnus はそれを試そうとはしません。一度で
も「接続が拒否された」(connection refused) という結果を受け取ったなら、
それはサーバーが「落ちている」(down) のだ、とみなします。

では、一時的にそのマシンの機嫌が悪いだけだったら何が起こるのでしょう? マ
シンが復活したかどうかをどうすれば調べることができるのでしょう?

それには、サーバーバッファーに移動して (@pxref{Server Buffer})、以下の命
令で突いてみて下さい:

@table @kbd
@item O
@kindex O (サーバー)
@findex gnus-server-open-server
現在の行のサーバーとの接続を確立しようとしま
す (@code{gnus-server-open-server})。

@item C
@kindex C (サーバー)
@findex gnus-server-close-server
サーバーとの接続 (もしあれば) を閉じま
す (@code{gnus-server-close-server})。

@item D
@kindex D (サーバー)
@findex gnus-server-deny-server
現在のサーバーに接続不可の印を付けま
す (@code{gnus-server-open-all-server})。

@item M-o
@kindex M-o (サーバー)
@findex gnus-server-open-all-servers
バッファーにあるすべてのサーバーとの接続を開きま
す (@code{gnus-server-open-all-servers})。

@item M-c
@kindex M-c (サーバー)
@findex gnus-server-close-all-servers
バッファーにあるすべてのサーバーとの接続を閉じま
す (@code{gnus-server-close-all-servers})。

@item R
@kindex R (サーバー)
@findex gnus-server-remove-denials
Gnus が接続を拒否されたすべてのサーバーの、すべての印を消去し
ます (@code{gnus-server-remove-denials})。

@item L
@kindex L (サーバー)
@findex gnus-server-offline-server
サーバーの状態をオフラインにします (@code{gnus-server-offline-server})。
@end table

@node Getting News
@section ニュースの取得
@cindex reading news
@cindex news back ends

ニュースリーダーは普通はニュースを読むために使われます。Gnus は現在はニュー
スを取得するための二つの方法だけを提供しています---@acronym{NNTP} サーバー
から、またはローカルスプールから読むことができます。

@menu
* NNTP::                        @acronym{NNTP} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む
@end menu

@node NNTP
@subsection NNTP
@cindex nntp

@acronym{NNTP} サーバーから外部グループを購読するのは比較的簡単です。単
に選択方法として @code{nntp} を指定し、@acronym{NNTP} サーバーのアドレス
を、うーん、アドレスとして指定するだけです。

@acronym{NNTP} サーバーが標準ではないポート (port) に設置されているとき
は、選択方法の三番目の要素をこのポートの番号に設定すれば、正しいポートに
接続することができるでしょう。そのためにはグループ情報を編集しなければな
りません (@pxref{Foreign Groups})。

外部グループの名前は基本グループと同じでも構いません。実際、あなたの思う
ままに同じグループを可能な限りの違ったサーバーから購読することができます。
名前の衝突は起こりません。

以下の変数は仮想 @code{nntp} サーバーを作るために使われます:

@table @code
@item nntp-server-opened-hook
@vindex nntp-server-opened-hook
@cindex @sc{mode reader}
@cindex authinfo
@cindex authentification
@cindex nntp authentification
@findex nntp-send-authinfo
@findex nntp-send-mode-reader
は接続ができた後に実行されます。それは @acronym{NNTP} サーバーに接続した
後に、それに命令を送るために使うことができます。ディフォルトで
は @code{MODE READER} 命令が、@code{nntp-send-mode-reader} 関数によって
サーバーに送られるようになっています。この関数は常にこのフックにあるべき
です。

@item nntp-authinfo-function
@vindex nntp-authinfo-function
@findex nntp-send-authinfo
@vindex nntp-authinfo-file
この関数は @acronym{NNTP} サーバーに @samp{AUTHINFO} を送るために使われ
ます。ディフォルトの関数は @code{nntp-send-authinfo} で、適切な記載事項
を探すために @file{~/.authinfo} (もしくは @code{nntp-authinfo-file} 変数
に設定した何でも) を調べます。もし一つも見つからなかったら、ログイン名と
パスワードの入力を要求します。@file{~/.authinfo} ファイルの様式
は @code{ftp} のための @file{~/.netrc} ファイルと (ほとんど) 同じです。
それは @code{ftp} のマニュアルページで定義されていますが、ここに顕著な実
例があります:

@enumerate
@item
ファイルは一つ以上の行を含み、それぞれは一つのサーバーを定義します。

@item
それぞれの行は任意の数の標章 (token) と値の対を含むことができます。

有効な標章は @samp{machine}, @samp{login}, @samp{password},
@samp{default} です。加えて、Gnus は @file{.netrc}/@code{ftp} の構文の原
型には現れない二つの新しい標章、名付けて @samp{port} と @samp{force} を
導入します。(これが @file{.authinfo} ファイルの様式が @file{.netrc} ファ
イルの様式から逸脱する唯一の方法です。) @samp{port} はサーバーのどのポー
トを認証に用いるかを示し、@samp{force} は以下で説明します。
@end enumerate

これがそのファイルの例です:

@example
machine news.uio.no login larsi password geheimnis
machine nntp.ifi.uio.no login larsi force yes
@end example

標章と値の対はどんな順番ででも現れることができます。例え
ば @samp{machine} が最初でなければならない必要はありません。

この例では、前者のサーバーにログイン名とパスワードの両方が与えられている
のに対して、後者にはログイン名だけがあり、利用者はパスワードの入力を求め
られるでしょう。後者は @samp{force} タグも持っていて、これによって接続時
に @var{nntp} サーバーに認証情報 (authinfo) が送られます。ディフォル
ト (すなわち、@samp{force} タグが無いとき) では、@var{nntp} サーバーが認
証情報を尋ねない限りそれを @var{nntp} サーバーに送りません。

@samp{machine} 行に合致しないすべてのサーバーに適用され
る @samp{default} 行を追加することもできます。

@example
default force yes
@end example

これは、それ以前に書かれていないすべてのサーバーに @samp{AUTHINFO} 命令
を強制的に送ります。

@file{~/.authinfo} ファイルを世界中が読めるような設定のままで放置しない
ように注意して下さい。

@item nntp-server-action-alist
@vindex nntp-server-action-alist
これはサーバーの型に合致する正規表現と、合致が起こったときに取られる動作
の連想リストです。例えば、Gnus に innd に接続したときに毎回ビープ音を鳴
らしたいのであれば、次のようにすることができます:

@lisp
(setq nntp-server-action-list
      '(("innd" (ding))))
@end lisp

まぁ、そんなことをしたいとは思わないでしょうけれどね。

ディフォルトの値は

@lisp
'(("nntpd 1\\.5\\.11t"
   (remove-hook 'nntp-server-opened-hook
                'nntp-send-mode-reader)))
@end lisp

で、これは nntpd 1.5.11t には @code{MODE READER} 命令を確実に送らないよ
うにします。なぜなら、その命令はサーバーの息の根を止めると聞いているから
です。

@item nntp-maximum-request
@vindex nntp-maximum-request
もし @acronym{NNTP} サーバーが @acronym{NOV} ヘッダーをサポートしていな
いのであれば、このバックエンドは @code{head} 命令をいくつも送って、ヘッ
ダーを集めます。この動作を速くするために、バックエンドは返答を待たずにこ
の命令をたくさん送り、それからすべての返答を読みます。これは変
数 @code{nntp-maximum-request} によって制御され、ディフォルトで 400 です。
もしネットワークの具合が良くないようなら、この変数を 1 に設定するべきで
しょう。

@item nntp-connection-timeout
@vindex nntp-connection-timeout
定期的に接続している外部 @code{nntp} グループがたくさんあると、ちゃんと
応答しなかったり常識的な時間内に返答できないくらいの負荷がかかってい
る @acronym{NNTP} サーバーの問題があるはずです。これはやっかいな問題をも
たらしますが、@code{nntp-connection-timeout} を設定することによってある
程度解消することができます。これは接続を諦める前に、@code{nntp} バックエ
ンドが何秒待つかを示す整数です。もしこれが @code{nil} であると、それがディ
フォルトですが、時間切れによる切断は行ないません。

@item nntp-nov-is-evil
@vindex nntp-nov-is-evil
@acronym{NNTP} サーバーが @acronym{NOV} をサポートしていない場合は、この
変数を @code{t} に設定すれば良いでしょう。でも @code{nntp} は普通
は @acronym{NOV} が使えるかどうかを自動的に調べます。(訳注: ですから、わ
ざわざ設定しなくても構いません。)

@item nntp-xover-commands
@vindex nntp-xover-commands
@cindex @acronym{NOV}
@cindex XOVER
サーバーから @acronym{NOV} 行を取得するための命令として使われる文字列の
リストです。この変数のディフォルトの値は @code{("XOVER" "XOVERVIEW")} で
す。(訳注: それらを順に試します。)

@item nntp-nov-gap
@vindex nntp-nov-gap
@code{nntp} は、普通はサーバーに @acronym{NOV} 行のための一つの大きな要
求を送ります。サーバーは一つの巨大な行のリストで応答します。しかし、グルー
プの 2-5000 の記事を読んだ後で 1 と 5001 を読みたいだけだとしても、
@code{nntp} は必要の無い 4999 個の @acronym{NOV} 行を取得することになり
ます。この変数は、どれくらい大きな二つの連続した記事群の間の隔た
り (gap) まで @code{XOVER} の要求を分割せずに送るかを決定します。ネット
ワークが速い場合に、この変数を本当に小さな数値に設定してしまうと、おそら
く取得が遅くなることに注意して下さい。この変数が @code{nil} ならば、
@code{nntp} は要求を分割しません。ディフォルトは 5 です。

@item nntp-prepare-server-hook
@vindex nntp-prepare-server-hook
@acronym{NNTP} サーバーに接続を試みる前に実行するフックです。

@item nntp-record-commands
@vindex nntp-record-commands
これを @code{nil} でない値にすると、@code{nntp} は @acronym{NNTP} サーバー
に送ったすべての命令を (時刻と共に) @samp{*nntp-log*} バッファーに記録し
ます。これは動作していないように見える Gnus の @acronym{NNTP} 接続をデバッ
グしているときに役に立ちます。

@item nntp-open-connection-function
@vindex nntp-open-connection-function
どのように @acronym{NNTP} サーバーと接続するかをカスタマイズすることがで
きます。@code{nntp-open-connection-function} パラメーターを設定しておく
と、Gnus は接続を確立するためにその関数を使います。そのために七つの関数
があらかじめ用意されています。それらは二種類に分類することができ、直接接
続するための関数群 (四つ) と間接的に接続するためのもの (三つ) があります。

@item nntp-prepare-post-hook
@vindex nntp-prepare-post-hook
記事を投稿する直前に実行されるフックです。もし記事
に @code{Message-ID} ヘッダーが無くてニュースサーバーが推奨 ID を提供し
てくれるならば、このフックが実行される前にそれが記事に加えられます。これ
は、もしあなたが Gnus が @code{Message-ID} ヘッダーを付けないようにして
いても、@code{Cancel-Lock} ヘッダーを作るために利用することができます。
それにはこうすれば良いでしょう:

@lisp
(add-hook 'nntp-prepare-post-hook 'canlock-insert-header)
@end lisp

すべてのサーバーが推奨 ID をサポートしているわけではないことに注意して下
さい。これは例えば INN 2.3.0 以上で動作します。
@end table

@menu
* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
* NNTP marks::                  @acronym{NNTP} サーバー用の印の保存
@end menu

@node Direct Functions
@subsubsection 直接接続するための関数
@cindex direct connection functions

これらの関数は、あなたのマシンと @acronym{NNTP} サーバーを接続するために
直接呼ばれます。また、それらの動作はそれらが共通に参照する変数に影響され
ます (@pxref{Common Variables})。

@table @code
@findex nntp-open-network-stream
@item nntp-open-network-stream
これはディフォルトで、単純に遠隔システムのポートなどに接続します。

@findex nntp-open-tls-stream
@item nntp-open-tls-stream
@dfn{安全な} チャンネルを使ってサーバーに接続します。これを使うために
は @uref{http://www.gnu.org/software/gnutls/, GNUTLS} をインストールして
おかなければなりません。それからサーバーを次のように定義します:

@lisp
;; @r{ポート 563 が "nntps" として @file{/etc/services} で定義済み}
;; @r{であっても、@samp{gnutls-cli -p} でその名前は使えません。}
;;
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open-tls-stream)
      (nntp-port-number )
      (nntp-address "snews.bar.com"))
@end lisp

@findex nntp-open-ssl-stream
@item nntp-open-ssl-stream
@dfn{安全な} チャンネルを使ってサーバーに接続します。これを使うために
は @uref{http://www.openssl.org, OpenSSL} また
は @uref{ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL, SSLeay} をインストールし
ておかなければなりません。それからサーバーを次のように定義します:

@lisp
;; @r{ポート 563 が "snews" として @file{/etc/services} で定義済みで}
;; @r{あっても、@samp{openssl s_client -port} でその名前は使えません。}
;;
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open-ssl-stream)
      (nntp-port-number 563)
      (nntp-address "snews.bar.com"))
@end lisp

@findex nntp-open-telnet-stream
@item nntp-open-telnet-stream
単に @samp{telnet} して @acronym{NNTP} サーバーに接続します。ディフォル
トの @code{nntp-open-network-stream} がそれをするのにもかかわらず、なぜ
この関数があるのか不思議に思うかもしれません。その理由 (の一つ) は、もし
あなたが防壁の中にいたとしても @code{runsocks} のようなコマンドラッパー
のおかげで外の世界を直接アクセスできるならば、それをこのように使うことが
できるのです:

@lisp
(nntp "socksified"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-telnet-stream)
      (nntp-address "the.news.server"))
@end lisp

Emacs のセッション全体をラップして、ディフォルトのメソッドを使うというの
は、良い考えではありません。
@end table

@node Indirect Functions
@subsubsection 間接的に接続するための関数
@cindex indirect connection functions

これらの関数は、実際に @acronym{NNTP} サーバーに接続する前に中間のホスト
に接続するために間接的に呼ばれます。すべてのこれらの関数と関連する変数
は ``via'' 接続の仲間に属しているとも言えるので、それを明確にするために
すべて ``via'' という接頭語が付けられます。また、それらの動作はそれらが
共通に参照する変数に影響されます (@pxref{Common Variables})。

@table @code
@item nntp-open-via-rlogin-and-telnet
@findex nntp-open-via-rlogin-and-telnet
遠隔システムに @samp{rlogin} して、そこから本当
の @acronym{NNTP} サーバーに @samp{telnet} します。これは、例えばあなた
が始めに防壁マシンに接続しなければならない場合に便利です。

@code{nntp-open-via-rlogin-and-telnet}-用の変数:

@table @code
@item nntp-via-rlogin-command
@vindex nntp-via-rlogin-command
中間のホストにログインするために使われるコマンドです。ディフォルト
は @samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-via-rlogin-command-switches
@vindex nntp-via-rlogin-command-switches
@code{nntp-via-rlogin-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @code{nil} です。も
し @samp{ssh} を @code{nntp-via-rlogin-command} の値として使うならば、デー
タ接続を圧縮するために @samp{("-C")} を使うことができます。あるいは、も
し中間のホストで telnet コマンドが疑似端末を必要とするならば、これ
を @samp{("-t" "-e" "none")} または @samp{("-C" "-t" "-e" "none")} にし
て下さい。
@end table

@code{nntp-end-of-line} の値を @samp{\n} に変更する必要があるであろうこ
とに注意して下さい (@pxref{Common Variables})。

@item nntp-open-via-rlogin-and-netcat
@findex nntp-open-via-rlogin-and-netcat
本質的には同じことなのですが、中間のホストから本当の @acronym{NNTP} サー
バーに接続するために、@samp{telnet} の代わり
に @uref{http://netcat.sourceforge.net/, netcat} を使います。

@code{nntp-open-via-rlogin-and-netcat}-用の変数:

@table @code
@item nntp-via-netcat-command
@vindex nntp-via-netcat-command
中間のホストから本当の @acronym{NNTP} サーバーに接続するために使われるコ
マンドです。ディフォルトは @samp{nc} です。代わり
に @uref{http://www.imasy.or.jp/~gotoh/ssh/connect.html, connect} のよう
な、他のコマンドを使うこともできます。

@item nntp-via-netcat-switches
@vindex nntp-via-netcat-switches
@code{nntp-via-netcat-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @code{nil} です。

@item nntp-via-rlogin-command
@vindex nntp-via-rlogin-command
中間のホストにログインするために使われるコマンドです。ディフォルト
は @samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-via-rlogin-command-switches
@vindex nntp-via-rlogin-command-switches
@code{nntp-via-rlogin-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @code{nil} です。
@end table

@item nntp-open-via-telnet-and-telnet
@findex nntp-open-via-telnet-and-telnet
これも本質的には同じことなのですが、中間のホストに接続するため
に @samp{rlogin} の代わりに @samp{telnet} を使います。

@code{nntp-open-via-telnet-and-telnet}-用の変数:

@table @code
@item nntp-via-telnet-command
@vindex nntp-via-telnet-command
中間のホストに @code{telnet} するために使われるコマンドです。ディフォル
トは @samp{telnet} です。

@item nntp-via-telnet-switches
@vindex nntp-via-telnet-switches
@code{nntp-via-telnet-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @samp{("-8")} です。

@item nntp-via-user-password
@vindex nntp-via-user-password
中間のホストにログインするときに使われるパスワードです。

@item nntp-via-envuser
@vindex nntp-via-envuser
もし非-@code{nil} なら、中間の @code{telnet} のセッション (クライアント
とサーバーの両方) で @code{ENVIRON} オプションをサポートし、ログイン名の
入力を要求しません。これは例えば Solaris の @code{telnet} で動作します。

@item nntp-via-shell-prompt
@vindex nntp-via-shell-prompt
中間のホストでのシェルのプロンプトに合致する正規表現です。ディフォルト
は @samp{bash\\|\$ *\r?$\\|> *\r?} です。
@end table

@code{nntp-end-of-line} の値を @samp{\n} に変更する必要があるであろうこ
とに注意して下さい (@pxref{Common Variables})。
@end table

これらは上記のすべての関数が参照する付加的な変数です:

@table @code
@item nntp-via-user-name
@vindex nntp-via-user-name
中間のホストに接続するときに使う利用者名です。

@item nntp-via-address
@vindex nntp-via-address
接続する中間のホストのアドレスです。
@end table

@node Common Variables
@subsubsection 共通の変数

以下の変数は、すべての、またはいくつかのあらかじめ用意されている関数の動
作に影響を及ぼします。設定されていなければ、すべての関数が影響されま
す (それぞれの仮想サーバーにおいて、サーバー変数として個々に値が設定され
ていない場合に、以下の値がディフォルトで使われます)。

@table @code
@item nntp-pre-command
@vindex nntp-pre-command
素の接続用の関数ではないも
の (@code{nntp-open-network-stream}、@code{nntp-open-tls-stream} また
は @code{nntp-open-ssl-stream} 以外のすべて) を通して接続するときに使う
コマンドラッパーです。例えばあなたは @samp{SOCKS} ラッパーを割り当てるで
しょう。(訳注: @code{telnet} などの外部コマンドに被せて使われます。)

@item nntp-address
@vindex nntp-address
@acronym{NNTP} サーバーのアドレスです。

@item nntp-port-number
@vindex nntp-port-number
接続する @acronym{NNTP} サーバーのポート番号です。ディフォルト
は @samp{nntp} です。@acronym{TLS}/@acronym{SSL} を介し
た @acronym{NNTP} を使うには、ポートの名前ではなくて整数 (つま
り @samp{snews} や @samp{nntps} ではなくて @samp{563}) を指定する必要が
あります。外部の @acronym{TLS}/@acronym{SSL} ツールはポートの名前では動
作しないからです。

@item nntp-end-of-line
@vindex nntp-end-of-line
@acronym{NNTP} サーバーとお話をしているときに行の終わりの印として使われ
る文字列です。これはディフォルトで @samp{\r\n} ですが、素ではない接続用
の telnet 同等の関数を使っているときは @samp{\n} であるべきです。

@item nntp-telnet-command
@vindex nntp-telnet-command
@samp{telnet} を通して @acronym{NNTP} サーバーと接続するときに使うコマン
ドです。これは中間のホストと接続するためのものでは @emph{ありません}。こ
れはまさに本当の @acronym{NNTP} サーバーと接続するためのものです。ディフォ
ルトは @samp{telnet} です。

@item nntp-telnet-switches
@vindex nntp-telnet-switches
@code{nntp-telnet-command} に渡すスイッチのリストです。ディフォルト
は @samp{("-8")} です。
@end table

@node NNTP marks
@subsubsection NNTP marks
@cindex storing NNTP marks

Gnus は @acronym{NNTP} サーバーのための記事の印 (marks) (@pxref{Marking
Articles}) を印ファイルに保存します。印ファイルはあるグループで設定した
印を記録し、それぞれのファイルは、対応するサーバーに対して専用です。印ファ
イルは、ニュースサーバーに似ている古典的な階層
で @file{~/News/marks} (@code{nntp-marks-directory}) に保存されます。例
えば news.gmane.org サーバーにおける @samp{gmane.discuss} グループのため
の印ファイル
は @file{~/News/marks/news.gmane.org/gmane/discuss/.marks} に保存されま
す。

印ファイルは役に立ちます。@file{~/News/marks} ディレクトリーは (rsync、
scp または他の何かを使って) Gnus を走らせる別のホストにコピーすることが
でき、どの記事を読んで印を付けたかをそちらで再現します。
@file{~/News/marks} のデータは、@file{~/.newsrc.eld} にある同じものより
も優先されます。

印ファイルは、それぞれのサーバーでそれ専用に非常に特化されることに注意し
て下さい。Gnus は記事番号を記憶するので、両方のホストで同じサーバーを使っ
ていないと、ものごとは壊れてしまうでしょう (大抵の @acronym{NNTP} サーバー
は他のどんなサーバーとも同じ記事番号を使いません)。しかし、あるホストで
サーバー A、B、C を使い、別のホストでサーバー A、D、E を使う場合には、
A のための印ファイルを同じにすることができるので、二つのホスト間でそのサー
バーは同期するでしょう。

@acronym{NNTP} 印の使用は性能の劣化を招き、Gnus をのろく感じさせる可能性
があります。そういう場合は @code{nntp-marks-is-evil} 変数を @code{t} に
設定してみて下さい。すると、印は @file{~/.newsrc.eld} (だけ) に格納され
るようになるでしょう。

関連する変数:

@table @code
@item nntp-marks-is-evil
@vindex nntp-marks-is-evil
非-@code{nil} だったら、このバックエンドは印ファイルを無視します。ディフォ
ルトは @code{nil} です。

@item nntp-marks-directory
@vindex nntp-marks-directory
@acronym{NNTP} グループの印が格納されるディレクトリーです。
@end table

@node News Spool
@subsection ニューススプール
@cindex nnspool
@cindex news spool

ローカルスプールから外部グループを購読することは極めて簡単だし便利かもし
れません。たとえば、非常に大きな記事があるグループ---例え
ば @samp{alt.binaries.pictures.furniture} を読む速度が速くなります。

とにかく、@code{nnspool} を選択方法として、かつ @code{""} (もしくは何で
も) をアドレスとして指定するだけです。

もしローカルスプールにつなぐことが可能なら、おそらくそれを基本選択方法と
して使うべきでしょう (@pxref{Finding the News})。それは普通
は @code{nntp} 選択方法を使うより速いですが、そうでないかもしれません。
それは場合によります。何があなたのサイトで一番良いかを見つけるために、い
ろいろと試してみなければなりません。

@table @code
@item nnspool-inews-program
@vindex nnspool-inews-program
記事を投稿するために使われるプログラムです。

@item nnspool-inews-switches
@vindex nnspool-inews-switches
記事を投稿するときに inews プログラムに与えられるパラメーターです。

@item nnspool-spool-directory
@vindex nnspool-spool-directory
@code{nnspool} が記事を探すところです。これは普通
は @file{/usr/spool/news/} です。

@item nnspool-nov-directory
@vindex nnspool-nov-directory
@code{nnspool} が @acronym{NOV} ファイルを探すところです。これは普通
は @file{/usr/spool/news/over.view/} です。

@item nnspool-lib-dir
@vindex nnspool-lib-dir
ニュースのライブラリーが置かれているディレクトリーの場所です (ディフォル
トで @file{/usr/lib/news/} です)。

@item nnspool-active-file
@vindex nnspool-active-file
アクティブファイルの絶対パス名です。

@item nnspool-newsgroups-file
@vindex nnspool-newsgroups-file
@file{newsgroups} ファイルの絶対パス名です。

@item nnspool-history-file
@vindex nnspool-history-file
@file{history} ファイルの絶対パス名です。

@item nnspool-active-times-file
@vindex nnspool-active-times-file
@file{active.times} ファイルの絶対パス名です。

@item nnspool-nov-is-evil
@vindex nnspool-nov-is-evil
@code{nil} でないと、@code{nnspool} はそれが見つけたどん
な @acronym{NOV} ファイルも使おうとはしません。

@item nnspool-sift-nov-with-sed
@vindex nnspool-sift-nov-with-sed
@cindex sed
@code{nil} でないと、これがディフォルトですが、概観ファイル (overview)
から関連する部分を得るために @code{sed} を使います。もし @code{nil} だと、
@code{nnspool} はファイル全体をバッファーに読み込んで、そこで実行します。
@end table

@node Getting Mail
@section メール取得
@cindex reading mail
@cindex mail

ニュースリーダーでメールを読むなんて実に奇妙ですよね?  いや、もちろんで
きるのですが。

@menu
* Mail in a Newsreader::        ニュースリーダでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだつような分割をすることができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる
@end menu

@node Mail in a Newsreader
@subsection ニュースリーダでメール

使い慣れた伝統的なメールリーダから Gnus に乗り換えることを決断したならば、
かなりのカルチャーショックを経験することになるでしょう。

Gnus は伝統的なメールリーダのようなふるまいをしません。あなたが望むな
らそのようにもできますが、それは骨折り損のくたびれ儲けです。

Gnus はふつう同じ手法ですべてのグループを扱います。あるグループを選んで
新しい/未読のメッセージを読むと、読んだ記事には既読の印が付けられ、(意図
的に要求しなければ) 以後はそれらを目にすることはありません。これってとて
もニュースリーダ的でしょ。

あなたは記事を消すために特別な操作はしません。

このことは既読の記事はすべて消されてしまうことを意味するのかって? そりゃ
あんまりですよね!

そうではありません。古い記事はいろんな仕組みによって @dfn{expire} され
るのです。ニュース記事はニュースの管理人 (が管理しているサーバー) によっ
て expire の処理が制御され、メールの expire の処理はあなたが制御します。
メールの expire については @ref{Expiring Mail} を参照して下さい。

しばらくメールとニュースの両方を使ってみれば、記事の取り扱いについて配
送の機構が行なうことはわずかであることに気が付きます。

多くの人たちは複数のメーリングリストを講読しています。それら
は @acronym{SMTP} で配送される、メール、です。それらの記事をとても注意深
く読んでいるにもかかわらず、何週間も返事が無いことがあるでしょう。私たち
はそういう記事をセーブする必要はありません。なぜならば、もう一度読む必要
が生じても、それらはどこかに保存されているからです。

ある人たちは小人数に利用されているローカルニュースグループを講読していま
す。それらは @acronym{NNTP} で配送される、ニュース、です。私たちは自分の
仕事に役立てるために、それらの膨大な記事の断片を読んだり返事をしなければ
なりません。そしてそれらは保存されていないかもしれませんから、興味のある
記事を個人メールと同じように保存しなければならないでしょう。

配送の仕組みの違いはどうでもよいことで、大事なのはいかに主題に興味を持っ
ているかと、もう一度読みたいときにいかに簡単に呼び出せるかなのです。

Gnus はメールをニュースグループのように ``グループ'' に並べ変えて、各々
のグループ (メールかニュース) を別個に扱うための豊富な機能を提供します。

ある人たちは Gnus (えっへん) のやりかたに満足できなくて、Gnus がメール
リーダになることを欲します。Gnus をもっとメールリーダ的なものにするた
めに鞭打つことは可能ではあるのですが、前にも言ったように簡単ではありま
せん。いわゆるメールリーダが好みならば @sc{vm} を使いましょう。これは
優秀な、厳密な意味でのメールリーダです。

脅かすわけではないのですが、はっきりさせておきたいのは、あなたに記事に
ついての新しいやり方を修得して欲しいということです。あなたが Gnus のや
り方を受け入れてくれた暁には、きっとあなたは Gnus が好きになること請け
合いです。

(少くとも、私が Gnus に入れた、Emacs のサブリミナル脳味噌洗濯関数を売っ
てくれた人はそれを保証しています。あなたも同化します。あなたは Gnus を愛
します。あなたは Gnus でのメールの方法を愛します。絶対に。)

@node Getting Started Reading Mail
@subsection メールを読むことを始める

Gnus を使って新しいメールを読むことは非常に簡単です。あなたのメールバッ
クエンドのあなたの選択を @code{gnus-secondary-select-methods} に放り込む
だけで、あとのことは自動的に起こります。

例えば、@code{nnml} (これは ``一メール一ファイル'' バックエンドです) を
使いたいなら、次のものをあなたの @file{~/.gnus.el} ファイルに入れること
ができます。

@lisp
(setq gnus-secondary-select-methods '((nnml "")))
@end lisp

今や、次に Gnus を起動したときには、このバックエンドは新しい記事を求め、
それはあなたのスプールファイルからすべてのメッセージをディレクトリー、ディ
フォルトでは @file{~/Mail/} に移動します。作成された新しいグルー
プ (@samp{mail.misc}) が購読され、他のグループと同じように読むことができ
ます。

あなたはおそらくメールをいくつかのグループに分割したいでしょうけど:

@lisp
(setq nnmail-split-methods
      '(("junk" "^From:.*Lars Ingebrigtsen")
        ("crazy" "^Subject:.*die\\^Organization:.*flabby")
        ("other" "")))
@end lisp

これは結果として三つの新しい @code{nnml} メールグループを作りま
す: @samp{nnml:junk}, @samp{nnml:crazy}, @samp{nnml:other} です。最初
の二つのグループに合わないメールはすべて最後のグループに入れられます。

これは Gnus でメールを読むために充分であるはずです。マニュアルのこの部分
の他の項を熟読する必要があるかもしれませんが。特
に @ref{Choosing a Mail Back End} と @ref{Expiring Mail} を。

@node Splitting Mail
@subsection メールの分割
@cindex splitting mail
@cindex mail splitting
@cindex mail filtering (splitting)

@vindex nnmail-split-methods
変数 @code{nnmail-split-methods} は入ってくるメールをどのようにグループ
分けするかを指定します。

@lisp
(setq nnmail-split-methods
  '(("mail.junk" "^From:.*Lars Ingebrigtsen")
    ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
    ("mail.other" "")))
@end lisp

この変数はリストのリストで、これらのリストの最初のそれぞれの要素がメール
グループの名前で (ところで、それらは @samp{mail} で始まる必要はありませ
ん)、二つめの要素がそれぞれのメールのヘッダーからそれがどのグループに属
するかを決定する正規表現です。最初の文字列は、@code{replace-match} によっ
て、合致した文章からの副表現を挿入するために使われるような、
@code{samp\\1} の様式を含むかもしれません。たとえば:

@lisp
("list.\\1" "From:.* \\(.*\\)-list@@majordomo.com")
@end lisp

@noindent
この場合、挿入されるテキストを小文字にすべきかどうか
を @code{nnmail-split-lowercase-expanded} が制御します。@xref{Fancy Mail
Splitting}.

二番目の要素は関数であることもできます。その場合は、それは法則の最初の要
素を引数として、ヘッダーに範囲を狭めて (narrowed to headers) 呼ばれます。
それは、メールがそのグループに属すると考えるのであれば、@code{nil} でな
い値を帰す必要があります。

@cindex @samp{bogus} group
これらのグループの最後は常に総合的なものであるべきで、他の正規表現に合致
しないメールに合致するために、この正規表現は @emph{いつも} @samp{""} で
あるべきです。(これらの法則は連想リストの初めから終わりまで順番に実行さ
れます。クロスポストを使用可能にしていない限り、最初の合致した法則
が ``勝ちます''。クロスポストを使用可能にしている場合、すべての合致した
法則が ``勝ちます''。)  合致する規則がなかったら、メールは最後
に @samp{bogus} グループで終わります。メール分割によって新しいグループが
作られた場合は、それらを見るために @code{gnus-group-find-new-groups} を
実行する必要があるでしょう。これは @samp{bogus} グループにも当てはまりま
す。

もしあなた自身でこれをいじくりまわしたいときは、あなたの選んだ関数をこの
変数に設定することができます。この関数は入って来たメールメッセージのヘッ
ダーに範囲を狭められたバッファーで引数なしで呼ばれます。この関数は、それ
がこのメールメッセージを運ぶべきである、と考えるグループ名のリストを返す
べきです。

すべてのメールバックエンドは、入って来た貧乏で純粋なヘッダーを乱暴に扱っ
ても良いことに注意して下さい。それらはすべて @code{Lines} ヘッダーを追加
します。いくつかは @code{X-Gnus-Group} ヘッダーを加えます。たいていのも
のは Unix の mbox の @code{From<SPACE>} 行を何か別の名前に変えます。

@vindex nnmail-crosspost
メールバックエンドはすべてクロスポストの機能を提供しています。いくつかの
正規表現が合致すると、メールはすべてのグループに ``クロスポスト'' されま
す。@code{nnmail-crosspost} はこの機能を使うかどうかを指定します。どの記
事も総合の (@samp{""}) グループにクロスポストされないことに注意して下さ
い。

@vindex nnmail-crosspost-link-function
@cindex crosspost
@cindex links
@code{nnmh} と @code{nnml} はクロスポストされた記事にハードリン
ク (hardlink) を作ることによってクロスポストを行ないます。しかし、すべて
のファイルシステムがハードリンクの機能を提供しているわけではありません。
もしあなたがその場合に当てはまるのであれば、
@code{nnmail-crosspost-link-function} を @code{copy-file} に設定して下さ
い。(この変数はディフォルトで @code{add-name-to-file} です。)

@kindex M-x nnmail-split-history
@findex nnmail-split-history
前のメール分割がメッセージをどこに入れたかを見たい場合は、
@kbd{M-x nnmail-split-history} 命令を使うことができます。これからスプー
ルし直そうとするメッセージがどこに入るかを見たい場合は、
@code{gnus-summary-respool-trace} と関連する命
令 (@pxref{Mail Group Commands}) を使うことができます。

@vindex nnmail-split-header-length-limit
@code{nnmail-split-header-length-limit} の制限より長いヘッダー行は、分割
関数の処理対象から除外されます。

@vindex nnmail-mail-splitting-charset
@vindex nnmail-mail-splitting-decodes
(訳注: オリジナルの Gnus とは仕様が微妙に異なることに注意して下さい) ディ
フォルトでは分割コードは @acronym{MIME} エンコードされたヘッダーをデコー
ドするので、非-@acronym{ASCII} 文字列に合致させることができます。変
数 @code{nnmail-mail-splitting-charset} が @acronym{MIME} 文字セッ
ト (mime-charset) であったらそれ、@acronym{MIME} 文字セットではない
非-@code{nil} な値だったらそのときの @code{default-mime-charset} の値で、
(@acronym{MIME} エンコードされたものではない) 非-@acronym{ASCII} ビット
パターンもデコードします。この動作
は @code{nnmail-mail-splitting-decodes} を @code{nil} にすることによって
完全に止めることができ、生のヘッダーのデータを元に記事に合致させたい場合
には有効でしょう。

@vindex nnmail-resplit-incoming
ディフォルトでは入ってくるすべてのメッセージに対して分割が働きます。も
し @code{mail-sources} 変
数 (@pxref{Mail Source Specifiers}) に @code{directory} の項を設定しても、
しかし、ディフォルトでは分割は @emph{起こりません}。変
数 @code{nnmail-resplit-incoming} を非-@code{nil} な値に設定することによっ
て、この場合でも分割を起こさせることができます。(この変数は他の種類の項
目に対しては効果がありません。)

Gnus はあなたに自分自身に跳ね返ってくるような可能性のあるすべての機会を
提供します。例えば、あなたの上司からくるすべてのメールを含んだグループを
作ったとしましょう。それから、偶発的にそのグループの購読取り止めが起こっ
たとします。Gnus はそれでも上司からのすべてのメールを未購読のグループに
入れるので、上司が ''月曜日までにその報告書を準備しないと首だ!'' という
メールをあなたに送っても、あなたはそれを見ることはなく、火曜日になって本
当は翌月の家賃を払うために空のボトルを集めるべきであっても、まだ有給で雇
われていると信じているかもしれません。

@node Mail Sources
@subsection Mail Sources

いろんなところからメールを取得することができます---メールスプール、
@acronym{POP} メールサーバー、procmail ディレクトリー、maildir などが例
としてあります。

@menu
* Mail Source Specifiers::      メールの元がどこかを指定する
* Mail Source Customization::   世の中に影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使用する
@end menu

@node Mail Source Specifiers
@subsubsection メールソース指示子
@cindex POP
@cindex mail server
@cindex procmail
@cindex mail spool
@cindex mail source

@dfn{メールソース指示子} に @code{メールソース} (@pxref{Fetching Mail})
を設定することで、Gnus にメールを取得する方法を教えることができます。

これは例です:

@lisp
(pop :server "pop3.mailserver.com" :user "myname")
@end lisp

御覧の通り、メールソース指示子はリストで、最初の要素は @dfn{メールソース
の型}、その次は任意の数の @dfn{キーワード} となります。明示的に指定され
ていないキーワードはディフォルト値になります。

以下のメールソースの型を使用可能です:

@table @code
@item file
単独のファイルからメールを取得します。普通はメールスプールです。

キーワード:

@table @code
@item :path
ファイルの名前です。ディフォルト値は @env{MAIL} 環境変数の値
か @code{rmail-spool-directory} の値 (普通
は @file{usr-mail/spool/user-name} のようなもの) です。

@item :prescript
@itemx :postscript
メールを取得する前後に実行するスクリプトです。
@end table

ファイルメールソースの例:

@lisp
(file :path "/usr/spool/mail/user-name")
@end lisp

もしくは、ディフォルトのファイル名を使うと:

@lisp
(file)
@end lisp

メールスプールファイルがローカルマシンに無い場合は、
@acronym{POP} や @acronym{IMAP} などでメールを取得するのが最善です。ここ
では ange-ftp のファイル名は使用できません---メールを移動しているときに
メールスプールをロックする方法がありません。

適切なサーバーを設置することが不可能なら、変わりに  ssh を使うことができ
ます。

@lisp
(setq mail-sources
      '((file :prescript "ssh host bin/getmail >%t")))
@end lisp

@samp{getmail} スクリプトは以下のようなものになります:

@example
#!/bin/sh
#  getmail - move mail from spool to stdout
#  flu@@iki.fi

MOVEMAIL=/usr/lib/emacs/20.3/i386-redhat-linux/movemail
TMP=$HOME/Mail/tmp
rm -f $TMP; $MOVEMAIL $MAIL $TMP >/dev/null && cat $TMP
@end example

目的に合うように使用したい @samp{movemail} に合わせてスクリプトを書き換
えて下さい。

@item directory
@vindex nnmail-scan-directory-mail-source-once
ディレクトリー中の複数のファイルからメールを取得します。これは普通
は procmail に新しいメールをいくつかのファイルに分割させているときに使用
されます。すなわち、そのディレクトリーにあるファイルとグループは一対一で
対応しているので、@file{foo.bar.spool} ファイルにあるメールは、
@code{foo.bar} グループに置かれます (サフィックス @code{.spool} は変更可
能です)。@code{nnmail-scan-directory-mail-source-once} を @code{nil} 以
外の値にすると、Gnus は新しいメールソースを一回だけ調べるようになります。
これは、指定したレベルのメールグループだけを調べたいときに、とりわけ便利
です。

@vindex nnmail-resplit-incoming
@code{nnmail-resplit-incoming} という変数もあり、これを非-@code{nil} に
すると通常の分割処理がディレクトリー中のすべてのファイルに対して行なわれ
ます (@pxref{Splitting Mail})。

キーワード:

@table @code
@item :path
ファイルのあるディレクトリーの名前です。これにはディフォルト値はありませ
ん。

@item :suffix
この接尾語で終わるファイルだけが使用されます。ディフォルト値
は @samp{.spool} です。

@item :predicate
この述語が @code{nil} でない値を返すファイルのみです。ディフォルト値
は @code{identity} です。これは追加の選別器として使用されます---正しい接
尾語 @emph{と} この述語を満足するファイルだけが考慮されます。

@item :prescript
@itemx :postscript
メールの取得の前/後に実行されるスクリプトです。
@end table

ディレクトリーメールソースの例です:

@lisp
(directory :path "/home/user-name/procmail-dir/"
           :suffix ".prcml")
@end lisp

@item pop
@acronym{POP} サーバーからメールを取得します。

キーワード:

@table @code
@item :server
@acronym{POP} サーバーの名前です。ディフォルト値は @env{MAILHOST} 環境変
数から取得されます。

@item :port
@acronym{POP} サーバーのポート番号です。これは数値 (例え
ば @samp{:port 1234}) か文字列 (例えば @samp{:port "pop3"}) です。もし文
字列なら Unix システムにおける @file{/etc/services} に載っているサービス
名でなければなりません。ディフォルト値は @samp{pop3} です。システムによっ
ては @samp{"pop-3"} としなければならないかもしれません。

@item :user
@acronym{POP} サーバーに与える利用者名です。ディフォルト値はログイン名で
す。

@item :password
@acronym{POP} サーバーに与えるパスワードです。指定されない場合は、利用者
は入力を求められます。

@item :program
@acronym{POP} サーバーからメールを取得するために使用されるプログラムです。
これは @code{format} のような文字列であるべきです。例です:

@example
fetchmail %u@@%s -P %p %t
@end example

有効な書式使用指示文字は:

@table @samp
@item t
メールが移動されるファイルの名前です。これは常にこの文字列に含まれていな
ければなりません。

@item s
サーバーの名前です。

@item P
サーバーのポート番号です。

@item u
使用する利用者名です。

@item p
使用するパスワードです。
@end table

これらの仕様で使われる値は対応するキーワードに与えた値から取られます。

@item :prescript
メールを取得する前に実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

@item :postscript
メールを取得した後に実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

@item :function
@acronym{POP} サーバーからメールを取得するために使う関数です。その関数は
一つのパラメーターとともに呼ばれます---メールがそこへ移動されるべきファ
イルです。

@item :authentication
これは @code{password} かシンボル @code{apop} で、どの認証方式を使うかを
決めるもののどちらかです。ディフォルト値は @code{password} です。

@item :connection
サーバーに接続するときに使うストリームで、@code{ssl}, @code{tls} または
それ以外を指定できます。ディフォルトは @code{nil} で、安全ではない接続を
用います。SSL/TLS では外部プログラムとライブラリが必要であることに注意し
て下さい:

@itemize @bullet
@item
@dfn{ssl:} @acronym{SSL} を使います。OpenSSL (@samp{openssl} プログラ
ム) か SSLeay (@samp{s_client}) と外部ライブラリ @samp{ssl.el} が必要で
す。
@item
@dfn{starttls:} STARTTLS (@acronym{SSL} に類似) を使います。外部ライブラ
リ @samp{starttls.el} と @samp{starttls} プログラムが必要です。
@samp{starttls}.
@end itemize

@item :leave
非-@code{nil} でメールをサーバーに残し、メッセージの取得に UIDL を使いま
す。ディフォルトは @code{nil} です。
@end table

@vindex pop3-movemail
@vindex pop3-leave-mail-on-server
@code{:program} と @code{:function} キーワードが指定されていないと、
@code{pop3-movemail} が使用されます。@code{pop3-movemail} を使う場合、
@code{pop3-leave-mail-on-server} が非-@code{nil} だったら、メールは取得
後でも @acronym{POP} サーバーに残されます。@acronym{POP} サーバーはセッ
ション中の状態の情報を維持しません。クライアントが信頼できる情報はクライ
アントそのものにありますが、実際にそこにあるものは正しくないかもしれない
ことに注意して下さい。それらが正しく情報を維持しない場合は、すべてが崩壊
して、あなたは壊れたメールボックスとともに置き去りになる可能性があります。

これはいくつかの例です。ディフォルトの利用者名を使って、ディフォルト
の @acronym{POP} サーバーから取得し、ディフォルトの取得方法を使用します:

@lisp
(pop)
@end lisp

指名されたサーバーから指名された利用者とパスワードで取得します:

@lisp
(pop :server "my.pop.server"
     :user "user-name" :password "secret")
@end lisp

メールの移動に @samp{movemail} を使います:

@lisp
(pop :program "movemail po:%u %t %p")
@end lisp

@item maildir
Maildir からメールを取得します。これは現在 qmail と postfix でのみでサポー
トされている mailbox 形式で、特別のディレクトリーのそれぞれのファイルが
正確に 1 メールとなっています。

キーワード:

@table @code
@item :path
メールが保存されるディレクトリーの名前です。ディフォルト値は環境変
数 @env{MAILDIR} から取得した値か、または @file{~/Maildir/} です。
@item :subdirs
Maildir のサブディレクトリーです。ディフォルト値
は @samp{("new" "cur")} です。
@c Gnus で取得する前に、ときどき pop3 デーモンでメールを探すなら、以下の最
@c 初の例のように、maildir の中の @code{cur} ディレクトリーからもメールを取
@c 得する必要があります。

リモートマシンからメールを取り寄せることも出来ます。
(というのも、maildir はロックの問題を気にせずに済むから。)
@end table

Maildir メールソースの例をふたつ:

@lisp
(maildir :path "/home/user-name/Maildir/"
         :subdirs ("cur" "new"))
@end lisp

@lisp
(maildir :path "/user@@remotehost.org:~/Maildir/"
         :subdirs ("new"))
@end lisp

@item imap
@acronym{IMAP} サーバーからメールを取得します。何らかの理由
で @acronym{IMAP} を意図されたようなネットワーク上でメールを読むプロトコ
ルとして扱いたくないときは、Gnus では @acronym{POP} サーバーと同様に扱う
ことができ、与えられた @acronym{IMAP} メールボックスから記事を取得します。
詳しくは @ref{IMAP} を参照して下さい。

Kerberos, GSSAPI, @acronym{TLS}/@acronym{SSL} および STARTTLS のための外
部プログラムとライブラリが必要であることに留意して下さい。@xref{IMAP}.

キーワード:

@table @code
@item :server
@acronym{IMAP} サーバーの名前。ディフォルト値は環境変
数 @env{MAILHOST} から得ます。

@item :port
@acronym{IMAP} サーバーのポート番号。普通はディフォルト値
は @samp{143} で、@acronym{TLS}/@acronym{SSL} 接続には @samp{993} です。

@item :user
@acronym{IMAP} サーバーに渡す利用者名です。ディフォルト値はログイン名で
す。

@item :password
@acronym{IMAP} サーバーに渡すパスワードです。指定されていないときは、利
用者は入力を促されます。

@item :stream
サーバーに接続するときに使うストリーム。@code{imap-stream-alist} にある
シンボルの中のひとつを設定します。現状では @samp{gssapi},
@samp{kerberos4}, @samp{starttls}, @samp{tls}, @samp{ssl},
@samp{shell} またはディフォルト値の @samp{network} になります。

@item :authentication
サーバーでの認証にどの認証法を使うか。これ
は @code{imap-authenticator-alist} のシンボルの一つを設定します。現状で
は @samp{gssapi}, @samp{kerberos4}, @samp{digest-md5}, @samp{cram-md5},
@samp{anonymous} またはディフォルト値の @samp{login} になります。

@item :program
:stream に `shell' が設定されているときは、この値が変
数 @code{imap-shell-program} に割り当てられます。これは @code{format} ふ
うの文字列 (または文字列のリスト) でなければなりません。例を示しましょう。

@example
ssh %s imapd
@end example

有効な format 指示子は以下の通りです。

@table @samp
@item s
サーバーの名前。

@item l
@code{imap-default-user} で設定された利用者名。

@item p
サーバーのポート番号。
@end table

これらの指定に使われる値は、対応するキーワードに与えた値から取ってきます。

@item :mailbox
メールを取得するメールボックスの名前。ディフォルト値は @samp{INBOX} で、
これは普通は入ってくるメールを受け取るメールボックスです。

@item :predicate
取得する記事を決定するために使われる述語。ディフォルト値の、@samp{UNSEEN
UNDELETED} はおそらくたいていの人には最良の選択でしょうが、ときど
き @acronym{IMAP} クライアントでメールボックスを覗き、いくつかの記事に既
読 (もしくは、SEEN) の印を付けるなら、@samp{1:*} に設定する必要があるか
もしれません。そうすれば、メールボックスのすべての記事は印の如何に関わら
ず取得されます。述語の完全な一覧は、RFC2060 の 6.4.4 節を読んで下さい。

@item :fetchflag
サーバーで、取得した記事に印を付ける方法。ディフォルト値
の @samp{\Deleted} はそれらに消去の印を付けますが、他に @samp{\Seen} で
は単に既読の印を付けます。これらは最もありそうな二つの選択ですが、他の印
も RFC2060 の 2.3.2 節で定義されています。

@item :dontexpunge
@code{nil} でなかったら、記事を取得した後で、それらに消去の印が付いてい
ても削除しません。
@end table

@acronym{IMAP} メールソースの例:

@lisp
(imap :server "mail.mycorp.com"
      :stream kerberos4
      :fetchflag "\\Seen")
@end lisp

@item webmail
@uref{http://www.hotmail.com/}, @uref{http://webmail.netscape.com/},
@uref{http://www.netaddress.com/}, @uref{http://www.yahoo.com/} などのウェ
ブメールサーバーからメールを取得します。

注: ウェブメールはクッキーに大きく依存します。url "4.0pre.46" を使う場合
は "one-line-cookie" パッチを当てる必要があります。

警告: メールが失われるかもしれません。無保証です。

キーワード:

@table @code
@item :subtype
ウェブメールサーバーの型です。ディフォルト値は @code{hotmail} です。他の
候補は @code{netscape}, @code{netaddress}, @code{my-deja} です。

@item :user
ウェブメールサーバーの利用者名です。ディフォルト値はログイン名です。

@item :password
ウェブメールサーバーのパスワードです。指定しない場合は、利用者に入力を促
します。

@item :dontexpunge
@code{nil} でなかったら、未読の記事だけを取得して、それらをごみ箱のフォ
ルダーに移動しません。
@end table

ウェブメールのソースの例です:

@lisp
(webmail :subtype 'hotmail
         :user "user-name"
         :password "secret")
@end lisp
@end table

@table @dfn
@item Common Keywords
共通キーワードはどんな型のメールソースにも使うことができます。

キーワード:

@table @code
@item :plugged
@code{nil} でなかったら、Gnus が @dfn{unplugged} であってもメールを取得
します。もしあなたがディレクトリーをメールソースに使っているならば、この
例のように指定することができます:

@lisp
(setq mail-sources
      '((directory :path "/home/pavel/.Spool/"
                   :suffix ""
                   :plugged t)))
@end lisp

あなたが @dfn{unplugged} であっても Gnus はメールを取得します。これは、
ローカルのメールとニュースを使う場合に便利です。
@end table
@end table

@subsubsection 関数インターフェース

上記のいくつかのキーワードは、実行するための Lisp 関数を指定します。関数
が実行されている間だけ、それぞれのキーワード @code{:foo} の値とし
て Lisp 変数 @code{foo} が使われます。例えば、以下のメールソースの設定例
について考えてみて下さい。

@lisp
(setq mail-sources '((pop :user "jrl"
                          :server "pophost" :function fetchfunc)))
@end lisp

関数 @code{fetchfunc} が実行されているとき、@code{user} というシンボルの
値は @code{"jrl"} になり、@code{server} というシンボルの値
は @code{"pophost"} になります。
@code{port}, @code{password}, @code{program}, @code{prescript},
@code{postscript}, @code{function} および @code{authentication} の値もま
た、それらの既定値になります。

それぞれの型のメールソースのためのキーワードのリストについては、上記を参
照して下さい。

@node Mail Source Customization
@subsubsection メールソースのカスタマイズ

以下はメールの取得方法に影響する変数の一覧です。普通はこれらはどれも設定
する必要はないでしょう。

@table @code
@item mail-source-crash-box
@vindex mail-source-crash-box
メールを操作している間に保存されている場所です。ディフォルト値
は @file{~/.emacs-mail-crash-box} です。

@item mail-source-delete-incoming
@vindex mail-source-delete-incoming
@code{nil} でなければ、入って来たファイルは、それを処理した後に消去され
ます。@code{t} ではファイルをただちに消去し、@code{nil} ではいかなるファ
イルも消しません。正の数だった場合は、その日数以上に古いファイルを消去し
ます (これは新着メールを受け取るときだけ行なわれます)。
@code{mail-source-delete-incoming} を @code{nil} にしておいて、
@code{mail-source-delete-old-incoming} をフックまたは手動で呼んでも良い
です。

@item mail-source-delete-old-incoming-confirm
@vindex mail-source-delete-old-incoming-confirm
非-@code{nil} だったら、古い incoming (メールの到着時に使われた) ファイ
ルを消去するときに確認を求めます。この変数
は @code{mail-source-delete-incoming} が正の数である場合だけ使われます。

@item mail-source-ignore-errors
@vindex mail-source-ignore-errors
非-@code{nil} だったら、メールソースからメールを読むときのエラーを無視し
ます。

@item mail-source-directory
@vindex mail-source-directory
入ってきたメールソースのファイルが (もしあれば) 保存されるディレクトリー
です。ディフォルト値は @file{~/Mail/} です。現時点では、これが使われる唯
一のものは変数 @code{mail-source-delete-incoming} が @code{nil} または数
値であった場合、入ってきたファイルが保存される場所の指定です。

@item mail-source-incoming-file-prefix
@vindex mail-source-incoming-file-prefix
入ってきたメールを保存するファイルの接頭語です。ディフォルト値
は @file{Incoming} で、この場合ファイル
は @file{Incoming30630D_} や @file{Incoming298602ZD} のようになります。
@code{mail-source-delete-incoming} が @code{nil} または数値の場合だけで
すが。

@item mail-source-default-file-modes
@vindex mail-source-default-file-modes
すべての新しいメールファイルはこのファイルモードになります。ディフォルト
値は 384 です。

@item mail-source-movemail-program
@vindex mail-source-movemail-program
非-@code{nil} だったら新着メールの取り込むためのプログラムの名前。
@code{nil} だったら @var{exec-directory} にある @code{movemail}。
@end table

@node Fetching Mail
@subsubsection メールの取得

@vindex mail-sources
@vindex nnmail-spool-file
実際に Gnus にどこから新しいメールを取得するかを教えるには、
@code{mail-sources} をメールソース指示子のリストに設定することで
す (@pxref{Mail Source Specifiers})。

この変数 (と旧式の @code{nnmail-spool-file}) が @code{nil} であれば、メー
ルバックエンドは決して自分自身ではメールを取得しようとしません。

ローカルのスプールと @acronym{POP} メールサーバーの両方からメールを取得
したいなら、このようにすることができます:

@lisp
(setq mail-sources
      '((file)
        (pop :server "pop3.mail.server"
             :password "secret")))
@end lisp

もしくは、これらのキーワードのディフォルト値を使いたくなければ:

@lisp
(setq mail-sources
      '((file :path "/var/spool/mail/user-name")
        (pop :server "pop3.mail.server"
             :user "user-name"
             :port "pop3"
             :password "secret")))
@end lisp

メールバックエンドを使うときは、Gnus はすべてのメールを inbox から吸い上
げて、ホームディレクトリーに放り投げます。あなたがメールバックエンドを使っ
ていない場合は、Gnus は一通もメールを移動しません---最初に魔法の呼び出し
をたくさんしなければなりません。まず五角形を描き、蝋燭に火を付け、山羊を
生け贄として捧げ終えた後で、Gnus があなたのメールを移動しても本当にあま
り驚いてはいけません。

@node Mail Back End Variables
@subsection メールバックエンド変数

これらの変数は (たいていの場合) すべての違ったメールバックエンドに関連し
ます。

@table @code
@vindex nnmail-read-incoming-hook
@item nnmail-read-incoming-hook
メールバックエンドは新しいメールを読み込んだ後にこのフックを呼びます。も
しそうしたいと思うなら、このフックをメール監視プログラムに知らせるために
使うことができます。

@vindex nnmail-split-hook
@item nnmail-split-hook
@findex gnus-article-decode-encoded-words
@cindex RFC 1522 decoding
@cindex RFC 2047 decoding
それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前にそれが保
存されているバッファーで実行されるフックです。このフックはそれが適合する
と考えるように自由にバッファーの内容を編集することができます---バッファー
は分割が終わった後で消去され、バッファーで行なわれた変更はどのファイルに
も現れません。@code{gnus-article-decode-rfc1522} がこのフックに加えるこ
とが適切な関数の一つです。

@vindex nnmail-pre-get-new-mail-hook
@vindex nnmail-post-get-new-mail-hook
@item nnmail-pre-get-new-mail-hook
@itemx nnmail-post-get-new-mail-hook
これらは入ってくるメールを扱うときに実行される役に立つ二つのフックで
す---@code{nnmail-pre-get-new-mail-hook} (これは新しいメールを扱う直前に
呼ばれます) と @code{nnmail-post-get-new-mail-hook} (これはメールの扱い
が終わったときに呼ばれます) です。次のものは、この二つのフックを使って新
しいメールファイルに与えられるディフォルトのファイルのモードを変更する例
です:

@lisp
(add-hook 'nnmail-pre-get-new-mail-hook
          (lambda () (set-default-file-modes 511)))

(add-hook 'nnmail-post-get-new-mail-hook
          (lambda () (set-default-file-modes 551)))
@end lisp

@item nnmail-use-long-file-names
@vindex nnmail-use-long-file-names
@code{nil} でないなら、メールバックエンドは長いファイル名とディレクトリー
名を使います。@samp{mail.misc} のようなグループ名は @file{mail.misc} と
いうディレクトリー (@code{nnml} バックエンドが使われているとみなすと) か
ファイル (@code{nnfolder} バックエンドが使われているとみなすと) という結
果になります。もしそれが @code{nil} であるなら、同じグループ
は @file{mail/misc} という結果になります。

@item nnmail-delete-file-function
@vindex nnmail-delete-file-function
@findex delete-file
ファイルを消去するために呼ばれる関数です。ディフォルト値
は @code{delete-file} です。

@item nnmail-cache-accepted-message-ids
@vindex nnmail-cache-accepted-message-ids
@code{nil} でないと、バックエンドに入って来た記事 (例えば、@code{Gcc} に
よって) の @code{Message-ID} をメール重複発見ファイルに入れます。ディフォ
ルトは @code{nil} です。

@item nnmail-cache-ignore-groups
@vindex nnmail-cache-ignore-groups
正規表現か正規表現のリストです。正規表現にグループ名が合致する
と @code{Message-ID} キャッシュに記録されません。

例えば特級分割 (@pxref{Fancy Mail Splitting}) を関
数 @code{nnmail-split-fancy-with-parent} とともに使っている場合に役立つ
でしょう。
@end table

@node Fancy Mail Splitting
@subsection 特級メール分割
@cindex mail splitting
@cindex fancy mail splitting

@vindex nnmail-split-fancy
@findex nnmail-split-fancy
比較的単純な標準のメール分割指定の方法ではあなたの望むことができない場合、
@code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定すること
ができます。それから変数 @code{nnmail-split-fancy} で遊ぶことができます。

まずこの変数の値の例を見てみましょう:

@lisp
;; @r{メールデーモン (mailer deamon) は普通のグループにはクロスポスト}
;; @r{されません。警告は本当のエラーとは違ったグループに入れられます。}
(| ("from" mail (| ("subject" "warn.*" "mail.warning")
                   "mail.misc"))
   ;; @r{エラーでないメッセージはすべての関連したグループにクロスポスト}
   ;; @r{されますが、(ding) リストと他の (ding) 関連のメールのためのグ}
   ;; @r{ループにはクロスポストしません。}
   (& (| (any "ding@@ifi\\.uio\\.no" "ding.list")
         ("subject "ding" "ding.misc"))
      ;; @r{他のメーリングリスト@dots{}}
      (any "procmail@@informatik\\.rwth-aachen\\.de" "procmail.list")
      (any "SmartList@@informatik\\.rwth-aachen\\.de" "SmartList.list")
      ;; @r{以下のどちらのメーリングリストも同じ接頭語なので、bugs-}
      ;; @r{だけに投稿されたものが mypkg.list にクロスポストされないよ}
      ;; @r{うにしています。しかし本当にクロスポストされた記事をクロス}
      ;; @r{ポストすることは許しています。}
      (any "bugs-mypackage@@somewhere" "mypkg.bugs")
      (any "mypackage@@somewhere" - "bugs-mypackage" "mypkg.list")
      ;; @r{人々@dots{}}
      (any "larsi@@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
   ;; @r{合致しなかったメールはすべてを捕まえるグループへ行きます。}
   "misc.misc")
@end lisp

この変数は @dfn{分割} の様式になっています。分割は (あるいは) それぞれの
分割が他の分割を含む再帰的構造です。これは使用可能な分割構文です:

@table @code

@item group
もし分割が文字列であると、それはグループ名としてみなされます。普通の正規
表現の合致がなされます。例は下の方を見て下さい。

@item (@var{field} @var{value} [- @var{restrict} [@dots{}] ] @var{split})
もし分割がリストで、最初の要素が文字列であり、ヘッダー @var{field} (正規
表現) が @var{value} (これも正規表現) を含んでいる場合、メッセージ
を @var{split} で指定されたところに蓄積します。@var{restrict} (また他の
正規表現) が @var{field} の後で、合致した @var{value} の最後の前のいくつ
かの文字列に合致したら、@var{split} は無視されます。@var{restrict} の閉
包のどれもが合致しなければ @var{split} が実行されます。

@item (| @var{split} @dots{})
分割がリストで、最初の要素が @code{|} (垂直棒) であると、それぞれ
の @var{split} をそのうちの一つが合致するまで実行します。@var{split} は
メールメッセージが一つ以上のグループに蓄積されたときに ``合致した'' とし
ます。

@item (& @var{split} @dots{})
分割がリストで、最初の要素が @code{&} であると、リストのすべて
の @var{split} (複数) を実行します。

@item junk
もし分割がシンボル @code{junk} であると、そのメッセージを保存しませ
ん (すなわち、消去してしまいます)。非常に注意して使って下さい。

@item (: @var{function} @var{arg1} @var{arg2} @dots{})
もし分割がリストで、最初の要素が @code{:} であると、二番目の要素
が @var{args} を引数として関数として呼ばれます。関数は @var{split} を返
すべきです。

@cindex body split
例えば以下の関数は、記事のボディーに基づいた分割に使えるでしょう:

@lisp
(defun split-on-body ()
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (when (re-search-forward "Some.*string" nil t)
        "string.group"))))
@end lisp

@var{function} が走らされるとき、バッファーはメッセージの部分に狭められ
ます。それが上記の例
で @code{save-excursion} と @code{save-restriction} の後
で @code{(widen)} が呼ばれる必要がある理由です。さらに nnimap バックエン
ドの場合、ディフォルトでは記事のボディーがダウンロードされないことに注意
して下さい。それをするために
は @code{nnimap-split-download-body} を @code{t} に設定する必要がありま
す (@pxref{Splitting in IMAP})。

@item (! @var{func} @var{split})
分割がリストで、最初の要素が @code{!} であると @var{split} が実行され、
@var{func} は @var{split} の結果を引数として呼ばれます。@var{func} は分
割を返すべきです。

@item nil
もし分割が @code{nil} であれば、それは無視されます。

@end table

これらの分割で、@var{fileld} は完全なフィールド名に合致しなければなりま
せん。@var{value} は基礎モード (fundamental mode) 構文テーブル (syntax
table) に従って完全に合致しなければなりません。正規表現でフィールド名か
語の部分に合致させるために @code{.*} を使うことができます。言い換えれば、
すべての @var{value} は @samp{\<} と @samp{\>} の対で囲まれます。

@vindex nnmail-split-abbrev-alist
@var{field} と @var{value} は Lisp シンボル (symbol) であることもでき、
その場合それらは @code{nnmail-split-abbrev-alist} で指定されているように
展開されます。これはセルの @sc{car} がキーを含んでいて、@sc{cdr} が関連
付けられた値を持っているコンスセル (cons cell) の連想リストです。以下の
項目が、あらかじめ @code{nnmail-split-abbrev-alist} に定義されています:

@table @code
@item from
@samp{From}、@samp{Sender} および @samp{Resent-From} の各フィールドに合
致します。
@item to
@samp{To}、@samp{Cc}、@samp{Apparently-To}、@samp{Resent-To} およ
び @samp{Resent-Cc} の各フィールドに合致します。
@item any
@code{from} と @code{to} を統合したものです。
@end table

@vindex nnmail-split-fancy-syntax-table
@code{nnmail-split-fancy-syntax-table} がこれらのすべての分割が実行され
ているときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、Gnus に動的にグループを作らせたいの
であれば (例えば、グループ名で @code{replace-match} のような代用をする)、
次のようなことができます。

@example
(any "debian-\\b\\(\\w+\\)@@lists.debian.org" "mail.debian.\\1")
@end example

この例では、@samp{debian-foo@@lists.debian.org} に送られたメール
は @samp{mail.debian.foo} という風になります。

もし文字列が要素 @samp{\&} を含んでいると、代わりに前で合致した文字列が
使われます。同様に、要素 @samp{\\1} から @samp{\\9} まではグループ付
け 1 から 9 までで合致した文字列で代替されます。

@vindex nnmail-split-lowercase-expanded
ここで、合致した文字列を小文字にしたもので代替するべきかどうか
を @code{nnmail-split-lowercase-expanded} が制御します。これを
非-@code{nil} にすることによって、アドレスに大文字と小文字が区別せずに使
われている (例えば mailing-list@@domain と Mailing-List@@Domain) 場合で
も、複数のグループが生成されてしまうことを避けることができます。ディフォ
ルトは @code{t} です。

@vindex nnmail-split-fancy-match-partial-words
@code{nnmail-split-fancy-match-partial-words} は、特級分割で部分的な語が
合致するかどうかを制御します。

通常 @code{nnmail-split-fancy} で与えられる正規表現は、暗に語の区切りを
表す @code{\<...\>} 印で囲まれています。この変数が真であると、それらは何
によっても暗に囲まれません。

@example
(any "joe" "joemail")
@end example

この例で、通常 @samp{joedavis@@foo.org} から来たメッセージ
は @samp{joemail} に格納されません。しかし、
@code{nnmail-split-fancy-match-partial-words} を @code{t} に設定すると合
致が起きます。要するに、語を区切る条件が削除され、代わりに合致がよ
り grep らしくなるのです。

@findex nnmail-split-fancy-with-parent
関数 @code{nnmail-split-fancy-with-parent} は、フォローアップ記事を親記
事と同じグループに振り分けるために使います。メールの振り分けを一生懸命設
定してみても完璧にはできないことがありますね。例えば、上司から個人宛ての
メールが届いたとします。自分が携っているプロジェクトとは別の話です。けれ
ど「他のメールと区別できるようにこれこれこういう言葉を表題に書いて下さい」
と上司に向かって指図するわけにはいきませんから、結局自分の手を煩わしてひ
とつひとつメールを正しいグループに振り分けるはめになります。そんなときに
この関数を使うと、この面倒な作業を一スレッドにつき一回きりで済ますことが
できます。

この機能を利用するためには、まず変
数 @code{nnmail-treat-duplicates} およ
び @code{nnmail-cache-accepted-message-ids} の値を非-code{nil} に設定す
る必要があります。それができた
ら @code{nnmail-split-fancy-with-parent} を使ってみて下さい。コロンを使っ
てこんな風に書きます:

@lisp
(setq nnmail-treat-duplicates 'warn     ; @r{または @code{delete}}
      nnmail-cache-accepted-message-ids t
      nnmail-split-fancy
      '(| (: nnmail-split-fancy-with-parent)
          ;; @r{残りの振り分け方はここに書く}
        ))
@end lisp

この機能は実際、次の様に働いています: 変数
@code{nnmail-treat-duplicates} の値が非-@code{nil} の場合、Gnus は見つけ
た全記事のメッセージ ID を変数 @code{nnmail-message-id-cache-file} が指
定するファイルに記録します。このとき、それぞれの記事が存在するグループの
名前を併記します (ただしメールの場合だけ、さもなければグループ名は調べま
せん)。さて、いよいよメールの振り分けが始まると、関数
@code{nnmail-split-fancy-with-parent} は、対象となる各記事の References
(と In-Reply-To) ヘッダーを調べ、@code{nnmail-message-id-cache-file} に
指定されているファイルにそれらのメッセージ ID があるかどうか調べます。親
記事が見つかると、そのグループ名が正規表
現 @code{nnmail-split-fancy-with-parent-ignore-groups} に合致しなければ、
この関数は対応するグループ名を返すわけです。ここで、変
数 @code{nnmail-message-id-cache-length} の値を既定値よりも幾らか大きな
値に設定することをお勧めします。そうすると、今調べられたメッセージ ID 達
は今しばらくキャッシュの中に存続できます (5000 に設定するとキャッシュファ
イルの大きさはだいたい 300 キロバイトぐらいになるみたいです)。
@vindex nnmail-cache-accepted-message-ids
さらに、変数 @code{nnmail-cache-accepted-message-ids} の値を
非-@code{nil} に設定すれば、Gnus は移動された記事のメッセージ ID をも記
録するので、フォローアップ記事は親記事の移動先と同じグループに入るように
なります。

あるグループをキャッシュに記録したくない場合は、変
数 @code{nnmail-cache-ignore-groups} も参照して下さい。例えば、外に出す
すべてのメッセージが ``outgoing'' グループで書かれているならば、
@code{nnmail-cache-ignore-groups} をそのグループ名に合致するように設定す
るのが良いです。さもないとあなたのすべてのメッセージに対する返事が、最後
は ``outgoing'' グループに入ってしまうでしょう。

@node Group Mail Splitting
@subsection グループメール分割
@cindex mail splitting
@cindex group mail splitting

@findex gnus-group-split
たーくさんのメーリングリストを購読しているけれど、手でメール分割規則を維
持したくないときは、グループメール分割というものがあなたのためにあります。
グループパラメーターかグループカスタマイズ
で @code{to-list}, @code{to-address} の両方もしくはどちらかを設定し
て @code{nnmail-split-methods} を @code{gnus-group-split} に設定するだけ
です。分割関数はすべてのグループでこれらのパラメーターを走査し、それに従っ
て分割します。すなわち、メールグループのパラメー
ター @code{to-list} か @code{to-address} で指定されたアドレスから投稿さ
れたものか、そのアドレスへ投稿されたメッセージがそのグループに保存されま
す。

ときには、メーリングリストには複数のアドレスがあり、メール分割にそれらす
べてを認識させる必要があるかもしれません: @code{extra-aliases} グループ
パラメーターを追加のアドレスのリストに設定するだけで終りです。正規表現を
使いたければ、@code{split-regexp} を設定して下さい。

これらのすべてのグループのパラメーターは、@code{nnmail-split-fancy} 分割
を作成するために使用され、それは @var{field} が @samp{any} で、
@var{value} が @code{to-list}, @code{to-address},
@code{extra-aliases} のすべて、@code{split-regexp} のすべての合致に合致
する単独の正規表現、@var{split} がグループの名前になります。
@var{restrict} も使用できます: @code{split-exclude} パラメーターを正規表
現のリストに設定するだけです。

これらのすべてのパラメーターを使って正しい分割が生成されないときや、何か
違ったものが必要なときは、パラメー
ター @code{split-spec} を @code{nnmail-split-fancy} 分割に設定することが
できます。この場合は、他の前に書いたすべてのパラメーター
は @code{gnus-group-split} に無視されます。特に、
@code{split-spec} は @code{nil} に設定することができ、その場合はグループ
は @code{gnus-group-split} に無視されます。

@vindex gnus-group-split-default-catch-all-group
@code{gnus-group-split} はそれぞれのグループに一つの分割を含む単一
の @code{&} 特級分割を定義することで合致するすべてのグループにクロスポス
トをします。メッセージがどの分割にも合致しなければ、どれかのグループ
で @var{split-spec} が @code{catch-all} に設定されていない場合
は @code{gnus-group-split-default-catch-all-group} で指定されているグルー
プに保存されます。@code{split-spec} が @code{catch-all} に設定されている
グループがある場合は、そのグループがすべてを捕獲するグループとして使用さ
れます。この変数はしばしば単にグループを指定するために使われますが、任意
の複雑な特級分割をも設定する (結局、グループ名は特級分割なのです) ので、
個人のメールフォルダーのどのメーリングリストにも当てはまらないメールを分
割するのに便利でしょう。なおこの特級分割は、@code{|} 分割リストの最後の
要素 - グループパラメーターから抽出された規則を持つ @code{&} 分割を含
む - として追加されることに注意して下さい。

そろそろ例を出すべきでしょう。以下のグループパラメーターが定義されている
とします:

@example
nnml:mail.bar:
((to-address . "bar@@femail.com")
 (split-regexp . ".*@@femail\\.com"))
nnml:mail.foo:
((to-list . "foo@@nowhere.gov")
 (extra-aliases "foo@@localhost" "foo-redist@@home")
 (split-exclude "bugs-foo" "rambling-foo")
 (admin-address . "foo-request@@nowhere.gov"))
nnml:mail.others:
((split-spec . catch-all))
@end example

@code{nnmail-split-methods} を @code{gnus-group-split} に設定すると、
@code{nnmail-split-fancy} が選択されて、変
数 @code{nnmail-split-fancy} が以下のように設定されているかのように振舞
います:

@lisp
(| (& (any "\\(bar@@femail\\.com\\|.*@@femail\\.com\\)" "mail.bar")
      (any "\\(foo@@nowhere\\.gov\\|foo@@localhost\\|foo-redist@@home\\)"
           - "bugs-foo" - "rambling-foo" "mail.foo"))
   "mail.others")
@end lisp

@findex gnus-group-split-fancy
すべてのメールグループでグループ分割を使用したくはないときは、
@code{nnmail-split-fancy} 分割を次のように使用することでいくつかのグルー
プだけに使うことができます。

@lisp
(: gnus-group-split-fancy @var{groups} @var{no-crosspost} @var{catch-all})
@end lisp

@var{groups} は出力の分割を生成するためにパラメーターが走査されるグルー
プ名のリストか正規表現です。@var{no-crosspost} はクロスポストを使用禁止
にるために使うことができます。その場合、単一の @code{|} 分割が出力されま
す。
@var{catch-all} は @code{gnus-group-split-default-catch-all-group} のよ
うに、最後の手段として使われる特級分割です。
@var{catch-all} が @code{nil} であるか、@code{split-regexp} がどれかの選
択されたグループ空文字列に合致すると、全捕獲分割は行なわれません。そうで
ない場合、@code{split-spec} が @code{catch-all} に設定されているグループ
では、それが @var{catch-all} 引数よりも優先されます。

@findex gnus-group-split-setup
不運なことに、すべてのグルプとパラメーターを走査することは非常に遅いです。
特にすべてのメッセージに対してなされることを考えると。けれども、絶望しな
いで! 関数 @code{gnus-group-split-setup} が @code{gnus-group-split} をよ
りずっと効率的な方法で使うことができます。それ
は @code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定し、
@code{nnmail-split-fancy} を @code{gnus-group-split-fancy} で生成された
分割に設定します。こうしてどんなに分割するメッセージがたくさんあっても、
グループパラメーターは一度だけ走査されます。

@findex gnus-group-split-update
しかし、グループパラメーターを変更すると、@code{nnmail-split-fancy} を手
で更新しなければなりません。@code{gnus-group-split-update} を実行するこ
とでそれを行なえます。自動的に更新される方が好みなら、
@code{gnus-group-split-setup} にそれを実行するように教えるだけです。例え
ば、@file{~/.gnus.el} に以下のものを追加して下さい:

@lisp
(gnus-group-split-setup @var{auto-update} @var{catch-all})
@end lisp

@var{auto-update} が @code{nil} で無いと、
@code{gnus-group-split-update} が @code{nnmail-pre-get-new-mail-hook} に
追加され、二度と @code{nnmail-split-fancy} の更新を心配する必要はありま
せん。@var{catch-all} を省略しない場合は (それはオプション
で @code{nil} と等
価)、@code{gnus-group-split-default-catch-all-group} はその値に設定され
ます。

@vindex gnus-group-split-updated-hook
@code{nnmail-split-fancy} が @code{gnus-group-split-update} で設定された
後で変更する必要があるときのために、この関数
は @code{gnus-group-split-update-hook} を終了する直前に実行します。

@node Incorporating Old Mail
@subsection 古いメールを取り込む
@cindex incorporating old mail
@cindex import old mail

たいていの人は色々なファイルフォーマットで蓄積されたたくさんの古いメール
があるでしょう。もし Gnus に粋な Gnus メールバックエンドの一つを使うよう
に設定したのであれば、おそらく古いメールをメールグループに取り込みたいと
思うでしょう。

それをすることはとても簡単です。

例を挙げましょう: @code{nnml} (@pxref{Mail Spool}) を使ってメールを読ん
でいて、@code{nnmail-split-methods} を満足できる値に設定しています。古
い Unix mbox ファイルが重要だけれど古いメールで満たされています。あなた
はそれを @code{nnml} グループに移動したいと思っています。

方法です:

@enumerate
@item
グループバッファーに行きます。

@item
@kbd{G f} と打って、mbox ファイルから @code{nndoc} グループを作成するよ
うに促されたときに mbox のファイル名前を与えます (@pxref{Foreign
Groups})。

@item
@kbd{SPACE} を打って、新しく作られたグループに入ります。

@item
@kbd{M P b} を打って、グループバッファーのすべての記事に実行印を付けま
す (@pxref{Setting Process Marks})。

@item
@kbd{B r} を打ってすべてのプロセス印の付いた再スプールし、促されたとき
に @samp{nnml} と答えます (@pxref{Mail Group Commands})。
@end enumerate

mbox ファイルのすべてのメールメッセージも今やあなたの @code{nnml} グルー
プに広がっています。それらに入って、変な故障もなくものごとがうまくいって
いるかどうかを調べて下さい。もし大丈夫なようであれば、mbox ファイルを消
すことを考えるかもしれませんが、私はすべてのメールがあるべきところに納まっ
ているのを完全に確認するまでは、そうはしません。

@node Expiring Mail
@subsection メールの期限切れ消去
@cindex article expiry

伝統的なメールリーダーは、何か、既読の印を付けると記事を削除する傾向があ
ります。Gnus はメールを読むことに対して、基本的にまったく違った方法を取
ります。

Gnus は基本的にメールを比較的特別な方法で受け取られたニュースであるとみ
なします。それは実際にメールを変更したり、メールメッセージを消す権力があ
るとは考えません。メールグループに入って、記事に ``既読'' の印を付けたり、
他の流儀で切ったりしても、メール記事はまだシステムに存在しています。繰り
返します: Gnus はあなたの古い、既読メールを消去しません。もちろん、あな
たがそうしろと頼まない限りの話ですが。

Gnus に望ましくないメールを削除させるためには、記事を @dfn{期限切れ消去
可能} (expirable) として印を付けなければなりません。(ディフォルトのキー
割り当てでは、@kbd{E} をタイプしなければならないことを意味します。) しか
しながら、これは記事が即座に消え去るということではありません。一般的に、
メール記事は次のような場合にシステムによって削除されます 1) 期限切れ消去
可能の印を付けられる 2) 一週間以上経った記事である。もし記事を期限切れ消
去可能にしなければ、それは地獄が凍りつくまでシステムに残りつづけます。こ
れはもう一度強調付きで繰り返されるに足るものです: ``もし'' あなたが記事
を ``期限切れ消去可能'' であると ``しない'' なら、Gnus は ``決して'' そ
れらの ``記事'' を消去しません。

手作業で記事に期限切れ消去可能の印を付けなければならないわけではありませ
ん。Gnus は ``auto-expire'' および ``total-expire'' と呼ばれる二つの機能
を提供して、あなたの手助けをします。かいつまんで言えば、
``auto-expire'' はあなたが記事を選択したときに Gnus が @kbd{E} を叩いて
くれることを意味します。そして ``total-expire'' は、すべての既読の記事は
期限切れ消去可能であると Gnus が解釈することを意味します。したがっ
て @samp{E} の印が付けられた記事に加えて、@samp{r}, @samp{R}, @samp{O},
@samp{K}, @samp{Y} などの印が付けられた記事も期限切れ消去可能であると解
釈されます。

Auto-expire または total-expire は、いつ使用されるべきですか? メーリング
リストを購読しているほとんどの人々は、それぞれのリストをそれ自身のグルー
プに分割し、それらのグループに対して auto-expire または total-expire を
有効にします。(@xref{Splitting Mail}, それぞれのリストのそれ自身のグルー
プへの分割についてのさらなる情報。)

Auto-expire または total-expire のどちらが良いですか? それは答えにくいで
す。概して言えば、たぶん auto-expire が速いでしょう。auto-expire の別の
利点はより多くのマークを使える - 再び読むことになっている (be supposed
to stick around の意訳) 記事については、今までどおり可視 (tick)、保
留 (dormant) または既読 (read) の中から選ぶことができる - ということです。
しかし total-expire では dormant と ticked からしか選べません。
total-expire の利点は、適応スコア付け (@pxref{Adaptive Scoring}) で良好
に働くことです。Auto-expire は通常のスコア付けでは動作しますが、適応スコ
ア付けではだめです。

@vindex gnus-auto-expirable-newsgroups
正規表現 @code{gnus-auto-expirable-newsgroups} に合致するグループはすべ
ての既読記事に自動的に期限切れ消去可能の印が付けられます。すべての期限切
れ消去可能の印の付いた記事は概略バッファーの最初の桁に @samp{E} が表示さ
れます。

ディフォルトでは自動期限切れ消去可能を使用すると、Gnus はあなたが読んだ
すべての記事を、それが既読であったか未読であったかに関わらず、期限切れ消
去可能として印を付けます。既読の印の付いた記事が自動的に期限切れ消去可能
として印付けられるのを避けるために、以下のようなもの
を @file{~/.gnus.el} ファイルに書くことができます:

@vindex gnus-mark-article-hook
@lisp
(remove-hook 'gnus-mark-article-hook
             'gnus-summary-mark-read-and-unread-as-read)
(add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)
@end lisp

自動期限切れ消去可能グループを作ることは、すべての既読記事が期限切れ消去
されることではないことに気を付けて下さい---期限切れ消去可能として印の付
いた記事だけが期限切れ消去されます。@kbd{d} 命令が自動的に記事を期限切れ
消去可能にするのでは無いということにも気を付けて下さい---半自動の、自動
期限切れ消去可能グループで記事を既読に印付けることだけが記事を期限切れ消
去可能にします。

@lisp
(setq gnus-auto-expirable-newsgroups
      "mail.nosense-list\\|mail.nice-list")
@end lisp

自動期限切れ消去を実行する他の方法は、グループのグループパラメーターとし
て、要素 @code{auto-expirable} を持つことです。

もし適応スコア付け (@pxref{Adaptive Scoring}) と自動期限切れ消去を使用し
ているなら、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあま
り良く相互作用しません。

@vindex nnmail-expiry-wait
変数 @code{nnmail-expiry-wait} は期限切れ消去可能記事がどれくらいの期間
生存しているかのディフォルトの時間設定を提供します。Gnus はメッセージが
送られたときではなく、それが @emph{到着} してからの日を計算します。ディ
フォルトは 7 日間です。

Gnus は記事がどのグループに属しているかに基づいて、それがどのくらい生存
するかを成功に設定する関数も提供しています。@samp{mail.private} グループ
は期限を 1ヶ月に、@samp{mail.junk} グループでは期限を 1 日に、その他のも
のには期限を 6 日間にするには:

@vindex nnmail-expiry-wait-function
@lisp
(setq nnmail-expiry-wait-function
      (lambda (group)
       (cond ((string= group "mail.private")
               31)
             ((string= group "mail.junk")
               1)
             ((string= group "important")
              'never)
             (t
               6))))
@end lisp

この関数に与えられるグループ名は ``装飾無し'' のグループ名です---
@samp{nnml:} やその他の似たようなものは付きません。

変数 @code{nnmail-expiry-wait} と関
数 @code{nnmail-expiry-wait-function} は数値 (整数である必要はありませ
ん) かシンボル @code{immediate} か @code{never} のどちらかであることがで
きます。

期限切れ期間を選択的に変更するためにグループパラメー
ター @code{expiry-wait} を使うこともできます (@pxref{Group Parameters})。

@vindex nnmail-expiry-target
記事の期限切れ消去の普通の動作はそれらを消去することです。しかし、場合に
よってはそれらを消去するよりも別のグループに移動した方が有意義かもしれま
せん。変数 @code{nnmail-expiry-target} (とグループパラメー
ター @code{expiry-target}) はこれを制御します。この変数の値はすべてのグ
ループに対するディフォルトになりますが、特定のグループごとにグループパラ
メーターを使って指定すれば、それで優先させることができます。ディフォルト
の値は @code{delete} ですが、文字列 (記事を移動する先のグループ名) また
は移動先のグループ名か @code{delete} を返す関数 (記事に範囲を狭めたバッ
ファーで、その記事が存在しているグループ名が引数として与えられます) にす
ることができます。

グループ名を指定する場合の例:
@lisp
(setq nnmail-expiry-target "nnml:expired")
@end lisp

@findex nnmail-fancy-expiry-target
@vindex nnmail-fancy-expiry-targets
Gnus には変数 @code{nnmail-fancy-expiry-targets} に従ってメールを期限切
れ消去するための関数 @code{nnmail-fancy-expiry-target} があります。これ
は例です:

@lisp
 (setq nnmail-expiry-target 'nnmail-fancy-expiry-target
       nnmail-fancy-expiry-targets
       '((to-from "boss" "nnfolder:Work")
         ("subject" "IMPORTANT" "nnfolder:IMPORTANT.%Y.%b")
         ("from" ".*" "nnfolder:Archive-%Y")))
@end lisp

この設定によって、表題に @code{IMPORTANT} を持ち、
@code{YYYY} 年 @code{MMM} 月に発信されたいかなるメール
も @code{nnfolder:IMPORTANT.YYYY.MMM} グループに期限切れ消去 (訳注: 実際
の動作は保存) されます。もし From または To ヘッダーが文字
列 @code{boss} を含んでいたら @code{nnfolder:Work} に期限切れ消去されま
す。それ以外のすべてのメールは @code{nnfolder:Archive-YYYY} に期限切れ消
去されます。

@vindex nnmail-keep-last-article
@code{nnmail-keep-last-article} が @code{nil} でないと、Gnus はメールニュー
スグループの最後の記事を決して期限切れ消去しません。これは procmail の利
用者の人生を楽にするためです。

@vindex gnus-total-expirable-newsgroups
ところで: そこにある、Gnus が決して期限切れ消去可能でない記事を期限切れ
消去することはない、というのは嘘です。@code{total-expire} をグループパラ
メーターに入れると、記事は期限切れ消去の印が付きませんが、すべての記事は
期限切れ消去過程に入れられます。非常に注意して使って下さい。さらにもっと
危険なものは変数 @code{gnus-total-expirable-newsgroups} です。この正規表
現に合致するすべてのグループはすべての既読記事が期限切れ消去可能の過程に
突っ込まれます。これは、当のグループの @emph{すべて} の古いメール記事は
少し後で削除されるということです。非常に注意して使って、あなたが使用した
正規表現が間違ったグループに合致して、あなたのすべての重要なメールが消え
てしまったと言って、私のところに泣き付いて来ないで下さい。@emph{男} にな
りなさい! もしくは @emph{女} になりなさい! あなたが気持ちよいと感じるす
べてのものと! ですからそこに!

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ消
去可能) にしますが。

@vindex gnus-inhibit-user-auto-expire
@code{gnus-inhibit-user-auto-expire} が @code{nil} でなければ、グループ
が自動期限切れ消去が使用されるようになっていても、利用者の印付け命令は記
事に期限切れ消去可能の印を付けません。

@node Washing Mail
@subsection メール洗濯
@cindex mail washing
@cindex list server brain damage
@cindex incoming mail treatment

メイラー (mailer) やリストサーバー (list server) は本当に本当に馬鹿げた
ことをすることで悪名高いです。``わぁ、RFC822 はサーバーを通っていくメッ
セージのすべての行の最後に @code{wE aRe ElIte!!!!!1!!} を加えることを明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1'' えぇ、そのとおりです
が、RFC822 は能力の低い人によって読まれるようには書かれていません。明白
なことはそこでは議論されていません。ですから。そういうことです。

問題点: ドイツ版 Microsoft Exchange は返答の表題に @samp{Re: } の代わり
に @samp{AW: } を付け加えます。私はこれに動揺して狼狽しているふりをする
こともできましたが、そうする気力がありませんでした。それは笑うべきことで
す。

Gnus は記事を表示するときにそれを洗濯するために過度の関数を提供していま
すが、メールをディスクに保存する前に選別をすることができた方が良いでしょ
う。その目的のために、三つのフックとそのフックに入れることのできる色々な
関数があります。

@table @code
@item nnmail-prepare-incoming-hook
@vindex nnmail-prepare-incoming-hook
このフックはメールに何かをする前に呼ばれ、基本的な、メールを掃いてきれい
にする所作のためにあります。それはすべての新しい、入ってきたメールを含ん
でいるバッファーで呼ばれます。使うことのできる関数は:

@table @code
@item nnheader-ms-strip-cr
@findex nnheader-ms-strip-cr
それぞれの行から、最後にあるキャリッジリターン (carriage return) を取り
除きます。これは MS のマシン上で動作している Emacs のディフォルトです。
@end table

@item nnmail-prepare-incoming-header-hook
@vindex nnmail-prepare-incoming-header-hook
このフックはそれぞれのヘッダーに範囲を狭められて (narrowed) 呼ばれます。
ヘッダーをきれいにするときに使うことができます。使うことのできる関数は:

@table @code
@item nnmail-remove-leading-whitespace
@findex nnmail-remove-leading-whitespace
ヘッダーにそれが良く見えるように ``有用な'' リストサーバーが前の方に付け
加えた空白を無くします。あぁぁ。

(この関数はすべてのメッセージのボディー中にあるヘッダー (ボディー中のメッ
セージが持っているヘッダー行のようなもの) に対しても動作するので、使用に
際しては潜在的な危険を孕んでいます。したがってバグを修正するよりは、文書
で特徴を示すのが、もちろん正しい解決の道です。)

@item nnmail-remove-list-identifiers
@findex nnmail-remove-list-identifiers
いくつかのリストサーバーは同一識別子を付け加えます---例えば、
@samp{(idm)}---をすべての @code{Subject} ヘッダーの最初に付けます。それ
は、石器時代のメールヘッダーを使っている人には良いことだと思います。この
関数は正規表現 @code{nnmail-list-identifiers} に合致する文字列を取り除き
ます。それは正規表現のリストであることもできます。
@code{nnmail-list-identifiers} に @code{\\(..\\)} を含めてはいけません。

例えば、@samp{(idm)} と @samp{nagnagnag} 同一識別子を取り除きたいのなら:

@lisp
(setq nnmail-list-identifiers
      '("(idm)" "nagnagnag"))
@end lisp

これは @code{gnus-list-identifiers} で非破壊的に行なうこともできます。
@xref{Article Hiding}.

@item nnmail-remove-tabs
@findex nnmail-remove-tabs
すべての @samp{TAB} 文字を @samp{SPACE} 文字に変換します。

@item nnmail-fix-eudora-headers
@findex nnmail-fix-eudora-headers
@cindex Eudora
Eudora は壊れた @code{References} ヘッダーを作成しますが、
@code{In-Reply-To} ヘッダーにはちゃんとしたものを入れます。この関数
は @code{References} ヘッダーを取り除きます。
@end table

@item nnmail-prepare-incoming-message-hook
@vindex nnmail-prepare-incoming-message-hook
このフックはそれぞれのメッセージに範囲を狭められて呼ばれます。使うことの
できる関数は:

@table @code
@item article-de-quoted-unreadable
@findex article-de-quoted-unreadable
Quoted Readable エンコードをデコードします。
@end table
@end table

@node Duplicates
@subsection 重複

@vindex nnmail-treat-duplicates
@vindex nnmail-message-id-cache-length
@vindex nnmail-message-id-cache-file
@cindex duplicate mails
いくつかのメーリングリストのメンバーなら、時々同じメールを二つ受け取るこ
とがあります。これはとてもうるさく感じることもあるので、@code{nnmail} は
それが発見するかもしれない重複を調べて扱います。これをするために、古
い @code{Message-ID} を保存しま
す---@code{nnmail-messagge-id-cache-file} に。これはディフォルトで
は @file{~/.nnmail-cache} です。それに保存される最大数
の @code{Message-ID} は変数 @code{nnmail-message-id-cache-length} に制御
され、それはディフォルトで 1000 です。(ですから、
1000 @code{Message-ID} が溜められます。) これが恐ろしいと思ったなら、
@code{nnmail-treat-duplicates} を @code{warn} (ディフォルトではそのよう
になっていますが) に設定することができ、そうすれば、@code{nnmail} は重複
メールを消去しません。その代わりに、メールの先頭にこれは違ったメッセージ
の重複であるという警告を挿入します。

この変数は関数であることもできます。その場合は、関数
は @code{Message-ID} を引数として、当のメッセージに範囲を狭められたバッ
ファーから呼ばれます。この関数は @code{nil}, @code{warn},
@code{delete} のどれかを返さなければなりません。

変数を @code{nil} に設定することによって、この機能を完全に使わないように
することができます。

もしすべての重複メールを特別な @dfn{duplicate} グループに入れたいのであ
れば、普通のメール分割方法を使ってそれをすることができます:

@lisp
(setq nnmail-split-fancy
      '(| ;; @r{重複メッセージは分離されたグループへ行きます。}
        ("gnus-warning" "duplicat\\(e\\|ion\\) of message" "duplicate")
        ;; @r{デーモンやポストマスターや似たようなものからの}
        ;; @r{メッセージは他のところへ。}
        (any mail "mail.misc")
        ;; @r{他の法則。}
        [ ... ] ))
@end lisp

もしくは次のようなもの:
@lisp
(setq nnmail-split-methods
      '(("duplicates" "^Gnus-Warning:.*duplicate")
        ;; @r{他の法則。}
        [...]))
@end lisp

すばらしい機能があります: もし受け手がメールを Gnus で読んでいることを知っ
ていて、@code{nnmail-treat-duplicates} が @code{delete} に設定してあると、
あなたの知っている、その人がすでに受け取ったメール
の @code{Message-ID} を使って、考える限りたくさんの侮辱を送ることができ
ます。その楽しさを考えてみて下さい! その人はそれらを決してみることはあり
ません! わぉ!

@node Not Reading Mail
@subsection メールを読むのではない

メールバックエンドを使い始めると、それらにはあなたがそれらでメールを読み
たいと思っていると仮定するといううるさい癖があります。これはもっともでな
いことではないかもしれませんが、あなたの望むことではないかもしれません。

もし @code{mail-sources} と @code{nnmail-spool-file} を @code{nil} に設
定すると、どのバックエンドも入ってくるメールを読もうと試みることはなく、
望むことの手助けになるでしょう。

@vindex nnbabyl-get-new-mail
@vindex nnmbox-get-new-mail
@vindex nnml-get-new-mail
@vindex nnmh-get-new-mail
@vindex nnfolder-get-new-mail
例えば、@code{nnml} でメールを読むことに非常に満足していて、古
い Rmail ファイルが @code{nnbabyl} で隠されているのをさっと見たいだけな
ら、これは余分でしょう。すべてのバックエンドは バックエンド-
@code{get-new-mail} という変数を持っています。もし @code{nnbabyl} のメー
ル読み込みを使用不可にしたいのであれば、グループの仮想サーバー
を @code{nnbabyl-get-new-mail} を @code{nil} に設定するように編集します。

すべてのメールバックエンドは入ってくるメールを読み込むときに、保存される
べき記事に範囲を狭めて @code{nn}*@code{-prepare-save-mail-hook} を呼びま
す。

@node Choosing a Mail Back End
@subsection メールバックエンドを選ぶ

Gnus はメールグループを動作するようにするとメールスプールを読み込みます。
メールファイルはまずあなたのホームディレクトリーに複写されます。その後に
何が起こるかはメールをどの様式で溜めたいかによって変わります。

標準の Gnus では六つの違ったメールバックエンドがあり、個別にさらなるバッ
クエンドを使用可能です。ほとんどの人が使うメールバックエンドは (それがた
ぶん最速だから) @code{nnml} です (@pxref{Mail Spool})。

@menu
* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Rmail Babyl::                 Emacs のプログラムは Rmail の Babyl フォーマットを使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察
@end menu

@node Unix Mail Box
@subsubsection Unix メールボックス
@cindex nnmbox
@cindex unix mail box

@vindex nnmbox-active-file
@vindex nnmbox-mbox-file
@dfn{nnmbox} バックエンドはメールを蓄蔵するために標準の Un*x mbox ファイ
ルを用います。@code{nnmbox} はそれぞれのメール記事にそれがどのグループに
属しているかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

@table @code
@item nnmbox-mbox-file
@vindex nnmbox-mbox-file
利用者のホームディレクトリーのメールボックスの名前。既定値
は @file{~/mbox} です。

@item nnmbox-activate-file
@vindex nnmbox-active-file
メールボックスのアクティブファイルの名前。既定値
は @file{~/.mbox-active} です。

@item nnmbox-get-new-mail
@vindex nnmbox-get-new-mail
@code{nil} でなければ、@code{nnmbox} は入って来たメールを読み込んでグルー
プに分割します。既定値は @code{t} です。
@end table

@node Rmail Babyl
@subsubsection Rmail Babyl
@cindex nnbabyl
@cindex Rmail mbox

@vindex nnbabyl-active-file
@vindex nnbabyl-mbox-file
@dfn{nnbabyl} バックエンドはメールを蓄蔵するために Babyl メールボック
ス (別名 @dfn{Rmail mbox}) を使います。@code{nnbabyl} はそれぞれの記事に
それがどのグループに属しているかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

@table @code
@item nnbabyl-mbox-file
@vindex nnbabyl-mbox-file
Rmail mbox ファイルの名前。既定値は @file{~/RMAIL} です。

@item nnbabyl-active-file
@vindex nnbabyl-active-file
rmail box のためのアクティブファイルの名前。既定値
は @file{~/.rmail-active} です。

@item nnbabyl-get-new-mail
@vindex nnbabyl-get-new-mail
@code{nil} でなければ、@code{nnbabyl} は入ってくるメールを読み込みます。
既定値は @code{t} です。
@end table

@node Mail Spool
@subsubsection メールスプール
@cindex nnml
@cindex mail @acronym{NOV} spool

@dfn{nnml} スプールメール様式は他の知られた様式とは互換性がありません。
それは少し注意して使われるべきです。

@vindex nnml-directory
もしこのバックエンドを使うと、Gnus は入ってくるメールを、それぞれのメー
ルを 1 ファイルとしてファイルに分割し、記事を変
数 @code{nnml-directory} で指定されたディレクトリーの下の対応するディレ
クトリーに入れます。ディフォルトの値は @file{~/Mail/} です。

前もってディレクトリーを作っておく必要はありません。それの面倒は Gnus が
見てくれます。

もしあなたのアカウントに蓄積できるファイルの数に厳密な制限があるなら、こ
のバックエンドを使うべきではありません。それぞれのメールはそれ自身のファ
イルを得るので、数週間でたくさんの iノードを占有する可能性は十分にありま
す。別にこれが問題でなく、親切なシステム管理者が、気が狂ったよう
に ``誰が私の iノードを食いつぶしているんだ? 誰だ? 誰!?'' と叫びながら歩
き回ることが問題でないなら、これがおそらく使うことのできる一番速い様式で
あるということは知っておくべきでしょう。新しいメールを読むためだけに大き
な mbox ファイルを重い足取りで探す必要はありません。

@code{nnml} は記事分割に関してはおそらく一番遅いバックエンドでしょう。そ
れは多くのファイルを作らなければならず、それは入ってくるメールのため
の @acronym{NOV} データベースも作成しなければなりません。これのために、
メールを読むことに関してはたぶん最速のバックエンドになります。

@cindex self contained nnml servers
@cindex marks
印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
@code{nnml} サーバーは @code{tar} などを使ってバックアップしたり、後であ
なたが付けた印がすべて保たれた状態で Gnus に戻す (本来の @code{nnml} サー
バーによって追加する) ことができる特質を持つようになります。グループの印
はそれぞれの @code{nnml} グループのディレクトリー内の、通
常 @file{.marks} ファイル (@code{nnml-marks-file-name} を参照) に格納さ
れます。また、個々の @code{nnml} グループについてもバックアップすること
が可能で、(バックアップを nnml ディレクトリーに戻した後で) @kbd{G m} キー
を使ってそのグループを元に戻します。

もし何らかの理由によって @file{.marks} ファイルがおかしくなっていると思っ
たときは、単にそれら全部を消してしまうことができます。Gnus は次回起動す
るときに、それらを正しく再作成するでしょう。

仮想サーバーの設定:

@table @code
@item nnml-directory
@vindex nnml-directory
すべての @code{nnml} ディレクトリーはこのディレクトリーの下に置かれます。
既定値は @code{message-directory} の値 (その既定値は @file{~/Mail}) です。

@item nnml-active-file
@vindex nnml-active-file
@code{nnml} サーバーのためのアクティブファイル。既定値
は @file{~/Mail/active} です。

@item nnml-newsgroups-file
@vindex nnml-newsgroups-file
@code{nnml} グループ記述ファイル。@xref{Newsgroups File Format}. 既定値
は @file{~/Mail/newsgroups} です。

@item nnml-get-new-mail
@vindex nnml-get-new-mail
@code{nil} でなければ、@code{nnml} は入って来たメール読み込みます。既定
値は @code{t} です。

@item nnml-nov-is-evil
@vindex nnml-nov-is-evil
@code{nil} でなければ、このバックエンドはどの @acronym{NOV} ファイルも無
視します。既定値は @code{nil} です。

@item nnml-nov-file-name
@vindex nnml-nov-file-name
@acronym{NOV} ファイルの名前。ディフォルトは @file{.overview} です。

@item nnml-prepare-save-mail-hook
@vindex nnml-prepare-save-mail-hook
保存する前に記事に範囲を狭めて実行するフックです。

@item nnml-marks-is-evil
@vindex nnml-marks-is-evil
非-@code{nil} であると、このバックエンドはいかなる @sc{印} ファイルも無
視します。ディフォルトは @code{nil} です。

@item nnml-marks-file-name
@vindex nnml-marks-file-name
@dfn{印} ファイルの名前です。ディフォルトは @file{.marks} です。

@item nnml-use-compressed-files
@vindex nnml-use-compressed-files
非-@code{nil} だったら @code{nnml} はメッセージファイルを圧縮します。た
だし @code{auto-compression-mode} が有効になっていなければなりませ
ん (@pxref{Compressed Files, ,Compressed Files, emacs, The Emacs
Editor})。

@item nnml-compressed-files-size-threshold
@vindex nnml-compressed-files-size-threshold
メッセージファイルを圧縮するかどうかを判断するための、サイズの閾値です。
@code{nnml-use-compressed-files} が非-@code{nil} に設定されていて、本文
の文字数がこの変数の値より大きかったら、メッセージファイルは圧縮されます。
@end table

@findex nnml-generate-nov-databases
@code{nnml} グループと @acronym{NOV} ファイルが完全に良い状態でなくなっ
てしまったなら、@kbd{M-x nnml-generate-nov-databases} と打つことによって、
完全に更新することができます。この命令は、それぞれすべてのファイルを見る
ことによって @code{nnml} 階層全体をトロール魚網でさらうので、それが終わ
るまでには時間がかかるかもしれません。この機能へのより良いインターフェー
スはサーバーバッファーで見つかるでしょう (@pxref{Server Commands})。

@node MH Spool
@subsubsection MH スプール
@cindex nnmh
@cindex mh-e mail spool

@code{nnmh} は、@acronym{NOV} データベースを作らないこととアクティブファ
イルや印ファイルを保持しないことを除いて、@code{nnml} と似ています。その
ことは @code{nnmh} を @code{nnml} より @emph{かなり} 遅いバックエンドに
していますが、それは procmail のスクリプトを書くためにずっとやりやすくなっ
てもいます。

仮想サーバーの設定:

@table @code
@item nnmh-directory
@vindex nnmh-directory
すべての @code{nnmh} ディレクトリーはこのディレクトリーの下に置かれます。
既定値は @code{message-directory} の値 (その既定値は @file{~/Mail}) です。

@item nnmh-get-new-mail
@vindex nnmh-get-new-mail
@code{nil} でなければ、@code{nnmh} は入ってくるメールを読み込みます。既
定値は @code{t} です。

@item nnmh-be-safe
@vindex nnmh-be-safe
@code{nil} でなければ、@code{nnmh} はフォルダーにある記事が実際
に Gnus が考えているものと同じであるかを調べるという馬鹿げたことをやりま
す。それは日付と目に入るすべての情報を調べるので、これを @code{t} に設定
することは深刻な速度低下が起こるということです。もし @code{nnmh} 記事を
読むのに Gnus 以外のものを使っていないのであれば、この変数を @code{t} に
設定する必要はありません。既定値は @code{nil} です。
@end table

@node Maildir
@subsubsection Maildir
@cindex nnmaildir
@cindex maildir

@code{nnmaildir} は Gnus のグループに対応した各々
の maildir に maildir フォーマットでメールを格納します。このフォーマッ
トは @uref{http://cr.yp.to/proto/maildir.html} およ
び @uref{http://www.qmail.org/man/man5/maildir.html} で文書化されていま
す。また @code{nnmaildir} は maildir の中の @file{.nnmaildir/} ディレク
トリーに特別な情報を格納します。

Maildir フォーマットはロックを必要としない同時配送と講読を可能にするため
に設計されました。他のバックエンドでは、メールを何らかのスプールに渡して
そのスプールからグループに分割するために Gnus を設定しなければならないで
しょう。それは今まで通り @code{nnmaildir} で行なうことができますが、もっ
と一般的な設定は Gnus のグループとして現われる maildir にメールを直接配
送することです。

@code{nnmaildir} は完全に信頼できることを目指しています: @kbd{C-g} はメ
モリー中のデータを壊さないし、@code{SIGKILL} がファイルの中のデータを壊
すことはありません。

@code{nnmaildir} は記事の印と @acronym{NOV} データをそれぞれの maildir
に格納します。それによって、ある Gnus の環境から別の場所に maildir 全体
をコピーすることができ、印は保存されます。

仮想サーバーの設定:

@table @code
@item directory
それぞれの @code{nnmaildir} サーバー (一つを越えるサーバーが必要だとはと
ても思えませんが) に対してディレクトリーを作り、それを maildir また
は maildir へのシンボリックリンクとして実装する必要があります (他の目的
のためにすでに使われているディレクトリーを選んではいけません)。それぞれ
の maildir は、そのサーバーのニュースグループとして Gnus に現れ、シンボ
リックリンクのファイル名がそのグループの名前になります。ディレクトリーに
ある @samp{.} で始まるどんなファイル名も無視されます。ディレクトリーは最
初に Gnus を起動したときとグループバッファーで @kbd{g} をタイプしたとき
はいつでも走査され、どれかの maildir が削除または追加されたとき
に @code{nnmaildir} は通知します。

@code{directory} パラメーターの値は Lisp 式でなければなりません。
@code{eval} で処理された後で、@code{expand-file-name} によってこのサーバー
のためのディレクトリーのパスを獲得します。その結果得られた文字列が、サー
バーが閉じられるまで使われます (もし、式や @code{eval} を知らなくでも心
配ご無用; 単なる文字列で動作します)。このパラメーターは任意ではなく、設
定しなければなりません。@code{"~/Mail"} やそれのサブディレクトリーを使う
ことは推奨できません。いくつかの Gnus の他の部分がそれをディフォルトでい
ろんなものに使うので、@code{nnmaildir} でもそれを使うと混乱するかもしれ
ません。@code{"~/.nnmaildir"} が一般的な値です。

@item target-prefix
これは Lisp 式でなければなりません。@code{eval} で処理された後で、
@code{expand-file-name} によって新しい maildir が生成されるディレクトリー
の名前を獲得します。式はサーバーが開通したときだけ @code{eval} され、そ
の結果得られた文字列が、サーバーが閉じられるまで使われます。

@code{nnmaildir} サーバーにグループを作ると、その名前の頭
に @code{target-prefix} が付加された maildir と、その maildir を指し示す
シンボリックリンクが素のグループ名の名前で作成されます。したがって、
@code{directory} が @code{"~/.nnmaildir"} で、
@code{target-prefix} が @code{"../maildirs/"} だった場合に @code{foo} と
いうグループを作ると、@code{nnmaildir} は maildir とし
て @file{~/.nnmaildir/../maildirs/foo} を、@file{../maildirs/foo} へのシ
ンボリックリンクとして @file{~/.nnmaildir/foo} を作成します。

同じ @code{directory} に maildirs とシンボリックリンクの両方を作成するた
めに、スラッシュを含まない文字列を @code{target-prefix} に設定することが
できます。この場合は、名前が @code{target-prefix} で始ま
る @code{directory} で見つかるどの maildir も、グループとは見なされませ
ん (が、それらを指し示すシンボリックリンクがグループになります)。

特別な場合として @code{target-prefix} が @code{""} (ディフォルト) だった
ら、グループを作るときに、@code{directory} において対応するシンボリック
リンクを持たない maildir が作成されます。そのようなグループに対して
は、@code{force} 引数を与えないと @code{gnus-group-delete-group} が使え
ないことに注意して下さい。

@item directory-files
これは @code{directory-files} と同じインターフェースの関
数 (または @code{directory-files} そのもの) でなければなりません。これ
は maildir 用のサーバーの @code{directory} を走査するために使われます。
このパラメーターは任意です。ディフォルト値は、
@code{nnheader-directory-files-is-safe} が @code{nil} だった
ら @code{nnheader-directory-files-safe} で、それ以外の場合
は @code{directory-files} で
す (@code{nnheader-directory-files-is-safe} はサーバーが開通したときに一
回だけ検査されますが、ディレクトリーが走査されるときに毎回チェックさせた
いのならば、それを行なう関数をあなたが自前で用意する必要があります)。

@item get-new-mail
非-@code{nil} にしておくと、いつもの通りにグループの maildir 自体におい
て新着メールを走査した後で、このサーバー
は @code{nnmail-split-methods} か @code{nnmail-split-fancy} によ
る @code{mail-sources} から、従来の Gnus の方法でメールを取り込みます。
ディフォルト値は @code{nil} です。

@code{mail-sources} と @code{nnmaildir} グループの両方で同じ maildir を
使っては @emph{いけません}。その結果は運良く有益になるかもしれませんが、
そんな意図では設計されていません。将来は違う結果をもたらす可能性がありま
す。あなたの分割規則が新しいグループを作るようになっている場合は、
@code{create-directory} サーバーパラメーターを与えることを忘れないで下さ
い。
@end table

@subsubsection グループパラメーター

@code{nnmaildir} はいくつかのグループパラメーターを使います。これらのす
べてを無視しても安全です。ディフォルトの @code{nnmaildir} の動作は、他の
メールバックエンドのディフォルト (記事が一週間後に消去される、など) と同
じです。期限切れ消去のパラメーターを除いて、この機能はすべ
て @code{nnmaildir} に特有です。したがって、別のバックエンドですでに行なっ
ている動作を単に踏襲させようというのであれば、これを無視することができま
す。

これらのパラメーターのうちのどれでも、その値がベクトルである場合は、オリ
ジナルの値に代わって、第一の要素が Lisp 式として評価された結果が使われま
す。値がベクトルでない場合は、その値そのものが Lisp 式として評価されます。
(そのため、これらのパラメーターは他とは違う名前、違うけれども似た意味を
持つ他のバックエンドでサポートされている同様のパラメーター、を使います。)
(数、文字列、@code{nil}、および @code{t} については、@code{eval} の関与
を再び無視することができます。他の値について、それが適切な場合には、余分
なクオートを使い、かつベクトルで値を包むことを忘れないで下さい。)

@table @code
@item expire-age
記事が消去されるまでの寿命の秒数を整数で、またはシンボル @code{never} で
記事が期限切れ消去されてはならないことを指定します。このパラメーターが設
定されていないと、いつも
の @code{nnmail-expiry-wait} (@code{-function}) 変
数 (@code{expiry-wait}(@code{-function}) グループパラメーターが設定され
ていると、それが優先される) を最後のよりどころにします。3日の値が欲しい
ならば、@code{[(* 3 24 60 60)]} のようなものを使って下さい。
@code{nnmaildir} は式を評価して、その結果を使います。記事の寿命は記事ファ
イルの変更時刻を基点に計測されます。通常これは記事が配送された時刻と同じ
ですが、記事の編集はそれを若くします。(期限切れ消去以外の) 記事の移動も
また、記事を若くしてしまうでしょう。

@item expire-group
これが文字列 (@code{"backend+server.address.string:group.name"} のような
完全な Gnus のグループ名) で、かつそのパラメーターが同じ名前のグループに
属さない場合、期限切れ消去が行なわれる際に、記事は消去される前に指定され
たグループに移動させられます。@emph{これが @code{nnmaildir} グループに設
定されると、移動先のグループにおいて、記事が元のグループにあったときとちょ
うど同じだけ古くなります。} したがって、移動先のグループにおけ
る @code{expire-age} には注意して下さい。これがパラメーターが属するのと
同じグループの名前に設定されると、記事はまったく期限切れ消去されません。
ベクトル式を使うと、最初の要素が一回、それぞれの記事について評価されます。
したがって、記事をどこに置くかを決めるために、その式
は @code{nnmaildir-article-file-name} などに照会することができます。
@emph{このパラメーターが設定されていないと、
@code{nnmaildir} は @code{expiry-target} グループパラメーター
や @code{nnmail-expiry-target} 変数を顧みません。}

@item read-only
これが @code{t} に設定されていると、@code{nnmaildir} はその記事をこのグ
ループで読み出し専用として扱います。この意味は、記事は @file{new/} か
ら @file{cur/} に改名されない、記事は @file{cur/} ではな
く @file{new/} でのみ見つかる、記事は消去されない、記事は編集できない、
ということです。@file{new/} は他の maildir の @file{new/} ディレクトリー、
例えばみんなが興味があるメーリングリストを含んでいるシステムで共通のメー
ルボックス、へのシンボリックリンクであると想定されます。@file{new/} 以外
の maildir にあるすべてのものは、読み出し専用として扱われ @emph{ません}。
したがって共有のメールボックスに対しては、あなた自身の maildir を設定す
る (または 共有のメールボックスに書き込み権限を持つ) 必要が依然としてあ
ります。あなたの maildir は記事の余分なコピーをまったく含まないでしょう。

@item directory-files
@code{directory-files} と同じインターフェースの関数です。記事を見つける
ために、このグループに対応する maildir のディレクトリーを走査するために
使われます。ディフォルトはサーバーの @code{directory-files} パラメーター
で設定されている関数です。

@item distrust-Lines:
非-@code{nil} であると、@code{nnmaildir} は @code{Lines:} ヘッダーフィー
ルドを使う代わりにいつも記事の行数を数えます。@code{nil} だった場合は、
あればそのヘッダーフィールドが使われます。

@item always-marks
@code{['(read expire)]} のような印シンボルのリストです。Gnus が記事の印
を @code{nnmaildir} に尋ねるときはいつでも、ファイルシステムに格納されて
いる印が何であるかとは無関係に、@code{nnmaildir} はすべての記事がこれら
の印を持っていると答えます。これは構想を試すための機能で、おそらく結局は
削除されるでしょう。それは Gnus 本体で行なわれるか、あるいは有益でなけれ
ば放棄されるべきです。

@item never-marks
@code{['(tick expire)]} のような印シンボルのリストです。Gnus が記事の印
を @code{nnmaildir} に尋ねるときはいつでも、ファイルシステムに格納されて
いる印が何であるかとは無関係に、@code{nnmaildir} はこれらの印を持ってい
る記事は無いと答えます。@code{never-marks} は @code{always-marks} よりも
優先されます。これは構想を試すための機能で、おそらく結局は削除されるでしょ
う。それは Gnus 本体で行なわれるか、あるいは有益でなければ放棄されるべき
です。

@item nov-cache-size
@acronym{NOV} メモリーキャッシュのサイズを指定する整数です。スピードアッ
プのために、@code{nnmaildir} はそれぞれのグループの限定された数の記事に
対して、メモリー上に @acronym{NOV} データを保持します。(これはたぶん有用
ではなく、将来はおそらく削除されるでしょう)。このパラメーターの値は、サー
バーが開通した後で最初にグループが見られたとき、すなわち一般には最初
に Gnus を起動したとき、だけ注目されます。サーバーが閉じられて再び開通さ
れるまでは、@acronym{NOV} キャッシュのサイズは変更されません。ディフォル
トは概略バッファーに表示される記事の数の見積り (@code{tick} 印があっ
て @code{read} が無い記事の数に少々の余分を加えたもの) です。
@end table

@subsubsection 記事の識別
記事はそれぞれの maildir の @file{cur/} ディレクトリーに格納されます。各々
の記事には @code{uniq:info} のような名前が付けられます。ここ
で @code{uniq} はコロンを含みません。@code{nnmaildir} は @code{:info} の
部分を保持しますが無視します。(他の maildir リーダーは一般に印を格納する
ためにこの部分を使います。) @code{uniq} の部分は記事をユニークに識別し、
maildir の @file{.nnmaildir/} サブディレクトリーの色々な場所に記事に関連
した情報を格納するために使われます。概略バッファーで記事を要求した後で、
記事の完全なパス名が @code{nnmaildir-article-file-name} 変数から得られま
す。

@subsubsection NOV データ
@code{uniq} によって識別される記事は、その @acronym{NOV} データ (概略バッ
ファーの行を生成するために使われる) を @file{.nnmaildir/nov/uniq} に格納
します。@code{nnmaildir-generate-nov-databases} 関数はありません。(その
必要はあまりありません。記事の @acronym{NOV} データは記事
か @code{nnmail-extra-headers} が変化したときに自動的に更新されま
す。) 対応する @acronym{NOV} ファイルをただ消すことによって単一の記事
の @acronym{NOV} データの生成を @code{nnmaildir} に強制することはできま
す。しかし @emph{ご用心}。これは @code{nnmaildir} がこの記事に新しい記事
番号を割り振らせ、@code{seen} 印、エージェント、およびキャッシュにとって
面倒なことになります。

@subsubsection 記事の印
@file{.nnmaildir/marks/flag/uniq} ファイルがある場合に、@code{uniq} によっ
て識別される記事は、@code{flag} 印を持つものと考えられます。
Gnus が @code{nnmaildir} にグループの印を尋ねると、@code{nnmaildir} はそ
のようなファイルを探して、見つけた印のセットを報告します。
Gnus が @code{nnmaildir} に印のセットの格納を要求すると、
@code{nnmaildir} は必要な対応するファイルを生成し、または消去します。(実
際は、それぞれの印のために新しいファイルを作るのではなく、iノード を節約
するために単に @file{.nnmaildir/markfile} へのハードリンクを張ります。)

@file{.nnmaildir/marks/} に新しいディレクトリーを作ることによって、新し
い印を創造することができます。印を保持しつつ maildir を tar でまとめてサー
バーからそれを削除し、後で tar をほどくことができます。印ファイルを作成
または消去することによって、あなた自身が印を追加または削除することができ
ます。Gnus が動作していて @code{nnmaildir} サーバーが開通しているときに
これを行なう場合は、最初にすべての @code{nnmaildir} グループの概略バッ
ファーから退出してグループバッファーで @kbd{s} をタイプし、その後グルー
プバッファーで @kbd{g} か @kbd{M-g} をタイプするのが最良です。そうしない
と Gnus は変更を捉えてくれずに、それらを元に戻してしまうかもしれません。

@node Mail Folders
@subsubsection メールフォルダー
@cindex nnfolder
@cindex mbox folders
@cindex mail folders

@code{nnfolder} はそれぞれのメールグループを違ったファイルに蓄蔵するバッ
クエンドです。それぞれのファイルは標準の Un*x mbox 様式です。
@code{nnfolder} は記事番号と到着日を記録しておくための追加のヘッダーを加
えます。

@cindex self contained nnfolder servers
@cindex marks
印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
@code{nnfolder} サーバーは @code{tar} などを使ってバックアップしたり、後
であなたが付けた印がすべて保たれた状態で Gnus に戻す (本来
の @code{nnfolder} サーバーによって追加する) ことができる特質を持つよう
になります。グループの印は @code{nnfolder} ディレクトリー内の、mbox ファ
イルに通常 @file{.mrk} (@code{nnfolder-marks-file-name} を参照) が付加さ
れた名前のファイルに格納されます。また、個々の @code{nnfolder} グループ
についてもバックアップすることが可能で、(バックアップを nnfolder ディレ
クトリーに戻した後で) @kbd{G m} キーを使ってそのグループを元に戻します。

仮想サーバーの設定:

@table @code
@item nnfolder-directory
@vindex nnfolder-directory
すべての @code{nnfolder} メールボックスはこのディレクトリーの下に置かれ
ます。既定値は @code{message-directory} の値 (その既定値
は @file{~/Mail}) です。

@item nnfolder-active-file
@vindex nnfolder-active-file
アクティブファイルの名前。既定値は @file{~/Mail/active} です。

@item nnfolder-newgroups-file
@vindex nnfolder-newsgroups-file
グループ記述ファイルの名前。@xref{Newsgroups File Format}. 既定値
は @file{~/Mail/newsgroups"} です。

@item nnfolder-get-new-mail
@vindex nnfolder-get-new-mail
@code{nil} でなければ、@code{nnfolder} は入ってくるメールを読み込みます。
既定値は @code{t} です。

@item nnfolder-save-buffer-hook
@vindex nnfolder-save-buffer-hook
@cindex backup files
フォルダーを保存する前に実行されるフックです。@code{nnfolder} バッファー
に対してさえも Emacs は通常のバックアップの変名をすることに注意して下さ
い。この機能を無効にしたいのであれば、@file{.emacs} ファイルで次のような
ことをすることができます:

@lisp
(defun turn off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)
@end lisp

@item nnfolder-delete-mail-hook
@vindex nnfolder-delete-mail-hook
これから消去されるメッセージに範囲を狭められて実行されるフックです。この
関数は別のところにメッセージをコピーしたり、消去するまえに何らかの情報を
取り出すために使ったりすることができます。

@item nnfolder-nov-is-evil
@vindex nnfolder-nov-is-evil
もし非-@code{nil} なら、このバックエンドは @acronym{NOV} ファイルを無視
します。既定値は @code{nil} です。

@item nnfolder-nov-file-suffix
@vindex nnfolder-nov-file-suffix
@acronym{NOV} ファイルの拡張子です。ディフォルトは @file{.nov} です。

@item nnfolder-nov-directory
@vindex nnfolder-nov-directory
@acronym{NOV} ファイルが格納されるディレクトリーです。@code{nil} だった
ら @code{nnfolder-directory} が使われます。

@item nnfolder-marks-is-evil
@vindex nnfolder-marks-is-evil
非-@code{nil} であると、このバックエンドはいかなる @sc{印} ファイルをも
無視します。ディフォルトは @code{nil} です。

@item nnfolder-marks-file-suffix
@vindex nnfolder-marks-file-suffix
@sc{印} ファイルの拡張子です。ディフォルトは @file{.mrk} です。

@item nnfolder-marks-directory
@vindex nnfolder-marks-directory
@sc{印} ファイルが格納されるディレクトリーです。@code{nil} だった
ら @code{nnfolder-directory} が使われます。
@end table

@findex nnfolder-generate-active-file
@kindex M-x nnfolder-generate-active-file
@code{nnfolder} で読みたいと思う、たくさんの @code{nnfolder} のようなファ
イルを持っているのであれば、
@code{nnfolder} に @code{nnfolder-directory} にあるすべてのそのようなファ
イルに気付かせるために、@kbd{M-x nnfolder-generate-active-file} 命令を使
うことができます。これは長いファイル名を使っているときにのみ動作しますが。

@node Comparing Mail Back Ends
@subsubsection メールバックエンドの比較

まず、用語として、@dfn{バックエンド} (back end) は低次の接続方法のための
普通の語です---もし望むなら、透過的であり、それは何かを成し遂げるもので
す。そのこころは、メールはどこからか来なければならず、適切なバックエンド
の選択は、メールを Gnus のすぐ近くに取得するために要求される、というもの
です。

同じ概念が Usenet 自身にも存在します。記事への接触は今日では、普通
は @acronym{NNTP} でなされますが、昔々の憂鬱な深夜の時代は、皆は記事が存
在するマシン (今日では @acronym{NNTP} サーバーと呼ぶもの) でリーダーを動
かし、リーダーからの接続は、直接記事のディレクトリースプールに踏み込むと
いうものでした。それでも、たまたまサーバー (もしくは、NFS でスプールが読
めるような場合) にいるような場合は、これらの方法を選ぶため
に @code{nntp} や @code{nnspool} バックエンドのどちらかを選ぶことができ
ました。

メールバックエンドを選択することのゴールは、元の形式を扱うのに適した方法
と、将来使用するために便利な形式にメールを残すことの両方を同時に表現する
ことです。それぞれには良い点と悪い点がいくつかあります:

@table @code
@item nnmbox

UNIX システムは歴史的に単一の、非常に一般的な、うまく定義された形式を持っ
ています。すべてのメッセージは単一の @dfn{スプールファイル} に到着し、正
規表現 @samp{^From_} に合致する行で区切られています。(私の @samp{_} の記
号の使用はスペースを意味するためで、この例ではこれは RFC で指定されてい
る @samp{From:} ヘッダーで無いことを明らかにするためです。) Emacs は、そ
れに Gnus も、歴史的に Unix 環境から広まりましたので、元の mailbox 形式
をあまりぐちゃぐちゃにしないというのは、最も簡素な方法です。ですから、こ
のバックエンドを選ぶと、本当のスプールからメールを取得して、Gnus の好む
ディレクトリーにメールを移動するための Gnus の主な活動は、単に、実行過程
で何も (評価できる) 変更をせずに複製することです。それは Gnus の環境の使
用可能範囲にメールを移動する ``最も愚かな''方法です。これは定められた場
所に移動するのを速くしますが、Gnus がどこに何があるかを調べるときは、解
析が遅くなります。

@item nnbabyl

むかしむかし、TOPS と呼ばれるオペレーティングシステムや、似たようなもの
を実行している DEC-10 と DEC-20 というものがあり、普通の (唯一の?) メー
ルを読む環境は Babyl と呼ばれるものでした。そのシステムに着いたメールが
どのような形式になっていたかは知りませんが、Babyl はメールが変換される、
それ用の内部形式を持っており、主に、Babyl 特有のヘッダーと状態ビットをファ
イルのそれぞれのメッセージの先頭に加えることをしていました。
Rmail は Emacs の最初のメールリーダーで、Richard Stallman によって書かれ、
Stallman はその TOPS/Babyl 環境の出身であるため、Rmail をすでに存在して
いたメールファイルの一族を理解する様に書きました。Gnus は (この問題に関
しては VM も) この形式をサポートし続けています。それは、そのメーラー特有
のヘッダー/ビットというものがなかなか質が良いと考えられているからです。
Rmail 自身ももちろんまだ存在していて、まだ Stallman によって維持されてい
ます。

上の形式の両方はメールをファイルシステムの単独のファイルに入れ、メールを
見るたびに、ファイル全体を解析しなければなりません。

@item nnml

@code{nnml} はほとんど @code{nnspool} 接続の Usenet システムを操作してい
るような感じのするバックエンドです。(実際のところ、すごく以前に、
@code{nnml} は @code{nnspool} から枝分かれしたものだと思います。)
メールは元のスプールファイルから取り出され、それから個々のファイル
に 1:1 で分けられます。Usenet 様式のアクティブファイル (INN や CNews に
基づいたニュースシステムで (例えば) @file{/var/lib/news/active} や、動
詞 @samp{NNTP LIST} で返されるものに類似したもの) を維持し、今からだとか
なり前に @acronym{NNTP} サーバーのために定義されている、
@dfn{overview} ファイルも、グループへ入るときの効率のために作成します。
メール分割では、たくさんのファイルの作成と、@code{nnml} アクティブファイ
ルの更新、メッセージ毎の overview への追加のために遅くなりますが、使用時
にはアクティブファイルと overview での索引機能により、とてつもなく速くな
ります。

@code{nnml} は @dfn{inode} を非常にたくさん消費します。すなわち、ファイ
ルシステムで新しいファイルを入れるための可能な場所を定義する資源をたくさ
ん占有します。システム管理者は、かっちりした共有ファイルシステムでの大量
の inode の占有を快く思いません。しかし、ファイルシステムが自分自身のも
のである個人マシン上で生活しているなら、@code{nnml} は非常に大きな利点が
あります。

また、FAT16 の Windows の世界に生きているなら、問題があるでしょう。たく
さんの小さなファイルで多くの場所を取られてしまいます。

@item nnmh

Rand MH メール閲覧システムは UNIX システムにかなり長い間存在しています。
メッセージのスプールファイルを個々のファイルに分割することにより操作しま
すが、索引機能が少しか、まったくないかという程度です---@code{nnmh} は意
味的には ``@code{nnml} にアクティブファイルと overview のないもの'' と等
価です。これは議論のあるところですが、最悪の選択です。というのは、個々の
ファイルの作成の遅さが、グループで何が新しいかを知るときの解析のための使
用の遅さが結び付くからです。

@item nnfolder

基本的に @code{nnfolder} の効果はグループ毎の @code{nnmbox} (上で説明さ
れている最初の方法) です。すなわち、@code{nnmbox} 自身は @emph{すべ
て} のメールを一つのファイルに入れます; @code{nnfolder} はメールグループ
それぞれが Unix mail box ファイルを持つように少し最適化をします。
@code{nnmobx} よりも、それぞれのグループを別に解析するので速く、そのうえ
メールを移動させるのに最小限の労力を要求する単純な Unix mail box 形式を
提供します。加えて、Gnus がそれぞれの別のグループにどのくらいのメッセー
ジがあるかを調べるための ``アクティブ'' ファイルを維持します。

もしたくさんの量のメッセージを受け取ることが予想されるグループがあるなら、
@code{nnfolder} は最善の選択ではありませんが、それなりの量のメールしか受
け取らないなら、おそらく @code{nnfolder} はすべての中で一番適したバック
エンドでしょう。

@item nnmaildir

期限切れ消去や他のことがらを設定するのに、@code{nnmaildir} は他のメール
バックエンドとは少々異なった、互換性の無いグループパラメーターを使います。

@code{nnmaildir} は大方 @code{nnml} と似たものですが、いくらか顕著な違い
があります。それぞれのメッセージは別々のファイルに格納されますが、ファイ
ル名は Gnus の記事番号と関係がありません。ま
た @code{nnmaildir} は @code{nnml} の overview に相当するファイルを記事
ごとに一つ格納するので、@code{nnml} の約二倍の量の iノードを使います。
(@code{df -i} を使って iノードの割り当てがどれほどたくさんあるかを調べて
下さい。) そのために遅くなったり多くの場所を取ってしまうようならば、
@uref{http://www.namesys.com/, ReiserFS} や他の非ブロック構造のファイル
システムへの転換を検討して下さい。

maildir は受信配送のためのロックを必要としないので、あなたがグループとし
て使っている maildir は、配送されてきたメールを直接受け取るため
の maildir にすることもできます。これは、メールが配送されてくる過程で異
なるメールボックスに仕分されるようになっているのならば、Gnus のメール分
割を省略できることを意味します。@code{mail-sources} におけ
る @code{directory} の項には似た効果がありますが、配送されてくるメールを
スプールするためのメールボックスの一揃い (mbox 形式ではそのためにメッセー
ジの本文が壊れる) と、他の (何であれあなたの好みの形式の) グループとして
使われる組が必要です。maildir は @code{new/} サブディレクトリーに置かれ
る組み込みスプールです。メール分割が二重チェックのような扱いを受けない代
わりに、メールを @code{new/} から @code{cur/} に移動することに、今のとこ
ろは気を付けて下さい。

@code{nnmaildir} はグループの記事の印を、それに対応する maildir に格納し
ます。Gnus の外からそれらを簡単に操作できるようにするために、そのように
作られているのです。maildir を tar でまとめてから別のどこかで展開しても、
印はそのままです。@code{nnml} も印を格納しますが、
@code{nnmaildir} で Gnus の外からそれらを使うように簡単ではありません。

@code{nnmaildir} は速度を上げるためにかなりの量のメモリを使います。
(@code{nnml} の場合はファイルに格納し、@code{nnmh} では何度も記事ファイ
ルを解析して得るものごとを、それはメモリ上に保持します。) これがあなたに
とって問題ならば、@code{nov-cache-size} グループパラメーターを何か小さな
値 (0 はおそらくだめだが 1 だったらたぶん動く) に設定することによって、
少ないメモリを使うようにすることができます。このキャッシュ機構は、おそら
く将来は削除されるでしょう。

起動は他のバックエンドよりも @code{nnmaildir} が遅いでしょう。ファイルシ
ステムに依存している部分以外のすべては速いでしょう。

@code{nnmaildir} は @code{nnoo} を使わないので、@code{nnmaildir} から派
生したバックエンドを書くのに @code{nnoo} は使えません。
@end table

@node Browsing the Web
@section Browsing the Web
@cindex web
@cindex browsing the web
@cindex www
@cindex http

ウェブに基づいた議論の場はどんどん広まっています。多くの分野で、ウェブの
掲示板は最も重要な場になり、メーリングリストやニュースグループの重要性を
翳らせています。理由は簡単です---新しい利用者が使い易いからです。ただ場
所をクリックするだけで、議論の場があります。メーリングリストでは、面倒な
購読手続きをしなければならず、ほとんどの人はニュースグループがどこにある
かすら知りません。

この筋書きの問題は、ウェブブラウザーはニュースリーダーとしてはあまり良く
ないということです。どんな記事を読んだかを記録しません。興味のある表題に
スコアを付けることができません。オフラインで読むことができません。何度も
クリックすることを要求し、最後にはあなたは嫌になります。

それで---ウェブブラウザーが掲示板を読むのに適していないのなら、どうして
代わりに Gnus を使わないのでしょう?

Gnus はこれらのソースへの界面を提供するバックエンド群を少し備えつつあり
ます。

@menu
* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* RSS::                         RDF Site Summary を読む
* Customizing w3::              Gnus から Emacs/W3 を操作する
@end menu

すべてのウェブソースは、動作させるために Emacs/W3 と url ライブラリが必
要です。

これらのウェブソースの一番の問題は長期間は動作しない可能性が高いことです。
@acronym{HTML} データから情報を集めるのはせいぜい推測で、構造が変化した
ときには、Gnus バックエンドは動作しません。でも、ある程度新しいバージョ
ンのバックエンドを使っていれば大丈夫のはずです。

これらのウェブ方法に共通することは、ウェブソースはしばしば落ちていたり、
使用可能でなかったり、単純に楽しむには遅すぎることがある、ということです。
そういう場合には、Gnu Agent (@pxref{Gnus Unplugged}) に記事のダウンロー
ドを任せて、ローカルディスクから好きなときに読むようにすることができます。
これで、World Wide Wait とはおさらばです。

@node Archiving Mail
@subsection メールの保存
@cindex archiving mail
@cindex backup of mail

いくつかのバックエンド、特に @code{nnml}, @code{nnfolder} およ
び @code{nnmaildir} は、それぞれのグループの記事の印を本当に保持します。
これらのサーバーで、グループの印を保ちつつ保存したり元に戻すのはかなり簡
単です。

(でも、グループレベルとグループパラメーターをも保持するには、今までとお
り @file{.newsrc.eld} の神に、舞いと生贄を捧げなければなりませんが。)

@code{nnml}, @code{nnfolder} または @code{nnmaildir} サーバーにまるごと
保存するには、サーバーのディレクトリーを再帰的にコピーします。Gnus を終
了する必要は無いので、保存は @code{cron} やそれに類するものが行なうこと
ができます。データを復帰させるにはディレクトリー木 (tree) を元に戻すこと
で行ない、そのディレクトリーを指し示すように Gnus のサーバーの定義に追加
します。@ref{Article Backlog}, @ref{Asynchronous Fetching} およびその他
は、データを上書きして邪魔をするかもしれないので、あなたはデータを復帰さ
せる前に Gnus を終了する必要があるかもしれません。

個々の @code{nnml}, @code{nnfolder} または @code{nnmaildir} のグループを、
印を保持しつつ保存することもできます。@code{nnml} か @code{nnmaildir} で
は、そのグループのディレクトリーにあるすべてのファイルをコピーします。
@code{nnfolder} では、基本のフォルダーファイル (@file{FOO}) と印ファイ
ル (@file{FOO.mrk}) の両方をコピーする必要があります。グループを元に戻す
のは、グループバッファーで @kbd{G m} キーを使います。その最後の手順によっ
て、Gnus は新しいディレクトリーができたことを知ります。
@code{nnmaildir} は自動的に新しいディレクトリーを知るので、その場
合 @kbd{G m} は不要です。

@node Web Searches
@subsection ウェブ検索
@cindex nnweb
@cindex Google
@cindex dejanews
@cindex gmane
@cindex Usenet searches
@cindex searching the Usenet

それは、なんというか、Usenet から文字列に合致する記事を検索するのはとて
も素晴らしいんだけど、その、あのウェブブラウザーってやつを使って、そんで
もって、宣伝を読ませられるっていうのは、その、なんというか、ほんとう
に @emph{不様ね} というか、それで、Gnus ではブラウザーを使わずに、その、
@emph{超かっこよく} それができる、ってことです。

@code{nnweb} バックエンドは、強力な検索エンジンに対して簡単なインターフェー
スを提供します。@code{nnweb} グループを作成し、検索パターンを入力し、そ
してそのグループに入って他の普通のグループのように記事を読みます。グルー
プバッファー (@pxref{Foreign Groups}) の @kbd{G w} 命令によってお手軽に
これができます。

@code{nnweb} グループは、固定グループになろうとはしません---このグループ
では記事番号はごく一時的なものとして扱います。つまり、@code{nnweb} グルー
プに入るたびに (たとえ検索パターンを変更していなくとも)、記事の順序が違っ
ているかもしれません。また、重複抑制 (@pxref{Duplicate Suppression}) を
使ってもうまく働かないでしょう。というのは、@code{nnweb} は検索エンジ
ン (例えば Google) を使って記事を読み込むまでは、@code{Message-ID} を知
ることはできないからです。あなたが読んだ記事を憶えておくための唯一の方法
は、@code{Date} ヘッダーをもとにスコアを付けることだけです---つまりあな
たがそのグループを最後に読んだ日付より、前に投稿された記事をすべて既読に
する、ということです。

もし検索エンジンの出力形式が変更されると、@code{nnweb} はそれをうまく解
釈できず、処理は失敗するでしょう。もしウェブ提供者達がそんなことをしたら、
彼らを激しく責めるべきでしょう---それは広告で金を稼ぐのが彼ら
の @emph{レーゾン・デートル} (存在理由) であり、社会にサービスを提供する
ことではないからです。@code{nnweb} はすべての記事から広告を洗い流してし
まうので、提供者たちがムカついていると思われるかもしれません。まあ見てて
下さい。

@code{nnweb} を使うには、@code{url} と @code{w3} パッケージをインストー
ルしておかなくてななりません。

以下は仮想サーバー変数です。

@table @code
@item nnweb-type
@vindex nnweb-type
どの検索エンジンを使っているか。現在サポートされている種類は、
@code{google}, @code{dejanews} そして @code{gmane} です。
@code{dejanews} は @code{google} の別名になっていることに注意して下さい。

@item nnweb-search
@vindex nnweb-search
検索エンジンに与える検索文字列。

@item nnweb-max-hits
@vindex nnweb-max-hits
表示する検索結果の最大数。ディフォルト値は 999 です。

@item nnweb-type-definition
@vindex nnweb-type-definition
型・定義連想リスト。この連想リストは、さまざまな検索エンジンの種類に対し
て、@code{nnweb} がどうすべきかを与えます。以下に示す要素を与えなくては
なりません。

@table @code
@item article
記事をデコードし、Gnus が理解できる形で提供する関数。

@item map
記事番号からメッセージヘッダーと URL を得る連想リストを作成する関数。

@item search
検索エンジンに検索文字列を送る関数。

@item address
前述の関数が検索文字列を送るべきアドレス。

@item id
@code{Message-ID} をもとに記事を取得するための URL 形式文字列。
@end table
@end table

@node Slashdot
@subsection Slashdot
@cindex Slashdot
@cindex nnslashdot

@uref{http://slashdot.org/, Slashdot} は人気のあるニュースサイトで、ニュー
ス記事の後に活発な議論がなされています。@code{nnslashdot} では便利な方法
でこの会議室を読むことができます。

ここから読むための一番簡単な方法は以下のようなもの
を @file{~/.gnus.el} ファイルに入れることです。

@lisp
(setq gnus-secondary-select-methods
      '((nnslashdot "")))
@end lisp

これは Gnus に @code{nnslashdot} バックエンドに新しいコメントとグループ
を尋ねるようにします。@kbd{F} 命令はそれぞれの新しいニュース記事を新し
い Gnus のグループとして購読し、これらのグループに入ることでコメントを読
むことができます。(ディフォルトの購読方法では、新しいグループをゾンビと
して購読することに注意して下さい。他の方法も使えま
す (@pxref{Subscription Methods})。

もしあなたが古い @code{nnslashdot} グループを削除したいのならば、
@kbd{G DEL} が最も手軽な道具です (@pxref{Foreign Groups})。

@code{nnslashdot} コメントにフォローアップ (または新しいコメントの投稿)
をするときは、少し @acronym{HTML} に変換されます。特に、@samp{> } で引用
されたテキストはその代わりに @samp{blockquote} で引用され、署名にはそれ
ぞれの行の最後に @samp{br} が追加されます。それ以外は、メッセージバッファー
に直接 @acronym{HTML} を書くことができます。Slashdot はいくつ
か @acronym{HTML} を選別することに気を付けて下さい。

以下の変数で振る舞いを変えることができます:

@table @code
@item nnslashdot-threaded
@code{nnslashdot} がグループをスレッドで表示するかどうか。ディフォルト値
は @code{t} です。スレッドを表示できるためには、@code{nnslashdot} はグルー
プに入る際にそのすべてのコメントを取得する必要があります。スレッド表示が
要求されていないと、@code{nnslashdot} は利用者が欲しいコメントだけを取得
します。スレッドの方がきれいですが、スレッド無し表示より、ずっとずっと遅
くなります。

@item nnslashdot-login-name
@vindex nnslashdot-login-name
投稿時に使うログイン名です。

@item nnslashdot-password
@vindex nnslashdot-password
投稿時に使うパスワードです。

@item nnslashdot-directory
@vindex nnslashdot-directory
@code{nnslashdot} がファイルを保存する場所です。ディフォルト値
は @file{~/News/slashdot/} です。

@item nnslashdot-active-url
@vindex nnslashdot-active-url
ニュース記事とコメントを取得するために使われる @acronym{URL} の文字列で
す。ディフォルト値
は @samp{http://slashdot.org/search.pl?section=&min=%d} です。

@item nnslashdot-comments-url
@vindex nnslashdot-comments-url
コメントを取得するために使用される @acronym{URL} 文字列です。

@item nnslashdot-article-url
@vindex nnslashdot-article-url
ニュース記事を取得するために使われる @acronym{URL} 文字列です。ディフォ
ルト値は @samp{http://slashdot.org/article.pl?sid=%s&mode=nocomment} で
す。

@item nnslashdot-threshold
@vindex nnslashdot-threshold
スコアのしきい値です。ディフォルト値は -1 です。

@item nnslashdot-group-number
@vindex nnslashdot-group-number
最新の 10 に加えて更新を続ける古いグループの数です。ディフォルト値
は 0 です。
@end table

@node Ultimate
@subsection Ultimate
@cindex nnultimate
@cindex Ultimate Bulletin Board

@uref{http://www.ultimatebb.com/, The Ultimate Bulletin Board} はおそら
く一番良く使われているウェブ掲示板システムでしょう。とても整然として良い
界面で、Gnus がグループを最新の状態に保っておくために情報を得ることが可
能です。

@code{nnultimate} を始めるための一番簡単な方法はグループバッファーで以下
のようなものをすることです: @kbd{B nnultimate RET
http://www.tcj.com/messboard.ubbcgi/ RET}。(興味のある会議室
の @acronym{URL} (@samp{Ultimate.cgi} 等を最後に含んでいないもの) に変え
て下さい。Ultimate ウェブサイトにはたくさん挙げられています。) それから
サーバーバッファーで興味のあるグループを購読し、グループバッファーからそ
れらを読んで下さい。

以下の @code{nnutimate} 変数を変更可能です:

@table @code
@item nnultimate-directory
@vindex nnultimate-directory
@code{nnultimate} がファイルを保存するディレクトリーです。ディフォルト値
は @file{~/News/ultimate/} です。
@end table

@node Web Archive
@subsection Web Archive
@cindex nnwarchive
@cindex Web Archive

メーリングリストの中には例えば、
@uref{http://www.egroups.com/} や @uref{http://www.mail-archive.com/} の
ようにウェブサーバーにしかアーカイブが無いものもあります。とても整然とし
て良い界面で、Gnus がグループを最新の状態に保っておくために情報を得るこ
とが可能です。

@findex gnus-group-make-warchive-group
@code{nnwarchive} を始めるための一番簡単な方法はグループバッファーで以下
のようなものをすることです: @kbd{M-x gnus-group-make-warchive-group RET
@var{an_egroup} RET egroups RET www.egroups.com RET
@var{your@@email.address} RET}。(@var{an_egroup} を購読しているメーリン
グリストに、@var{your@@emailaddress} を電子メールアドレスに置き換えて下
さい。) または @kbd{B nnwarchive RET mail-archive RET} でバックエンドを
ブラウズして下さい。

以下の @code{nnwarchive} 変数を変えることが可能です:

@table @code
@item nnwarchive-directory
@vindex nnwarchive-directory
@code{nnwarchive} がファイルを保存するディレクトリーです。ディフォルト値
は @file{~/News/warchive} です。

@item nnwarchive-login
@vindex nnwarchive-login
ウェブサーバーでのアカウント名です。

@item nnwarchive-passwd
@vindex nnwarchive-passwd
ウェブサーバーでのアカウントのパスワードです。
@end table

@node RSS
@subsection RSS
@cindex nnrss
@cindex RSS

いくつかのサイトは RDF site summary (@acronym{RSS}) を持っています。
@acronym{RSS} は、ニュースに関連するサイト (BBC や CNN のような) の主要
項目を要約するためのフォーマットです。しかし基本的に、リストのようなもの
なら何でも、@acronym{RSS} feed として提供することができま
す: weblogs、changelogs あるいは wiki (例え
ば @url{http://cliki.net/recent-changes.rdf}) への最近の変更。

@acronym{RSS} はとても規則的かつ良質なインターフェースで、Gnus がグルー
プを常に新しくしておくための情報を得ることができます。

注: @code{utf-8} coding system をサポートする Emacs を使うのが良いです。
@acronym{RSS} は、非-@acronym{ASCII} テキストをエンコードするために、ディ
フォルトで UTF-8 を使うからです。それはまた、ディフォルトで
非-@acronym{ASCII} グループ名にも使われます。

@kindex G R (概略)
Feed を講読するには、概略バッファーから @kbd{G R} を使って下さ
い---feed の所在、タイトルおよび説明の入力を求められるでしょう。タイトル
はどんな文字でもよく、それはグループ名とグループのデータ・ファイルの名前
に使われます。説明は省略できます。

簡単に @code{nnrss} をはじめる方法は、グループバッファーで @kbd{B nnrss
RET RET y} のようなことを唱え、そしてグループを講読することです。

@code{nnrss} バックエンドは、それぞれの @code{nnrss} グループのためのデー
タ・ファイルを @code{nnrss-directory} (下記参照) に保存します。
非-@acronym{ASCII} 文字を含んでいるファイル名
は、@code{nnmail-pathname-coding-system} 変数で指定された coding
system でエンコードされます。それが @code{nil} であると、Emacs で
は coding system はディフォルト
で @code{default-file-name-coding-system} の値になります。あなた
が XEmacs を使っていて、非-@acronym{ASCII} グループ名を使いたければ、
@code{nnmail-pathname-coding-system} 変数の値を適切に設定しなければなり
ません。

@cindex OPML
あなたの講読目録を @acronym{OPML} フォーマット (Outline Processor Markup
Language) でロード/セーブするために、以下のコマンドを使うこともできます。

@defun nnrss-opml-import file
@acronym{OPML} ファイルの入力を促し、そのファイルにあるそれぞれ
の feed を講読します。
@end defun

@defun nnrss-opml-export
現在の @acronym{RSS} 講読目録を @acronym{OPML} フォーマットでバッファー
に書き出します。
@end defun

以下の @code{nnrss} 変数が変更可能です:

@table @code
@item nnrss-directory
@vindex nnrss-directory
@code{nnrss} がファイルを書き込むディレクトリーで、ディフォルト
は @file{~/News/rss/} です。

@item nnrss-file-coding-system
@vindex nnrss-file-coding-system
@code{nnrss} グループのデータ・ファイルを読み書きするときに使われ
る coding system です。ディフォルト
は @code{mm-universal-coding-system} の値 (そのディフォルトは Emacs で
は @code{emacs-mule}、XEmacs では @code{escape-quoted}) です。

@item nnrss-use-local
@vindex nnrss-use-local
@findex nnrss-generate-download-script
@code{nnrss-use-local} を @code{t} に設定すると、
@code{nnrss} は @code{nnrss-directory} にあるローカルファイルから feed
を読みます。@code{nnrss-generate-download-script} コマンドを使うことによっ
て、@command{wget} を使ったダウンロード・スクリプトを作ることができます。
@end table

概略バッファーに説明を表示させたいならば、以下のコードが役に立つでしょう。

@lisp
(add-to-list 'nnmail-extra-headers nnrss-description-field)
(setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-15,15f%]%) %s%uX\n")

(defun gnus-user-format-function-X (header)
  (let ((descr
         (assq nnrss-description-field (mail-header-extra header))))
    (if descr (concat "\n\t" (cdr descr)) "")))
@end lisp

以下のコードは、概略バッファーから直接 nnrss の url をオープンするのに便
利かもしれません。
@lisp
(require 'browse-url)

(defun browse-nnrss-url( arg )
  (interactive "p")
  (let ((url (assq nnrss-url-field
                   (mail-header-extra
                    (gnus-data-header
                     (assq (gnus-summary-article-number)
                           gnus-newsgroup-data))))))
    (if url
        (progn
          (browse-url (cdr url))
          (gnus-summary-mark-as-read-forward 1))
      (gnus-summary-scroll-up arg))))

(eval-after-load "gnus"
  #'(define-key gnus-summary-mode-map
      (kbd "<RET>") 'browse-nnrss-url))
(add-to-list 'nnmail-extra-headers nnrss-url-field)
@end lisp

@node Customizing w3
@subsection w3 のカスタマイズ
@cindex w3
@cindex html
@cindex url
@cindex Netscape

Gnus はウェブページを取得するために url ライブラリを、ウェブページを表示
するために Emacs/W3 を使います。Emacs/W3 のことはそのマニュアルに記載さ
れていますが、ここでは Gnus の利用者にとってより適切ないくつかの事柄を述
べることにします。

例えば、よくある質問に Emacs/W3 に @code{browse-url} の機能 (Netscape の
ような外部プラウザーを使うように設定されている) を使ってリンクを参照させ
るにはどうしたらよいか、というのがあります。以下は一つの方法です。

@lisp
(eval-after-load "w3"
  '(progn
    (fset 'w3-fetch-orig (symbol-function 'w3-fetch))
    (defun w3-fetch (&optional url target)
      (interactive (list (w3-read-url-with-default)))
      (if (eq major-mode 'gnus-article-mode)
          (browse-url url)
        (w3-fetch-orig url target)))))
@end lisp

これをあなたの .emacs ファイルに書き込むことによって、Gnus の記事バッファー
で @acronym{HTML} リンクを叩けば、@code{browse-url} を使ってそのリンクを
参照するようになるでしょう。

@node IMAP
@section IMAP
@cindex nnimap
@cindex @acronym{IMAP}

@acronym{IMAP} はメール (もしくは、ニュース、もしくは @dots{}) を読むた
めのネットワークプロトコルです。現代風の @acronym{NNTP} と考えて下さい。
@acronym{IMAP} サーバーへの接続はニュースサーバーへの接続と非常に似てい
て、そのサーバーのネットワークアドレスを指定するだけになっています。

@acronym{IMAP} には二つの特質があります。一つは、
@acronym{IMAP} は @acronym{POP} でできることは全部できる、それゆ
え @acronym{POP++} のようにも見えるということ。二つ目は、
@acronym{IMAP} は @acronym{NNTP} がニュースを貯蔵するプロトコルであるよ
うに、メールを貯蔵するプロトコルであるということです。しかしなが
ら @acronym{IMAP} は @acronym{NNTP} より多くの機能を提供します。ニュース
は読むだけですが、メールは読み書きができます。

@acronym{IMAP} を @acronym{POP++} のように使いたいときは、
@code{mail-sources} に imap を登録して下さい。これによっ
て Gnus は @acronym{IMAP} サーバーからメールを取り込んで、ローカルディス
クに貯蔵します。ここではその使い方の説明はしませんから、
@ref{Mail Sources} を参照して下さい。

@acronym{IMAP} をメールを貯蔵するプロトコルとして使いたいときは、
@code{gnus-secondary-select-methods} に nnimap を登録して下さい。これに
よって Gnus は @acronym{IMAP} サーバーに貯蔵されているメールを操作するよ
うになります。これがここで説明する使い方です。

いくつかの @acronym{IMAP} サーバーを @file{~/.gnus.el} で設定すると、た
ぶん以下のようなものになるでしょう。(注: @acronym{TLS}/@acronym{SSL} で
は外部プログラムとライブラリが必要です。以下を参照して下さい。)

@lisp
(setq gnus-secondary-select-methods
      '((nnimap "simpleserver") ; @r{普通の設定}
        ; @r{SSH ポートをフォワードしたサーバー:}
        (nnimap "dolk"
                (nnimap-address "localhost")
                (nnimap-server-port 1430))
        ; @r{ローカルホストで運転している UW サーバー:}
        (nnimap "barbar"
                (nnimap-server-port 143)
                (nnimap-address "localhost")
                (nnimap-list-pattern ("INBOX" "mail/*")))
        ; @r{匿名で使える cyrus の公衆サーバー:}
        (nnimap "cyrus.andrew.cmu.edu"
                (nnimap-authenticator anonymous)
                (nnimap-list-pattern "archive.*")
                (nnimap-stream network))
        ; @r{標準ではないポートの @acronym{SSL} サーバー:}
        (nnimap "vic20"
                (nnimap-address "vic20.somewhere.com")
                (nnimap-server-port 9930)
                (nnimap-stream ssl))))
@end lisp

新しいサーバーを定義した後で、@kbd{U} のような Gnus の通常のコマンドをグ
ループバッファーで使う (@pxref{Subscription Commands}) か、またはサーバー
バッファー (@pxref{Server Buffer}) を介して、そのサーバーのグループを講
読することができます。

以下の変数は仮想 @code{nnimap} サーバーを作成するために使うことができま
す。

@table @code
@item nnimap-address
@vindex nnimap-address

遠隔 @acronym{IMAP} サーバーのアドレスです。指定されていない場合は仮想サー
バーのものになります。

@item nnimap-server-port
@vindex nnimap-server-port
接続を試みるサーバーのポートです。ディフォルトはポート 143、また
は @acronym{TLS}/@acronym{SSL} では 993 です。

これは整数でなければなりません。以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-server-port 4711))
@end lisp

@item nnimap-list-pattern
@vindex nnimap-list-pattern
使用可能なメールボックスを制限するための文字列かリストです。これは、サー
バーに非常に多くのメールボックスがあるけれど、興味のあるものは少しだけで
あるときに使用します。サーバーにはホームディレクトリー
を @acronym{IMAP} 経由で出すものもあるので、その場合はおそらくメールボッ
クスを @file{~/Mail/*} に制限したいでしょう。

文字列は REFERENCE と上の文字列との cons であることもできます。ど
の REFERENCE が使用されるかはサーバー特有ですが、ワシントン大学のサーバー
では、メールボックスと連結されたディレクトリーです。

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-list-pattern ("INBOX" "Mail/*" "alt.sex.*"
                               ("~friend/Mail/" . "list/*"))))
@end lisp

@item nnimap-stream
@vindex nnimap-stream
サーバーに接続するときに使われるストリームの型です。ディフォルトで
は nnimap は @acronym{TLS}/@acronym{SSL} を除く以下のすべてを自動的に検
知してそれを使います。(@acronym{TLS}/@acronym{SSL} を使
う @acronym{IMAP} は STARTTLS で置き換えられています。これは自動検出でき
ますが、まだ広範囲に配備されていません。)

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-stream ssl))
@end lisp

@code{nnimap-stream} の値はシンボルでなければならないことに注意して下さ
い!

@itemize @bullet
@item
@dfn{gssapi:} GSSAPI (普通は Kerberos 5) を使います。@samp{gsasl} また
は @samp{imtest} プログラムが必要です。
@item
@dfn{kerberos4:} Kerberos 4 を使います。@samp{imtest} プログラムが必要で
す。
@item
@dfn{starttls:} STARTTLS (@acronym{TLS}/@acronym{SSL} に類似) を使います。
外部ライブラリ @samp{starttls.el} と @samp{starttls} プログラムが必要で
す。
@item
@dfn{tls:} @acronym{TLS} を使います。GNUTLS (@samp{gnutls-cli} プログラ
ム) が必要です。
@item
@dfn{ssl:} @acronym{SSL} を使います。OpenSSL (@samp{openssl} プログラ
ム) か SSLeay (@samp{s_client}) が必要です。
@item
@dfn{shell:} シェル命令を使って @acronym{IMAP} 接続を開始します。
@item
@dfn{network:} 生の、TCP/IP のネットワーク接続です。
@end itemize

@vindex imap-kerberos4-program
@samp{imtest} プログラムは Cyrus IMAPD に含まれています。もしあなた
が 2.0.14 未満の Cyrus IMAPD に含まれている @samp{imtest} (バージョ
ン 1.5.x と 1.6.x) を使っているなら、
@code{imap-process-connection-type} をいじり回して、
@file{imap.el} が @samp{imtest} と通信するときにパイプではなく
て pty を使うようにさせる必要があります。そうするとあなた
は @acronym{IMAP} コマンドの行の長さの制限に悩まされるでしょう。それはメー
ルボックスにたくさんの記事があるときに Gnus を無期限にハングさせてしまう
かもしれません。変数 @code{imap-kerberos4-program} は imtest プログラム
に渡すパタメータを含みます。

@acronym{TLS} 接続では GNUTLS 由来の @code{gnutls-cli} プログラムが必要
です。これは @uref{http://www.gnu.org/software/gnutls/} から手に入れるこ
とができます。

@vindex imap-gssapi-program
このパラメーターは、副シェルで GSSAPI 認証による @acronym{IMAP} 接続を起
動するためのコマンド行のリストを指定します。これらは接続が確立するまで、
またはリストが使い尽くされるまで、順ぐりに試されます。ディフォルトでは、
@uref{http://www.gnu.org/software/gsasl/} にある GNU SASL によ
る @samp{gsasl} と、Cyrus IMAPD による @samp{imtest} プログラ
ム (@code{imap-kerberos4-program} 参照) が試されます。

@vindex imap-ssl-program
@acronym{SSL} 接続のための OpenSSL プログラム
は @uref{http://www.openssl.org/} から入手できます。OpenSSL は以前
は SSLeay として知られていたもので、nnimap はそれもサポートします。しか
し、SSLeay の最新版である 0.9.x には重大なバグがあるため使えません。以前
の版、特に SSLeay 0.8.x は使えることがわかっています。変
数 @code{imap-ssl-program} は OpenSSL/SSLeay に渡すパタメータを含みます。

@vindex imap-shell-program
@vindex imap-shell-host
@acronym{IMAP} 接続に @code{shell} ストリームを使う場合、変
数 @code{imap-shell-program} は何のプログラムを呼ぶかを指定します。

@item nnimap-authenticator
@vindex nnimap-authenticator

サーバーに接続するために使われる認証です。ディフォルトでは nnimap はサー
バーが使用可能な一番安全な認証を使用します。

以下はサーバー指定の例です。

@lisp
(nnimap "mail.server.com"
        (nnimap-authenticator anonymous))
@end lisp

@code{nnimap-authenticator} の値はシンボルでなければならないことに注意し
て下さい!

@itemize @bullet
@item
@dfn{gssapi:} GSSAPI (普通は Kerberos 5) 認証です。外部プログラ
ム @code{gsasl} または @code{imtest} が必要です。
@item
@dfn{kerberos4:} Kerberos 4 による認証です。外部プログラ
ム @code{imtest} が必要です。
@item
@dfn{digest-md5:} DIGEST-MD5 で暗号化された 利用者名/パスワード です。外
部ライブラリ @file{digest-md5.el} が必要です。
@item
@dfn{cram-md5:} CRAM-MD5 で暗号化された 利用者名/パスワード です。
@item
@dfn{login:} LOGIN 経由での生の 利用者名/パスワード です。
@item
@dfn{anonymous:} 電子メールアドレスをパスワードとして与え、
``anonymous'' としてログインします。
@end itemize

@item nnimap-expunge-on-close
@cindex expunging
@vindex nnimap-expunge-on-close

パルメニデスと違って、@acronym{IMAP} の設計者達は、存在していないものが
実際には存在していると決めました。もっと詳しく説明すると、
@acronym{IMAP} は実際には記事を消去しない、記事に @code{Deleted} という
印を付ける概念があり、これ (えっと、@code{Deleted} という印を付けること
です) が nnimap が Gnus で記事を消去するときにすることで
す (@kbd{B DEL} などで)。(訳注: パルメニデスは紀元前 5 世紀のギリシア
の Elea 派の哲学者)

記事を @code{Deleted} フラグで印を付けたときには本当は消去されていないの
で、実際に消去するための方法が必要となります。循環しているように感じます
か?

伝統的に、nnimap はメールボックスを閉じるときに @code{Deleted} という印
の付いたすべての記事を消去してきましたが、今はサーバー変数により設定可能
です。

選択肢は:

@table @code
@item always
これがディフォルトの振舞いで、メールボックスを閉じるとき
に ``Deleted'' と印の付いた記事を消去します。
@item never
決して記事を消去しません。現在は、消去の印が付いた記事を nnimap で表示す
る方法はありませんが、他の @acronym{IMAP} クライアントはではできるかもし
れません。手で EXPUNGE コマンドを発行したいとき
は @xref{Expunging mailboxes}.
@item ask
メールボックスを閉じるときに、nnimap が消去された記事を削除するかどうか
を尋ねます。
@end table

@item nnimap-importantize-dormant
@vindex nnimap-importantize-dormant

非-@code{nil} (ディフォルト) だったら、他の @acronym{IMAP} クライアント
のために保留記事を印付きとしても印を付けます。Gnus の内部では、保留記事
は元々すでに保留記事としてのみ印が付けられています。これは、他
の @acronym{IMAP} クライアントにおける保留記事を、あたかも印付きのように
きわ立たせます。(別の言い方をすると、Gnus は二つの印を付け、
@acronym{IMAP} はたった一つだということです。)

たぶんこれをいじりまわすのは、あなたが利用者単位の保留フラグを付けようと
するだけの理由によるでしょう。こんな感じで:

@lisp
(setcdr (assq 'dormant nnimap-mark-to-flag-alist)
        (format "gnus-dormant-%s" (user-login-name)))
(setcdr (assq 'dormant nnimap-mark-to-predicate-alist)
        (format "KEYWORD gnus-dormant-%s" (user-login-name)))
@end lisp

この場合、あなたは利用者単位の保留フラグを、他の利用者に印付きとして見ら
れたくないと思っています。

@item nnimap-expunge-search-string
@cindex expunging
@vindex nnimap-expunge-search-string

この変数には、期限切れ消去するのが望ましい記事を探すときにサーバーに送っ
た @acronym{IMAP} の検索コマンドが入っています。ディフォルト
は @code{"UID %s NOT SINCE %s"} で、ここで最初の @code{%s} は UID で置き
換えられ、二番目の @code{%s} は日付で置き換えられます。

たぶん使いものになる別の値は @code{"UID %s NOT SENTSINCE %s"} で、
nnimap に記事の内部的な日付の代わりに Date: を使うようにさせます。さらな
る情報や使うことができる文字列については、RFC 2060 のセクション 6.4.4 を
見て下さい。

@item nnimap-authinfo-file
@vindex nnimap-authinfo-file

サーバーにログインするために使う認証情報 (authinfo) を含むファイルです。
その形式は (ほとんど) @code{ftp} の @file{~/.netrc} ファイルと同じです。
厳密な定義は、変数 @code{nntp-authinfo-file} を見て下さい。そし
て @ref{NNTP} も見て下さい。IMAP サーバー用の .authinfo 行の例です:

@example
machine students.uio.no login larsi password geheimnis port imap
@end example

安全な IMAP で使われる実際のポート番号は port 993 ですが、
@code{nnimap-stream} として @code{tls} または @code{ssl} を使う場合、そ
れは @code{port imap} または @code{port 143} でなければならないことに注
意して下さい。便宜上 Gnus は @code{port imap} の同義語とし
て @code{port imaps} を受け入れます。

@item nnimap-need-unselect-to-notice-new-mail
@vindex nnimap-need-unselect-to-notice-new-mail

新着メールを探す前にメールボックスを未選択にします。何らかの状況の元で、
幾らかのサーバーが、これを必要とするようです。Courier 1.7.1 はそうだとい
う報告がありました。
@end table

@menu
* Splitting in IMAP::           nnimap でメールを分割する
* Expiring in IMAP::            nnimap によるメールの期限切れ消去
* Editing IMAP ACLs::           メールボックスへの他の利用者の使用を制限/許可する
* Expunging mailboxes::         ``メールボックス圧縮'' ボタンと等価なもの
* A note on namespaces::        Gnus で @acronym{IMAP} 名前空間を使う (使わない) 方法
* Debugging IMAP::              ものごとが働かないときにするべきこと
@end menu

@node Splitting in IMAP
@subsection IMAP での分割
@cindex splitting imap mail

分割は Gnus の利用者が何年もの間愛してきたもので、今や残りの世界も追いつ
こうとしています。はい、想像して下さい、@acronym{IMAP} サーバーの中にサー
バー側で分割できるものはあまり多くなく、しかもそれらは標準でないプロトコ
ルを使っているようです。これは、Gnus の @acronym{IMAP} サポートは自分自
身で分割をしなければならないということです。

そして実際にします。

(ついでに言えば、みんなが夢見ていたのでしょうね。その結果 Sieve は市場占
有率を増して、いくつもの IMAP サーバーによってサポートされるようになりま
した。幸いに Gnus もそれをサポートします。@xref{Sieve Commands}.)

関連する変数は三つです:

@table @code
@item nnimap-split-crosspost
@cindex splitting, crosspost
@cindex crosspost
@vindex nnimap-split-crosspost

@code{nil} でなければ、いくつかの分割方法がメールと合致したときにクロス
ポストをします。@code{nil} ならば、@code{nnimap-split-rule} で最初に見つ
かったものが使われます。

Nnmail で対応するもの: @code{nnmail-crosspost}.

@item nnimap-split-inbox
@cindex splitting, inbox
@cindex inbox
@vindex nnimap-split-inbox

分割の元となる @acronym{IMAP} のメールボックスの名前を指定した文字列か文
字列のリストです。ディフォルト値は @code{nil} で、分割は使用しないように
なっています!

@lisp
(setq nnimap-split-inbox
      '("INBOX" ("~/friend/Mail" . "lists/*") "lists.imap"))
@end lisp

Nnmail に対応するものはありません。

@item nnimap-split-rule
@cindex splitting, rules
@vindex nnimap-split-rule

@code{nnimap-split-inbox} で見つかった新しいメールはこの変数に従って分割
されます。

この変数はリストのリストから成ります。副リストの最初の要素
は @acronym{IMAP} のメールボックスで、二つめの要素の正規表現に合致した記
事の移動先を指定します。わかりましたか? いいえ、私もわかりません。例が必
要です。

@lisp
(setq nnimap-split-rule
      '(("INBOX.nnimap"
         "^Sender: owner-nnimap@@vic20.globalcom.se")
        ("INBOX.junk"    "^Subject:.*MAKE MONEY")
        ("INBOX.private" "")))
@end lisp

これは nnimap メーリングリストからのすべての記事をメールボック
ス INBOX.nnimap に入れ、Subject: 行に MAKE MONEY のあるすべての記事
を INBOX.junk に入れ、その他すべてのものを INBOX.private に入れます。

最初の文字列は、replace-match で合致したテキストから副表現を挿入するとき
に使用されるのと同じような、@samp{\\1} 形式を含むことができます。例えば:

@lisp
("INBOX.lists.\\1"     "^Sender: owner-\\([a-z-]+\\)@@")
@end lisp

最初の要素をシンボル @code{junk} にして、合致するメッセージを単に消すべ
きであることを表すこともできます。気を付けて使って下さい。

二つ目の要素は関数であることもできます。その場合は、記事のヘッダーがある
バッファーで、その規則の最初の要素を引数として呼ばれます。メールがそのグ
ループに属すると考える場合は、@code{nil} でない値を返す必要があります。

Nnmail の利用者は最後の正規表現はすべての記事に合致するように空でなくて
はならないことを覚えているかもしれません (上の例のように)。これ
は nnimap では必要ではありません。正規表現のどれにも合致しない記事
は inbox から移動されません。(inbox に未読記事を大量に置いておくと、分割
のコードは新しいメールを取得するときにそれらすべてを調べるので、実行速度
に影響する可能性があります。)

これらの規則は連想リストの最初から終りに向かって実行されます。クロスポス
トが使用可能になっていないかぎり、最初に合致した規則が ``勝ち'' ます。ク
ロスポストをしている場合は、すべての合致した規則が ``勝ち'' ます。

この変数はその値として関数を持つこともできます。その関数は記事のヘッダー
の部分に範囲が狭められた状態で呼ばれ、記事の移動先だと思うグループを返す
ものでなければなりません。@code{nnimap-split-fancy} を参照して下さい。

分割コードは必要ならメールボックスを作成します。

異なる仮想サーバー毎に違う分割の規則を使ったり、それどころか同じサーバー
の異なる inbox 毎に違う分割の規則を使うことができるようにするために、こ
の変数の構文は以下のように拡張されています。

@lisp
(setq nnimap-split-rule
      '(("my1server"    (".*"    (("ding"    "ding@@gnus.org")
                                  ("junk"    "From:.*Simon")))
        ("my2server"    ("INBOX" nnimap-split-fancy))
        ("my[34]server" (".*"    (("private" "To:.*Simon")
                                  ("junk"    my-junk-func)))))
@end lisp

仮想サーバー名は実際には正規表現なので、同じ規則をいくつかのサーバーに適
用できるでしょう。この例ではサー
バー @code{my3server} と @code{my4server} が同じ規則を使います。同様
に inbox 文字列も正規表現です。上記の分割の規則の実例は、関数、またはグ
ループの正規表現かグループの関数、の両方です。

Nnmail で対応するもの: @code{nnmail-split-methods}.

@item nnimap-split-predicate
@cindex splitting
@vindex nnimap-split-predicate

この述語に合致する @code{nnimap-split-inbox} にあるメールは分割されます。
これは文字列で既定値は @samp{UNSEEN UNDELETED} です。

もしあなたが inbox にあるメールを読むために別の @acronym{IMAP} クライア
ントを使っているが、購読度に関わらずにすべての記事を Gnus に分割させたい
ならば、これは役に立つかもしれません。その場合は @samp{UNDELETED} に変え
れば良いでしょう。

@item nnimap-split-fancy
@cindex splitting, fancy
@findex nnimap-split-fancy
@vindex nnimap-split-fancy

もしあなたが特級分割を使いたいならば、@code{nnimap-split-rule} の値
を @code{nnmail-split-fancy} に設定することができます。
@xref{Fancy Mail Splitting}.

しかし nnmail と nnimap とで異なる特級分割方式を持つようにするには、
@code{nnimap-split-rule} の値を @code{nnimap-split-fancy} に設定して、
nnimap 特有の特級分割方式を @code{nnimap-split-fancy} に定義して下さい。

例:

@lisp
(setq nnimap-split-rule 'nnimap-split-fancy
      nnimap-split-fancy ...)
@end lisp

Nnmail で対応するもの: @code{nnmail-split-fancy}.

@item nnimap-split-download-body
@findex nnimap-split-download-body
@vindex nnimap-split-download-body

分割しているときにすべての記事をダウンロードするには非-@code{nil} に設定
して下さい。これは普通は必要ではなく、ものごとを相当に遅くしてしまうでしょ
う。記事を分割するために本文を分析する高度な関数を使いたい場合には、必要
かもしれません。
@end table

@node Expiring in IMAP
@subsection IMAP での期限切れ消去
@cindex expiring imap mail

@code{nnimap} は完全な @code{nnmail} 由来のバックエンドではありませんが、
たいていの期限切れ消去 (@pxref{Expiring Mail}) の標準機能をサポートしま
す。@acronym{IMAP} の分割 (@pxref{Splitting in IMAP}) で
は @code{nnmail} の変数を複製しない (例えば @var{nnimap-expiry-wait} を
生成しない) 点が違うのですが、@code{nnmail} の変数を流用します。以下
は @code{nnimap} の期限切れ消去処理で使われる変数です。

期限切れ消去の印がどのように適切に @acronym{IMAP} サーバーに記録されるか
についてもここで言及しておきましょう。期限切れ消去の印は @code{imap} ク
ライアント特有の印である @code{gnus-expire} に変換され、メッセージに記録
されます。これは、他のクライアントはメッセージのクライアント特有のフラグ
を見るかもしれないのに対して、Gnus はたぶん @code{gnus-expire} の印を適
切に扱い理解するだけであることを意味します。またこれはサーバーが、クライ
アント特有のフラグのメッセージへの恒久的な保存をサポートしなければならな
いことも意味します。幸いに、たいていはサポートします。

@table @code
@item nnmail-expiry-wait
@item nnmail-expiry-wait-function

これらの変数は完全にサポートされています。期限切れ消去の値は、数、シンボ
ルの @code{immediate} または @code{never} です。

@item nnmail-expiry-target

この変数はサポートされていて、内部的にはこれを扱う @code{nnmail} 関数を
呼ぶことによって実装されています。もし行き先が同じサーバー
の @acronym{IMAP} グループだったら、記事は追加される代わりにコピーされ
る (アップロードし直される) という最適化も含みます。
@end table

@node Editing IMAP ACLs
@subsection IMAP の ACL を編集する。
@cindex editing imap acls
@cindex Access Control Lists
@cindex Editing @acronym{IMAP} ACLs
@kindex G l (グループ)
@findex gnus-group-nnimap-edit-acl

ACL は Access Control List (使用制限一覧) の略です。@acronym{IMAP} で
は ACL は他の利用者によるあなたのメールボックスの使用を制限 (もしくは許
可) するために使われています。@acronym{IMAP} サーバーすべてにこの機能が
あるわけではなく、無いサーバーでこれらの関数を使うとエラーが発生します。

メールボックスへの ACL を編集するためには、
@kbd{G l} (@code{gnus-group-edit-nnimap-acl}) を入力します。そうすると、
詳しい指示とともに ACL 編集ウィンドウが現れます。

使用の例:

@itemize @bullet
@item
メーリングリストのメールボックスで ``anyone'' に ``lrs'' 許
可 (lookup, read, seen/unseen フラグの保持) を与えることで、同じサーバー
の他の利用者がそれを購読することなく読むことができます。
@item
少なくとも Cyrus のサーバーにおいては、``plussing'' が動作するために (つ
まり、user+mail@@domain が INBOX.mailbox という @acronym{IMAP} のメール
ボックスになる)、利用者 ``anyone'' に投稿 ("p") の許可を与える必要があり
ます。
@end itemize

@node Expunging mailboxes
@subsection メールボックスの削除
@cindex expunging

@cindex expunge
@cindex manual expunging
@kindex G x (グループ)
@findex gnus-group-nnimap-expunge

@code{nnimap-expunge-on-close} に @code{never} を設定していれば、メール
ボックスのすべての消去された記事を手動で削除する必要があるでしょう。
@kbd{G x} がまさにこのことをします。

現時点では、消去された記事を表示する方法はありません。ただ消去できるだけ
です。

@node A note on namespaces
@subsection 名前空間に関する注意
@cindex IMAP namespace
@cindex namespaces

@acronym{IMAP} プロトコルには名前空間 (namespaces) と呼ばれる概念があり、
以下の RFC2060 の文書で記述されています。

@example
5.1.2.  メールボックス名前空間命名規則

   習慣により "#" で始まっているすべてのメールボックス名の最初の階層要素
   は、残りの名前の "名前空間" を示している。これは、それぞれ独自の名前
   空間を持つ異なるメールボックス保管の間での、曖昧さを取り除くことを可
   能にする。

      例えば USENET ニュースグループへのアクセスを提供する実装は、USENET
      ニュースグループ名前空間を他のメールボックスから分離するために、
      "#news" 名前空間を用いてもよい。こうして comp.mail.misc ニュースグ
      ループは "#news.comp.mail.misc" というメールボックス名を持ち、名前
      "comp.mail.misc" は別のオブジェクト (例えば、利用者の個人メールボッ
      クス) を指すことはありうる。

(訳註: http://kame.zit.to/~obata/imap/rfc/rfc2060ja.txt より転載)
@end example

ここには Gnus における @acronym{IMAP} の実装に対する関係を保証する文書が
無いのですが、いくつかのサーバーは Gnus のメールボックスの名前の使い方で
は動作しないやり方で名前空間接頭語を使っています。

具体的には、ワシントン大学の @acronym{IMAP} サーバー
は @code{#driver.mbx/read-mail} のようなメールボックス名を使っていて、そ
れは @sc{create} と @sc{append} コマンドでだけ有効です。メールボックスが
作られた後 (またはメッセージがメールボックスに追加された後) では、それは
名前空間接頭語を付けずにアクセス、すなわち @code{read-mail} されなければ
なりません。Gnus は利用者が CREATE と APPEND コマンドだけで入力したメー
ルボックス名を保証できないので、絶対に名前空間接頭語が付いたメールボック
ス名を Gnus で使ってはいけません。

@code{#driver.*/} 接頭語についてのさらなる使い方の情報は UoW IMAPD の文
書を見て下さい。それらは強力な工具なので、どんな効果があるかが確かな場合
だけ使って下さい。

@node Debugging IMAP
@subsection IMAP のデバッグ
@cindex IMAP debugging
@cindex protocol dump (IMAP)

@acronym{IMAP} は @acronym{NNTP} や @acronym{POP3} よりもっと複雑なプロ
トコルです。実装上のバグが無いとは言い切れないので、私たちは、すぐにそれ
らを直すために最善を尽くします。あなたが奇妙な振る舞いに出会ったとしたら、
サーバーか Gnus のどちらかにバグがある可能性があります。

あなたが一般的なネットワーク・プロトコルに精通しているならば、Gnus とサー
バーの間でやりとりされるプロトコル・ダンプを読むことによって、おそらくい
くつかの手掛かりを抽出することができるでしょう。精通していなくても、プロ
トコル・ダンプを IMAP に関するバグ報告に含めれば、その問題の解決にとって
重要なデータで私たちを助けます。したがって、Gnus の IMAP バグを報告する
ときに、プロトコル・ダンプを含めることを強く奨励します。

@vindex imap-log
プロトコル・ダンプは、それを有効にしているとたくさんのデータを生成するの
で、ディフォルトでは無効になっています。有効にするには、以下のよう
に @code{imap-log} を設定して下さい:

@lisp
(setq imap-log t)
@end lisp

これは @code{imap.el} パッケージに、サーバーとのやりとりを何でも記録させ
ます。その記録は @samp{*imap-log*} というバッファーに格納されます。とき
として @code{BAD} という札が付けられる、エラーメッセージを探して下さい。
でも、バグを提出するときは、すべてのデータを含めるようにして下さい。

@node Other Sources
@section その他のグループ源

Gnus はただ単にニュースやメールを読む以上のことができます。以下
に示す方法によって、Gnus でディレクトリーやファイルを、あたかも
ニュースグループであるかのように閲覧することができるようになりま
す。

@menu
* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        @sc{soup} パケットを ``オフライン'' で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する
@end menu

@node Directory Groups
@subsection ディレクトリーグループ
@cindex nndir
@cindex directory groups

もし、たくさんの記事が個別のファイルとして入っているディレクトリーがあれ
ば、それをニュースグループとして扱うことができます。もちろん、ファイルは
数字のファイル名をもっていなければなりません。

ここで Emacs の素晴らしいパッケージの中でも最も素晴らし
い @code{ange-ftp} (とその後継の @code{efs}) について触れる良い機会でしょ
う。私が @code{nndir} を書いたときは、これ---ディレクトリーを読むバック
エンドについてはあまり考えていませんでした。とんでもないことだね。

@code{ange-ftp} はこの情況を劇的に変化させました。例えば、
@code{ange-ftp} ファイル
名 @file{/ftp.hpc.uh.edu:/pub/emacs/ding-list/} をディレクトリー名として
入力したとすると、@code{ange-ftp} あるいは @code{efs} は実に、
@samp{シナ} の向こうのディレクトリーをニュースグループとして読むことを可
能にするのです。おーい、分散ニュースよ!

@code{nndir} は @acronym{NOV} ファイルが存在すればそれを利用します。

@code{nndir} は ``読み出し専用'' のバックエンドです---この選択方法では、
記事の削除や期限切れ消去を行なうことはできません。@code{nndir} が使える
ものなら何でも @code{nnmh} あるいは @code{nnml} を使うことができるので、
もし読み出し専用ではない @code{nndir} が必要だと思ったら、これらのどちら
かの方法に切り替えることもできます。

@node Anything Groups
@subsection なんでもグループ
@cindex nneething

(一つのスプール風ディレクトリーと解釈できる) @code{nndir} バックエンドか
ら @code{nneething} までは、ほんのすぐそこです。それはいかなるディレクト
リーでもニュースグループに見せかけてしまう、というものです。不思議です、
でも真実です。

@code{nneething} にディレクトリーを与えると、そのディレクトリーを走査し、
各ファイルに記事番号を割り当てます。このようなグループに入ったときは、
@code{nneething} は Gnus が使う ``ヘッダー'' を作らなくてはなりません。
つまるところ、Gnus はニュースリーダなんです。忘れてるかもしれないので念
のため。@code{nneething} はこれを二段階で処理します。最初に、問題となる
ファイルをそれぞれ詮索してまわります。もしそのファイルが記事のように見え
たなら (すなわち、最初の数行がヘッダーのように見えたら) それをヘッダーと
して使います。もしそれがヘッダーのないただの適当なファイル (例えば C の
ソースファイル) であったなら、@code{nneething} はヘッダーを虚空から作り
出します。これはファイルの所有者、名前、日付を使い、これらの要素に対して
できることを何でもやります。

これはあなたにとってはすべて自動的に起こることで、あなたはニュースグルー
プにとても良く似た何かを見せられることになるでしょう。ほんとうに寸分違わ
ない、ニュースグループのようなものを。記事を選択すると、それはいつものよ
うに、記事バッファーに表示されるでしょう。

ディレクトリーを表わしている行を選択すると、Gnus はあなたをこ
の @code{nneething} グループのための新しい概略バッファーに連れて行くでしょ
う。以下同様で、もしあなたがそうしたければ、この方法で全ディスクを駆け巡
ることができます。ですが、Gnus は本当は dired ではなく、そのように意図さ
れたものでもない、ということは覚えておいて下さい。

ここでの動作には全体的に二つのモードがあります--- 一時モードと固定モード
です。一時的な操作を行なっているときは (すなわち、グループバッファー
で @kbd{G D} とする)、Gnus はどのファイルを読んだか、どのファイルが新し
いか、などの情報を憶えておきません。もし @kbd{G m} で普通に固
定 @code{nneething} グループを作ると、Gnus は記事番号とファイル名の対応
表を憶えておき、このグループを他のグループと同様に扱うことができるように
なります。固定 @code{nneething} グループを作動させると、未読記事がいくつ
含まれているかを知らされたり、などなど。

いくつかの変数があります。

@table @code
@item nneething-map-file-directory
@vindex nneething-map-file-directory
すべての固定 @code{nneething} グループの対応表はこのディレクトリーに格納
されます。このディフォルト値は @file{~/.nneething/} です。

@item nneething-exclude-files
@vindex nneething-exclude-files
この正規表現に合致するファイルはすべて無視されます。自動保存ファイルなど
を除くのに便利に使えます。そしてそれがまさにディフォルトで行なわれる動作
です。

@item nneething-include-files
@vindex nneething-include-files
そのファイルをグループに含めるかを示す正規表現です。この変数
が @code{nil} でなければ、この正規表現に合致するファイルだけが含まれます。

@item nneething-map-file
@vindex nneething-map-file
対応表ファイルの名前。
@end table

@node Document Groups
@subsection 文書グループ
@cindex nndoc
@cindex documentation group
@cindex help group

@code{nndoc} は一つのファイルをニュースグループとして読むことをできるよ
うにする、ちょっと気の利いたやつです。いくつかのファイル種別がサポートさ
れています。

@table @code
@cindex Babyl
@cindex Rmail mbox

@item babyl
Babyl (Rmail) 形式のメールボックス。
@cindex mbox
@cindex Unix mbox

@item mbox
標準 Unix mbox ファイル。

@cindex MMDF mail box
@item mmdf
MMDF 形式のメールボックス。

@item news
いくつかのニュース記事が連結された一つのファイル。

@item rnews
@cindex rnews batch files
rnews のバッチ転送形式。
@cindex forwarded messages

@item forward
転送された記事。

@item nsmail
Netscape のメールボックス。

@item mime-parts
@acronym{MIME} のマルチパートのメッセージ。

@item standard-digest
標準 (RFC 1153) まとめ送り形式。

@item mime-digest
@acronym{MIME} のまとめ送りメッセージ。

@item lanl-gov-announce
ロスアラモス国立研究所 (LANL) Gov Announce からの発表メッセージ。

@item rfc822-forward
RFC822 で転送されたメッセージ。

@item outlook
Outlook のメールボックス。

@item oe-dbx
Outlook Express の dbx メールボックス。

@item exim-bounce
Exim MTA から跳ね返されたメッセージ。

@item forward
非公式の規則で転送されたメッセージ。

@item rfc934
RFC934 形式で転送されたメッセージ。

@item mailman
mailman のまとめ送り。

@item clari-briefs
Clarinet のニュース項目を要約したまとめ送り。

@item slack-digest
非標準まとめ送り形式---だいたいはうまく合致するが、でも扱いは下手。

@item mail-in-mail
最後の手段。
@end table

また、特別な ``ファイル種別'' @code{guess} を使うこともできます。これ
は @code{nndoc} は注目しているファイルの種別を推測しようとする、という意
味です。@code{digest} は @code{nndoc} にそのファイルがどのまとめ送り形式
かを推測させるという意味です。

@code{nndoc} はファイルを書き換えようとしたり、余分なヘッダーを挿入しよ
うとしたりはしません---単純に、ファイルをそのグループの主成分として使え
るようにする、というようなものです。それだけのことです。

もしあなたが古い保存記事を持っていて、それを新しくてかっこいい Gnus のメー
ルバックエンドに追加したいというときは、おそらく @code{nndoc} が助けにな
ります。例えばあなたがメールを古い @file{RMAIL} で持っていて、それをあな
たの新しい @code{nnml} グループに分配したいとします。あなたはそのファイ
ルを @code{nndoc} を使って開いて (グループバッファーで @kbd{G f} 命令を
使う (@pxref{Foreign Groups}))、バッファー内の全記事にプロセス印を付
け (例えば @kbd{M P b})、そして @code{nnml} を使って再スプー
ル (@kbd{B r}) します。すべてがうまくいけば、@file{RMAIL} ファイル内のす
べてのメールはたくさんの  @code{nnml} ディレクトリーの中にも保存されます。
そしてあなたはあの厄介な @file{RMAIL} を削除することもできます。あなたに
ガッツがあれば!

仮想サーバー変数。

@table @code
@item nndoc-article-type
@vindex nndoc-article-type
これは @code{mbox}, @code{babyl}, @code{digest}, @code{news},
@code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx}, @code{mailman} および @code{mail-in-mail} また
は @code{guess} のいずれかでなくてはなりません。

@item nndoc-post-type
@vindex nndoc-post-type
この変数は Gnus にそのグループがニュースグループかメールグループかを教え
ます。正当な値は二つあります。@code{mail} (ディフォルト
値) か @code{news} です。
@end table

@menu
* Document Server Internals::   あなた独自の文書種別を追加する方法
@end menu

@node Document Server Internals
@subsubsection 文書サーバーの内部

@code{nndoc} で認識される新しい文書種別を追加することは難しくありません。
その文書がどのように見えるのかを寄せ集めて、その文書種別を認識する述語関
数を書き、そして @code{nndoc} に繋げるだけです。

まず、これが文書種別定義の例です。

@example
(mmdf
 (article-begin .  "^\^A\^A\^A\^A\n")
 (body-end .  "^\^A\^A\^A\^A\n"))
@end example

この定義は単に、唯一の名前 (@dfn{name}) とそれに続く正規表現と仮想変数設
定の列からなります。以下がこれに使える変数です---変数の数に圧倒されない
で下さい。ほとんどの文書種別はごくわずかの設定で定義できます。

@table @code
@item first-article
これがあれば、@code{nndoc} はこの正規表現に合致する何かが見つかるまで、
すべてのテキストを読み飛ばします。合致する前のすべてのテキストは完全に無
視されます。

@item article-begin
この設定はすべての文書種別定義において必ずなくてはなりません。これは各記
事の始まりがどのように見えるかを指定します。

@item head-begin-function
これがある場合、これは記事の先頭にポイントを移動させる関数でなくてはなり
ません。

@item nndoc-head-begin
これがある場合、これは記事のヘッダーに合致する正規表現でなくてはなりませ
ん。

@item nndoc-head-end
これは記事のヘッダーの最後に合致しなくてはなりません。これのディフォルト
値は @samp{^$}---空行です。

@item body-begin-function
これがある場合、この関数は記事のボディーの開始位置にポイントを移動させる
関数でなくてはなりません。

@item body-begin
これは記事のボディーの開始位置に合致しなくてはなりません。これのディフォ
ルト値は @samp{^\n} です。

@item body-end-function
これがある場合、この関数は記事のボディーの最後の位置にポイントを移動させ
る関数でなくてはなりません。

@item body-end
これがあれば、記事のボディーの最後に合致しなくてはなりません。

@item file-end
これがある場合、これはファイルの最後に合致しなくてはなりません。この正規
表現の後ろのテキストはすべて、完全に無視されます。
@end table

このように、これらの変数を使って @code{nndoc} は文書ファイルを、それぞれ
ヘッダーとボディーを持った記事の連なりとして解剖することができます。しか
し、すべての文書種別がすべてこのようなニュース風になってるわけではないの
で、さらにいくつかの変数---ヘッダーやボディーを Gnus の趣味に合うように
変形させる変数が必要になります。

@table @code
@item prepare-body-function
これがあれば、この関数は記事が要求されたときに呼び出されます。これはボディー
の開始位置のポイントとともに呼び出され、文書の内容の一部がエンコードされ
ている場合に有用です。

@item article-transform-function
これがあれば、この関数は記事が要求されたときに呼び出されます。これは、記
事のヘッダーとボディーの両方により広範囲な変形を行なうために使われるもの
です。

@item generate-head-function
これがあれば、この関数は Gnus が理解できるヘッダーを生成するために呼び出
されます。これは記事番号をパラメーターとして呼び出され、問題の記事のきれ
いなヘッダーを生成することを求められます。これはすべての記事のヘッダーが
要求されるときに呼び出されます。
@end table

私が作った中で最も複雑な例---標準まとめ送り形式を見てみましょう。

@example
(standard-digest
 (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
 (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
 (prepare-body-function . nndoc-unquote-dashes)
 (body-end-function . nndoc-digest-body-end)
 (head-end . "^ ?$")
 (body-begin . "^ ?\n")
 (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
 (subtype digest guess))
@end example

70 文字のダッシュ (`-') の行より前はすべて無視されるというのが分かります。
また @samp{^End of} で始まる行より後ろもすべて無視されます。各記事
は 30 文字のダッシュの行で始まり、ヘッダーとボディーの区切りの行は一個の
スペースを含むことがあり、そしてボディーはそれが渡される前
に @code{nndoc-unquote-dashes} を通されます。

あなた独自の文書定義を @code{nndoc} に接続するには、
@code{nndoc-add-type} 関数を使用します。これは二つのパラメーターをとりま
す--- 一つ目はその定義自身で、二つ目の (省略可能な) パラメーターはこの定
義を、文書種別定義連想リストのどこに置くかを指定します。この連想リストは
順番に走査され、与えられた種別 @var{type} に対し
て @code{nndoc-@var{type}-type-p} が呼び出されます。このように文書
が @code{mmdf} 種別であるかどうかを調べるため
に @code{nndoc-mmdf-type-p} が呼び出され、そして以下同様に続きます。これ
らの種別述語関数は、その文書がその種別でない場合は @code{nil} を返し、そ
の種別である場合は @code{t} を返し、その種別かもしれないときは数値を返さ
なくてはなりません。高い数値は高い可能性を意味し、低い数値は低い可能性を
意味します。@samp{0} は正しい値の中でもっとも低い数値です。

@node SOUP
@subsection SOUP
@cindex SOUP
@cindex offline

PC の世界の人々はよく、``オフライン'' ニュースリーダについて話をしていま
す。これはリーダとニュース配送を合体させた、実在するモンスターです。内蔵
モデムプログラム付きでね。きゃはは!

もちろん、我らが Unix キチガイの人間供は @code{uucp} だと
か @code{nntpd} のようなものを使い、神の領域たるメール、ニュースの配送を
正しく設定するのです。そして僕たちはただ普通のニュースリーダを使います。

しかし、あなたがとても遅いモデムを持っていてこれらを正しく設定することに
興味が無ければ、脳みそに楽をさせる方をするのも時には便利です。

@sc{soup} と呼ばれるファイル形式はニュースとメールをサーバーから家のマシ
ンへと転送し、それをまた戻すために開発されました。ちょっと面倒くさいかも
しれないけどね。

はじめにいくつか用語を。

@table @dfn
@item server
これは外の世界に繋がっていて、あなたがニュースとメールを送受信するマシン
です。

@item home machine
これはあなたが実際に読んだり返事を書いたりしたいマシンです。これは普通、
他の世界といかなる形でも接続されていません。

@item packet
メッセージと命令を含んだもの。パケットには二種類あります。

@table @dfn
@item message packets
これはサーバーで作られるパケットで、普通はあなたが読むためのたくさんのメッ
セージが含まれています。これらはディフォルトでは @file{SoupoutX.tgz} と
いう名前です。ここで @var{x} は数字です。

@item response packets
(返信パケット) このパケットは自宅マシンで作られるパケットで、普通はあな
たの書いた返事が含まれています。これらはディフォルトで
は @file{SoupinX.tgz} という名前です。ここで @var{x} は数字です。
@end table
@end table

@enumerate

@item
まず @sc{soup} パケットを作るためにサーバーにログインします。
@sc{soup} のための専用のブツ (@code{awk} プログラムのような) を使っても
良いし、Gnus の @sc{soup} 命令を使ってパケットを作っても良いで
す (@kbd{O s} あるいは @kbd{G s b} そして @kbd{G s p})

(@pxref{SOUP Commands})。

@item
パケットを自宅に転送します。電車で、船で、自動車で、あるいはモデムで、何
でもいいです。

@item
パケットをあなたのホームディレクトリーに置きます。

@item
Gnus をあなたの自宅マシンでかっ飛ばして、@code{nnsoup} バックエンドを基
本サーバーあるいは二次サーバーとして使用します。

@item
記事やメールを読んで必要なやつに返事を書いてフォローアップ記事を書きま
す (@pxref{SOUP Replies})。

@item
@kbd{G s r} 命令を実行して、これらの返事を @sc{soup} パケットに梱包しま
す。

@item
このパケットをサーバーに転送します。

@item
Gnus から @kbd{G s s} 命令を使ってこのパケットからメールを出します。

@item
あとはこれを死ぬまで続けます。

@end enumerate

つまり基本的に二者分割システムができたことになりま
す---@code{nnsoup} を読むために、Gnus を @sc{soup} パケットの梱包と送出
に使います。

@menu
* SOUP Commands::               @sc{soup} パケットを作成、送出する命令
* SOUP Groups::                 @sc{soup} パケットを読むバックエンド
* SOUP Replies::                @code{nnsoup} にメールとニュースを引き継がせる方法
@end menu

@node SOUP Commands
@subsubsection SOUP 命令

これらの命令は @sc{soup} パケットの作成と操作を行なうものです。

@table @kbd
@item G s b
@kindex G s b (グループ)
@findex gnus-group-brew-soup
現在のグループのすべての未読記事を梱包す
る (@code{gnus-group-brew-soup})。このコマンドはプロセス/接頭引数の習慣
に従います。

@item G s w
@kindex G s w (グループ)
@findex gnus-soup-save-areas
すべての @sc{soup} データファイルを保存しま
す (@code{gnus-soup-save-areas})。

@item G s s
@kindex G s s (グループ)
@findex gnus-soup-send-replies
返信パケットからすべての返信を送出する (@code{gnus-soup-send-replies})。

@item G s p
@kindex G s p (グループ)
@findex gnus-soup-pack-packet
すべてのファイルを  @sc{soup} パケットに梱包す
る (@code{gnus-soup-pack-packet})。

@item G s r
@kindex G s r (グループ)
@findex nnsoup-pack-replies
すべての返信を返信パケットに梱包する (@code{nnsoup-pack-replies})。

@item O s
@kindex O s (概略)
@findex gnus-soup-add-article
この概略モード命令は、現在の記事を @sc{soup} パケットに追加しま
す (@code{gnus-soup-add-article})。これはプロセス/接頭引数の習慣に従いま
す (@pxref{Process/Prefix})。
@end table

Gnus がこれらの実体をどこに置くかをカスタマイズするいくつかの変数があり
ます。

@table @code
@item gnus-soup-directory
@vindex gnus-soup-directory
@sc{soup} パケットを作成中に Gnus が中間ファイルを保存するディレクトリー
です。ディフォルト値は @file{~/SoupBrew/} です。

@item gnus-soup-replies-directory
@vindex gnus-soup-replies-directory
返信パケット送信中に Gnus が使用する一時ディレクトリーです。
@file{~/SoupBrew/SoupReplies/} がディフォルト値です。

@item gnus-soup-prefix-file
@vindex gnus-soup-prefix-file
Gnus が最後に使った接頭語を保存するファイル名です。ディフォルト値
は @samp{gnus-prefix} です。

@item gnus-soup-packer
@vindex gnus-soup-packer
@sc{soup} パケットを梱包する命令文字列の形式です。ディフォルト値
は @samp{tar cf - %s | gzip > $HOME/Soupout%d.tgz} です。

@item gnus-soup-unpacker
@vindex gnus-soup-unpacker
@sc{soup} パケットを取り出す命令文字列の形式です。ディフォルト値
は @samp{gunzip -c %s | tar xvf -} です。

@item gnus-soup-packet-directory
@vindex gnus-soup-packet-directory
Gnus が返信パケットを探しに行く場所です。ディフォルト値は @file{~/} です。

@item gnus-soup-packet-regexp
@vindex gnus-soup-packet-regexp
@code{gnus-soup-packet-directory} 内の @sc{soup} パケットに合致する正規
表現です。
@end table

@node SOUP Groups
@subsubsection SOUP グループ
@cindex nnsoup

@code{nnsoup} は @sc{soup} パケットを読むためのバックエンドです。これは
入ってきたパケットを読み、それを取り出して、あなたが暇なときに読むディレ
クトリーに展開します。

これらはこの振る舞いをカスタマイズできる変数です。

@table @code
@item nnsoup-tmp-directory
@vindex nnsoup-tmp-directory
@code{nnsoup} が @sc{soup} パケットを取り出すとき、このディレクトリー内
で行ないます (ディフォルト値は @file{/tmp/})。

@item nnsoup-directory
@vindex nnsoup-directory
そして @code{nnsoup} がそれぞれのメッセージと索引ファイルをこのディレク
トリーに移動させます。ディフォルト値は @file{~/SOUP/} です。

@item nnsoup-replies-directory
@vindex nnsoup-replies-directory
すべての返信は、返信パケットに梱包される前にこのディレクトリーに格納され
ます。ディフォルト値は @file{~/SOUP/replies/} です。

@item nnsoup-replies-format-type
@vindex nnsoup-replies-format-type
返信パケットの @sc{soup} 形式です。ディフォルト値
は @samp{?n} (rnews) で、この変数には触るべきではないと私は思います。た
ぶん文書に明記すべきでさえなかったね。ちぇっ! もう手遅れか。

@item nnsoup-replies-index-type
@vindex nnsoup-replies-index-type
返信パケットの索引の種類です。ディフォルト値は @samp{?n} で、意味
は ``なし'' です。これもいじるんじゃないよ!

@item nnsoup-active-file
@vindex nnsoup-active-file
@code{nnsoup} がたくさんの情報を格納する場所です。これは @code{nntp} の
意味での ``アクティブファイル'' ではなく、Emacs Lisp のファイルです。こ
のファイルを無くしてしまったり、何か壊してしまったら、あなたは死にます。
ディフォルト値は @file{~/SOUP/active} です。

@item nnsoup-packer
@vindex nnsoup-packer
返信 @sc{soup} パケットを梱包する命令文字列の形式です。ディフォルト値
は @samp{tar cf - %s | gzip > $HOME/Soupin%d.tgz} です。

@item nnsoup-unpacker
@vindex nnsoup-unpacker
入ってくる @sc{soup} パケットを取り出すための命令文字列の形式です。ディ
フォルト値は @samp{gunzip -c %s | tar xvf -} です。

@item nnsoup-packet-directory
@vindex nnsoup-packet-directory
入ってきたパケットを @code{nnsoup} が探す場所です。ディフォルト値
は @file{~/} です。

@item nnsoup-packet-regexp
@vindex nnsoup-packet-regexp
入ってきた @sc{soup} パケットに合致する正規表現です。ディフォルト値
は @samp{Soupout} です。

@item nnsoup-always-save
@vindex nnsoup-always-save
@code{nil} 以外であれば、メッセージを投稿した後に返信バッファーを保存す
る。
@end table

@node SOUP Replies
@subsubsection SOUP 返信

単に @code{nnsoup} を使うだけでは、@sc{soup} 返信パケット中のあなたの投
稿とメールの送信が、魔法のように自動的に終了するわけではありません。それ
を起こすにはもうちょっと働かなくてはいけません。

@findex nnsoup-set-variables
@code{nnsoup-set-variables} 命令は、あなたのすべてのフォローアップ記事と
返信を @sc{soup} システムに確実に終了させるように、適切な変数を設定しま
す。

特別に、これが実際に行なわれることです。

@lisp
(setq message-send-news-function 'nnsoup-request-post)
(setq message-send-mail-function 'nnsoup-request-mail)
@end lisp

それだけです、ほんとに。もし @sc{soup} システムにニュースだけを入れたかっ
たら、最初の行だけを使って下さい。もしメールだけを @sc{soup} させたかっ
たら、二番目を使って下さい。

@node Mail-To-News Gateways
@subsection メールからニュースへのゲートウェイ
@cindex mail-to-news gateways
@cindex gateways

もしあなたのローカルの @code{nntp} サーバーが、何らかの理由で投稿を許可
していなければ、数あるメールからニュースへのゲートウェイを使って投稿する
ことができます。@code{nngateway} バックエンドはこのインターフェースを提
供します。

このバックエンドからは何も読み出せないことに注意して下さい---これは投稿
するためだけに使われます。

以下はサーバー変数です。

@table @code
@item nngateway-address
@vindex nngateway-address
これがメール・ニュースゲートウェイのアドレスです。

@item nngateway-header-transformation
@vindex nngateway-header-transformation
ニュースヘッダーは、メール・ニュースゲートウェイが受け付けられるように、
奇妙な形に変形しておかなくてはならない時があります。この変数はどんな変形
処理が呼び出されるべきかを示しており、ディフォルト値
は @code{nngateway-simple-header-transformation} になっています。この関
数は変形するヘッダーに領域制限 (narrow) されて呼び出され、一個の引
数---ゲートウェイのアドレスを与えられます。

ディフォルト値の関数は、単に新しい @code{To} ヘッダー
を @code{Newsgroups} ヘッダーとゲートウェイアドレスをもとに挿入します。
例えば、以下のような @code{Newsgroups} ヘッダー

@example
Newsgroups: alt.religion.emacs
@end example

を持つ記事には、次のような @code{To} ヘッダーが挿入されます。

@example
To: alt-religion-emacs@@GATEWAY
@end example

以下の既製関数が存在します:

@findex nngateway-simple-header-transformation

@table @code
@item nngateway-simple-header-transformaton
@var{newsgroup}@@@code{nngateway-address} のような @code{To} ヘッダーを
作ります。

@findex nngateway-mail2news-header-transformation

@item nngateway-mail2news-header-transformation
@code{nngateway-address} のような @code{To} ヘッダーを作ります。

ここに例があります。

@lisp
(setq gnus-post-method
      '(nngateway
        "mail2news@@replay.com"
        (nngateway-header-transformation
         nngateway-mail2news-header-transformation)))
@end lisp
@end table
@end table

つまり、これを使うには、こんな風にするだけです。

@lisp
(setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))
@end lisp

@node Combined Groups
@section 合併グループ

Gnus は、すべてのグループの種類を混合して、大きなグループに合併させるこ
とができます。

@menu
* Virtual Groups::              たくさんのグループの記事を合併させる
* Kibozed Groups::              ニューススプールの中からの記事を検索する
@end menu

@node Virtual Groups
@subsection 仮想グループ
@cindex nnvirtual
@cindex virtual groups
@cindex merging groups

nnvirtual グループ (@dfn{nnvirtual group}) は実は他のグループの集合以上
の何物でもありません。

例えば、もし小さなグループをたくさん読むのが嫌になってきたら、それらを一
つの大きなグループに入れて、嫌になるくらい巨大で手に負えないグループを読
むことができます。これがコンピューターの楽しみだね!

選択方法として @code{nnvirtual} を指定して下さい。アドレスは、それを構成
するグループに合致する正規表現です。

仮想グループ内で付けられたすべての印は、その構成グループの記事にくっつけ
られます。つまり、もし仮想グループ内で記事に可視記事の印を付けると、その
記事はもともとの構成グループの中でも可視記事になります。(そして逆も成り
立ちます---構成グループ内で付けた印は仮想グループ内でも表示されま
す。) 空の仮想グループを作るには、グループバッファーで @kbd{G V}
(@code{gnus-group-make-empty-virtual}) を実行し、@kbd{M-e}
(@code{gnus-group-edit-group-method}) でメソッドの正規表現を編集して下さ
い。

これが、Andrea Dworkin に関するすべてのニュースグループを、一つの巨大で
シアワセなニュースグループにまとめる @code{nnvirtual} 方法の例です。

@lisp
(nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")
@end lisp

構成グループは基本グループでも外部グループでも構いません。すべて問題無く
動くはずですが、もしあなたのコンピューターが爆発でもしてしまったら、それ
はたぶん私が悪いんでしょうね。

いくつかのサーバーから同じグループを集めることは、利用者
が Distribution ヘッダーを使って配布範囲を制限している場合は、非常に良い
かもしれません。もしあなたが @samp{soc.motss} を、日本のサーバーとノルウェー
のサーバーの両方から読みたければ、グループの正規表現として以下の値が使え
ます。

@example
"^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"
@end example

(でもちょっと注意。@kbd{G m} でグループを作成するときは、バックスラッシュ
を二重に付けてはいけません。そして文字列の最初と最後の引用記
号 (@samp{"..."}) も取り払って下さい。)

これはちょっとうまく動作するはずです---両方のグループの記事は全部完全に
一つのグループになり、重複も無いはずです。スレッド表示 (とその他) も通常
通りうまく動作するでしょうけど、記事の並ぶ順序には問題があるかもしれませ
ん。日付による並べ替えはここでは仕様外となるかもしれませ
ん (@pxref{Selecting a Group})。

なお、ここで一つだけ制限があります---仮想グループに含まれるグループはす
べて生きている (すなわち、購読または非購読の) 状態でなくてはなりません。
削除あるいはゾンビグループは @code{nnvirtual} グループの構成グループにな
ることはできません。

@vindex nnvirtual-always-rescan
@code{nnvirtual-always-rescan} が @code{nil} 以外であれば、
@code{nnvirtual} は仮想グループに入ったとき常に、未読記事を走査します。
この変数が @code{nil} (これがディフォルト) であって、仮想グループを作成
した後に構成グループ内の記事を読んだ場合は、その構成グループで読まれた記
事は、仮想グループに入ったときに表示されるでしょう。もし共通の構成グルー
プを持つ二つの仮想グループがある場合にもこの影響があります。その場合はこ
の変数を @code{t} にした方が良いです。あるいは仮想グループに入る時に、毎
回そのグループの上で @code{M-g} を叩いても良いです---これはほぼ同様の効
果があります。

@code{nnvirtual} はメールとニュースの両方のグループを構成グループとする
ことができます。@code{nnvirtual} グループの記事に返答するときは、
@code{nnvirtual} は記事の出所の構成グループのバックエンドにそれがニュー
スのバックエンドであるかメールのバックエンドであるかを尋ねなければなりま
せん。しかし、@kbd{^} をしたときには、普通は構成バックエンドがこれを知る
確かな方法はなく、その場合は、@code{nnvirtual} は Gnus に記事はニュース
でないバックエンドから来たと告げることになります。(安全のために。)

このような場合は、メッセージバッファーでの @kbd{C-c C-n} が応答しようと
している記事から @code{Newsgroups} 行を抜き出して挿入します。

@code{nnvirtual} グループは、構成グループから記事と印以外は継承しません。
例えばグループパラメーターもそうなのですが、それらは継承されません。

@node Kibozed Groups
@subsection Kiboze グループ
@cindex nnkiboze
@cindex kibozing

@dfn{Kiboze} する、とは、``ニューススプール全部 (あるいはその一部) か
ら grep すること'' と @acronym{OED} (オックスフォード大辞典) によって定
義されています。@code{nnkiboze} はこれをあなたのために行なってくれるバッ
クエンドです。嬉しいね! これでどんな @acronym{NNTP} サーバーでも、役に立
たない要求で止まってしまうまで酷使することができるね。ああ、なんて幸せな
んだ!

@kindex G k (グループ)
kiboze グループを作成するには、グループバッファーで @kbd{G k} 命令を使い
ます。

@code{nnkiboze} 方法におけるアドレス欄は、@code{nnvirtual} と同様に、
@code{nnkiboze} に ``含めたい'' グループに合致する正規表現です。ここ
が @code{nnkiboze} と @code{nnvirtual} バックエンドの最も類似している点
です。

この構成グループを列挙する正規表現に加えて、@code{nnkiboze} グループには、
グループ内のどの記事を含めるかを決めるスコアファイルがなくてはなりませ
ん (@pxref{Scoring})。

@kindex M-x nnkiboze-generate-groups
@findex nnkiboze-generate-groups
あなたの欲しい @code{nnkiboze} グループを作成した後には、
@kbd{M-x nnkiboze-generate-groups} を実行しなければなりません。この命令
は時間がかかります。とってもかかります。すごく、すごーくかかります。
Gnus はその @code{nnkiboze} グループの一部となるべき記事があるかどうかを
調べるために、全部の構成グループの全部の記事に対してヘッダーを取得し、そ
れらすべてに対してスコア処理を実行しなくてはならないのです。

構成グループの数を抑えるように、限定した正規表現を使って下さい。さもない
と、あなたのところのシステム管理者を怒らせてしまって、@acronym{NNTP} サー
バーからあなたを追い出して二度と入れないようにしてしまうかもしれません。
不慣れな人がよくやることです。

@code{nnkiboze} の構成グループは生きている必要はありません---死んでても
良いし、外部グループでも構いません。無制限です。

@vindex nnkiboze-directory
@code{nnkiboze} グループの生成によって、二つのファイ
ル @code{nnkiboze-directory} 内に作成されます。これのディフォルト値
は @file{~/News/kiboze/} です。一方のファイルはそのグループの全記事
の @acronym{NOV} ヘッダー行を含んでいて、もう一方は構成記事を見つけるた
めにどのグループが検索されたかの情報を格納する、@file{.newsrc} の補助ファ
イルです。

@code{nnkiboze} グループ内の既読となった記事は、その記事
の @acronym{NOV} 行が @acronym{NOV} ファイルから削除されます。

@node Email Based Diary
@section 電子メールによる日程管理
@cindex diary
@cindex email based diary
@cindex calendar

この項では @code{nndiary} という特別なメール・バックエンドと、その仲間
の @code{gnus-diary} ライブラリについて説明します。それが「特別」なのは、
Gnus でメールを読むための標準の選択肢の一つであるつもりは無いからです。
それ (標準の選択肢) については @ref{Choosing a Mail Back End} を参照して
下さい。代わりに、特別な方法であなたのメールのいくつかを扱う、すなわちこ
れはリマインダ (予定を思い出させるもの) として使われます。

典型的な筋書きは、こうです。

@itemize @bullet
@item
あなたはアンディ・マクドウェルかブルース・ウィリス (あなたの好みに合わせ
て、どちらかを選んで下さい) と、一ヶ月後にデートの約束をしました。それを
忘れるわけにはいきません。
@item
そこで、自分宛てにリマインダのメッセージを (実際のところ、毎日一通) 送り
ます。
@item
あなたはそれをすっかり忘れて、受け取った新しいメールをいつもどおりに読み
続けます。
@item
デートの日が近付いてくると、グループバッファーで @kbd{g} をタイプしたと
きに、ときどきあなたの予定を思い出させるために、あたかも新着で未読のよう
に、メッセージが再びポップアップするでしょう。
@item
これを含んでいる「新しい」メッセージを読んで下さい、そして、再びあなたが
過ごす夜を夢見て下さい。
@item
いったんデートが終わると (実際にはディナーのすぐ後で寝入ってしまったとし
ても)、期限切れ消去の印が付いていれば、メッセージは自動的に消去されます。
@end itemize

Gnus Diary バックエンドは、(常に取り消されることが無い) 定期的な予定を、
几帳面な人たちと同じように扱う能力を持っていて、本当のメール・バックエン
ドのように動作し、いろんなやり方で設定することができます。このすべてが、
以下の各項で説明されます。

@menu
* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      nndiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること
@end menu

@node The NNDiary Back End
@subsection NNDiary バックエンド
@cindex nndiary
@cindex the nndiary back end

@code{nndiary} は @code{nnml} (@pxref{Mail Spool}) にとてもよく似ている
バックエンドです。現にそれは @code{nnml} と @code{nndraft} を合わせたも
のに見えるでしょう。@code{nnml} をご存知ならば、あなたはすで
に @code{nndiary} がメッセージを格納する仕組み (一通あたり一つのファイル、
一グループあたり一つのディレクトリー) に精通しています。

何はさておき、@code{nndiary} をちゃんと動作させるには、一つの要件があり
ます: Gnus のグループの日付の機能を使わ @emph{なければ} なりません。それ
がどういうふうに行なわれるかは @ref{Group Timestamp} を見て下さい。

@menu
* Diary Messages::              メッセージを nndiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル
@end menu

@node Diary Messages
@subsubsection 日程メッセージ
@cindex nndiary messages
@cindex nndiary mails

七つの特別なヘッダーが必須であること以外、@code{nndiary} のメッセージは
普通のものです。それらのヘッダーは @code{X-Diary-<something>} の様式で表
され、@code{<something>} の部分は @code{Minute}, @code{Hour},
@code{Dom}, @code{Month}, @code{Year}, @code{Time-Zone} およ
び @code{Dow} のうちの一つです。@code{Dom} は「日 (Day of Month)」を、
@code{Dow} は「曜日 (Day ofWeek)」を意味します。これらのヘッダー
は crontab の仕様のように働いて、予定日を定義します。

@itemize @bullet
@item
@code{Time-Zone} のもの以外のすべてのヘッダーについて、ヘッダーの値は星
印 (可能なすべての値を意味します) かコンマで区切られたフィールドのリスト
です。
@item
フィールドは整数か範囲です。
@item
範囲とは、ダッシュ (-) で区切られた二つの整数です。
@item
可能な値は、それぞれ @code{Minute} には 0--59、@code{Hour} には 0--23、
@code{Dom} には 1--31、@code{Month} には 1--12、@code{Year} には 1971 よ
り大きい値、そして @code{Dow} には 0--6 (0 が日曜日) です。
@item
特別な場合として、@code{Dom} または @code{Dow} における星印は「可能なす
べての値」ではなく、「もう一方のフィールドだけを使う」意味になります。両
方とも星印にした場合は、どちらを使っても同じ結果になることに注意して下さ
い。
@item
@code{Time-Zone} ヘッダーは、値を一つしか持てない (例えば @code{GMT}) 点
で特別です。星印は「可能なすべての値」ではなく (それは意味をなさないので)、
「現在のローカルなタイムゾーン」を意味します。ここではたいてい星印を使う
でしょう。しかし、利用できるタイムゾーンの値については、変
数 @code{nndiary-headers} を見て下さい。
@end itemize

1999年から 2010年までの毎週月曜日と毎月の一日の 12:00, 20:00, 21:00,
22:00, 23:00 および 24:00 を設定するために、メッセージに加える日程ヘッダー
の具体例です (その時何をしたら良いかは、自分で考えて下さい):

@example
X-Diary-Minute: 0
X-Diary-Hour: 12, 20-24
X-Diary-Dom: 1
X-Diary-Month: *
X-Diary-Year: 1999-2010
X-Diary-Dow: 1
X-Diary-Time-Zone: *
@end example

@node Running NNDiary
@subsubsection NNDiary を動かす
@cindex running nndiary
@cindex nndiary operation modes

@code{nndiary} には二つの動作モードがあります。一つはディフォルトの
「伝統型 (traditional)」、もう一つは「自律型 (autonomous)」です。伝統型
のモードでは、@code{nndiary} はそれ自身が新着メールを取得することはあり
ません。日程メッセージとして扱うために、メールを基本のメール・バックエン
ドから nndiary グループに、移動 (@kbd{B m}) またはコピー (@kbd{B c}) し
なければなりません。自律型のモードでは、@code{nndiary} はそれ自身のメー
ルを取ってきて、基本のメール・バックエンドとは独立してそれを扱います。

本質的に Gnus は、同時に複数の「マスター」メール・バックエンドを許容する
ようには設計されていなことに、注意すべきです。しかし @code{nndiary} では、
これは意味をなします。あなたは本当に、日程メッセージを日程グループに直接
送って、それらを受け取りたいのです。そこで @code{nndiary} は、まさに「二
番目の第一メール・バックエンド」をサポートします (私が知っている限り、そ
れはこの機能を提供する唯一のバックエンドです)。しかしながら制約があっ
て (いつの日にか解消することを願いますが)、自律型のモードでは再スプール
ができません。

自律型のモードで @code{nndiary} を使うためには、いくつかのことをやっても
らわなければなりません:

@itemize @bullet
@item
新着メールを @code{nndiary} が自分で取り込めるようにします。以下の行
を @file{gnusrc} ファイルに記入して下さい:

@lisp
(setq nndiary-get-new-mail t)
@end lisp
@item
日程メッセージ (@code{X-Diary-*} ヘッダーを含んでいる) が、Gnus がそれら
を処理する @emph{前} に専用のフォルダーに分配されるように、準備を行なわ
なければなりません。繰り返しますが、Gnus が複数の第一メール・バックエン
ドを適切に扱うことが (まだ ?) できないので、これが必要です。別々のソース
からそれらのメッセージを取り込むことによって、この欠点はある程度補われま
す。

日程ファイルを @file{~/.nndiary} (これがディフォルトの @code{nndiary} の
メールソース・ファイルです) に格納するための procmailrc の項の例です:

@example
:0 HD :
* ^X-Diary
.nndiary
@end example
@end itemize

いったんこれを実施したら、日程メールの取り込みと分割の処理に影響する、以
下の二つのオプションをカスタマイズする必要があるでしょう:

@defvar nndiary-mail-sources
標準の @code{mail-sources} 変数の、日程用に特化した代替品です。同じシン
タックスを使い、ディフォルト値は @code{(file :path "~/.nndiary")} です。
@end defvar

@defvar nndiary-split-methods
標準の @code{nnmail-split-methods} 変数の、日程用に特化した代替品です。
同じシンタックスを使います。
@end defvar

最終的には @code{gnus-secondary-select-methods} に、恒久的
な @code{nndiary} 仮想サーバー (@code{(nndiary "diary")} が行なうべきで
あるようなもの) を追加しても良いでしょう。

うまくいけば、Gnus を再起動すると、ほとんどすべ
て (@file{nndiary.el} の TODO の項を参照) が期待通りに (自律型のモードで
は、@kbd{g} や @kbd{M-g} をグループバッファーでタイプすれば新しい日程メー
ルをも取り込んで、日程用に特化した規則に従ってそれらを分割するし、
@kbd{F} は新しい日程グループを見つけてくれる、など) 動作するでしょう。

@node Customizing NNDiary
@subsubsection NNDiary のカスタマイズ
@cindex customizing nndiary
@cindex nndiary customization

さあ @code{nndiary} が立ち上がって動作しています。それをカスタマイズする
ときが来ました。カスタマイズするためのグループは @code{nndiary} です (へ
えー)。どのオプションをカスタマイズし倒したいかを見つけるために、それに
目を通して下さい。あなたが変更したいのは、おそらく以下のたった二つの変数
でしょう:

@defvar nndiary-reminders
予定を思い出させてもらいたい時刻のリスト (例えば三週間前、それから二日前、
それから一時間前、そしてそのとき) です。「思い出させてもらう」の意味は、
新着メールを取り込んだときに、日程メッセージが真新しく未読になって、ポッ
プアップすることであることを思い出して下さい。
@end defvar

@defvar nndiary-week-starts-on-monday
読んで字の如し。さもなくば日曜日が仮定されます (それがディフォルトです)。
@end defvar

@node The Gnus Diary Library
@subsection Gnus Diary ライブラリ
@cindex gnus-diary
@cindex the Gnus diary library

@code{nndiary} を手作業で使うの (ヘッダーを手で書く、とか) は、いささか
うんざりします。幸い @code{nndiary} の上位階層に書かれ
た @code{gnus-diary} というライブラリがあって、たくさんの便利なことをやっ
てくれます。

それを使うためには、以下の行を @file{gnusrc} ファイルに加えて下さい:

@lisp
(require 'gnus-diary)
@end lisp

さらに、どんな @code{gnus-user-format-function-[d|D]} (@pxref{Summary
Buffer Lines}) も、使ってはいけません。@code{gnus-diary} はそれらの両方
を提供します (あなたがそれらを使っていたら、すみません)。

@menu
* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで
@end menu

@node Diary Summary Line Format
@subsubsection 日程の概略行仕様
@cindex diary summary buffer line
@cindex diary summary line format

標準の概略行仕様 (通常 @samp{From Joe: Subject} のようなもの) で日程メッ
セージを表示するのは、まったく役に立ちません。たいていはあなたがメッセー
ジを書いた人で、おおかた予定の日付を見たいと思っているでしょう。

@code{gnus-diary} は、概略行仕様で使う二つの追加の利用者定義の書法仕様を
提供します。@code{D} は次の予定が生じるときのための整形された時刻表
示 (例えば ``Sat, Sep 22 01, 12:00'') を表すのに対して、@code{d} は次の
予定が生じるまでのおおよその残り時間 (例えば ``in 6 months, 1 week'') を
表します。

ジョーの誕生日が、概略行にどう表示されるかの例です (定期的な予定を指定す
ると消されないことを除いて、メッセージが期限切れ消去可能であることに注目
して下さい):

@example
   E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)
@end example

上記のようなものを得るために、普段だったら、あなたは以下の行を日程グルー
プのパラメーターに加えようとするでしょう:

@lisp
(gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")
@end lisp

でも @code{gnus-diary} はそれを自動で行ないます (@pxref{Diary Group
Parameters})。あなたはしかし、以下のユーザー・オプション群で提供される概
略行仕様を、カスタマイズすることができます:

@defvar gnus-diary-summary-line-format
日程グループで使う概略行仕様を定義します (@pxref{Summary Buffer Lines})。
@code{gnus-diary} はそれを、日程グループのパラメーターを自動で更新するた
めに使います。
@end defvar

@defvar gnus-diary-time-format
日程の概略バッファーに日付を表示するための書法仕様を定義します。これ
は利用者定義の書法仕様 @code{D} で使われます。詳細は変数の説明文を見て下
さい。
@end defvar

@defvar gnus-diary-delay-format-function
日程の概略バッファーに遅延 (残り時間) を表示するための整形関数を定義しま
す。これは利用者定義の書法仕様 @code{d} で使われます。現在は英語とフラン
ス語のための組み込み関数があり、自分で定義することもできます。詳細は変数
の説明文を見て下さい。
@end defvar

@node Diary Articles Sorting
@subsubsection 日程記事の並べ替え
@cindex diary articles sorting
@cindex diary summary lines sorting
@findex gnus-summary-sort-by-schedule
@findex gnus-thread-sort-by-schedule
@findex gnus-article-sort-by-schedule

@code{gnus-diary} は並べ替えのための関数 (@pxref{Sorting the Summary
Buffer}) として @code{gnus-summary-sort-by-schedule}、
@code{gnus-thread-sort-by-schedule} およ
び @code{gnus-article-sort-by-schedule} を提供します。これらの関数によっ
て、最も近い予定から最も遠い方まで、日程の概略バッファーを整理することが
できます。

@code{gnus-diary} は自動的に、概略バッファーの「並べ替え (sort)」メニュー
に @code{gnus-summary-sort-by-schedule} を組み込み、他の二つを第一次
の (ゆえにディフォルトの) 並べ替え関数として、グループパラメー
ター (@pxref{Diary Group Parameters}) に登録します。

@node Diary Headers Generation
@subsubsection 日程ヘッダーの生成
@cindex diary headers generation
@findex gnus-diary-check-message

@code{gnus-diary} は、@code{X-Diary-*} ヘッダーの取り扱いを補佐するため
に、@code{gnus-diary-check-message} という関数を提供します。この関数は、
すべての必要な日程ヘッダーが確実に現在のメッセージに含まれるようにして、
必要ならば値を入力するか修正することを要求します。

記事を日程グループに移動またはコピーすると自動的にそれを発動するように、
この関数は @code{nndiary} バックエンドのフックとして組み入れられています。
それはさらに、通常のメールを日程用のものに変換する操作を簡単にするために、
@code{message-mode} と @code{article-edit-mode} におい
て @kbd{C-c D c} キーとして設定もされています。

接頭引数を伴ってこの関数を呼ぶと、それらがあるか、正しいかどうかとは無関
係に、日程ヘッダーの入力を強制します。そうやって、例えばすでに正しく設定
されたメッセージの日程を、とても簡単に変更することができます。

@node Diary Group Parameters
@subsubsection 日程グループのパラメーター
@cindex diary group parameters

新しい日程グループを作るか、またはそれを開くと、@code{gnus-diary} は自動
的にグループパラメーターを検査し、必要なら概略行仕様を日程用に特化した値
に設定し、日程用の並べ替え関数を組み込み、さらにそのグループの投稿様
式 (posting-style) に種々の @code{X-Diary-*} ヘッダーを加えます。そして、
日程メッセージを送るのは、より簡単です。メッセージを用意するために、日程
グループで @kbd{C-u a} か @kbd{C-u m} を使うことによって、これらのヘッダー
が自動的に挿入されるので (まだ適切な値で満たされていませんが)。

@node Sending or Not Sending
@subsection 送信するべきか、しないべきか

さて、以上の説明を読んでくれたものとして、以下は @code{nndiary} でメール
を送信することに関する、二つの最後の注意事項です:

@itemize @bullet
@item
@code{nndiary} は @emph{本当の} メール・バックエンドです。本当にあなたは
本当の日程メッセージを本当に送ります。これは、日程メッセージを送ることに
よって、誰にでも (彼らが Gnus と @code{nndiary} を使っているのならば) 予
定を伝えることができることをも意味します。
@item
しかしながら @code{nndiary} は @code{request-post} メソッドを持ってもい
るので、日程グループで @kbd{C-u m} の代わりに @kbd{C-u a} を使うことによっ
て、メッセージを実際に送信するのではなく、そのグループにローカルに格納す
ることもできます。これは個人的な予定のためには、とても手ごろです。
@end itemize

@node Gnus Unplugged
@section Gnus の切り離し
@cindex offline
@cindex unplugged
@cindex agent
@cindex Gnus agent
@cindex Gnus unplugged

いにしえの時代 (およそ 1988 年2月頃)、人々はニュースリーダーを、大きなマ
シンの上でネットワークに永続的に接続して走らせていました。ニュースの配送
はニュースサーバーによって取り扱われ、すべてのニュースリーダーがすべきこ
とは、ニュースを読むことであったのです。信じられないかもしれませんが。

今日では、多くの人々は自宅でニュースやメールを読み、ネットワークに接続す
るためにモデムの類を使います。電話代の請求書が莫大なものに上らないように、
すべてのニュースとメールを吸い上げ、電話を切り、数時間掛けて読み、そして
送りたい返信をすべて送信する、という手段を持つことは良いことでありましょ
う。あとはこの手順を繰り返すのです。

もちろん、これを行なうためにニュースサーバーを使うこともできます。私
は @code{inn} を @code{slurp}, @code{pop}, @code{sendmail} と一緒にここ
数年使ってきましたが、しかしこれは退屈な仕事です。もしあるマシン上でニュー
スを読む人があなたしかいなければ、ニュースサーバーの機能をニュースリーダー
に任せるようにすることは理にかなっています。

Gnus を ``オフライン'' のニュースリーダーとして仕立てるのは極めて簡単で
す。実際、エージェントは今やディフォルトで有効になっている (@pxref{Agent
Variables, gnus-agent}) ので、あなたは何も設定する必要が無いのです。

もちろん、これをオフラインニュースリーダーとして使うには、いくつか新しい
命令を覚えなくてはなりません。

@menu
* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               エージェントが概略バッファーに変化をもたらすかもしれない方法
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を消す方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and IMAP::              エージェントを @acronym{IMAP} で使う方法
* Outgoing Messages::           投稿、メールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{~/.gnus.el} の例
* Batching Agents::             @code{cron} ジョブによるニュース取得方法
* Agent Caveats::               あなたが予想することと、それが実際にすること
@end menu

@node Agent Basics
@subsection エージェントの基礎

まず、いくつかの用語を片付けておきましょう。

ネットワークとの通信が切れているとき (そしてエージェントがそれを知らされ
ているとき)、Gnus エージェントは切り離されている (@dfn{unplugged}) と言
います。ネットワークの通信が復活し (そして Gnus がそれを知れば)、エージェ
ントは差し込まれている (@dfn{plugged}) と言います。

ローカル (@dfn{local}) マシンとは、あなたが触っているマシンで、ネットワー
クに継続的に接続されているものではありません。

ダウンロード (@dfn{downloading}) とはネットワークから何かをあなたのロー
カルマシンに取ってくることを意味します。アップロー
ド (@dfn{uploading}) はその逆をすることです。

ご存知のように Gnus はあなたがドジを踏むすべての機会を提供します。それを
柔軟性と言う人もいます。さらに Gnus は大いにカスタマイズ可能で、それは利
用者が、Gnus がどのように動作するかについて発言権を持っていることを意味
します。他のニュースリーダーは有無を言わずあなたにドジを踏ませるかもしれ
ませんが、Gnus ではあなたに選択権があります!

Gnus は実際には plugged または unplugged のどちらの状態にもありません。
もっと正確に言えば、サーバーごとにそれぞれの状態を持ちます。これは、いく
つかのサーバーが接続できないときに、他のサーバーは接続できることを意味し
ます。さらに、 Agent によっていくつかのサーバーをすべて無視することがで
きます (その意味は、それらがいつも plugged になっているのと似ているとい
うことです)。

Agent を切り離しても、なぜ Gnus がネットに接続しているのかがいぶかしく思
われたとき、行なうべき次のステップはサーバーがすべてエージェント化されて
いるかどうかを観察することです。エージェント化されていないサーバーがあっ
たら、あなたは犯人を見つけたのです。

もう一つの状態は @dfn{offline} です。サーバーはときどき到達可能ではなく
なります。Gnus がこのことを知ると、そのサーバーを offline の状態に切り換
えても良いかどうかを尋ねます。はい、と答えたならば、(offline に戻して良
いかと Gnus が尋ねた場合以外は) サーバーは多少 unplugged だったときのよ
うに振る舞います。

エージェントを使った典型的な Gnus の対話操作を見てみましょう。

@itemize @bullet

@item
@findex gnus-unplugged
Gnus を @code{gnus-unplugged} で起動します。これは Gnus エージェントを切
り離されている状態で起動します。この状態では、すでに取得しているニュース
記事はすべて読むことができます。

@item
そして、新しいニュースが到着しているかどうかを調べることにします。あなた
は (PPP か何かを使って) あなたのマシンをネットワークに接続し、Gnus を差
し込むために @kbd{J j} を叩き、そして普通は新着メールを検査するため
に @kbd{g} を使います。Gnus エージェントが切り離されてい
る (@dfn{unplugged}) ときの新着メールの検査について
は @ref{Mail Source Specifiers} を参照して下さい。

@item
そして、その場ですぐに新しいニュースを読むこともできるし、ニュースをロー
カルマシンにダウンロードすることもできます。後者を実行したければ、
@kbd{g} を押して新着メールを検査してから @kbd{J s} で全グループから適切
な記事をすべて取得します。(Gnus にどの記事をダウンロードしたいかを指定す
るには @ref{Agent Categories} を参照して下さい。)

@item
記事を取得した後は @kbd{J j} を押して、Gnus を再び切り離し状態にさせ、
PPP 関係 (など) を閉じます。そうしてニュースをオフラインで読むことができ
ます。

@item
そして第二ステップに戻ります。
@end itemize

以下にエージェントを初めて (かそこらに) 使うときに必要ないくつかの作業を
示します。

@itemize @bullet

@item
どのサーバーをエージェントで面倒を見るかを決めます。もしメールバックエン
ドがあれば、それをエージェントに面倒を見させるのはおそらく無意味でしょう。
サーバーバッファーに移動し (グループバッファーで @kbd{^})、エージェント
に扱って欲しいサーバー (複数可) で @kbd{J a} を押す (@pxref{Server Agent
Commands}) か、またはエージェントに扱って欲しくないのに自動的に追加され
たサーバーで @kbd{J r} を押します。ディフォルトで
は @code{gnus-select-method} と @code{gnus-secondary-select-methods} に
あるすべての @code{nntp} と @code{nnimap} サーバーがエージェント化されま
す。

@item
ダウンロード方針を決定します。あなたの方針を実装するためにエージェント分
類、トピックパラメーター、グループパラメーターのどれを使うかをいったん決
めてしまえば、これはかなり簡単です。あなたが Gnus の初心者ならば、たぶん
分類で始めるのが最良でしょう、@xref{Agent Categories}.

トピックパラメーター (@pxref{Topic Parameters}) とエージェント分
類 (@pxref{Agent Categories}) の両方は、多数のグループに適用する方針の設
定を用意しています。どれを使うかは完全にあなたの責任です。両方を混ぜて使
う場合は、トピックパラメーターは分類を無効にすることを考慮に入れなければ
ならないでしょう。あなたの方針にそぐわない少数のグループがあるのならば、
それらの設定を変更するためにグループパラメー
ター (@pxref{Group Parameters}) を使うことができます。

@item
ええと@dots{}、以上です。
@end itemize

@node Agent Categories
@subsection エージェント分類

ニュース配送機構とニュースリーダーを統合する一つの大きな理由は、どの記事
をダウンロードするかについて、より良い制御を可能とすることです。莫大な量
の記事をダウンロードしてもあまり意味はなく、それらを読んでもあまり面白く
ないことが分かるだけです。何をダウンロードするかの選択はもっと慎重である
べきであり、その記事が面白いと分かった時点で、ダウンロードするための印を
手動で付けるべきなのです。

何をダウンロードするかを制御するためのより有効な方法の一つは、分
類 (@dfn{category}) を作成して、そしてその分類にいくつか (あるいは全
部) のグループを割り当てることです。他の分類に属さないグループ
は @code{ディフォルト} の分類に属します。Gnus は分類の作成と管理のための
独自のバッファーを持っています。

もしそうしたければ、グループパラメーター (@pxref{Group Parameters}) とト
ピックパラメーター (@pxref{Topic Parameters}) を、エージェントを制御する
代替手段に使うことができます。実際に違うのは、グループとトピックパラメー
ターが何でもかんでも (kitchen sink) 含むのに対して、分類はエージェントに
特化している (したがってあまり学ばなくても良い) ということだけです。

エージェントパラメーターは複数の違う場所で設定することができるので、どの
ソースが信用できるかを決めるための規則を設けました。この規則は、パラメー
ターのソースが次の順序で調べられることを定めます: グループパラメーター、
トピックパラメーター、エージェント分類、そして最後はカスタマイズできる変
数群です。したがって、広い範囲で動作を起こさせるためにこれらのソースをす
べて混合することができます。どこに設定を置いたのかを忘れてしまったからと
いって、私を責めないで下さいよ。

@menu
* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス
@end menu

@node Category Syntax
@subsubsection 分類の文法

分類は、名前、その分類に属するグループのリスト、およびカスタマイズ可能な
変数よりも優先される多くの任意なパラメーターから成ります。エージェントパ
ラメーターの完全なリストを以下に示します。

@cindex Agent Parameters
@table @code
@item agent-cat-name
分類の名前。

@item agent-groups
この分類にあるグループのリスト。

@item agent-predicate
(通常) どの記事をダウンロードするのが適当かという大まかな輪郭を与える述
語。そして

@item agent-score-file
(通常) どの記事をダウンロードするかを決めるときのよりきめの細かいスコア
規則。(このダウンロードスコア (@dfn{download score}) は通常のスコアとは
必ずしも関係が無いことに注意して下さい。)

@item agent-enable-expiration
このグループの古い記事をエージェントが期限切れ消去すべきかどうかを示す
ブール変数。大抵のグループはディスク空間を浪費しないために期限切れ消去さ
れるべきです。いや、実際には gnus.* 階層は期限切れ消去されるべきではな
いグループだけを含んでいると言っても、たぶん差し支えありません。

@item agent-days-until-old
既読の記事を期限切れ消去しても差し支えないことを判断する前に、エージェン
トが待っているべき日数を示す整数。

@item agent-low-score
@code{gnus-agent-low-score} よりも優先される整数。

@item agent-high-score
@code{gnus-agent-high-score} よりも優先される整数。

@item agent-length-when-short
@code{gnus-agent-short-article} よりも優先される整数。

@item agent-length-when-long
@code{gnus-agent-long-article} よりも優先される整数。

@item agent-enable-undownloaded-faces
ダウンロードされていない記事
を @code{gnus-summary-*-undownloaded-face} を使って概略バッファーに表示
すべきかどうかを示すシンボル。@code{nil} 以外ならどんなシンボルでも、ダ
ウンロードされていない記事用のフェースを使うようになります。
@end table

いったん分類が作られたら、分類の名前を変えることはできません。

それぞれの分類は、その分類の限られたメンバーであるグループのリストを維持
します。限られた規則は自動的に執行されます。新しい分類にグループを追加す
ると、それは古い分類から自動的に取り除かれます。

述語の一番単純な形式は @code{true} や @code{false} のような単独の述語か
らなります。これらの二つはそれぞれ、すべての可能な記事をダウンロードする
か、まったく何もしないか、です。これらの二つの特別な述語の場合は、追加の
スコア規則は余分です。

@code{high} や @code{low} という述語は下で説明されているように、
@code{gnus-agent-high-score} と @code{gnus-agent-low-score} との記事のス
コアとの関係により記事をダウンロードします。

ダウンロードが適切かどうかの、さらに細かい制御を得るために、述語は論理演
算子が間に散りばめられた述語の組み合わせからなることができます。

おそらくいくつかの例がそのまま使えます。

以下は簡単な述語です。(これはディフォルトの述語です。つまり、他のどの分
類にも含まれないすべてのグループに対して使用されます。)

@lisp
short
@end lisp

とっても簡単でしょ? この述語は、記事が短い (``短い'' 価値がある) 場合に
限り真になります。

これはもっと複雑な述語です。

@lisp
(or high
    (and
     (not low)
     (not long)))
@end lisp

この意味は、高いスコアを持っているか、あるいはスコアが低くなくてかつ長く
ない、という記事をダウンロードする、ということです。わかるだろ。

使ってもよい論理演算子は、@code{or}, @code{and}, @code{not} です。(もし
使いたければ、より ``C'' 風の演算子 @samp{|}, @code{&}, @code{!} を代り
に使うことができます。)

以下の述語はあらかじめ定義されていますが、これらのどれもあなたのやりたい
ことに一致しなければ、自分で独自のものを書くこともできます。

それぞれのこれらの述語を評価するとき、名前が付けられた定数は、適切なパラ
メーターの元に @code{gnus-agent-find-parameter} を呼ぶことによって決定さ
れた値で束縛されます。例え
ば gnus-agent-short-article は @code{(gnus-agent-find-parameter group
'agent-short-article)} に束縛されます。これは、あなたがあなたの分類で述
語を指定してから、その述語を個々のグループについて調整できることを意味し
ます。

@table @code
@item short
記事が @code{gnus-agent-short-article} 行より短かければ真です。ディフォ
ルト値は 100 です。

@item long
記事が @code{gnus-agent-long-article} 行より長ければ真です。ディフォルト
値は 200 です。

@item low
記事のダウンロードスコアが @code{gnus-agent-low-score} 以下であれば真で
す。ディフォルト値は 0 です。

@item high
記事のダウンロードスコアが @code{gnus-agent-high-score} 以上であれば真で
す。ディフォルト値は 0 です。

@item spam
Gnus エージェントがその記事を spam だと推測したら真です。この発見的手法
は今後変更されるかもしれませんが、現時点では、これはチェックサムを計算し
記事が一致するかどうかを調べています。

@item true
常に真です。

@item false
常に偽です。
@end table

あなたが自分の独自の述語関数を作成したければ、これを知っておいて下さ
い: 関数は引数無しで呼び出されますが、
@code{gnus-headers} と @code{gnus-score} 動的変数には便利な値が束縛され
ます。

例えば、一定の日付以上前に投稿された記事 (例えば、
@code{gnus-agent-expire-days} 以前に投稿されたもの) をダウンロードしない
とすることもできます。その場合、以下のような関数を書くでしょう:

@lisp
(defun my-article-old-p ()
  "Say whether an article is old."
  (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
     (- (time-to-days (current-time)) gnus-agent-expire-days)))
@end lisp

そうすると、述語はこのように定義します:

@lisp
(not my-article-old-p)
@end lisp

もしくは、@file{~/.gnus.el} や何か他のものでも、既定
の @code{gnus-category-predicate-list} に自分の述語を追加することもでき
ます。

@lisp
(require 'gnus-agent)
(setq gnus-category-predicate-alist
      (append gnus-category-predicate-alist
              '((old . my-article-old-p))))
@end lisp

そして、単に次のように述語を指定します:

@lisp
(not old)
@end lisp

上のようなものを使うときは、世の中には正しく設定されていないシステム/メー
ラーがあり、記事の日付はいつ投稿されたかを常に確実に示すわけではありませ
ん。あぁ、それをまったく気にしない人もいます。

上の述語はその分類に属する @emph{すべて} のグループに適用されます。しか
し、分類中の個々のグループに特定の述語を望んだり、怠惰過ぎて新しい分類を
設定できないときは、グループの個々の述語をグループパラメーターで次のよう
にすることができます。

@lisp
(agent-predicate . short)
@end lisp

これは agent 分類のディフォルトと等価なグループ/トピックパラメーターです。
このような一語の述語を指定しているときは、@code{agent-predicate} 指示は
ドット対記法である必要があることに注意して下さい。

上のものと等価な長い方の例は:

@lisp
(agent-predicate or high (and (not low) (not long)))
@end lisp

分類の指定で要求される外の丸括弧はここでは入力されておらず、ドット対の記
法でもなく、述語の値はリストあるとみなされます。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じですが、
例外として、実際に記事自身を調べる必要がある要素は禁止されています。つま
り、以下のヘッダーのみがスコア付けできます: @code{Subject}, @code{From},
@code{Date}, @code{Message-ID}, @code{References}, @code{Chars},
@code{Lines} and @code{Xref}.

述語と同様、グループに関して @code{ダウンロードスコア規則} の指定の使用
は、そこのすべてのグループに適用可能なら分類の定義、グループに特有ならグ
ループパラメーター、のどちらかにできます。

両方の場所で、@code{ダウンロードスコア規則} は以下の三つの形式を取ること
ができます:

@enumerate
@item
スコア規則

上で書かれているように、スコア付けキーワードの一部分しか使えないことを除
けば、これは普通の Gnus スコアファイルの構文と同じです。

例:

@itemize @bullet
@item
分類指定

@lisp
(("from"
       ("Lars Ingebrigtsen" 1000000 nil s))
("lines"
       (500 -100 nil <)))
@end lisp

@item
グループ/トピックパラメーター指定

@lisp
(agent-score ("from"
                   ("Lars Ingebrigtsen" 1000000 nil s))
             ("lines"
                   (500 -100 nil <)))
@end lisp

また、ここで一番外の括弧が省略されていることに注意して下さい。
@end itemize

@item
エージェントスコアファイル

これらのスコアファイルは上で述べられている使用可能なスコア付けキーワー
ド @emph{のみ} である必要があります。

例:

@itemize @bullet
@item
分類指定

@lisp
("~/News/agent.SCORE")
@end lisp

もしくは、たぶん

@lisp
("~/News/agent.SCORE" "~/News/agent.group.SCORE")
@end lisp

@item
グループパラメーター指定

@lisp
(agent-score "~/News/agent.SCORE")
@end lisp

上の様に、追加のスコアファイルを指定することができます。また括弧について
言わなければいけませんか?
@end itemize

@item
@code{普通} のスコアファイルの使用

一つのグループで二つのスコア規則を維持したくなく、グループの望み
の @code{ダウンロード} の基準が @code{読む} 基準と同じなら、エージェント
に何をダウンロードするかを決める際に @code{普通} のスコアファイルを参照
するようにすることができます。

分類定義か、グループパラメーターのこれらの指示はエージェントにグループに
適用可能なすべてのスコアファイルを読ませ、スコア付けキーワードの使用可能
な部分集合に無いものを @emph{選別して抜き取ります}。

@itemize @bullet
@item
分類指定

@lisp
file
@end lisp

@item
グループパラメーター指定

@lisp
(agent-score . file)
@end lisp
@end itemize
@end enumerate

@node Category Buffer
@subsubsection 分類バッファー

通常はすべての分類は分類バッファーから管理します。(グループバッファーか
ら @kbd{J c} 命令によって) 初めてこれに入ったとき、ディフォルトの分類だ
けが表示されます。

以下の命令がこのバッファーで使用できます。

@table @kbd
@item q
@kindex q (分類)
@findex gnus-category-exit
グループバッファーに戻ります (@code{gnus-category-exit})。

@item e
@kindex e (分類)
@findex gnus-category-customize-category
選択された分類のパラメーターを一括して設定するために、カスタマイズバッファー
を使います (@code{gnus-category-customize-category})。

@item k
@kindex k (分類)
@findex gnus-category-kill
現在の分類を消去します (@code{gnus-category-kill})。

@item c
@kindex c (分類)
@findex gnus-category-copy
現在の分類を複製します (@code{gnus-category-copy})。

@item a
@kindex a (分類)
@findex gnus-category-add
新しい分類を追加します (@code{gnus-category-add})。

@item p
@kindex p (分類)
@findex gnus-category-edit-predicate
現在の分類の述語を編集します (@code{gnus-category-edit-predicate})。

@item g
@kindex g (分類)
@findex gnus-category-edit-groups
現在の分類に属するグループの一覧を編集しま
す (@code{gnus-category-edit-groups})。

@item s
@kindex s (分類)
@findex gnus-category-edit-score
現在の分類のダウンロードスコア規則を編集しま
す (@code{gnus-category-edit-score})。

@item l
@kindex l (分類)
@findex gnus-category-list
すべての分類を表示します (@code{gnus-category-list})。
@end table

@node Category Variables
@subsubsection 分類変数

@table @code
@item gnus-category-mode-hook
@vindex gnus-category-mode-hook
分類バッファーで実行するフック。

@item gnus-category-line-format
@vindex gnus-category-line-format
分類バッファーの行様式 (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item c
分類の名前。

@item g
分類に属するグループの数。
@end table

@item gnus-category-mode-line-format
@vindex gnus-category-mode-line-format
分類モード行の様式 (@pxref{Mode Line Formatting})。

@item gnus-agent-short-article
@vindex gnus-agent-short-article
この変数より少ない行数の記事は短い。ディフォルト値は 100。

@item gnus-agent-long-article
@vindex gnus-agent-long-article
この変数より多い行数の記事は長い。ディフォルト値は 200。

@item gnus-agent-low-score
@vindex gnus-agent-low-score
この値より小さいスコアを持つ記事は低スコアである。ディフォルト値は 0。

@item gnus-agent-high-score
@vindex gnus-agent-high-score
この値より大きいスコアを持つ記事は高スコアである。ディフォルト値は 0。

@item gnus-agent-expire-days
@vindex gnus-agent-expire-days
期限切れ消去にふさわしくなるまで既読記事をエージェントのローカルディスク
に留めておく日数 (でも名前が同じだったら、これはそのサーバーにおける期限
切れ消去を意味しません。それは単に記事のローカルな複製を消すことを意味し
ます)。さらに理解すべき大事なことは、記事が読まれた時ではなくローカルディ
スクに記事が書かれた時から計数が始まるということです。ディフォルトは 7日。

@item gnus-agent-enable-expiration
@vindex gnus-agent-enable-expiration
グループの記事が、ディフォルトで期限切れ消去されるか、無期限に保持される
かを決定します。ディフォルトは @code{ENABLE} で、望むならば期限切れ消去
をさせないようにしなければならないことを意味します。一方、これ
を @code{DISABLE} に設定することができます。その場合、選択されたグループ
での期限切れ消去を有効にしなければなりません。
@end table

@node Agent Commands
@subsection エージェント命令
@findex gnus-agent-toggle-plugged
@kindex J j (Agent)

すべての Gnus エージェント命令は @kbd{J} サブマップにあります。
@kbd{J j} (@code{gnus-agent-toggle-plugged}) 命令はすべてのモードで動作
し、Gnus エージェントの切り離し/差し込み状態を切り替えます。

@menu
* Group Agent Commands::        グループの設定とそれらの内容の取得
* Summary Agent Commands::      手動で選択した記事を取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択
@end menu

@node Group Agent Commands
@subsubsection グループエージェント命令

@table @kbd
@item J u
@kindex J u (エージェント グループ)
@findex gnus-agent-fetch-groups
現在のグループの適格な記事をすべて取得しま
す (@code{gnus-agent-fetch-groups})。

@item J c
@kindex J c (エージェント グループ)
@findex gnus-enter-category-buffer
エージェント分類バッファーに入ります (@code{gnus-enter-category-buffer})。

@item J s
@kindex J s (エージェント グループ)
@findex gnus-agent-fetch-session
全グループの適格な記事をすべて取得しま
す (@code{gnus-agent-fetch-session})。

@item J S
@kindex J S (エージェント グループ)
@findex gnus-group-send-queue
順番待ち (queue) グループにある送信可能なメッセージをすべて送信しま
す (@code{gnus-group-send-queue})。@xref{Drafts}.

@item J a
@kindex J a (エージェント グループ)
@findex gnus-agent-add-group
現在のグループをエージェント分類に追加しま
す (@code{gnus-agent-add-group})。この命令はプロセス/接頭引数の習慣を理
解します (@pxref{Process/Prefix})。

@item J r
@kindex J r (エージェント グループ)
@findex gnus-agent-remove-group
現在のグループを、もし存在していれば、その分類から消去しま
す (@code{gnus-agent-remove-group})。この命令はプロセス/接頭引数の習慣を
理解します。(@pxref{Process/Prefix})。

@item J Y
@kindex J Y (エージェント グループ)
@findex gnus-agent-synchronize-flags
リモートサーバーが @dfn{unplugged} のときに変更されたフラグがあれば同期
させます。
@end table

@node Summary Agent Commands
@subsubsection 概略エージェント命令

@table @kbd
@item J #
@kindex J # (エージェント 概略)
@findex gnus-agent-mark-article
記事にダウンロードするように印を付ける (@code{gnus-agent-mark-article})。

@item J M-#
@kindex J M-# (エージェント 概略)
@findex gnus-agent-unmark-article
記事からダウンロードする印を消去する (@code{gnus-agent-unmark-article})。

@cindex %
@item @@
@kindex @@ (エージェント 概略)
@findex gnus-agent-toggle-mark
記事をダウンロードするかどうかを切り替え
る (@code{gnus-agent-toggle-mark})。ディフォルトではダウンロードの印
は @samp{%}。

@item J c
@kindex J c (エージェント 概略)
@findex gnus-agent-catchup
キャッシュされていない、ダウンロードされていない、またはダウンロードでき
ないすべての記事を既読にする (@code{gnus-agent-catchup})。

@item J S
@kindex J S (エージェント 概略)
@findex gnus-agent-fetch-group
このグループのすべての望ましい記事 (@pxref{Agent Categories}) をダウンロー
ドする。(@code{gnus-agent-fetch-group})。

@item J s
@kindex J s (エージェント 概略)
@findex gnus-agent-fetch-series
このグループのすべてのプロセス印が付いた記事をダウンロードする。
(@code{gnus-agent-fetch-series})。

@item J u
@kindex J u (エージェント 概略)
@findex gnus-agent-summary-fetch-group
現在のグループのダウンロード可能な記事を、すべてダウンロードす
る (@code{gnus-agent-summary-fetch-group})。
@end table

@node Server Agent Commands
@subsubsection サーバーエージェント命令

@table @kbd
@item J a
@kindex J a (エージェント サーバー)
@findex gnus-agent-add-server
現在のサーバーを、Gnus エージェントで扱われるサーバーの一覧に追加す
る (@code{gnus-agent-add-server})。

@item J r
@kindex J r (エージェント サーバー)
@findex gnus-agent-remove-server
現在のサーバーを、Gnus エージェントで扱われるサーバーの一覧から削除す
る (@code{gnus-agent-remove-server})。
@end table

@node Agent Visuals
@subsection エージェントの視覚効果

オフライン (unplugged) のときに概略を開いた場合に、Gnus が現在エージェン
トに格納されているヘッダーよりも多くの記事があることを、そのグループ
の active (訳注: 何番から何番までの記事があるかを示す管理情報) の範囲か
ら知っている場合、表題が @samp{[Undownloaded article #####]} のようになっ
ているいくつかの記事を見るかもしれません。それらは見当たらないヘッダーの
ための穴埋め (placeholders) です。印 (mark) を設定することはともかく、そ
れらの穴埋めの一つでできることは多くはありません。最終的に Gnus がグルー
プのヘッダーを取って来る機会を得たときに、それらの穴埋めは実際のヘッダー
で自動的に置き換えられるでしょう。気になるならば、それらの穴埋めを読み飛
ばすために、概略バッファーの動作を操作することができま
す (@code{gnus-auto-goto-ignores} 参照)。

すべての人にとって明白かもしれませんが、オフラインのときに利用できるのは、
以前に差し込まれていた間 (plugged) にエージェントに取り込まれたヘッダー
と記事だけです。言い換えると「差し込まれていた間に取り込むことを忘れると、
オフラインのセッションを満足できるものにするには足りない」ということです。
この理由のために、エージェントは概略バッファーに二つの視覚効果を加えます。
これらの効果は、オフラインのときにどの記事が利用できるかをいつも知らせる
ために、ダウンロードの状態を表示します。

第一の視覚効果は @samp{%O} 仕様です。この指示子を含めるため
に @code{gnus-summary-line-format} をカスタマイズすると、記事のダウンロー
ドの状態を示す単一の文字が加わるでしょう。エージェントかキャッシュのどち
らかに取り込まれた記事は、@code{gnus-downloaded-mark} (ディフォルト
は @samp{+}) を表示します。それら以外のすべての記事
は @code{gnus-undownloaded-mark} (ディフォルトは @samp{-}) を表示します。
エージェント化されていないグループを開くと、空白 (@samp{ }) が表示されま
す。

第二の視覚効果はダウンロードされていないことを示すフェースです。多く
の Gnus の利用者に好感と嫌悪をもたらすであろう、記事のスコアを三段
階 (low, normal, high) で表示するフェースがあります。問題は、フェースの
選択が条件検査とフェース名のリスト (@code{gnus-summary-highlight} 参
照) で制御されることです。それぞれの条件は、それがリストの中に現れる順に
検査されるので、後の条件よりも前の条件が優先されます。これが意味するすべ
ては、ダウンロードされていない記事に可視記事 (ticked) の印を付けても、そ
の記事は可視記事のフェースではなくて、ダウンロードされていない記事のフェー
スで表示し続けられるということです。

(記事を読むたびに同じ記事をダウンロードしないようにするため、または接続
時間を最小にするために) エージェントをキャッシュとして使う場合は、ダウン
ロードされていない記事のフェースはおそらく良い考えのように思えるでしょう。
ダウンロードされた記事に対してすべての仕事 (印を付ける、読む、削除す
る) を行なえば、いつも通常のフェースが現れるからです。@acronym{NOV} を
キャッシュすることによってオンライン性能を改善するためにエージェントを使っ
ている利用者にとって、ダウンロードされていない記事のフェースが見えるかも
しれないことは、まったくぞっとするほどいやなことでしょう。それらのどの記
事もエージェントに取り込まれていないので、ダウンロードされていない記事の
フェースのために、すべての普通のフェースが目立たなくなってしまうでしょう。

ダウンロードされていない記事のフェースを使いたい場合は、
@code{agent-enable-undownloaded-faces} グループパラメーター
を @code{t} に設定して、ダウンロードされていない記事のフェースを有効にし
なければなりません。このパラメーターは他のすべてのエージェントパラメーター
と同様に、エージェント分類 (@pxref{Agent Categories})、グループトピッ
ク (@pxref{Topic Parameters})、あるいは個々のグルー
プ (@pxref{Group Parameters}) に対して設定することができます。

エージェントを使うすべての利用者に共通した一つの問題は、それがディスクの
容量をいかに速く使い尽くすことができるかです。あなたが多くのグループでエー
ジェントを使用している場合、事実上ディスク容量を回復することはさらに困難
です。一つの解は @code{gnus-group-line-format} にある @samp{%F} 形式です。
この形式は、エージェントとキャッシュの両方で取得した記事によって占められ
る実際のディスク容量を表示します。どのグループが最も多い容量を使うかを知
ることによって、利用者は記事を「エージェント期限切れ消去」する場合に、ど
こに努力を集中するべきかがわかります。

@node Agent as Cache
@subsection キャッシュとしてのエージェント

Gnus が @dfn{plugged} であるときに、すでにエージェントに格納されているヘッ
ダーや記事をダウンロードするのは効率的ではありません。そこで Gnus は通常
ヘッダーを一回だけダウンロードしてエージェントに格納します。
@dfn{plugged} か @dfn{unplugged} にかかわらず、それらのヘッダーは後に概
略バッファーを生成するときに使われます。ディフォルトでは記事は (それは潜
在的にディスク空間を浪費するであろうから) エージェントにキャッシュされま
せんが、すでにエージェントにダウンロードした記事があるならば、Gnus はサー
バーから再び記事をダウンロードせずに、手元に格納されたコピーを使います。

あなたがそう望むのであれば、@dfn{plugged} な期間は常にヘッダーと記事をダ
ウンロードするように、エージェント (@code{gnus-agent-cache} 参
照 @ref{Agent Variables}) を設定することができます。Gnus はほとんど確か
にもっと遅くなりますが、サーバーとの同期は保たれます。nntp か nnimap バッ
クエンドを使っている場合は、たぶんこの最後の点は意味をなさないでしょう。

@node Agent Expiry
@subsection エージェント期限切れ消去

@vindex gnus-agent-expire-days
@findex gnus-agent-expire
@kindex M-x gnus-agent-expire
@kindex M-x gnus-agent-expire-group
@findex gnus-agent-expire-group
@cindex agent expiry
@cindex Gnus agent expiry
@cindex expiry

エージェントバックエンド @code{nnagent} は期限切れ消去を扱いません。ええ
と、少なくとも他のバックエンドのようにそれを扱いません。その代わりに、特
別な @code{gnus-agent-expire} と @code{gnus-agent-expire-group} 命令
が @code{gnus-agent-expire-days} の日数よりも古い既読記事をすべて消去し
ます。これらはあなたがディスク容量を使い切りそうだと思ったときにいつでも
実行することができます。どちらも特に速くもなく効率的でもなく、それらの一
つをいったん始めてしまったら (@kbd{C-g} やその他で) 中断することもあまり
良いことではありません。

例えば @code{gnus-request-expire-articles} のような他の関数は、エージェ
ントをグループに同期させるために @code{gnus-agent-expire} を実行するかも
しれないことに注意して下さい。

エージェントパラメーター @code{agent-enable-expiration} は、選択したグルー
プでの期限切れ消去を抑制するために使われるかもしれません。

@vindex gnus-agent-expire-all
@code{gnus-agent-expire-all} が @code{nil} でなければ、エージェントの期
限切れ消去コマンド群はすべての記事---未読、既読、可視、保留記事を消去し
ます。もし @code{nil} (これがディフォルト値) であれば、既読記事のみが消
去の対象となり、未読、可視、保留記事はさらに無期限に保持します。

期限切れ消去されているはずなのに残っている記事を見つけたならば、たぶんい
くつかの Gnus エージェントファイルが壊れています。
@code{gnus-agent-regenerate} と @code{gnus-agent-regenerate-group} は、
起こりうる問題を修復するための特別なコマンドです。

@node Agent Regeneration
@subsection エージェントを作り直す

@cindex agent regeneration
@cindex Gnus agent regeneration
@cindex regeneration

@code{nnagent} によって使われるローカルのデータ構造は、ある例外的な条件
によっておかしくなってしまうかもしれません。これが起こると、
@code{nnagent} の機能性が下がるかもしれないし、失敗しさえするかもしれま
せん。この問題の解決策は、内部の矛盾をすべて削除することによって、ローカ
ルのデータ構造を修復することです。

例えば、記事をエージェントにダウンロードしている間にサーバーへの接続が切
れてしまう場合、ローカルのデータ構造は接続が切れる前に記事が首尾良くダウ
ンロードされたかどうかを知りません。@code{gnus-agent-regenerate} また
は @code{gnus-agent-regenerate-group} を実行すると、そのような記事を二回
ダウンロードしなくても済むようにデータ構造を更新します。

@findex gnus-agent-regenerate
@kindex M-x gnus-agent-regenerate
@code{gnus-agent-regenerate} コマンドは、すべてのエージェント化されたグ
ループで @code{gnus-agent-regenerate-group} を実行します。どのバッファー
上でも @code{gnus-agent-regenerate} を実行することができますが、最初にす
べての概略バッファーを閉じることを強く勧めます。

@findex gnus-agent-regenerate-group
@kindex M-x gnus-agent-regenerate-group
@code{gnus-agent-regenerate-group} コマンドは、ローカル
の @acronym{NOV} (ヘッダー) データベースを修復するために、個々の記事のロー
カルなコピーを使います。その後それは、どの記事がローカルに格納されるかを
裏付けるための内部データ構造を更新します。引数を与えると、エージェントの
中の記事に未読の印を付けます。

@node Agent and IMAP
@subsection エージェントを IMAP で使う方法

エージェントは nnimap を含む Gnus のどんなバックエンドでも動作します。し
かし @acronym{NNTP} と @acronym{IMAP} にはいくつかの概念の違いがあるので、
この項では Gnus エージェントを @acronym{IMAP} の @dfn{unplugged} なモー
ドのクライアントとして円滑に使えるようにするための、いくつかの情報を提供
します。

心に留めておく最初のことは、すべてのフラグ (read, ticked な
ど) は nntp の場合における @file{.newsrc} ではなくて @acronym{IMAP} サー
バーに保持されるということです。したがって、Gnus は @dfn{unplugged} のと
きのフラグの変化を覚えておいて、再び接続したときにそれらのフラグを同期さ
せる必要があります。

Gnus はエージェントの元で nnimap グループを読むとき、フラグの変化に絶え
ず注意しています。あなたが再び接続したとき、Gnus はあなたが何らかのフラ
グを変更したかどうかを調べて、あなたがそれらをサーバーと同期させたいかど
うかを尋ねます。この挙動は @code{gnus-agent-synchronize-flags} でカスタ
マイズすることができます。

@vindex gnus-agent-synchronize-flags
もし @code{gnus-agent-synchronize-flags} が @code{nil} だったら、エージェ
ントは自動的にフラグを同期させることはしません。もしそれがディフォルト値
の @code{ask} だったら、エージェントはあなたが再接続したときにあなたが何
らかの変更を行なっていたかどうかを調べて、それらを同期させたいかどうかを
尋ねます。もしそれら以外の値だった場合は、すべてのフラグは自動的に同期さ
せられます。

もしあなたが、再接続したときに自動でフラグを同期させたくないなら、手動で
それを行なうこともできます。これにはグループバッファーの @kbd{J Y} キー
に割り当てられた @code{gnus-agent-synchronize-flags} コマンドを使います。

あなたが、@dfn{unplugged} のときの @acronym{IMAP} クライアントに期待する
であろういくつかの機能は、現在のエージェントには盛り込まれていません。そ
れらは以下の通りです。

@itemize @bullet

@item
@dfn{unplugged} のときの nnimap グループへのコピーと移動。

@item
@dfn{unplugged} のときの nnimap グループの作成と削除。
@end itemize

技術的注釈: すべてのローカルなフラグを一度にサーバーに ``押し込む'' 同期
はできませんが、利用者が一つずつフラグを更新することは可能です。したがっ
て、あなたが記事の一つのフラグをセットして、そのグループを抜け出てから再
度そのグループを選択してそのフラグを消せば、あなたが ``同期'' の操作を行
なったときに、そのフラグはセットされてサーバーからは削除されます。
@c FIXME: Does it make sense?
"The queued flag" に関する動作は、エージェントディレクトリーにあるサーバー
毎の @code{flags} ファイルの中で見つかるでしょう。それらはあなたがフラグ
を同期させたときに空になります。

@node Outgoing Messages
@subsection 差出用メッセージ

ディフォルトで、Gnus が切り離されているとき、すべての差出用メッセー
ジ (メールとニュースの両方) は下書きグループ ``queue''
(@pxref{Drafts}) に格納されます。投稿した後でも、ここでそのメッセージを
見たり編集するのは意のままです。

送出するメールが queue される (順番待ちになる) 状況を制御することは可能
です (@code{gnus-agent-queue-mail}, @ref{Agent Variables} 参照)。Gnus が
切り離されている場合、ニュースは常に queue されるだけです。

メッセージを送信するために、下書きグループから、そこで使える特別な命令を
使って送ることも、グループバッファー内で @kbd{J S} を使って、下書きグルー
プ内のすべての送信可能なメッセージ送信することもできます。ニュースの投稿
は Gnus が差し込まれているときだけできますが、メールはいつでも送信するこ
とができます。

切り離されているときにメールの送信ができず、かつ切り離されているときにうっ
かり @kbd{J S} を叩いてしまうことが心配ならば、Gnus にあなたの行動を確認
させることができます (@code{gnus-agent-prompt-send-queue}, @ref{Agent
Variables} 参照)。

@node Agent Variables
@subsection エージェント変数

@table @code
@item gnus-agent
@vindex gnus-agent
エージェントが有効になっているかどうか。ディフォルトは @code{t} です。
最初に有効にされると、いくつかのバックエンドをエージェント化するために、
エージェントは @code{gnus-agent-auto-agentize-methods} を使います。サー
バーバッファーでエージェントのコマンドを使うことによって、どのバックエン
ドをエージェント化するかを変更することができます。

サーバーバッファーに入るには、グループバッファー
で @kbd{^} (@code{gnus-group-enter-server-mode}) を使って下さい。

@item gnus-agent-directory
@vindex gnus-agent-directory
Gnus エージェントがファイルを格納する場所です。ディフォルト値
は @file{~/News/agent/} です。

@item gnus-agent-handle-level
@vindex gnus-agent-handle-level
この変数の値より高いレベル (@pxref{Group Levels}) のグループは、エージェ
ントからは無視されます。ディフォルト値は @code{gnus-level-subscribed} で、
これはディフォルトでは、購読しているグループのみがエージェントの処理の対
象となるということです。

@item gnus-agent-plugged-hook
@vindex gnus-agent-plugged-hook
ネットワークに接続されたときに実行されるフック。

@item gnus-agent-unplugged-hook
@vindex gnus-agent-unplugged-hook
ネットワークから切断されたときに実行されるフック。

@item gnus-agent-fetched-hook
@vindex gnus-agent-fetched-hook
記事を取り込み終わったときに実行されるフック。

@item gnus-agent-cache
@vindex gnus-agent-cache
plugged のときに、ローカルに持っている @acronym{NOV} と記事を使うかどう
かを制御する変数で、例えばエージェントをキャッシュとして使うには必須です。
ディフォルトでは非-@code{nil} で、エージェントをキャッシュとして使います。

@item gnus-agent-go-online
@vindex gnus-agent-go-online
@code{gnus-agent-go-online} が @code{nil} だったら、エージェントはオフラ
イン状態のサーバーをオンライン状態にしません。@code{ask} だったら、それ
がディフォルトですが、エージェントは再接続するときにオフライン状態のサー
バーをオンライン状態にするかどうかを尋ねます。それ以外の値だったら、オフ
ライン状態のサーバーは自動的にオンライン状態になります。

@item gnus-agent-mark-unread-after-downloaded
@vindex gnus-agent-mark-unread-after-downloaded
@code{gnus-agent-mark-unread-after-downloaded} が 非-@code{nil} だったら、
ダウンロードした後で記事に未読の印を付けます。これは通常、新しくダウンロー
ドされた記事を明確に未読にするための安全な行為です。ディフォルト
は @code{t} です。

@item gnus-agent-consider-all-articles
@vindex gnus-agent-consider-all-articles
@code{gnus-agent-consider-all-articles} が非-@code{nil} だったら、エージェ
ントはすべての記事について、それらをダウンロードする必要があるかどうかを
エージェントの述語に決定させます。@code{nil} だった場合、それがディフォ
ルトですが、エージェントは未読の記事をダウンロードするかどうかだけを述語
に決定させます。これを有効にするには、後でエージェントが期限切れ消去する
記事を何度も繰り返しダウンロードしないように、エージェントの期限切れ消去
の設定 (@pxref{Category Variables}) を見直す必要もあるかもしれません。

@item gnus-agent-max-fetch-size
@vindex gnus-agent-max-fetch-size
エージェントは、取得した記事を個々のファイルに入れるための解析を行なう前
に、それらを一時的なバッファーへ取り込みます。最大のバッファーサイズを超
過しないようにするために、記事がすべて取得されるまで、エージェントは取得
と解析を交互に行ないます。@code{gnus-agent-max-fetch-size} は、繰り返し
がどれくらい頻繁に起きるかを制御するための、サイズの限界を規定します。大
きな値は性能を改善します。小さな値は、万が一取得している間に接続が切れた
場合に、遅れ時間を最小にします (グループの状態を更新するため
に @code{gnus-agent-regenerate-group} を実行する必要があるかもしれませ
ん。でも、接続が切れる前に解析されたすべての記事は、unplugged の期間に利
用することができるでしょう。)。繰り返しに遭遇することは珍しいので、ディ
フォルトは 10M です

@item gnus-server-unopen-status
@vindex gnus-server-unopen-status
たぶんエージェント変数ではないがエージェントに密接に関連するこの変数は、
Gnus がサーバーに接続できなときに何が起きたかを物語ります。エージェント
が活性化されると、ディフォルトの @code{nil} では、利用者がサーバーとの接
続を絶つかエージェントを unplug にするかを Gnus に尋ねさせます。エージェ
ントが不活性化されると、Gnus はいつも単にサーバーとの接続を絶ちます。こ
の変数の他の選択肢には @code{denied} と @code{offline} があり、エージェ
ントが使われる場合は後者だけが有効です。

@item gnus-auto-goto-ignores
@vindex gnus-auto-goto-ignores
大抵の人は、エージェント変数ではないが密接に関連するもう一つの変数をここ
で探すでしょう。この変数は、ダウンロードされていない (ヘッダーだけがエー
ジェントに格納された)、そして取り込まれていない (記事もヘッダーも格納さ
れていない) 記事をどう操作するかを概略バッファーに伝えます。

正当な値は @code{nil} (どの記事も操作する)、
@code{undownloaded} (@dfn{unplugged} な期間の操作は取り込まれていない記
事を無視すること)、@code{always-undownloaded} (操作は取り込まれていない
記事を常に無視すること)、@code{unfetched} (操作はヘッダーが取り込まれて
いない記事を無視すること) です。(訳注: うーむ Kevin さんは何を言ってるん
だ?)

@item gnus-agent-queue-mail
@vindex gnus-agent-queue-mail
@code{gnus-agent-queue-mail} を @code{always} にすると、Gnus はメールを
いきなり送信してしまうのではなく、常に queue (順番待ち) に入れます。
@code{t} だったら Gnus は切り離されているときだけメールを queue に入れま
す。@code{nil} だったら queue に入れません。ディフォルトは @code{t} です。

@item gnus-agent-prompt-send-queue
@vindex gnus-agent-prompt-send-queue
@code{gnus-agent-prompt-send-queue} が非-@code{nil} だったら、切り離され
ているのにもかかわらず @kbd{J S} を叩いた場合に、Gnus は本当にそれを行なっ
ても良いかどうかを確認します。ディフォルトは @code{nil} です。

@item gnus-agent-auto-agentize-methods
@vindex gnus-agent-auto-agentize-methods
あなたが以前にエージェントを使ったことが無い (もっと技術的には、
@file{~/News/agent/lib/servers} が無い場合)、Gnus はほんの少数のサーバー
を自動的にエージェント化します。この変数はどのバックエンドを自動でエージェ
ント化すべきかを制御します。一般に、エージェント化は遠隔バックエンドだけ
に有用です。自動のエージェント化は、サーバーに対して @kbd{J a} を実行す
るのと同じ効果があります (@pxref{Server Agent Commands})。もしファイルが
存在するならば、それらを追加したり削除するためにサーバーを手動で操作しな
ければなりません。この変数は最初に Gnus を起動したときだけ適用されます。
ディフォルトは @samp{(nntp nnimap)} です。
@end table

@node Example Setup
@subsection 設定例

もしあなたがこのマニュアルを読みたくなくて、ごく標準的な設定がされている
とするなら、あなたの @file{~/.gnus.el} ファイルに以下のような設定をする
ところから始められるでしょう。

@lisp
;;; @r{Gnus がどのようにニュースを取得するかを定義する。ここでは}
;;; @r{ISP のサーバーから @acronym{NNTP} で取ってくることにする。}
(setq gnus-select-method '(nntp "news.your-isp.com"))

;;; @r{Gnus がどのようにメールを読むかを定義する。ISP の @acronym{POP}}
;;; @r{サーバーからメールを読むことにする。}
(setq mail-sources '((pop :server "pop.your-isp.com")))

;;; @r{Gnus がメールをどのように格納するかを指定する。nnml グループ}
;;; @r{を使う。}
(setq gnus-secondary-select-methods '((nnml "")))

;;; @r{Gnus をオフラインニュースリーダーにする。}
;;; (gnus-agentize) ; @r{旧式の設定。}
;;; (setq gnus-agent t) ; @r{現在のディフォルト。}
@end lisp

基本的にはこれだけで良いはずです。これをあなたの @file{~/.gnus.el} ファ
イルに入れて、あなたの要望に合わせて編集し、PPP (や何か) を起動して、
@kbd{M-x gnus} と打鍵して下さい。

初めて Gnus を実行するしたときは、いくつかのニュースグループがディフォル
トで自動的に購読されます。おそらくもっとたくさんのグループを購読したくな
るでしょうけど、そのためには、@kbd{A A} 命令で @acronym{NNTP} サーバーに
全グループの一覧を問い合わせなければなりません。これは通常とても時間がか
かりますが、一度だけしか実行する必要はありません。

しばらくの読み込みと解析の後に、グループの一覧を提示させられるでしょう。
@kbd{u} 命令で読みたいグループを購読します。読みたいグループを全部購読し
たら、@kbd{l} で削除グループをすべて画面から消去します。(@kbd{A k} で削
除グループはすべて戻ってきます。)

さて、ここでその場でグループを読むこともできるし、あるいは @kbd{J s} 命
令で記事をダウンロードすることもできます。あとはこのマニュアルの残りを読
んで、その他の何百億の項目からカスタマイズしたいことを見つけ出して下さい。

@node Batching Agents
@subsection 一括エージェント処理
@findex gnus-agent-batch

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何かのメッ
セージを投稿するのは)、いったんものごとを正しく設定してしまえば非常に簡
単です。以下のシェルスクリプトは必要なことをすべてやってくれるでしょう。

以下の呪文をコマンドラインで使うことによって、完全なバッチコマンドを走ら
せることができます:

@example
#!/bin/sh
emacs -batch -l ~/.emacs -l ~/.gnus.el gnus-agent-batch >/dev/null 2>&1
@end example

@node Agent Caveats
@subsection エージェントの問題点

Gnus エージェントは、よくある他のオフラインニュースリーダーのようには動
作しません。これらは想像的な人からの良くある質問です:

@table @dfn
@item 接続されているときに記事を読んだら、それは Agent に入るのですか?

@strong{いいえ}。この動作を望むのなら
ば @code{gnus-select-article-hook} に関
数 @code{gnus-agent-fetch-selected-article} を加えて下さい。

@item 接続されているときに記事を読んで、Agent に記事が存在している場合、
もう一回ダウンロードされるのですか?

@strong{いいえ}、ただし @code{gnus-agent-cache} が @code{nil} でなかった
ら、ですが。
@end table

要約すると、Gnus が切り離されているときはローカルに保存された記事を見る
だけです。接続されているときは ISP と話し、かつローカルに持っている記事
も使うかもしれません。

@node Scoring
@chapter スコア
@cindex scoring

他の人々は @dfn{削除ファイル} を使いますが、ここ Gnus タワーは削除よりも
スコアの方を好むので、他と格闘するよりは切り替えることにしました。それら
は完全に違うことをするので、真っ直ぐに座って注意を払って下さい!

@vindex gnus-summary-mark-below
すべての記事はスコアのディフォルト値を持ってお
り (@code{gnus-summary-default-score})、これはディフォルトで 0 です。こ
のスコアは対話的や、スコアファイル (score file) の方法により、上げられた
り下げられたりします。@code{gnus-summary-mark-below} よりも低いスコアの
記事には既読の印が付きます。

Gnus は概略バッファーを作成する前に、現在のグループに適用されるどん
な @dfn{スコアファイル} も読み込みます。

現在の記事に基づいてスコアの登録を挿入するいくつかの命令が概略バッファー
にあります。例えば、Gnus に特定の表題の記事のスコアを下げたり上げたりす
るように求めることができます。

二種類のスコア項目があります: 永続と一時的です。一時的スコア項目は自分自
身で期限がくると削除する登録です。例えば、一週間以上使われていないどんな
登録も、スコアファイルの大きさを小さくするために、静かに削除されます。

@menu
* Summary Score Commands::      現在のグループのためのスコア項目を追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする (まぁ、なんて用語 (Scoring) でしょう)
* Score File Format::           スコアファイルに何を入れるか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            大姉 (Big Sister) Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア項目がどこへ行くかをどのように指定するか
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                どうやって効果的にスコアを付けるか
* Reverse Scoring::             古いものの子であるという問題は問題ではない
* Global Score Files::          地をつかみ、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに変換する
* Advanced Scoring::            スコアの法則を作るために論理表現を使う
* Score Decays::                スコアを枯れていかせるのは役に立つこともある
@end menu

@node Summary Score Commands
@section 概略スコア命令
@cindex score commands

スコア項目を変更するスコア命令は実際に本当のスコアファイルを修正するわけ
ではありません。それはあまりに非効率です。Gnus は以前にロードされたスコ
アファイルのキャッシュを保持しており、その一つは @dfn{現在のスコアファイ
ル連想リスト} (current score file alist) と考えられています。スコア命令
は単純にこのリストに登録を挿入して、グループから出ると、このリストは保存
されます。

現在 (current) のスコアファイルは、実際にそのようなスコアファイルが存在
していない場合でも、ディフォルトでグループのローカルスコアファイルになっ
ています。スコア命令を何か他のスコアファイル (例、@file{all.SCORE}) に挿
入したいなら、まずこのスコアファイルを現在のものにしなければなりません。

一般的なスコア命令は実際にはスコアファイルを変更しません:

@table @kbd
@item V s
@kindex V s (概略)
@findex gnus-summary-set-score
現在の記事のスコアを設定します (@code{gnus-summary-set-score})。

@item V S
@kindex V S (概略)
@findex gnus-summary-current-score
現在の記事のスコアを表示します (@code{gnus-summary-current-score})。

@item V t
@kindex V t (概略)
@findex gnus-score-find-trace
現在の記事に使われているすべてのスコア法則 (score rule) を表示しま
す (@code{gnus-score-find-trace})。@code{*Score Trace*} バッファー
で、@kbd{e} をタイプして現在行のスコア法則に対応するスコアファイルを編集
することができ、@kbd{f} ではスコアファイルのフォーマッ
ト (@code{gnus-score-pretty-print}) と編集を行なうことができます。

@item V w
@kindex V w (概略)
@findex gnus-score-find-favourite-words
スコアに使われている語のリストを表示しま
す (@code{gnus-score-find-favourite-words})。

@item V R
@kindex V R (概略)
@findex gnus-summary-rescore
現在の概略でスコア過程を実行します (@code{gnus-summay-rescore})。これ
は Gnus の後ろでいろいろとスコアファイルで遊んで、それの効果を見たいとき
に役立つかもしれません。

@item V c
@kindex V c (概略)
@findex gnus-score-change-score-file
違ったスコアファイルを現在のものにしま
す (@code{gnus-score-change-score-file})。

@item V e
@kindex V e (概略)
@findex gnus-score-edit-current-scores
現在のスコアファイルを編集します (@code{gnus-score-edit-current-scores})。
@code{gnus-score-mode} バッファーに移動することになるでしょ
う (@pxref{Score File Editing})。

@item V f
@kindex V f (概略)
@findex gnus-score-edit-file
スコアファイルを編集して、このスコアファイルを現在のものにしま
す (@code{gnus-score-edit-file})。

@item V F
@kindex V F (概略)
@findex gnus-score-flush-cache
現在のスコアキャッシュを書き込みます (@code{gnus-score-flush-cache})。こ
れはスコアファイルを編集した後に役に立ちます。

@item V C
@kindex V C (概略)
@findex gnus-score-customize
視覚的で嬉しい方法でスコアファイルをカスタマイズしま
す (@code{gnus-score-customize})。
@end table

これらの命令の残りはローカルスコアファイルを修正します。

@table @kbd
@item V m
@kindex V m (概略)
@findex gnus-score-set-mark-below
スコアの入力を促進し、それよりも低いスコアのすべての記事に既読の印を付け
ます (@code{gnus-score-set-mark-below})。

@item V x
@kindex V x (概略)
@findex gnus-score-set-expunge-below
スコアの入力を促進し、そのスコアより低いすべての記事を削除するためのスコ
ア法則を現在のスコアファイルに付け加えま
す (@code{gnus-score-set-expunge-below})。
@end table

実際にスコア項目をするためのキー打ち込みは非常に規則正しい法則に従うので、
それらの命令すべてを表に上げる必要はありません。(たーくさんあります。)

@findex gnus-summary-increase-score
@findex gnus-summary-lower-score
@enumerate
@item
最初のキーはスコアを増やすための @kbd{I} (i の大文字) か、スコアを下げる
ための @kbd{L} です。
@item
二番目のキーはどのヘッダーにスコアをしたいかを表します。以下のキーが使用
可能です:

@table @kbd
@item a
著者 (author) の名前にスコアを付けます。

@item s
表題 (subject) の行にスコアを付けます。

@item x
@code{Xref} 行にスコアを付けます---すなわち、クロスポスト行です。

@item r
@code{References} 行にスコアを付けます。

@item d
日付 (date) にスコアを付けます。

@item l
行数 (number of lines) にスコアを付けます。

@item i
@code{Messsage-ID} ヘッダーにスコアを付けます。

@item e
``追加'' のヘッダー (すなわち、(@code{gnus-extra-headers} に設定されてい
て、@acronym{NNTP} サーバーが overview にそれらの情報を記録している) に
スコアを付けます。

@item f
フォローアップ (followup) にスコアを付けます---これは著者名との合致をし、
この著者へのフォローアップにスコアを加えます。(このキーを使うことによっ
て @file{ADAPT} ファイルが生成されます。)

@item b
記事の本文にスコアを付けます。

@item h
ヘッダーにスコアを付けます。

@item t
スレッドにスコアを付けます。(このキーを使うことによって @file{ADAPT} ファ
イルが生成されます。)
@end table

@item
三番目のキーは合致する型です。どの合致の型が有効かはどのヘッダーにスコア
を付けようとしているかに依ります。

@table @code
@item 文字列 (strings)

@table @kbd
@item e
正確な (exact) 合致です。

@item s
文字列の一部の (substring) 合致です。

@item f
大雑把な (fuzzy) 合致です (@pxref{Fuzzy Matching})。

@item r
正規表現 (regexp) の合致です。
@end table

@item 日付 (date)

@table @kbd
@item b
日付の前 (before) です。

@item a
日付の後 (after) です。

@item n
その日付です。
@end table

@item 数値 (number)

@table @kbd
@item <
数値より小さいものです。

@item =
数値と等しいものです。

@item >
数値より大きいものです。
@end table
@end table

@item
四つめで通常は最後のキーです。これが一時的 (すなわち期限切れ消去) のスコ
ア項目か、永続的な (すなわち期限切れ消去でない) スコア項目であるかという
こと、もしくはすぐになされるべきか、スコアファイルに追加することはしない
かということを指定します。

@table @kbd
@item t
一時的な (temporary) スコア項目です。

@item p
永続的な (permanent) スコア項目です。

@item i
即座の (immediate) スコア付けです。
@end table

@item
もし `e' (追加の (extra)) ヘッダーでスコア付けを行なっていると、どの名前
のヘッダーで行なうかを尋ねられます。これは @code{gnus-extra-headers} に
ある名前でなければなりません。@samp{TAB} による補完ができます。
@end enumerate

ですから、現在の著者に正確な合致で永続的にスコアを増やしたいとしましょ
う:
@kbd{I a e p}。表題に基づいてスコアを下げたくて、文字列の部分の合致を使
い、一時的なスコア項目をしたいのであれば: @kbd{L s s t}。非常に簡単です。

ものごとを複雑にするのは、短縮打鍵が存在するからです。二番目か三番目の文
字に大文字を使うと、Gnus は残る一つか二つの打鍵にディフォルト値を使いま
す。ディフォルト値は ``文字列の一部'' と ``一時的'' です。ですから、
@kbd{I A} は @kbd{I a s t} と同じで、@kbd{I a R} は @kbd{I a r t} と同じ
です。

これらの関数は数値接頭引数と、シンボル接頭引数を受け付けま
す (@pxref{Symbolic Prefixes})。数値接頭引数はどのくらい記事のスコアを下
げる (もしくは上げる) かを指定します。シンボル接頭引数 @code{a} は命令が
現在のスコアファイルではなく @file{all.SCORE} ファイルを使うことを指定し
ます。

@vindex gnus-score-mimic-keymap
@code{gnus-score-mimic-keymap} はこれらの命令がキーマップであるかのよう
に振る舞うかどうかを指定します。

@node Group Score Commands
@section グループスコア命令
@cindex group score commands

残念ながら、まだたくさんはありません。

@table @kbd
@item W e
@kindex W e (グループ)
@findex gnus-score-edit-all-score
すべてのグループに適用される all.SCORE ファイルを編集します。ポップアッ
プする @code{gnus-score-mode} のバッファーに入ります (@pxref{Score File
Editing})。

@item W f
@kindex W f (グループ)
@findex gnus-score-flush-cache
Gnus は何度もスコア連想リストを読み込むのを避けるために、それのキャッシュ
を保持しています。この命令はキャッシュを書き出しま
す (@code{gnus-score-flush-cache})。
@end table

以下のようなことをすることによって、コマンド行からスコア付けをすることが
できます。

@findex gnus-batch-score
@cindex batch scoring
@example
& emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score
@end example

@node Score Variables
@section スコア変数
@cindex score variables

@table @code
@item gnus-use-scoring
@vindex gnus-use-scoring
@code{nil} であれば、Gnus はスコアファイルを調べず、一般的に、スコア関連
の仕事をまったくしません。これはディフォルトで @code{t} です。

@item gnus-kill-killed
@vindex gnus-kill-killed
この変数が @code{nil} であれば、Gnus はすでに削除過程を実行された記事に
決してスコアファイルを適用しません。これはたくさんの時間を節約するでしょ
うが、もし削除ファイルをグループに適用しているときに、削除ファイルを変更
し、もっと多くの記事を削除するためにそれを再実行しても、それは動作しない
ということになります。それをするためにはこの変数を @code{t} に実行しなけ
ればなりません。(これはディフォルトで @code{t} です。)

@item gnus-kill-files-directory
@vindex gnus-kill-files-directory
すべての削除とスコアのファイルはこのディレクトリーに蓄積され、それはディ
フォルトでは環境変数 @env{SAVEDIR} によって初期化されます。ディフォルト
値は @file{~/News/} です。

@item gnus-score-file-suffix
@vindex gnus-score-file-suffix
スコアファイルにたどり着くためにグループ名に加える接尾語です (ディフォル
ト値は @file{SCORE} です)。

@item gnus-score-uncacheable-files
@vindex gnus-score-uncacheable-files
@cindex score cache
すべてのスコアファイルは普通はスコアファイルの過剰読み込みを避けるために
キャッシュされます。しかし、これによりあなたの Emacs が大きく肥大化する
のであれば、再び必要とされないようなスコアファイルを除去するためにこの正
規表現を使うことができます。@file{all.SCORE} のキャッシュを止めるのは悪
い考えですが、@file{comp.infosystems.www.authoring.misc.ADAPT} をキャッ
シュしないのは良い考えでしょう。実際のところ、この変数のディフォルト値
は @samp{ADAPT$} で、適応スコアファイルはキャッシュされません。

@item gnus-save-score
@vindex gnus-save-score
もし本当に複雑なスコアファイルを持っていて、たくさんの一括スコアをするの
であれば、この変数を @code{t} に設定すると良いかもしれません。これ
は Gnus にスコアを @file{.newsrc.eld} ファイルに保存するようにさせます。

これを @code{t} に設定しなければ、手動スコ
ア (@kbd{V s} (@code{gnus-summary-set-score}) で設定されたようなもの) は
グループ移動時に保存されません。

@item gnus-score-interactive-default-score
@vindex gnus-score-interactive-default-score
すべての対話的スコア上げ/下げ命令によって使われる上げ/下げするスコアです。
ディフォルトは 1000 で、過剰だと思うかもしれませんが、これは適応スコア付
けをする余地の存在することを確実にするためです。手で登録されたデータを適
応スコアでの小さな変更で上書きされたくはありません。

@item gnus-summary-default-score
@vindex gnus-summary-default-score
記事のスコアのディフォルト値で、ディフォルトでは 0 になっています。

@item gnus-summary-expunge-below
@vindex gnus-summary-expunge-below
この変数より低いスコアを持つ記事は概略の行に表示されません。ディフォルト
値は @code{nil} で、これはどの記事も隠されないということです。この変数は
各概略バッファーに固有で、@code{gnus-summary-mode-hook} によって設定され
るべきです。

@item gnus-score-over-mark
@vindex gnus-score-over-mark
ディフォルトのスコアより大きなスコアを持つ記事に対して (三桁目に) 使われ
る印です。ディフォルト値は @samp{+} です。

@item gnus-score-below-mark
@vindex gnus-score-below-mark
ディフォルトのスコアより小さなスコアを持つ記事に対して (三桁目に) 使われ
る印です。ディフォルト値は @samp{-} です。

@item gnus-score-find-score-files-function
@vindex gnus-score-find-score-files-function
現在のグループのスコアファイルを見つけるために使われる関数です。この関数
はグループ名を引数として呼ばれます。

使用可能な既定関数は:

@table @code
@item gnus-score-find-single
@findex gnus-score-find-single
グループ自身のスコアファイルだけを適用します。

@item gnus-score-find-bnews
@findex gnus-score-find-bnews
bnews 構文を使って、すべての合致するスコアファイルを適用します。これがディ
フォルトです。例えば、現在のグループが @samp{gnu.emacs.gnus} ならば、
@file{gnu.all.SCORE}, @file{not.alt.SCORE} と @file{gnu.all.SCORE} がす
べて適用されます。要するに、スコアファイル名
の @samp{all} が @samp{.*} に変換され、それから正規表現の合致がなされま
す。

これは、すべてのグループに適用したいスコア項目がいくつかある場合は、それ
らの登録を @file{all.SCORE} ファイルに入れるということです。

Gnus は一般的なスコアファイルを特定のスコアファイル向けのものより前に適
用しようと試みますが、スコアファイルはほとんど無作為の順番で適用されます。
これはスコアファイル名の要素の数を調べることによってなされます---
@samp{all} 要素を取り除いて。

@item gnus-score-find-hierarchical
@findex gnus-score-find-hierarchical
すべての親グループからのすべてのスコアファイルを適用します。これ
は @file{all.SCORE} のようなスコアファイルを持つことはできないけれど、
@file{SCORE}, @file{comp.SCORE} と @file{comp.emacs.SCORE} を、それぞれ
のサーバーに対して持つことができるということです。
@end table

この変数は関数のリストであることもできます。その場合は、これらのすべての
関数がグループ名を引数として呼ばれ、スコアファイルの返されたすべてのリス
トが適用されます。これらの関数は直接スコア連想リストのリストのリストを返
すこともできます。その場合は、それらのファイルでないスコア連想リストを返
す関数は、返される最後のスコアファイルがローカルスコアファイルであること
を確実にするために、おそらく ``本当の'' スコアファイル関数よりも前に置か
れるべきでしょう。ふぅ。

例えば、サーバーを特定しない全体スコアファイルを使って、親グループに準じ
たスコア付けを行なうならば、次の値を使えば良いでしょう。

@example
(list (lambda (group) ("all.SCORE"))
      'gnus-score-find-hierarchical)
@end example

@item gnus-score-expiry-days
@vindex gnus-score-expiry-days
この変数は使われていないスコアファイル登録が期限切れ消去されるまでどのく
らいの日が経つべきかを指定します。この変数が @code{nil} であると、スコア
ファイル登録は削除されません。ディフォルト値は 7 です。

@item gnus-update-score-entry-dates
@vindex gnus-update-score-entry-dates
この変数が @code{nil} でないと、一時的に合致したスコア項目は日付が更新さ
れます。(これは Gnus が期限切れ消去を操作している方法です---すべての合致
しない登録は古くなりすぎ、合致する登録を新鮮で若いままです。) しかし、こ
の変数を @code{nil} に設定すると、合致する登録でさえも古くなり、あの嫌な
死神と直面することになるでしょう。

@item gnus-score-after-write-file-function
@vindex gnus-score-after-write-file-function
そこでちょうど書かれたスコアファイルの名前と共に呼ばれる関数です。

@item gnus-score-thread-simplify
@vindex gnus-score-thread-simplify
この変数が @code{nil} でないと、記事表題はスレッドと同じ方法で表題スコア
のために単純化されます---現在
の @code{gnus-simplify-subject-functions} の値によって。スコア項目
が @code{文字列部分} か @code{正確な} 合致を使っていると、合致もこの方法
で単純化されます。
@end table

@node Score File Format
@section スコアファイル様式
@cindex score file format

スコアファイルは普通は単純な様式のものだけを含む @code{emacs-lisp} ファ
イルです。無頓着な利用者はこれを編集しないで下さい。すべては概略バッファー
から変更されるでしょう。

とにかく、それを自分でいじってみたくなったのなら、例があります:

@lisp
(("from"
  ("Lars Ingebrigtsen" -10000)
  ("Per Abrahamsen")
  ("larsi\\|lmi" -50000 nil R))
 ("subject"
  ("Ding is Badd" nil 728373))
 ("xref"
  ("alt.politics" -1000 728372 s))
 ("lines"
  (2 -100 nil <))
 (mark 0)
 (expunge -1000)
 (mark-and-expunge -10)
 (read-only nil)
 (orphan -10)
 (adapt t)
 (files "/hom/larsi/News/gnu.SCORE")
 (exclude-files "all.SCORE")
 (local (gnus-newsgroup-auto-expire t)
        (gnus-summary-make-false-root empty))
 (eval (ding)))
@end lisp

この例はたいていのスコアファイルの要素を説明しています。違った方法につい
ては、@ref{Advanced Scoring} を見て下さい。

これは Lisp コードのように見えますが、実際はここにあるものは何
も @code{評価} (eval) されません。しかし、Lisp リーダーがこの様式を読み
込むのに使われるので、意味的に有効でないとしても、文法的には有効です。

この連想リストでは六つのキーを使うことができます。

@table @code
@item 文字列 (STRING)
もしキーが文字列であると、それは合致が実行されるヘッダーの名前です。スコ
アはこれらの八つのヘッダーだけに実行されます: @code{From},
@code{Subject}, @code{References}, @code{Message-ID}, @code{Xref},
@code{Lines}, @code{Chars} および @code{Date} です。これらのヘッダーに加
えて、記事全体を取得して記事のより大きな部分で Gnus に合致を求めさせる三
つの文字列があります: @code{Body} は記事の本文で合致を求め、
@code{Head} は記事のヘッダーで合致を求め、@code{All} は記事全体で合致を
求めます。これら最後の三つのキーを使うことは、グループに入るときに速度
を @emph{かなり} 遅くすることに気を付けて下さい。スコアを付けることので
きる最後の ``ヘッダー'' は @code{Followup} です。これらのスコア項目は、
それに合致する記事へのすべてのフォローアップのための新しいスコア項目が付
け加えられます。

このキーに続くのは任意の数のスコア項目で、それぞれのスコア項目は一つから
四つまでの要素を持ちます。
@enumerate

@item
最初の要素は @dfn{合致要素} です。たいていのヘッダーではこれは文字列です
が、Lines と Chars ヘッダーではこれは整数でなければなりません。

@item
もし二番目の要素が存在するなら、それは数値であるべきで
す---@dfn{スコア要素}。この数値は負の無限大から正の無限大までの間の整数
であるべきです。もし合致が成功すれば、この数値が記事のスコアに加えられま
す。もしこの要素が存在していなければ、数
値 @code{gnus-score-interactive-default-score} が代わりに使われます。ディ
フォルト値は 1000 です。

@item
もし三番目の要素が存在していると、それは数値であるべきで
す---@dfn{日付要素} です。この日付は最後にこのスコア項目が合致した時刻を
示し、これはスコア項目の期限切れ消去機構の機能のために使われます。この要
素が存在していなければ、スコア項目は永続します。日付は紀元前 1年12月31日
から経過した日にちの数で表されます。

@item
もし四番目の要素が存在していると、それはシンボルであるべきで
す---@dfn{型要素} です。この要素はこのスコア項目が記事に合致するかどうか
を調べるのにどの関数が使われるべきであるかを指定します。

@table @dfn
@item From, Subject, References, Xref, Message-ID
たいていのヘッダーの型に対して、@code{r} と @code{R} (正規表
現) (regexp) や、@code{s} と @code{S} (文字列の一部) (substring) 型、
@code{e} と @code{E} (正確な合致) (exact match)、
@code{w} (語の合致) (word match) 型が存在します。もしこの要素が存在しな
いと、Gnus は文字列の一部の合致が用いられるべきであるとみなします。
@code{R}, @code{S}, @code{E} は合致が大文字と小文字を区別する方法で行な
われるという点で他のものと異なります。すべてのこれらの一文字型は本当
は @code{regexp}, @code{exact}, @code{word} 型の短縮形で、もしそうしたい
と思えばこちらを代わりに使うことができます。

@item Extra
標準の overview ヘッダーの文字列と同様、@code{gnus-extra-headers} を使っ
ていると、それらのヘッダーの値にスコアを付けることができます。この場合ス
コア項目の 5 番目の要素がスコアを付けるヘッダーの名前になります。
@acronym{NNTP} サーバーが overview に @samp{NNTP-Posting-Host} を記録し
ているならば、@file{all.SCORE} ファイルの以下の登録は、単一のホストか
ら spam の攻撃がある場合に有効です。

@lisp
("111.222.333.444" -1000 nil s
 "NNTP-Posting-Host")
@end lisp

@item Lines, Chars
これらの二つのヘッダーは違った合致の型を使います: @code{<}, @code{>},
@code{=}, @code{>=}, @code{<=} です。

これらの述語はもし

@example
(PREDICATE HEADER MATCH)
@end example

の評価が @code{nil} でないと、真となります。例えば、上級合
致 @code{("lines" 4 <)} (@pxref{Advanced Scoring}) は結果として以下の式
になります。

@lisp
(< header-value 4)
@end lisp

もしくは他の方法にしましょう: @code{<} を @code{Lines} で 4 を合致として
使っているときは、記事が 4 行よりも少ないときにスコアが追加されます。(混
乱して、反対ではないかと考え易いです。でも、そうではないのです。私が思う
に。)

合致が @code{Lines} でなされていると、いくつかのバックエン
ド (@code{nndir} のようなもの) は @code{Lines} ヘッダーを作成しないため
にすべての記事が 0 行であるとして扱われることに気を付けて下さい。これは
もし少しの行しかない記事のスコアを下げているのなら、変な結果が起こり得る
ことになります。

@item Date
Date (日付) ヘッダーには三つのなんとなくばかげている合致の型があります:
@code{before}, @code{at}, @code{after} です。私は本当にこれが役立つよう
な機会を想像できないのですが、この関数を提供しないのもなんとなくばかげて
います。そうした場合のためにあるのです。いつ必要になるかは誰にもわかりま
せん。転ばぬ先の杖。短気は損気。本をカバーで判断しては行けません。初めて
のデートでエッチしてはいけません。(しかし、私は少なくとも一人、引用しま
すが、``この関数は欠かせないものであることがわかった'' と言った人がいる
と聞いています。)

(訳注: 原典の "Once burnt, twice shy" を "短気は損気" としましたが、もっ
と適切な訳があればお知らせ下さい。)

@cindex ISO8601
@cindex date
もっと役立つ合致の型は @code{正規表現} です。それによって日付文字列に正
規表現を用いて合致させることができます。日付はまず ISO8601 短縮様
式 (compact format) に標準化されま
す---@var{YYYYMMDD}@code{T}@var{HHMMSS} です。例えば、もしすべての年
の 4月1日 に投稿されたすべての記事にが治させたいのであれば、
@samp{....0401.........} を合致文字列として使うことができます。(日付は元々
の標準時で保存されているので、その記事が投稿されたところで 4月1日 に投稿
された記事に合致することに注意して下さい。標準時は一家にとって非常に有益
な楽しみでしょう?)

@item Head, Body, All
これらの三つの合致のキーは @code{From} ヘッダー (など) と同じ合致の型を
使います。

@item Followup
この合致のキーは少し特別で、それは @code{From} ヘッダーに合致し、合致し
た記事だけでなくその記事へのすべてのフォローアップのスコアにも影響します。
これはたとえば、あなた自身の記事へのフォローアップのスコアを増やしたり、
良く知られた問題児へのフォローアップ記事のスコアを下げたりするのに使われ
ます。@code{From} ヘッダーが使うのと同じ型の合致を使います。(この合致キー
を使うと、@file{ADAPT} ファイルを作ることになります。)

@item Thread
この合致キーは @code{Followup} 合致キーと同じ行に動作します。
@code{Message-ID} @var{x} で始まっているスレッド (または副スレッド) にス
コアを付けたいのであれば、@samp{thread} 合致を付け加えます。これ
は @code{Reference} ヘッダーに @var{x} を持つそれぞれの記事に新し
い @samp{thread} 合致を追加します。(これらの新しい @samp{thread} 合致は
これらの合致する記事の @code{Message-ID} を使います。) これはスレッドの
いくつかの記事が完全な @code{References} ヘッダーを持っていなかったとし
ても、スレッド全体のスコアを上げ/下げできることを保証します。これを使う
と、スレッドの記事に決定的でないスコアが付くかもしれないということに注意
して下さい。(この合致キーを使うと、@file{ADAPT} ファイルを作ることになり
ます。)
@end table
@end enumerate

@cindex score file atoms
@item mark
この登録の値は数値であるべきです。この数値より低いスコアの記事には既読の
印が付きます。

@item expunge
この登録の値は数値であるべきです。この数値より低いスコアの記事は概略バッ
ファーから削除されます。

@item mark-and-expunge
この登録の値は数値であるべきです。この数値より低いスコアの記事には既読の
印が付き、概略バッファーから削除されます。

@item thread-mark-and-expunge
この登録の値は数値であるべきです。スコアの総計がこの数値より低いスレッド
には既読の印が付き、概略バッファーから削除されます。
@code{gnus-thread-score-function} はスレッドのスコアの総計をどのように計
算するかを指定します。

@item files
この登録の値は任意の数のファイル名であるべきです。これらのファイルもスコ
アファイルであるとみなされ、これがされたのと同じような方法で読み込まれま
す。

@item exclude-files
この登録の手がかりは任意の数のファイル名であるべきです。これらのファイル
は何らかの理由で普通は読み込まれるようになっていたとしても、読み込まれま
せん。

@item eval
この登録の値は @code{評価} されます。この要素は全体的スコアファイルを扱っ
ているときは無視されます。

@item read-only
読み込み専用スコアファイルは更新されたり保存されたりしません。全体的スコ
アファイルはこのアトムを使用するべきです (@pxref{Global Score Files})。
(注意: @dfn{全体的} はここでは本当に @dfn{全体的} という意味です。個人的
なすべてのグループに適用するスコアファイルのことではありません。)

@item orphan
この登録の値は数値であるべきです。親記事を持たない記事はスコアにこの数値
が加えられます。@samp{comp.lang.c} のような量の多いニュースグループを追
いかけているとして下さい。おそらく二、三のスレッドと新しいスレッドだけを
追いたいでしょう。

以下の三つのスコアファイル登録によってそれをすることができます:

@example
        (orphan -500)
        (mark-and-expunge -100)
@end example

最初にこのグループに入ったときは、新しいスレッドだけを見ます。それからお
もしろいと思ったスレッドのスコアを上げ (@kbd{I T} もしくは @kbd{I S} に
よって)、残りを無視 (@kbd{C y}) します。次にグループに入ったときは、おも
しろいスレッドの新しい記事とまったく新しいスレッドを見ることになります。

すなわち---orphan (孤児) スコアアトムは普通のスコア法則では発見できない
興味深いスレッドが少し存在しする量の多いグループのためにあります。

@item adapt
この登録は適応スコアを制御します。もしこれが @code{t} であると、ディフォ
ルトの適応スコア法則が使われます。もしこれが @code{ignore} であると、こ
のグループには適応スコアは実行されません。もしリストであると、そのリスト
は適応スコア法則として用いられます。もしそれが存在しないか、
@code{t} や @code{ignore} でない他のものであれば、ディフォルトの適応スコ
ア法則が使われます。たいていのグループに適応スコアを使いたいのであれば、
@code{gnus-use-adaptive-scorint} を @code{t} に設定し、@code{(adapt
ignore)} を適応スコアをしたくないグループに挿入するでしょう。少しのグルー
プでだけ適応スコアを行ないたいのであれば、
@code{gnus-use-adaptive-scoring} を @code{nil} に設定し、
@code{(adaptive t)} をそれを行ないたいグループのスコアファイルに挿入する
でしょう。

@item adaptive-file
すべての適応スコア項目はこの登録によって名づけられたファイルに入ります。
それはグループに入るときにも適用されます。このアトムは多くのグループに同
じ適応スコアファイルを用いることによって、複数のグループに一度に適応スコ
アを付けたいときに便利でしょう。

@item local
@cindex local variables
この登録の値は @code{(@var{var} @var{value})} 対のリストであるべきです。
それぞれの @var{var} は現在の概略バッファーのバッファー固有になり、指定
された値 (value) に設定されます。これは便利な、もし少し変だとしても、フッ
クをあまり好まないいくつかのグループで変数を設定する方法です。
@var{value} は評価されないことに注意して下さい。
@end table

@node Score File Editing
@section スコアファイル編集

普通はすべてのスコア命令を概略バッファーから発行しますが、手でそれらを編
集したい気に駆られるかもしれないので、それのためのモードを提供しています。

それは単純に少しカスタマイズされた @code{emacs-lisp} モードで、以下の追
加の命令が存在します:

@table @kbd
@item C-c C-c
@kindex C-c C-c (スコア)
@findex gnus-score-edit-done
あなたが行なった変更を保存して概略バッファーに戻りま
す (@code{gnus-score-edit-done})。

@item C-c C-d
@kindex C-c C-d (スコア)
@findex gnus-score-edit-insert-date
現在の日付を数値様式で挿入します (@code{gnus-score-edit-insert-date})。
もしこれがどのようなものであろうと考えているのであれば、これは本当に日の
数値です。

@item C-c C-p
@kindex C-c C-p (スコア)
@findex gnus-score-pretty-print
適応スコアファイルは整えられていない流儀で保存されます。もしこれらのファ
イルの内の一つを読みたいと思っているのであれば、まず @dfn{素敵な表示} を
したいでしょう。この命令 (@code{gnus-score-pretty-print}) があなたのため
にそれをします。
@end table

このモードを使うためには @kbd{M-x gnus-score-mode} と打って下さい。

@vindex gnus-score-mode-hook
@code{gnus-score-menu-hook} がスコアモードバッファーで実行されます。

概略バッファーでは、@kbd{V f}、@kbd{V e} および @kbd{V t} のような命令で
スコアファイルの編集を始めることができます。

@node Adaptive Scoring
@section 適応性スコア
@cindex adaptive scoring

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、Gnus に
はこれらをすべて自動的に---まるで魔法でも使ったように作成する方法があり
ます。いやむしろ、人工無能によって、という方が正確かな。

@vindex gnus-use-adaptive-scoring
記事を読んだとき、あるいは記事に既読の印を付けたとき、記事を削除したとき
に、その印を残しておいて下さい。グループから出るときに Gnus は、それらの
印の辺りを嗅ぎ回り、何の印を見つけたかに依存してスコア要素を追加します。
この機能
は @code{gnus-use-adaptive-scoring} を @code{t} か @code{(line)} に設定
することで有効になります。もしスコアを、表題に現れる個別の単語をもとに適
応させたければ、この変数を @code{(word)} に設定して下さい。両方の適応方
法を使いたければ、この変数を @code{(wordline)} に設定して下さい。

@vindex gnus-default-adaptive-score-alist
@code{gnus-default-adaptive-score-alist} 変数をカスタマイズすることで、
スコア付けの処理を完全に制御できます。例えば、このような感じになります。

@lisp
(setq gnus-default-adaptive-score-alist
      '((gnus-unread-mark)
        (gnus-ticked-mark (from 4))
        (gnus-dormant-mark (from 5))
        (gnus-del-mark (from -4) (subject -1))
        (gnus-read-mark (from 4) (subject 2))
        (gnus-expirable-mark (from -1) (subject -1))
        (gnus-killed-mark (from -1) (subject -3))
        (gnus-kill-file-mark)
        (gnus-ancient-mark)
        (gnus-low-score-mark)
        (gnus-catchup-mark (from -1) (subject -1))))
@end lisp

見てお分かりのように、この連想リストの各要素は、キーとして印 (変数名かも
しくは ``本当の'' 印---つまり文字) を持ちます。このキーの後には任意の数
のヘッダー/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が
一つもなければ、そのキーが記事の印としてついている記事に対しては適応性ス
コアは実行されません。例えば上記の例では、@code{gnus-unread-mark} がつい
ている記事は適応性スコアの登録項目にはなりません。

各記事はただ一つの印しか持ち得ないので、それぞれの記事にはこれらの規則の
うちただ一つしか適用されません。

@code{gnus-del-mark} を例に取りましょう---この連想リストでの意味は、この
印 (すなわち @samp{e} の印) がついている記事はすべて、@code{From} ヘッダー
をもとに -4 下げられ @code{Subject} で -1 下げられるスコア項目が追加され
ます。これをあなたの偏見に合わせて変更して下さい。

もし 10 個の記事に同じ subject で @code{gnus-del-mark} の印がついていた
とすると、この印に対する規則は十回適用されます。それはつまり、そ
の subject は -1 の十倍のスコアを得ます。その値は、私が大きく誤解してい
ないかぎり、-10 のはずです。

もし自動期限切れ消去 (メール) グループ (@pxref{Expiring Mail}) があれば、
既読記事にはすべて @samp{E} 印が付けられます。これはおそらく、適応性スコ
ア付けをちょっとばかり不可能にするので、自動期限切れ消去と適応性スコアは
一緒にはうまくやっていけません。

スコアを付けられるヘッダーには @code{from}, @code{subject},
@code{message-id}, @code{references}, @code{xref}, @code{lines},
@code{chars}, @code{date} があります。さらに @code{followup} にもスコア
付けできます。これは現在の記事の @code{Message-ID} を使用し
て @code{References} ヘッダーに合致、すなわちこれに続いたスレッドに合致
する適応性スコア項目を作成します。

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避けるた
めに、スコアファイルの @code{mark} アトムを何か小さい値---ことによれ
ば -300 くらいに設定しておいた方が良いです。

適応性スコアを一週間かそこら使ってくると、Gnus はそれ相応に調教され、あ
なたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きではない
投稿者を消去するようになるはずです。

どのグループにおいて適応性スコアを作動させるかは、スコアファイ
ル (@pxref{Score File Format}) を使うことによって制御できます。またこれ
を使って、違ったグループに対して違った規則を使うようにもできます。

@vindex gnus-adaptive-file-suffix
適応性スコア項目は、グループ名に @code{gnus-adaptive-file-suffix} を付加
した名前のファイルに入れられます。ディフォルト値は @file{ADAPT} です。

@vindex gnus-adaptive-pretty-print
適応性スコアファイルは巨大になり得るし、人の手で編集されることは想定され
ていません。@code{gnus-adaptive-pretty-print} が @code{nil} (ディフォル
ト) であると、それらのファイルは人に読めるような形式では書かれません。

@vindex gnus-score-exact-adapt-limit
適応性スコアを行なうときは、部分文字列一致やファジーな一致を行なった方が、
おそらくほとんどの場合において良い結果が得られるでしょう。しかし、ヘッダー
の一致した部分が短い場合、意図に反するような動作をする可能性が大きくなる
ので、@code{gnus-score-exact-adapt-limit} より短い長さしか一致しない場合
は完全一致が行なわれます。この変数が @code{nil} であれば、この問題が起こ
らないように常に完全一致が行なわれます。

@vindex gnus-default-adaptive-word-score-alist
上で述べたように、個別の単語に対してもヘッダー全体に対しても適応を行なう
ことができます。単語に対して適応を行なった場合、
@code{gnus-default-adaptive-word-score-alist} 変数によって、各単語に対し
てある印へどんなスコアを与えるかを指定します。

@lisp
(setq gnus-default-adaptive-word-score-alist
      `((,gnus-read-mark . 30)
        (,gnus-catchup-mark . -10)
        (,gnus-killed-mark . -20)
        (,gnus-del-mark . -15)))
@end lisp

これがディフォルト値です。単語に対する適応を有効にする
と @code{gnus-read-mark} の印のついた記事の表題に現れるすべての単語が、
スコアに 30 点追加するというスコア規則を生み出します。

@vindex gnus-default-ignored-adaptive-words
@vindex gnus-ignored-adaptive-words
@code{gnus-default-ignored-adaptive-words} のリストに現れる単語は無視さ
れます。無視したい単語を追加したいときは、この変数ではな
く @code{gnus-ignored-adaptive-words} リストの方を使って下さい。

@vindex gnus-adaptive-word-length-limit
短い単語では適応性スコアを作動させるべきではないと思う人もいるでしょう。
もしそうなら @code{gnus-adaptive-word-length-limit} に整数を設定すること
ができ、この数値より短い単語は無視されます。この変数のディフォルト値
は @code{nil} です。

@vindex gnus-adaptive-word-syntax-table
スコア付けが終了したとき、@code{gnus-adaptive-word-syntax-table} の文法
表がその影響を受けます。これは標準の文法表と似ていますが、単語の構成要素
とならない文字の数も考慮します。

@vindex gnus-adaptive-word-minimum
もし @code{gnus-adaptive-word-minimum} に数値が設定されていると、単語適
応性スコア付け処理において、記事のスコアがこの数値よりも小さくなることは
ありません。ディフォルト値は @code{nil} です。

@vindex gnus-adaptive-word-no-group-words
@code{gnus-acaptive-word-no-group-words} が @code{t} に設定されていると、
Gnus はグループ名のすべての語について、単語適応性スコアをしません。ほと
んどの表題が @samp{emacs} という語を含んでいる @samp{comp.editor.emacs}
のようなグループで便利です。

この機構をしばらく使ってみた後には、あなたがどんな単語が好きでどんな単語
が嫌いかを、この規則を通して診断する利用者精神分析命
令 @code{gnus-psychoanalyze-user} を書いてみると良いかもしれません。いや、
良くないかな。

単語適応性スコア付けは非常に実験的なものであって、今後変更されるであろう
ということは心に留めておいて下さい。第一印象では、これは現状ではまったく
使い物にならないように思えます。これをもっと使えるようにするためには、
(より厳密な統計的手法を巻き添えにして) さらなる作業が必要となるでしょう。

@node Home Score File
@section ホームスコアファイル

新しいスコアファイル登録項目が入れられるスコアファイルは、ホームスコアファ
イル @dfn{home score file} と呼ばれます。これは通常 (ディフォルトで) そ
のグループ用のスコアファイルになります。例えば、@samp{gnu.emacs.gnus} 用
のホームスコアファイルは @file{gnu.emacs.gnus.SCORE} となるわけです。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグルー
プ間で共通のホームスコアファイルを共有すると便利なときが多いでしょ
う---例えばすべての @samp{emacs} グループで同じホームスコアファイルを使
うこともできます。

@vindex gnus-home-score-file
これを制御する変数が @code{gnus-home-score-file} です。これは以下の値を
取り得ます。

@enumerate
@item
文字列。この場合このファイルがすべてのグループでホームスコアファイルとし
て使用されます。

@item
関数。この関数の結果がホームスコアファイルとして使用されます。この関数は
グループの名前を引数として呼び出されます。

@item
リスト。このリストの要素は以下の値を取り得ます。

@enumerate
@item
@code{(@var{regexp} @var{file-name})}。@var{regexp} がグループ名に合致す
れば、@var{file-name} がホームスコアファイルとして使用されます。

@item
関数。この関数が @code{nil} 以外を返せば、その戻り値がホームスコアファイ
ルとして使用されます。

@item
文字列。この文字列をホームスコアファイルとして使用します。
@end enumerate

このリストの中から合致するものを、最初から後ろの方に向かって探していきま
す。

@end enumerate

というわけで、単に一個のスコアファイルを使いたい場合は、以下のようにすれ
ばできます。

@lisp
(setq gnus-home-score-file
      "my-total-score-file.SCORE")
@end lisp

もし全 @samp{gnu} グループに対して @file{gnu.SCORE} を、全 @samp{rec} グ
ループに対して @file{rec.SCORE} (等々) を使いたければ、このようにできま
す。

@findex gnus-hierarchial-home-score-file
@lisp
(setq gnus-home-score-file
      'gnus-hierarchial-home-score-file)
@end lisp

これは便利なようにあらかじめ提供されている関数です。多の関数は以下の以下
のものを含みます。

@table @code
@item gnus-current-home-scre-file
@findex gnus-current-home-score-file
``現在の'' 標準スコアファイルを返します。これはスコア命令にスコアファイ
ルの ``最内部'' 合致への登録を加えるようにします。
@end table

もし @samp{emacs} グループ用のスコアファイルと、それとは別
の @samp{comp} グループ用のスコアファイルを使い、他の全部のグループでは
それぞれ独自のスコアファイルを使いたいのであれば、

@lisp
(setq gnus-home-score-file
      ;; @r{正規表現 @code{"\\.emacs"} に合致するすべてのグループ}
      '(("\\.emacs" "emacs.SCORE")
        ;; @r{すべての comp グループを単一のスコアファイルで}
        ("^comp" "comp.SCORE")))
@end lisp

@vindex gnus-home-adapt-file
@code{gnus-home-adapt-file} は @code{gnus-home-score-file} とまったく同
じように動作しますが、これは代わりに何をホーム適用スコアファイルにするか
を指定します。新しい適用ファイル登録項目はすべて、この変数で指定されるファ
イルに入れられます。値には同じ文法が許されます。

@code{gnus-home-score-file} と @code{gnus-home-adapt-file} の使用に加え
て、グループパラメーター (@pxref{Group Parameters}) とトピックパラメー
ター (@pxref{Topic Parameters}) を使ってほぼ同様のことができます。グルー
プ、トピックパラメーターはこの変数よりも優先されます。

@node Followups To Yourself
@section 自分自身へのフォローアップ

Gnus は現在のバッファーから @code{Message-ID} ヘッダーを見つけ出すために
二つの命令を提供しています。そして Gnus は、他の記事におけ
る @code{References} ヘッダー中にこの @code{Message-ID} を使っている得点
を、スコア規則として追加します。これは実質的に、その記事へ返答した記事で、
現在のバッファーにあるものすべてに対してスコアを増加させます。これはあな
たの言ったことに対してみんなが答えてくれたとき、すぐにそれに目を向けたい
ときにとても便利ですね。

@table @code
@item gnus-score-followup-article
@findex gnus-score-followup-article
これはあなた自身の記事に直接フォローアップした記事にスコアを加算します。

@item gnus-score-followup-thread
@findex gnus-score-followup-thread
これはあなたの記事より ``下'' のスレッドに現れる記事すべてに対してスコア
を加算します。
@end table

@vindex message-sent-hook
これら二つの関数は、基本的にはどちらも @code{message-sent-hook} のような
フックの中で使うためのものです。例えばこのように:
@lisp
(add-hook 'message-sent-hook 'gnus-score-followup-thread)
@end lisp

あなたの自分の @code{Message-ID} をじっくりと眺めてみると、はじめの二、
三文字は常に同じであることに気が付くでしょう。以下の二つは私のものです。

@example
<x6u3u47icf.fsf@@eyesore.no>
<x6sp9o7ibw.fsf@@eyesore.no>
@end example

つまりこのマシン上での ``私の'' の識別は @samp{x6} であるということです。
これは使えます---以下の規則は私自身へのフォローアップすべてに対してスコ
アを増加させるでしょう。

@lisp
("references"
 ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@@.*eyesore\\.no>"
  1000 nil r))
@end lisp

``あなたの'' が最初の二文字になるか最初の三文字になるかはシステムに依存
します。

@node Scoring On Other Headers
@section 他のヘッダーにスコアを付ける
@cindex scoring on other headers

Gnus が ``伝統的'' なヘッダー ---@samp{From}, @samp{Subject} など---にス
コアを付けるのはとても速いです。ですが、他のヘッダーにスコアを付けるに
は @code{head} のスコアのための規則を書く必要があり、それは合致を探すた
めに Gnus が毎回バックエンドから単独の記事を取り寄せなければならないこと
を意味します。これは大きなグループでは長い時間がかかります。

さて、ニュースグループではなくてメールグループでこれを行なうのはさほど大
変ではなく、そのためのすぐれた手段が用意されています。このマニュアル
の @ref{To From Newsgroups} の項ではこの機構がどう働くかが詳しく説明され
ていますが、ここでは @code{nnml} で @samp{To} と @samp{Cc} ヘッダーにス
コアを付ける方法の調理の例を挙げましょう。

以下を @file{~/.gnus.el} ファイルに置いて下さい。

@lisp
(setq gnus-extra-headers '(To Cc Newsgroups Keywords)
      nnmail-extra-headers gnus-extra-headers)
@end lisp

Gnus を再起動して、@kbd{M-x nnml-generate-nov-databases} コマンド
で @code{nnml} の overview ファイルを作り直します。もしあなたがたくさん
のメールを持っていると、これには長い時間がかかります。

そして @kbd{I e s p To RET <your name> RET} のようにすると、あなた
は @samp{To} と @samp{Cc} ヘッダーに ``extra headers'' としてスコアを付
けることができます。

わかったかな? 簡単だよね。

@node Scoring Tips
@section スコア付けの奥義
@cindex scoring tips

@table @dfn
@item クロスポスト
@cindex crossposts
@cindex scoring crossposts
クロスポストのスコアを低くしたければ、合致させるべき行
は @code{Xref} ヘッダーです。

@lisp
("xref" (" talk.politics.misc:" -1000))
@end lisp

@item 複数のクロスポスト
ある数、例えば三つ以上のグループにクロスポストされている記事のスコアを低
くしたければ、

@lisp
("xref"
  ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
   -1000 nil r))
@end lisp

@item 本文への合致
これは一般的にはあまり良い考えではありません---それはとても長時間かかっ
てしまうからです。実際 Gnus は、それぞれの記事を個別にサーバーから取得し
てこなければならないのです。でも、あなたはそれでもやりたいかもしれません
ね。合致させるキーは三つ (@code{Head}, @code{Body}, @code{All}) あるので
すが、スコアファイル毎に一つ選んでそれに固定した方が良いです。もし二つを
使うと、それぞれの記事は @emph{二回} 取得されてしまいます。も
し @code{Head} からちょっとだけ、@code{Body} からちょっとだけ合致させた
い、というのであれば、素直に @code{All} を使って全部合致させて下さい。

@item 既読の印付け
ある一定数値以下のスコアを持つ記事には、おそらく既読の印を付けてしまいた
くなるでしょう。これは @file{all.SCORE} ファイルに以下のものを入れておく
ことによって最も簡単に実現できます。

@lisp
((mark -100))
@end lisp

@code{expunge} を使って同様のことを考えることもできます。

@item 否定文字クラス
もし @code{[^abcd]*} みたいなものを指定すると、たぶん期待通りの結果は得
られないでしょう。これは改行文字にも合致してしまい、えーと、未知の世界ま
で続くかもしれません。代わりに @code{[^abcd\n]*} を使って下さい。
@end table

@node Reverse Scoring
@section 逆スコア
@cindex reverse scoring

もし、表題ヘッダーに @samp{Sex with Emacs} という文字がある記事だけを残
して、その他の記事すべてを消去してしまいたければ、スコアファイルに以下の
ようなものを入れることもできます。

@lisp
(("subject"
  ("Sex with Emacs" 2))
 (mark 1)
 (expunge 1))
@end lisp

そして @samp{Sex with Emacs} に合致するすべての記事を集めて、残りを蹴飛
ばすために既読の印を付け、消去します。

@node Global Score Files
@section グローバルスコアファイル
@cindex global score files

間違いなく、他のニュースリーダーは ``グローバル削除ファイ
ル (global kill file)'' を持っています。これは普通、すべてのグループに適
用される、利用者のホームディレクトリーに格納されている一つの削除ファイル
以上の何物でもありません。はん! ちっぽけなニュースリーダーだね。弱すぎ。

僕がここで話しているのはグローバルスコアファイルです。全世界中からの、至
る所からの利用者によるスコアファイル、世界の国々をすべて、巨大な一つの幸
せなスコアファイル同盟に団結させるスコアファイル !Ange-score! 新しくてテ
ストしていない!

@vindex gnus-global-score-files
他の人のスコアファイルを使うためにしなければならないことは、
@code{gnus-global-score-files} 変数を設定することだけです。それぞれのス
コアファイル毎に、あるいはそれぞれのスコアファイルディレクトリー毎に対し
て一つの項目になります。Gnus はどのスコアファイルをどのグループに使うの
が適切であるかを自分で決定します。

例え
ば @file{/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE} のス
コアファイルと @file{/ftp@@ftp.some-where:/pub/score} ディレクトリーにあ
るすべてのスコアファイルを使いたければ、

@lisp
(setq gnus-global-score-files
      '("/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
        "/ftp@@ftp.some-where:/pub/score/"))
@end lisp

@findex gnus-score-search-global-directories
@noindent
どうだい、簡単だろう? ディレクトリー名は @samp{/} で終わらなくてはなりま
せん。これらのディレクトリーは普通は、一回の Gnus 使用期間中に一回だけし
か読み込みません。もし遠隔ディレクトリーを手動で再読み込みする必要が出て
きたら、@code{gnus-score-search-global-directories} 命令を使うことができ
ます。

ただし現時点では、このオプションを使うとグループに入るのがいくらか遅くな
ります。(つまり---かなり、ですけど)

もしスコアファイルを、他の人たちに使ってもらうように維持したくなってきた
ら、単にあなたのスコアファイルを匿名 FTP に置いて、世界中に公表して下さ
い。逆司会者になれるよ! その後に続いて間違いなく起こる逆司会者戦争、すな
わち人々の共感を勝ち取るための逆司会者の戦いに参加することで、彼らのスコ
アファイルに間違った前提を使わせるように誘導するのだ! やった! これでネッ
トは救われる!

以下に、逆司会者なりたがりのための秘技をいくつか、即席で述べます。

@itemize @bullet

@item
非常に多くの場所にクロスポストされている記事は間違いなく屑である。
@item
一個の不適切な記事を減点するには、@code{Message-ID} で減点する。
@item
特に素晴らしい投稿者たちは永続的な主役達として加算する。
@item
そのグループの憲章無視の投稿を頻繁に繰り返す投稿者は、絶滅させてしまって
差し支えない。
@item
@code{mark} と @code{expunge} アトムを設定し、汚らわしい記事を完全に葬り
去る。

@item
消去のスコア項目を使ってファイルの大きさを小さく抑える。でもおそらくは、
サイトによって古い記事を長期間保存するように、期限切れ消去の期間は長く取
るでしょうけれども。
@end itemize

@dots{} 果たして他のニュースリーダーは将来、グローバルスコアファイルをサ
ポートするでしょうか? @emph{うふふ}。そう、どう考えてみたって、Blue
Wave や xrn や 1stReader とかいったニュースリーダーはスコアをサポートす
るべきだね。今は固唾を飲んで見守ることにしましょうか?

@node Kill Files
@section 消去ファイル
@cindex kill files

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がスコ
アファイルを考え出す前に私が書いたものなので、そのコードはまだ残っていま
す。

要するに、消去処理はスコア処理よりもかなり遅いので (私の言いたいの
は @emph{ものすごく})、あなたの消去ファイルはスコアファイルに書き換えた
方が良いかもしれません。

いずれにせよ、消去ファイルは普通の @code{emacs-lisp} ファイルです。この
ファイルの中にはどんな形式でも入れることができます。つまり消去ファイルを
グループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります。

@lisp
(gnus-kill "From" "Lars Ingebrigtsen")
(gnus-kill "Subject" "ding")
(gnus-expunge "X")
@end lisp

これは私が書いたすべての記事に既読の印を付け、概略バッファーから印のつい
た記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムではまったく違う消去ファイルの構文を使っています。も
し Gnus が @code{rn} の消去ファイルらしきものに出会ったら、何とかそれを
解釈しようとします。

@sc{gnus} 消去ファイルを編集するための二つの概略バッファー関数があります。

@table @kbd
@item M-k
@kindex M-k (概略)
@findex gnus-summary-edit-local-kill
そのグループの消去ファイルを編集す
る (@code{gnus-summary-edit-local-kill})。

@item M-K
@kindex M-K (概略)
@findex gnus-summary-edit-global-kill
一般消去ファイルを編集する (@code{gnus-summary-edit-global-kill})。
@end table

消去ファイルを編集する二つのグループモード関数があります。

@table @kbd
@item M-k
@kindex M-k (グループ)
@findex gnus-group-edit-local-kill
そのグループの消去ファイルを編集する (@code{gnus-group-edit-local-kill})。

@item M-K
@kindex M-K (グループ)
@findex gnus-group-edit-global-kill
一般消去ファイルを編集する (@code{gnus-group-edit-global-kill})。
@end table

消去ファイル変数。

@table @code
@item gnus-kill-file-name
@vindex gnus-kill-file-name
@samp{soc.motss} グループ用の消去ファイルは通
常 @file{soc.motss.KILL} という名前です。このファイル名を得るためにグルー
プ名に付加される接尾辞は、@code{gnus-kill-file-name} 変数で与えられます。
``グローバル'' 消去ファイルは (スコアファイルの意味で
の ``グローバル'' じゃないよ、もちろん) 単に @file{KILL} という名前です。

@vindex gnus-kill-save-kill-file
@item gnus-kill-save-kill-file
この変数が @code{nil} 以外であれば、Gnus は処理の後に消去ファイルを保存
します。これは期限切れ消去を行なう消去を使っているときに必要です。

@item gnus-apply-kill-hook
@vindex gnus-apply-kill-hook
@findex gnus-apply-kill-file-unless-scored
@findex gnus-apply-kill-file
グループに消去ファイルを適用するために呼び出されるフック。これはディフォ
ルトでは @code{(gnus-apply-kill-file)} です。もし同じグループに対してス
コアファイルがある場合には消去ファイルを無視したければ、このフック
を @code{(gnus-apply-kill-file-unless-scored)} に設定します。消去ファイ
ルを処理させたくなければ、この変数を @code{nil} に設定して下さい。

@item gnus-kill-file-mode-hook
@vindex gnus-kill-file-mode-hook
消去ファイルモードバッファー内で呼び出されるフック。
@end table

@node Converting Kill Files
@section 消去ファイルの変換
@cindex kill files
@cindex converting kill files

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコアファ
イルに変換したくなるでしょう。もしそれらが ``普通の'' やつであれば、
@file{gnus-kill-to-score.el} パッケージを使うことができます。そうでなけ
れば、手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では Gnus には含
まれません。
@uref{http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el} か
ら入手することができます。

もしあなたの消去ファイルが非常に複雑なものであれば---それ
に @code{gnus-kill} 形式以外のものがたくさん含まれていれば、それらを手で
変換しなければなりません。あるいは単にそれらを、そのままにしておいて下さ
い。Gnus は以前同様にそれらを使ってくれるでしょう。

@node Advanced Scoring
@section 上級スコア付け

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、ある人特定の題に
関して言っていることにだけ本当に興味がある場合はどうすれば良いのでしょ
う? もしくは、A さんが B さんにフォローアップしているときに言っているこ
とを読みたくないけれど、Cさんにフォローアップしているときは何を言ってい
るかを知りたいという場合は?

上級スコア法則を使うことで、任意の複雑なスコアの付け方を作成することがで
きます。

@menu
* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限利用する
@end menu

@node Advanced Scoring Syntax
@subsection 上級スコア付け構文

普通のスコア法則は法則の最初の要素に文字列があります。上級スコア付け法則
は最初の要素にリストがあります。二番目のリストは最初の要素
が @code{nil} でない値に評価されたときに適用されます。

これらのリストは三つの論理作用子からなっており、それらは一方向作用子で、
色々な合致作用子です。

論理作用子:

@table @code
@item &
@itemx and
この論理作用子はそれぞれの引数を @code{false} に評価されるものを見つける
まで評価し、それから停止します。すべての引数が @code{true} の値に評価さ
れた場合は、この作用子は @code{true} を返します。

@item |
@itemx or
この論理作用子はそれぞれの引数を @code{true} に評価されるものを見つける
まで評価します。もしどの引数も @code{true} でないと、この作用子
は @code{false} を返します。

@item !
@itemx not
@itemx ,A,
この論理作用子は単一の引数のみをとります。それはその引数の値の論理否定を
返します。
@end table

引数をスコア付けされている現在の記事の祖先に適用する @dfn{間接作用子} が
あります。例えば、@code{1-} は現在の記事の親にもスコア法則を適用します。
@code{2-} は現在の記事の祖父母にスコア法則を適用します。代わりに、
@code{^^} を書くこともでき、この時、@code{^} (キャラット) (carat) の数は
どのくらい祖先の記事までさかのぼるかを示します。

最後に、合致作用子があります。これらが本当の仕事をするものです。合致作用
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合致
作用子は @samp{("form" "Lars Ingebrigtsen" s)} のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。

@node Advanced Scoring Examples
@subsection 上級スコア付けの例

以下の例はスコアファイルの規則であることに注意して下さい。完璧なスコアファ
イルを作るには、別の括弧の組でそれらを囲んで下さい。

Lars さんが Gnus に関して話をしているときに、彼によって書かれた記事のス
コアを増やしたいとしましょう:

@example
@group
((&
  ("from" "Lars Ingebrigtsen")
  ("subject" "Gnus"))
 1000)
@end group
@end example

ね、とても単純でしょ?

彼が長い記事を書くとき、時々何か素敵なことを言います:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (|
   ("subject" "Gnus")
   ("lines" 100 >)))
 1000)
@end example

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (1- ("from" "Reig Eigir Logge")))
 -100000)
@end example

Redmondo が消えた靴下について書いたときにフォローアップしたすべての人の
スコアが上げられますが、それは彼らが白い靴下について語っているときのみで
す。しかし、Lars が靴下について話をしているときは、たいていあまりおもし
ろくありません:

@example
((&
  (1-
   (&
    ("from" "redmondo@@.*no" r)
    ("body" "disappearing.*socks" t)))
  (! ("from" "Lars Ingebrigtsen"))
  ("body" "white.*socks"))
 1000)
@end example

大量の記事が流れているグループを読んでいて、返答にしか興味が無いとしましょ
う。そういう場合にやることは、"Re:"、"Fw:" または "Fwd:" で始まる表題を
持っていないすべての記事のスコアを下げて、返答の印で始まる表題を持ってい
る記事のすべての親のスコアを上げることです。

@example
((! ("subject" "re:\\|fwd?:" r))
  -200)
((1- ("subject" "re:\\|fwd?:" r))
  200)
@end example

可能性は無限大です。

@node Advanced Scoring Tips
@subsection 上級スコアのちょっとした秘訣

@code{&} と @code{|} 論理作用子は、短縮回路論理を行ないます。すなわち、
その作用の結果が明らかになって時点で、引数を実行過程にかけることを止めま
す。例えば、@code{&} の引数の評価が @code{false} になると、残りの引数を
評価する目的は存在しなくなります。これは遅い合
致 (@samp{body} や @samp{header}) を最後に持ってきて、速い合
致 (@samp{from} や @samp{subject}) を最初に持ってくるべきであるというこ
とを意味します。

間接作用子 (@code{1-} など) はそれらの引数をスレッドの一世代前に作用する
ようにします。次のようなことをすれば:

@example
...
(1-
 (1-
  ("from" "lars")))
...
@end example

これは「現在の記事の祖父母の from ヘッダーにスコアを付ける」ということを
意味します。間接はとても速いですが、次の方よりも:

@example
(1-
 (&
  ("from" "Lars")
  ("subject" "Gnus")))
@end example

次の方が良いです:

@example
(&
 (1- ("from" "Lars"))
 (1- ("subject" "Gnus")))
@end example

@node Score Decays
@section スコア腐敗
@cindex score decays
@cindex decays

スコアは再現無く膨れ上がる傾向があることに気付くかもしれません。特に、適
応スコアを使っているときは。スコアが大きくなりすぎると、それらは意味を失
います---それらは単に最大を通り越してしまって、それを意味のある方法で使
うことは難しくなります。

@vindex gnus-decay-scores
@findex gnus-decay-score
@vindex gnus-decay-score-function
Gnus はこの問題の解決を助けるためにスコアを腐らせる機構を提供します。ス
コアファイルは読み込まれ、@code{gnus-decay-scores} が @code{nil} でない
と、Gnus はスコアファイルを腐敗機構を通し、すべての永続でないスコア法則
のスコアを下げます。もし @code{gnus-decay-scores} が正規表現だったら、そ
れに合致するスコアファイルだけが扱われます。例えば @emph{adaptive} スコ
アファイルだけを腐敗させるために、それを @samp{\\.ADAPT\\'} に設定するこ
とができます。腐敗自身は関数 @code{gnus-decay-score-function} によって実
行され、ディフォルト値は @code{gnus-decay-score} です。以下はその関数の
定義です:

@lisp
(defun gnus-decay-score (score)
  "Decay SCORE according to `gnus-score-decay-constant'
and `gnus-score-decay-scale'."
  (let ((n (- score
              (* (if (< score 0) -1 1)
                 (min (abs score)
                      (max gnus-score-decay-constant
                           (* (abs score)
                              gnus-score-decay-scale)))))))
    (if (and (featurep 'xemacs)
             ;; XEmacs' floor can handle only the floating point
             ;; number below the half of the maximum integer.
             (> (abs n) (lsh -1 -2)))
        (string-to-number
         (car (split-string (number-to-string n) "\\.")))
      (floor n))))
@end lisp

@vindex gnus-score-decay-scale
@vindex gnus-score-decay-constant
@code{gnus-score-decay-constant} はディフォルト値として 3 を持ちで、
@code{gnus-score-decay-scale} はディフォルト値として 0.05 を持ちます。こ
れは以下のようなことを引き起こします:

@enumerate
@item
-3 から 3 の間のスコアはこの関数が呼ばれたときに 0 に設定されます。

@item
3 から 60 までの間の大きさのスコアは三つ減らされます。

@item
60 より大きいスコアはスコアの 5% に減らされます。
@end enumerate

もしこの腐敗関数を好きでないなら、自分自身の関数を書いて下さい。それは腐
敗するべきスコアを唯一の引数として呼ばれ、整数であるべき新しいスコアを返
さなければなりません。

Gnus は一日に一回スコアを腐敗させようとします。例えば、もし Gnus を四日
間実行していないと、Gnus は四回スコアを腐らせます。

@iftex
@iflatex
@chapter Message
@include message-ja.texi
@chapter Sieve
@include sieve-ja.texi
@chapter PGG
@include pgg-ja.texi
@chapter SASL
@include sasl-ja.texi
@end iflatex
@end iftex

@node Various
@chapter いろいろ

@menu
* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーがどのように見えるべきかを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 どのようにして Gnus の速度を上げるか
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏でものごとを実行することができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* Image Enhancements::          最新の Emacs/XEmacs は絵を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        余計な商業的電子メールを避ける方法
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの
@end menu

@node Process/Prefix
@section プロセス/接頭引数
@cindex process/prefix convention

多くの関数、その中でも記事の移動、デコード、保存をするための関数は、
@dfn{プロセス/接頭引数の習慣} として知られているものを使います。

これは利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

もし数値接頭引数が N であると、現在の記事から始めて、次の N 記事に作業を
実行します。もし数値接頭引数が負であると、現在の記事から始めて、前
の N 記事に作業を実行します。

@vindex transient-mark-mode
@code{transient-mark-mode} が @code{nil} でなく、リージョンが操作されて
いると、リージョンにあるすべての記事に作業がなされます。

もし接頭引数が無いけれど、いくつかの記事はプロセス印が付いているという場
合は、プロセス印の付いている記事に作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事にだけ作
業を実行します。

これは本当に非常に簡単ですが、驚嘆を避けられるように詳細を明らかにしてお
く必要があるのです。

プロセス印に反応する記事は現在のプロセス印の付いている記事のリストをスタッ
クに積み、すべてのプロセス印の記事のリストを消去します。前回の設定
を @kbd{M P y} で復旧させることができます (@pxref{Setting Process Marks})。

@vindex gnus-summary-goto-unread
多くの人々を驚かせ、恐がらせると思われることは、例えば、@kbd{3 d} は本当
に @kbd{d} @kbd{d} @kbd{d} と同じことをすることです。それぞれ
の @kbd{d} (これは現在の記事に既読の印を付けます) はディフォルトでは印を
付けた後に次の未読記事に移動するので、@kbd{3 d} は概略バッファーがどのよ
うであっても、次の三つの未読記事を既読にします。もっと分かりやすい動作の
ためには @code{gnus-summary-goto-unread} を @code{nil} に設定して下さい。

多くのコマンドはプロセス/接頭引数の習慣を使いません。ということは、この
マニュアルではっきりと述べています。プロセス/接頭引数の習慣を使わないコ
マンドに適用するには、@kbd{M-&} コマンドを使いましょう。例えば、そのグルー
プのすべての記事を期限切れ消去可能として印を付けるに
は @kbd{M P b M-& E} とします。

@node Interactive
@section 対話的
@cindex interaction

@table @code
@item gnus-novice-user
@vindex gnus-novice-user
もしこの変数が @code{nil} でないと、あなたは Usenet の世界に新しく入って
来た人であるか、非常に慎重な人で、これは本当に良いことです。何か危険なこ
とをする前に、``本当にこれをしたいのですか?'' というような質問を受けます。
これはディフォルトでは @code{t} です。

@item gnus-expert-user
@vindex gnus-expert-user
この変数が @code{nil} でないと、あなたは Gnus からほとんど質問を受けるこ
とはありません。これは単純にあなたがどのような変なことをしていても、何を
しているかをわかっていると見なします。

@item gnus-interactive-catchup
@vindex gnus-interactive-catchup
@code{nil} でないと、グループに追いつく (catchup) 前に、確認を要求します。
これはディフォルトで @code{t} です。

@item gnus-interactive-exit
@vindex gnus-interactive-exit
Gnus を終了する前に確認を要求します。この変数はディフォルト
で @code{t} です。
@end table

@node Symbolic Prefixes
@section シンボルの接頭引数
@cindex symbolic prefixes

非常に多くの Emacs の命令は (数値) 接頭引数に反応します。例えば、
@kbd{C-u 4 C-f} はポイントを 4 文字先に移動し、
@kbd{C-u 9 0 0 I s s p} は永続 @code{Suject} 文字列の一部スコア法則
の 900 を現在の記事に加えます。

これは素敵で良いのですが、命令にもう少し追加の情報を与えたいときはどうす
れば良いのでしょう? えーと、たいていの命令がしていることは、``生の'' 接
頭引数を特別な方法で解釈することです。例えば、@kbd{C-u 0 C-x C-s} は現在
の記事を保存するときにバックアップファイルを作らないで欲しいということを
意味します。でも、バックアップファイルを作らないで保存し、同時
に Emacs に光って欲しく、素敵な音楽を演奏して欲しいときはどうすれば良い
でしょう?  それは不可能で、おそらくそれが不可能であってもあなたは幸せで
しょう。

@kindex M-i (概略)
@findex gnus-symbolic-argument
私はそうではありません。ですから、私は二つめの接頭引
数---@dfn{シンボル接頭引数} を加えました。接頭キー
は @kbd{M-i} (@code{gnus-symbolic-argument}) で、次に押される文字が値で
す。望むだけ多くの @kbd{M-i} 接頭語を積み重ねることができます。
@kbd{M-i a C-M-u} は ``@kbd{C-M-u} 命令にシンボル接頭引数 @code{a} を与
える'' ということです。@kbd{M-i a M-i b C-M-u} は @kbd{C-M-u} 命令にシン
ボル接頭引数 @code{a} @code{b} を与える'' ということです。趣旨は分かった
でしょう。

シンボル接頭引数を受け付けない命令にそれを打鍵することは何も悪いことをし
ませんが、良いことも何もしません。現在のところ、あまり多くの関数がシンボ
ル接頭引数を役立てているわけではありません。

もしどのように Gnus がこれを実装しているかに興味があるなら、
@ref{Extended Interactive} を見て下さい。

@node Formatting Variables
@section 書法仕様変数
@cindex formatting variables

このマニュアルを通して、あなたはおそら
く @code{gnus-group-line-format} また
は @code{gnus-summary-mode-line-format} のように呼ばれるたくさんの変数が
あることに気付いたでしょう。これらは Gnus が色々なバッファーでどのように
行を出力するかを制御します。非常にたくさんのものがあります。幸運なことに、
それらはすべて同じ構文を使うので、あまり嫌な目には会わないでしょう。

書法仕様 (format) 指定の例があります (グループバッファーより):
@samp{%M%S%5y: %(%g%)\n}。それは実際に非常に醜く、たくさんのパーセント記
号がどこにでもあります。

@menu
* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を修正する
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う
@end menu

現在のところ、Gnus は以下の書法仕様変数を使います:
@code{gnus-group-line-format}, @code{gnus-summary-line-format},
@code{gnus-server-line-format}, @code{gnus-topic-line-format},
@code{gnus-group-mode-line-format}, @code{gnus-summary-mode-line-format},
@code{gnus-article-mode-line-format}, @code{gnus-server-mode-line-format},
@code{gnus-summary-pick-line-format}。

これらすべての書法仕様変数は任意の elisp 式であることもできます。その場
合は、それらは要求される行に挿入するために @code{評価} されます。

@kindex M-x gnus-update-format
@findex gnus-update-format
Gnus はあなた自身の書法仕様指定を作る手伝いをする命令を備えています。
@kbd{M-x gnus-update-format} は現在の式を @code{評価} し、当の指定を更新
し、結果の Lisp 式を実行して行を作成することを実験できるバッファーに移動
します。

@node Formatting Basics
@subsection 書法仕様の基本

それぞれの要素 @samp{%} は当のバッファーが作成されるときに何らかの文字列
や他のもので置き換えられます。@samp{%5y} は ``@samp{y} 指定を挿入し、
5 文字の場所を得るために空白を入れなさい'' ということです。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、
@samp{%} と書法仕様の型の文字の間の数値修飾子は常に少なくともその長さに
なるように、出力に @dfn{詰め} れられます。@samp{%5y} はその部分を常
に (少なくとも) 5 文字の長さになるように、左に空白を詰めます。も
し @samp{%-5y} とすれば、代わりに右側に詰め込みます。

特に長い値からその部分を保護するために、長さを制限したいとも思うでしょう。
そのためには、@samp{%4,6y} とすることができて、これはその領域は決し
て 6 文字を超える長さにはならず、4 文字より少ない長さにならないというこ
とです。

Gnus は @samp{%&user-date;} のような、いくつかの拡張様式指示もサポートし
ます。

@node Mode Line Formatting
@subsection モード行書法仕様

モード行書法仕様変数 (例えば @code{gnus-summary-mode-line-format}) は以
下の二つの違い以外は、バッファー行に基づく書法仕様変数
と (@pxref{Formatting Basics}) 同じような規則に従います:

@enumerate

@item
最後に改行 (@samp{\n}) があってはなりません。

@item
特別な @samp{%%b} 指定をバッファー名を表示するために使うことができます。
えーと、本当はそれは指定ではないのです---@samp{%%} は単に書法仕様が機械
的に切り裂くのを切り抜けて @samp{%} をそのまま渡すための方法で、
Emacs が @samp{%b} を受け取ると、Emacs のモード行表示の部分がそれ
を ``バッファー名を表示しなさい'' と解釈します。Emacs が理解するモード行
指定の完全な一覧を見るためには、変数 @code{mode-line-format} の説明文を
見て下さい。

@end enumerate

@node Advanced Formatting
@subsection 上級書法仕様

何らかの方法で領域を後で処理するのは頻繁に役に立ちます。部分を詰め込む、
制限する、切り取ることと特定の値を抑制することは、@dfn{チルダ修飾子} を
使うことにより達成されます。よくあるチルダ指定はこのように見えるかもしれ
ません @samp{%~(cut 3)~(ignore "0")y}。

これらは有効な修飾子です:

@table @code
@item pad
@itemx pad-left
要求された長さになるまで、領域に空白を左側から詰め込みます。

@item pad-right
要求された長さになるまで、領域に空白を右側から詰め込みます。

@item max
@itemx max-left
指定された長さになるように、文字を左側から切り取ります。

@item max-right
指定された長さになるように、文字を右側から切り取ります。

@item cut
@itemx cut-left
指定された数の文字を左側から切り落とします。

@item cut-right
指定された数の文字を右側から切り落とします。

@item ignore
領域が指定された値と等しければ (equal)、空文字列を返します。

@item form
@samp{@@} 指定が使われたときに、指定された式を領域の値として使います。

これは例です:

@lisp
"~(form (current-time-string))@@"
@end lisp
@end table

例を出してみましょう。概略モード行での @samp{%o} 指定は小型の ISO0861 様
式の日付を返します---@samp{19960809T230410} です。これは発音しにくいので、
世紀を表す数と時間を削ぎ落として、6 文字の日付を残したいと思います。それ
は @samp{%~(cut-left 2)~(max-right 6)~(pad 6)o} となるでしょう。(切り落
とし (cutting) は 最大限 (maxing) より先になされるので、桁で素敵に見える
ようにするために日付が 6 文字より少なく無くならないことを保証するために
詰め込み (padding) が必要になります。)

無視 (ignore) が最初になされます。それから切り落とし (cut) が行なわれま
す。そして、それから最後の操作、詰め込み (pad) が行なわれます。

もしあなたが、これらの上級参照をたくさん使っているなら、Gnus がとても遅
くなるのがわかるでしょう。これはあなたが行の外見に満足したとき
に @kbd{M-x gnus-compile} を実行することで格段に速度低下を減らすことがで
きます。@xref{Compilation}.

@node User-Defined Specs
@subsection 利用者定義の指定

すべての指定は利用者定義---@samp{u} の指定を挿入することができます。書法
仕様文字列の次の文字はアルファベットである必要があります。Gnus は関
数 @code{gnus-user-format-function-}@samp{X} を呼び、ここ
で @samp{X} は @samp{%u} に続くアルファベットです。関数には単一の引数が
与えられます---引数の意味は関数がどのバッファーから呼ばれているかによっ
て変わります。関数は文字列を返すべきで、それは他の指定からの情報とまった
く同じようにバッファーに挿入されます。関数は意味の無い値と共に呼ばれるこ
ともありえるので、それの対策をするべきです。

Gnus は @samp{%u&foo;} のような拡張利用者定義指示もサポートします。
Gnus は関数 @code{gnus-user-format-function-}@samp{foo} を呼び出します。

新しい関数を定義しないでも、チルダ修飾
子 (@pxref{Advanced Formatting}) を使ってほとんど同じことを達成すること
ができます。例です: @samp{%~(form (count-lines (point-min) (point)))@@}。
ここで与えられた式は評価されて、現在の行数をもたらし、それから挿入されま
す。

@node Formatting Fonts
@subsection 書法仕様フォント

ハイライトのための指定があり、それらはすべての書法仕様変数によって共有さ
れています。@samp{%(} と @samp{%)} 指定の間の文章は特別
な @code{mouse-face} プロパティが設定され、それはそこにマウスのポインター
をあわせたときに (@code{gnus-mouse-face} によって) ハイライトされること
になります。

@samp{%@{} と @samp{%@}} 指定の間の文章は @code{gnus-face-0} を使って普
通のフェースが設定され、それはディフォルトで @code{bold} です。も
し @samp{%@{1} としたなら、代わりに @code{gnus-face-1} を得、以下同様で
す。欲しいだけたくさんのフェースを作って下さい。同じこと
が @code{mouse-face} 指定にも言えま
す---@samp{hello} が @code{gnus-mouse-face-3} でマウス−ハイライトされる
ためには、@samp{%3(hello%)} とすることができます。

@samp{%<<} と @samp{%>>} 指示子の間のテキストは特別
な @code{balloon-help} プロパティが @code{gnus-balloon-face-0} に設定さ
れます。@samp{%1<<} とすると、@code{gnus-balloon-face-1} を得て、他も同
様です。@code{gnus-balloon-face-*} 変数は文字列か文字列を返す関数を指す
シンボルのどちらかである必要があります。マウスがプロパティの設定されてい
るテキストの上を通過すると、バルーンウィンドウが現れて、文字列を表示しま
す。これの詳しい情報は @xref{Tooltips, ,Tooltips, emacs, The Emacs
Editor}, (GNU Emacs) または @code{balloon-help-mode} (XEmacs) の説明文字
列を参照して下さい。(技術的な理由のために、ギィメ (guillemets:
@footnote{guillemets (仏語) はギュメとも表記されます。日本語の「」に当た
るもので、口頭表現を表記したり、強調したい単語を囲む、何かからの引用部分
を囲む、書物等のタイトルを記す等様々に使われます。}) はこの節で
は @samp{<<} および @samp{>>} として近似されました。)

これはグループバッファーの代替手法です:

@lisp
;; @r{三つのフェースの型を作ります。}
(setq gnus-face-1 'bold)
(setq gnus-face-3 'italic)

;; @r{記事の数をボールドで緑のフェースにしたいので、}
;; @r{@code{my-green-bold} という新しいフェースを作りました。}
;; @r{}
(copy-face 'bold 'my-green-bold)
;; @r{色を設定します。}
(set-face-foreground 'my-green-bold "ForestGreen")
(setq gnus-face-2 'my-green-bold)

;; @r{新しい上等の書法仕様を設定します。}
(setq gnus-group-line-format
      "%M%S%3@{%5y%@}%2[:%] %(%1@{%g%@}%)\n")
@end lisp

あなたがこの案を使って完全に読めなくて非常に下品な表示を作ることができる
と確信しています。楽しんで下さい!

@samp{%(} 指定 (やその類のもの) はモード行変数ではまったく意味をなさない
ことに注意して下さい。

@node Positioning Point
@subsection ポイントの移動

Gnus は通常ほとんどのバッファーで、ポイントを各行のあらかじめ決められた
場所に移動します。ディフォルトでは、ポイントは行の最初のコロンに移動しま
す。あなたはこの振るまいを、三つの違う方法でカスタマイズすることができま
す。

また、あなたはコロンを行のどの場所にでも移動することができます。

@findex gnus-goto-colon
あなたはコロンの位置にポイントを移動させるための関数を定義し直すことがで
きます。その関数は @code{gnus-goto-colon} と呼ばれています。

でも、もしあなたが行にコロンを含めたくないならば、これを扱うためのおそら
く最も手ごろな方法は @samp{%*} 指示子を使うことです。あなたの行の書法仕
様の定義に @samp{%*} を入れておけば、Gnus はそこにポイントを置きます。

@node Tabulation
@subsection 整列

あなたは通常は、延ばしたり縮めたりして文字列をディスプレイに並べることが
できます。でも大きさが違う異なる文字列を連結させる場合は、単に文字列を出
力してしまうのがより手ごろであることが多いはずで、しかしそうするとその後
に続くテキストを並べるのに悩むことになります。

それを行なうため、Gnus は整列子 (tabulator) の指定 @samp{%=} を備えてい
ます。これには二つの形
式 @dfn{hard tabulators} と @dfn{soft tabulators} があります。

@samp{%50=} は文字列が 50桁から始まるように空白文字を詰め込みます。も
し 50桁より後ろにすでにテキストがある場合は何も挿入しません。これは穏や
か (soft) な整列子です。

@samp{%-50=} もまた、文字列が 50桁から始まるように空白文字を詰め込みます。
ですが、もし 50桁より後ろにすでにテキストがある場合、50桁より後ろにある
過剰なテキストは削除されます。これは厳密 (hard) な整列子です。

@node Wide Characters
@subsection Wide Characters

多くの地域において、固定幅フォントは同じ幅の文字を持っています。しかしい
くつかの地域、よく知られている東アジアの国々では、ラテン文字と幅の広い文
字が混在して使われています。

整形において、Gnus は文字列が 10個の文字の幅だとしたら、スクリーンで
も 10個分のラテン文字の幅になると仮定しますが、それは問題です。かの国々
では、それは正しくありません。

@vindex gnus-use-correct-string-widths
それを救済するために、あなた
は @code{gnus-use-correct-string-widths} を @code{t} に設定することがで
きます。これはバッファーの生成を遅くしますが、より美しい結果を得ることが
できるでしょう。既定値は @code{t} です。

@node Window Layout
@section ウィンドウの配置
@cindex window layout

いえ、X に関することはありませんから、おとなしくして下さい。

@vindex gnus-use-full-window
もし @code{gnus-use-full-window} が @code{nil} でないと、Gnus はすべての
他のウィンドウを消して、Emacs の画面全体を占有します。これはディフォルト
で @code{t} です。

この変数を @code{nil} に設定するのはそれなりに動作しますが、問題もありま
す。危険を覚悟の上で使って下さい。

@vindex gnus-buffer-configuration
@code{gnus-buffer-configuration} はそれぞれの Gnus のバッファーがどのく
らいの空間を与えられるべきかを現します。これはこの変数の抜粋です:

@lisp
((group (vertical 1.0 (group 1.0 point)
                      (if gnus-carpal (group-carpal 4))))
 (article (vertical 1.0 (summary 0.25 point)
                        (article 1.0))))
@end lisp

これは連想リストです。@dfn{キー} は何らかの動作や他のものを任命するシン
ボルです。例えば、グループバッファーを表示するときは、ウィンドウ設定関数
は @code{group} をキーとして使います。使用可能な名前の完全な一覧は下に挙
げられています。

@dfn{値} (すなわち、@dfn{分割}) はそれぞれのバッファーがどれくらいを占め
るべきかを指定します。@code{article} 分割を例に取ると -

@lisp
(article (vertical 1.0 (summary 0.25 point)
                       (article 1.0)))
@end lisp

この @dfn{分割} は概略バッファー (summary buffer) が画面の上の 25% を占
めるべきで、それは記事バッファー (article buffer) の上に配置されます。お
気づきの通り、100% + 25% は実際は 125% です (えぇ、皆さんの計算はこの様
になったと思います。) しかし、特別な数値 @code{1.0} は、残りのバッファー
が必要なものを取り去った後に、使用可能な残りの空間すべてを吸い取る、とい
うことを合図するために使われます。一つの分割につき、@code{1.0} の大きさ
指定のバッファーは一つだけでなくてはなりません。

ポイントは省略可能な三つ目の要素、@code{point} を持つバッファーに置かれ
ます。@code{frame} 分割では、タグ @code{frame-focus} が構成要素であ
る (すなわち、@code{point} タグが存在するかどうかによって、リストの三番
目か四番目かに存在する要素) 葉分割を持つ最後の副分割が焦点を得ることにな
ります。

次はもっと複雑な例です:

@lisp
(article (vertical 1.0 (group 4)
                       (summary 0.25 point)
                       (if gnus-carpal (summary-carpal 4))
                       (article 1.0)))
@end lisp

もし大きさ指定が浮動小数点数の代わりに整数であったなら、それは割合ではな
く、どのくらい多くの行をバッファーが占めるべきかを指定するために使われま
す。

もし @dfn{分割} が @code{評価} されるもののように見えるときは (明確にす
ると---分割の @code{car} が関数か原始関数 (subr) であるときは)、この分割
は @code{評価} されます。結果が @code{nil} でないなら、それは分割として
用いられます。これは、@code{gnus-carpal} が @code{nil} であれば三つのバッ
ファーが、@code{gnus-carpal} が @code{nil} でないなら、四つのバッファー
が存在するということです。

まだ複雑ではないですって? それでは、大きさにこれを試してみて下さい:

@lisp
(article (horizontal 1.0
             (vertical 0.5
                 (group 1.0)
                 (gnus-carpal 4))
             (vertical 1.0
                 (summary 0.25 point)
                 (summary-carpal 4)
                 (article 1.0))))
@end lisp

おぉっと。二つのバッファーに不思議な 100% タグが付いています。そして、あ
の @code{horizontal} っていうものは何でしょう?

もし分割の一つの最初の要素が @code{horizontal} であったなら、Gnus はウィ
ンドウを水平に分割し、二つのウィンドウを横に並べます。これらのそれぞれの
小片の中では、すべてを普通の流儀で行なうことができます。
@code{horizontal} の後の数値は、この小片に画面のどれくらいの割合が与えら
れるかを指定します。

それぞれの分割では、100% のタグを持つ要素が @emph{必ず} 一つある必要があ
ります。分割は決して正確には行なわれないので、このバッファーが分割から残
されたすべての行を占領します。

もう少し正式にするために、ここに有効な分割がどのようになるかの定義があり
ます:

@example
split      = frame | horizontal | vertical | buffer | form
frame      = "(frame " size *split ")"
horizontal = "(horizontal " size *split ")"
vertical   = "(vertical " size *split ")"
buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
size       = number | frame-params
buf-name   = group | article | summary ...
@end example

制限には、@code{frame} は最上位の分割としてしか現れることができないとい
うものがあります。@var{form} は有効な分割を返す Emacs Lisp の
式 (form) でなければなりません。それぞれの分割は完全に再帰的で、任意の数
の @code{vertical} と @code{horizontal} 分割を含むことができます。

@vindex gnus-window-min-width
@vindex gnus-window-min-height
@cindex window height
@cindex window width
正しい大きさを見つけるのは少し複雑です。どのウィンドウ
も @code{gnus-window-min-height} (ディフォルト値 1) の文字の高さよりも小
さくてはならず、少なくとも @code{gnus-window-min-width} (ディフォルト
値 1) の文字幅でなくてはなりません。Gnus は分割を適用する前にこれを強制
しようと試みます。もし普通の Emacs のウィンドウの幅/高さ制限を使いたいな
ら、この二つの変数を @code{nil} にするだけで良いです。

もし Emacs の用語になじんでいないのなら、
@code{horizontal} と @code{vertical} 分割は、期待するものと反対の動作を
するでしょう。@code{horizontal} 分割の中のウィンドウは横に並んで表示され、
@code{vertical} 分割の中のウィンドウは上下に表示されます。

@findex gnus-configure-frame
ウィンドウの設置に関して実験をしてみたいのであれば、よい方法は分割で直
接 @code{gnus-configure-frame} を呼ぶことです。これはバッファーを分割す
るときにすべての本当の仕事をする関数です。下のものは 5 ウィンドウのとて
もばかげた設定です。二つをグループバッファーに、三つを記事バッファーのた
めに充てます。(それはばかげていると言ったでしょ。) もし下の文
を @code{評価} すると、普通の Gnus の経路を使わないで、すぐにそれがどの
ように見えるかの考えを得ることができます。満足するまでそれで遊んで、それ
から @code{gnus-add-configuration} を使って新しい想像をバッファー設定リ
ストに加えて下さい。

@lisp
(gnus-configure-frame
 '(horizontal 1.0
    (vertical 10
      (group 1.0)
      (article 0.3 point))
    (vertical 1.0
      (article 1.0)
      (horizontal 4
        (group 1.0)
        (article 10)))))
@end lisp

いくつかのフレームも欲しいかもしれません。簡単です---@code{frame} 分割を
使うだけです:

@lisp
(gnus-configure-frame
 '(frame 1.0
         (vertical 1.0
                   (summary 0.25 point frame-focus)
                   (article 1.0))
         (vertical ((height . 5) (width . 15)
                    (user-position . t)
                    (left . -1) (top . 1))
                   (picon 1.0))))
@end lisp

この分割の結果は、最初 (もしくは、``主な'') フレームは見慣れた概略/記事
ウィンドウ設定で、小さな追加のフレームが picon を表示するために作られる
ということになります。ご覧の通り、普通の @code{1.0} 最上位指定の代わりに、
それぞれの追加の分割がフレームパラメーター連想リストを大きさ指定として持
たなければなりません (@pxref{Frame Parameters, ,Frame Parameters, elisp,
The GNU Emacs Lisp Reference Manual})。XEmacs では、フレームプロパティリ
ストも使えます---例えば、@code{(height 5 width 15 left -1 top 1)} はその
ようなパラメーターリストです。@code{gnus-buffer-configuration} に使用可
能なすべてのキーの一覧はそのディフォルト値で見つけることができます。

キー @code{message} は @code{gnus-group-mail} およ
び @code{gnus-summary-mail-other-window} の両方で使われることに注意して
下さい。もし二つを区別するほうが望ましいなら、このような物を使うことがで
きます:

@lisp
(message (horizontal 1.0
                     (vertical 1.0 (message 1.0 point))
                     (vertical 0.24
                               (if (buffer-live-p gnus-summary-buffer)
                                   '(summary 0.5))
                               (group 1.0))))
@end lisp

複数のフレームへの良くある要望は、メールとニュースの作成には別のフレーム
を使い、元のフレームはそのままに残すというものです。これの達成には、以下
のようなものでできます。

@lisp
(message
  (frame 1.0
         (if (not (buffer-live-p gnus-summary-buffer))
             (car (cdr (assoc 'group gnus-buffer-configuration)))
           (car (cdr (assoc 'summary gnus-buffer-configuration))))
         (vertical ((user-position . t) (top . 1) (left . 1)
                    (name . "Message"))
                   (message 1.0 point))))
@end lisp

@findex gnus-add-configuration
変数 @code{gnus-buffer-configuration} はとても長く複雑なので、単一の設定
の変更を簡単にするための関数があります: @code{gnus-add-configuration} で
す。もし、例えば、@code{article} の設定を変えたいのなら、次のようにでき
ます:

@lisp
(gnus-add-configuration
 '(article (vertical 1.0
               (group 4)
               (summary .25 point)
               (article 1.0))))
@end lisp

普通はこれらの @code{gnus-add-configuration} 呼び出し
を @file{~/.gnus.el} ファイルに入れるか、何らかの起動時のフックに入れる
でしょう---それらは Gnus が読み込まれた後に実行されるべきです。

@vindex gnus-always-force-window-configuration
もし設定で言及されたすべてのウィンドウがすでに見えているのであれば、
Gnus はウィンドウの設定を変更しません。もし常に ``正しい'' ウィンドウ設
定を強制したいのであれば、
@code{gnus-always-force-window-configuration} を @code{nil} でない値に設
定することができます。

木表示を使っていて (@pxref{Tree Display})、木ウィンドウは垂直方向に別の
ウィンドウで表示されるなら、ウィンドウの大きさが変更されることを避けるた
めに @code{gnus-tree-minimize-window} をいじるのが良いでしょう。

@subsection ウィンドウ設定の例

@itemize @bullet
@item
左側を狭めてグループバッファーに。右側を分割して概略バッ
ファー (上 1/6) と記事バッファー (下) に。

@ifinfo
@example
+---+---------+
| G | Summary |
| r +---------+
| o |         |
| u | Article |
| p |         |
+---+---------+
@end example
@end ifinfo

@lisp
(gnus-add-configuration
 '(article
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0
                         (summary 0.16 point)
                         (article 1.0)))))

(gnus-add-configuration
 '(summary
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0 (summary 1.0 point)))))
@end lisp
@end itemize

@node Faces and Fonts
@section フェースとフォント
@cindex faces
@cindex fonts
@cindex colors

フォントとフェースを弄るのは非常に難しかったのですが、今日では非常に簡単
です。単に @kbd{M-x customize-face} とやって、変えたいフェースを選び出し
て、標準のカスタマイズインターフェースを使って変更することができます。

@node Compilation
@section コンパイル
@cindex compilation
@cindex byte-compilation

@findex gnus-compile

あの行書法仕様指定変数を覚えています
か? @code{gnus-summary-line-format}, @code{gnus-group-line-format} など
などです。さて、Gnus はこれらの変数が何であっても注意を払いますが、不運
なことにそれらを変更すると大変重大な速度低下を引き起こすことになります。
(これらの変数のディフォルト値はそれらに関連付けられたバイトコンパイルさ
れた関数を持っていますが、利用者作成のものはもちろんそうではありません。)

これを改善するために、変数をいじくりまわして、(なんとなく) 満足したと感
じた後で、@kbd{M-x gnus-compile} を実行することができます。これは新しい
指定がバイトコンパイルされ、もう一度最高速度に復帰できるということです。
Gnus はこれらのバイトコンパイルされた指定を @file{.newsrc.eld} ファイル
に保存します。(もっとも利用者が定義した関数は、この関数によってコンパイ
ルされません---それらを @file{~/.gnus.el} ファイルに突っ込んでから、自分
で @file{~/.gnus.el} ファイルをバイトコンパイルしなければなりません。)

@node Mode Lines
@section モード行
@cindex mode lines

@vindex gnus-updated-mode-lines
@code{gnus-updated-mode-lines} はどのバッファーがそのモード行を常に最新
のものにしておくかを指定します。それはシンボルのリストです。使うことので
きるシンボルは @code{group}, @code{article}, @code{summary},
@code{server}, @code{browse}, @code{tree} などです。もし対応するシンボル
が存在すると、Gnus は該当するであろう情報でモード行を更新します。この変
数が @code{nil} であるなら、画面の再描画はもっと速いでしょう。

@cindex display-time

@vindex gnus-mode-non-string-length
ディフォルトでは、Gnus は概略バッファーと記事バッファーのモード行に現在
の記事の情報を表示します。Gnus が表示したい情報 (例えば、記事の表題) は
しばしばモード行よりも長いことがあるので、どこかで切り落とされなければな
りません。変数 @code{gnus-mode-non-string-length} はその行の他の要素 (す
なわち、情報でない部分) がどのくらいの長さであるかを指定します。もしモー
ド行に追加の要素を入れたなら、この変数を修正する必要があります:

@c Hook written by Francesco Potorti` <pot@cnuce.cnr.it>
@lisp
(add-hook 'display-time-hook
          (lambda () (setq gnus-mode-non-string-length
                           (+ 21
                              (if line-number-mode 5 0)
                              (if column-number-mode 4 0)
                              (length display-time-string)))))
@end lisp

もしこの変数が @code{nil} であるなら (これがディフォルト値ですが)、モー
ド行は切り落とされず、詰め込みもされません。ディフォルトでは、バッファー
の完全なパーセント表示さえもモード行から追いやられる可能性もあるので、お
そらく望ましい設定ではないということに注意して下さい。利用者が自分の設定
に合うようにこの変数を適切に設定しなければなりません。

@node Highlighting and Menus
@section ハイライトとメニュー
@cindex visual
@cindex highlighting
@cindex menus

@vindex gnus-visual
変数 @code{gnus-visual} はたいていの Gnus を素敵にする部分の操作をします。
@code{nil} であると、Gnus はメニューを作ったり、素敵な色やフォントを使っ
たりしようとしません。これは @file{gnus-vis.el} ファイルを読み込むことも
禁止します。

この変数は使用可能な視覚的プロパティのリストであることができます。以下の
要素は有効で、ディフォルトですべて含まれています:

@table @code
@item group-highlight
グループバッファーでハイライトをします。
@item summary-highlight
概略バッファーでハイライトをします。
@item article-highlight
記事バッファーでハイライトをします。
@item highlight
すべてのバッファーでハイライトをするようにします。
@item group-menu
グループバッファーでメニューを作成します。
@item summary-menu
概略バッファーでメニューを作成します。
@item article-menu
記事バッファーでメニューを作成します。
@item browse-menu
ブラウズバッファーでメニューを作成します。
@item server-menu
サーバーバッファーでメニューを作成します。
@item score-menu
スコアバッファーでメニューを作成します。
@item menu
すべてのバッファーでメニューを作成します。
@end table

ですから、記事バッファーだけをハイライトしたく、すべてのバッファーでメニュー
を作りたい場合は、このようにすることができます:

@lisp
(setq gnus-visual '(article-highlight menu))
@end lisp

もしハイライトだけで、メニューの類は欲しくないときは、次のようにできます:

@lisp
(setq gnus-visual '(highlight))
@end lisp

@code{gnus-visual} が @code{t} であると、ハイライトとメニューはすべて
の Gnus のバッファーで使用されます。

他のすべてのバッファーの外見に影響する総合的な変数は:

@table @code
@item gnus-mouse-face
@vindex gnus-mouse-face
これは Gnus でマウスのハイライトに使われるフェース (すなわち、フォン
ト) です。@code{gnus-visual} が @code{nil} であると、マウスハイライトは
なされません。
@end table

まったく違ったメニューを作成するために関連するフックがあります:

@table @code
@item gnus-article-menu-hook
@vindex gnus-article-menu-hook
記事モード (article mode) メニューを作成した後に呼ばれるフックです。

@item gnus-group-menu-hook
@vindex gnus-group-menu-hook
グループモード (group mode) メニューを作成した後に呼ばれるフックです。

@item gnus-summary-menu-hook
@vindex gnus-summary-menu-hook
概略モード (summary mode) メニューを作成した後に呼ばれるフックです。

@item gnus-server-menu-hook
@vindex gnus-server-menu-hook
サーバーモード (server mode) メニューを作成した後に呼ばれるフックです。

@item gnus-browse-menu-hook
@vindex gnus-browse-menu-hook
概観モード (browse mode) メニューを作成した後に呼ばれるフックです。

@item gnus-score-menu-hook
@vindex gnus-score-menu-hook
スコアモード (score mode) メニューを作成した後に呼ばれるフックです。
@end table

@node Buttons
@section ボタン
@cindex buttons
@cindex mouse
@cindex click

最近では、最新流行のマウス @dfn{mouse} 装置が、ちゃんとした操作法を学び
たがらないナウなヤングの間で大人気です。それでは、私が Tops 20 システム
上で Emacs を使っていた頃の '89 年の夏を思い起こしてみましょう。300 人の
利用者が、一つのマシン上で、みんなが Simula コンパイラを走らせていました。
ああ、ばかばかしい!

ほんとにそうだね。

@vindex gnus-carpal
まずですね、@code{gnus-carpal} を @code{t} に設定することによって、クリッ
クするだけで何でもできるボタンだらけのバッファーを Gnus に表示させること
ができます。とっても簡単です、ほんとに。指圧療法の先生に教えてあげて。
(訳注: carpal とは手首の骨のこと)

@table @code
@item gnus-carpal-mode-hook
@vindex gnus-carpal-mode-hook
すべての手首モードバッファーで実行するフック。

@item gnus-carpal-button-face
@vindex gnus-carpal-button-face
ボタンに使われるフェース。

@item gnus-carpal-header-face
@vindex gnus-carpal-header-face
手首バッファーのヘッダーで使用されるフェース。

@item gnus-carpal-group-buffer-buttons
@vindex gnus-carpal-group-buffer-buttons
グループバッファーのボタン。

@item gnus-carpal-summary-buffer-buttons
@vindex gnus-carpal-summary-buffer-buttons
概略バッファーのボタン。

@item gnus-carpal-server-buffer-buttons
@vindex gnus-carpal-server-buffer-buttons
サーバーバッファーのボタン。

@item gnus-carpal-browse-buffer-buttons
@vindex gnus-carpal-browse-buffer-buttons
閲覧バッファーのボタン。
@end table

すべての @code{buttons} 変数はリストです。このリストの要素は、
@code{car} が表示される文で @code{cdr} が関数シンボルの cons セルか、も
しくはただの文字列のどちらかです。

@node Daemons
@section デーモン
@cindex demons
@cindex daemons

Gnus、それは (言い伝えによれば) かつて書かれたいかなるプログラムよりも大
きく、あなたがやって欲しいと思うさまざまな奇妙なことを、あなたのいないと
ころで行なってくれるものです。例えば、あなたは時たま新着メールをチェック
してもらいたいかもしれません。あるいは Emacs をしばらく放っておいたとき
すべてのサーバーの接続を切断してもらいたくなるかもしれません。他にも何か
そういったことです。

Gnus はさまざまな制御子 @dfn{handlers} を定義することによってそのような
ことを可能にします。各制御子は三つの要素から成ります。
@var{関数}, @var{時間}, @var{空転} パラメーターです。

以下は Emacs が何もしない空転状態が三十分続いたときに接続を切断する制御
子の例です。

@lisp
(gnus-demon-close-connections nil 30)
@end lisp

以下は Emacs が何もしていないとき、一時間毎に @acronym{PGP} ヘッダーを走
査する制御子です。

@lisp
(gnus-demon-scan-pgp 60 t)
@end lisp

この @var{時間} パラメーターとそして @var{空転} パラメーターは、奇妙でか
つ素晴らしい方法で一緒に動作します。基本的には、
@var{空転} が @code{nil} の時にはこの関数は @var{時間} 分毎に呼び出され
ます。

もし @var{空転} が @code{t} であれば、この関数は Emacs が何もしていない
時に限り、@var{時間} 分後に呼び出されます。いったん Emacs がずっと空転状
態になった後は、この関数は @var{時間} 分毎に呼び出されます。

@var{空転} が数で @var{時間} も数である場合、この関数は、Emacs の空転状
態が @var{空転} 分続いた時に限り、@var{時間} 分毎に呼び出されます。

@var{空転} が数で @var{時間} が @code{nil} の場合、この関数は、Emacs の
空転状態が @var{空転} 分続く度に一度呼び出されます。

そして @var{時間} が文字列の場合は、@samp{07:31} のような形式でなければ
ならず、この関数は毎日その頃の時間になると一度呼び出されます。もちろん、
@var{空転} パラメーターで動作が変わります。

@vindex gnus-demon-timestep
(ここで ``分'' と言ったとき、それは実際に
は @code{gnus-demon-timestep} 秒のことです。これはディフォルトでは 60 で
す。もしこの変数を変更すると、すべての制御子の計時に影響を与えます。)

というわけで、制御子を追加したければ、@file{~/.gnus.el} ファイルに、以下
のようなものを書くことができます。

@findex gnus-demon-add-handler
@lisp
(gnus-demon-add-handler 'gnus-demon-close-connections 30 t)
@end lisp

@findex gnus-demon-add-nocem
@findex gnus-demon-add-scanmail
@findex gnus-demon-add-rescan
@findex gnus-demon-add-scan-timestamps
@findex gnus-demon-add-disconnection
このための既製関数がいくつか作成されています。@code{gnus-demon-add-nocem},
@code{gnus-demon-add-disconnection},
@code{gnus-demon-add-nntp-close-connection},
@code{gnus-demon-add-scan-timestamps}, @code{gnus-demon-add-rescan},
@code{gnus-demon-add-scanmail} で
す。これらの能力が欲しければ、単にこれらの関数を @file{~/.gnus.el} に入
れて下さい。

@findex gnus-demon-init
@findex gnus-demon-cancel
@vindex gnus-demon-handlers
もし @code{gnus-demon-handlers} で制御子を直接追加した場合には、それを効
かせるために @code{gnus-demon-init} を実行して下さい。すべてのデーモンを
取り消すには、@code{gnus-demon-cancel} 関数を使うことができます。

デーモンの追加は、やりすぎるのはとってもお行儀のよくないことです。すべて
のサーバーからすべてのニュースとメールを二秒毎に調べまわす関数を付け加え
ちゃったりすると、どんな立派なシステムでも間違いなくお払い箱にしてしまい
ます。そう動くんだもん。

@node NoCeM
@section NoCeM
@cindex nocem
@cindex spam

@dfn{Spam} とは、同じ記事を何回も何回も何回も投稿することです。Spam は悪
いことです。Spam は凶悪です。

Spam は通常一日かそこらで、さまざまな反 spam 機関から取り消しされます。
これらの機関は通常一緒に、@dfn{NoCeM} メッセージも送信します。
@dfn{NoCeM} は ``no see-'em'' (彼らを見たくない) と発音され、意味はその
名前の通りです---このメッセージは、罪を犯している記事を、つまり、消して
しまいます。

どうせその記事が取り消しされてしまうのなら、これら NoCeM メッセージは何
に使われるのでしょう? あるサイトでは取り消しメッセージを引き受けず、ある
サイトでは特定の数人からの取り消しメッセージのみしか引き受けません。それ
で、あなたは NoCeM メッセージを使いたくなるかもしれないわけです。これら
は @samp{alt.nocem.misc} ニュースグループで配布されています。

Gnus はこのグループのメッセージを自動的に読み、解釈することができ、これ
で spam を消し去ります。

もちろん、これらをカスタマイズするための変数がいくつかあります。

@table @code
@item gnus-use-nocem
@vindex gnus-use-nocem
この変数を @code{t} に設定することで活動を開始させます。ディフォルトで
は @code{nil} です。

@item gnus-nocem-groups
@vindex gnus-nocem-groups
Gnus はこのグループリストから NoCeM メッセージを探します。ディフォルト値
は @code{("news.lists.filters" "news.admin.net-abuse.bulletins"
"alt.nocem.misc" "news.admin.net-abuse.announce")} です。

@item gnus-nocem-issuers
@vindex gnus-nocem-issuers
NoCeM メッセージを発行する人はたくさんいます。このリストでは、誰のいうこ
とに従いたいかを指定します。ディフォルト値は @code{(("Automoose-1"
"clewis@@ferret.ocunix.on.ca" "cosmo.roadkill" "SpamHippo"
"hweede@@snafu.de")} です。彼らはみんな、立派で高潔な市民です。

このリストに含められる有名な反 spam 家たち
は @uref{http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html} に載って
います。

これらすべての人々の NoCeM メッセージに留意する必要はありません---いうこ
とを聞きたい人だけでいいんです。またその人からの NoCeMメッセージすべてを
受け入れる必要もありません。NoCeM メッセージにはそれぞれ種
別 @dfn{type} ヘッダーがついており、これはそのメッセージの厳密な定義を与
えています (多少は厳密な、程度ね。たいていは少だけど)。良く使われる種別
には、@samp{spam}, @samp{spew}, @samp{mmf}, @samp{binary},
@samp{troll} があります。これを指定するには、リストの中
で @code{(@var{発行者} @var{条件}@dots{})} 要素を使う必要があります。各
条件は文字列 (使いたい種別に合致する正規表現) か、また
は @code{(not @var{文字列})} という形式のリストです。この場合
は @var{文字列} は使いたくない種別に合致する正規表現です。

例えば、Chris Lewis からの NoCeM メッセージで、@samp{troll} メッセージ以
外のすべてを欲しい場合には、

@lisp
("clewis@@ferret.ocunix.on.ca" ".*" (not "troll"))
@end lisp

一方、彼の @samp{spam} と @samp{spew} メッセージ以外は何もしたくなければ、
以下のようにできます。

@lisp
("clewis@@ferret.ocunix.on.ca" (not ".*") "spew" "spam")
@end lisp

この指定は左から右に適用されます。

@item gnus-nocem-verifyer
@vindex gnus-nocem-verifyer
@findex pgg-verify
これは NoCeM 発行者が本人であることを検証する関数でなくてはなりません。
ディフォルト値は @code{pgg-verify} で、これは検証に成功したら
非-@code{nil} を返し、そうでなければ (NoCeM メッセージが署名されていない
場合を含みます) @code{nil} を返します。もしこれが非常に遅くて、検証結果
を気にしない (これはたぶん危険です) のであれば、この変数を @code{nil} に
することができます。

以前、ディフォルトは Mailcrypt の関数である @code{mc-verify} でした。ま
だそれを使うことができますが、PGP の公開鍵を GnuPG の鍵束に加えることを
厭わなければ、GnuPG とともに動作するディフォルトの関数に変えることができ
ます。

@item gnus-nocem-directory
@vindex gnus-nocem-directory
これは Gnus が NoCeM キャッシュファイルを保存する場所です。ディフォルト
値は @file{~/News/NoCeM/} です。

@item gnus-nocem-expiry-wait
@vindex gnus-nocem-expiry-wait
古い NoCeM 項目をキャッシュから消すまでの日数。ディフォルト値は 15 です。
これを短くするほど Gnus は速くなりますが、古い spam を見ることになってし
まうかもしれません。

@item gnus-nocem-check-from
@vindex gnus-nocem-check-from
非-@code{nil} では、記事のボディーにある発行人の正当性を調べます。そうで
ない場合は、著者が正しい発行人でなくても気にせずに記事を取り込みますが、
もしあなたが正しい発行人を見分けられるならば、そうした方がとても速くなる
でしょう。

@item gnus-nocem-check-article-limit
@vindex gnus-nocem-check-article-limit
非-@code{nil} で、すべての NoCeM グループにおけるチェックする記事の最大
数を指定します。NoCeM グループは巨大になることがあり、そうなると処理がと
ても遅くなります。
@end table

NoCeM を使うと、もしかするとメモリ喰いになるかもしれません。あなたがたく
さんの生きたグループ (つまり購読あるいは非購読グループ) を持っているのな
ら、Emacs プロセスは大きくなってしまうでしょう。もしこれが問題であれば、
非購読のグループを全部 (あるいはその多くを) 消し去ってしまった方が良いで
す (@pxref{Subscription Commands})。

@node Undo
@section やり直し
@cindex undo

実行したことのやり直しができると、とても便利です。普通の Emacs バッファー
では、これは十分簡単です---単に @code{undo} ボタンを押すだけです。しか
し Gnus のバッファーでは、これは簡単ではありません。

Gnus がバッファー内に表示しているものは、Gnus にとってはまったく何の価値
もありません---これはみんな、利用者に奇麗に見えるようにデザインされてい
るただのデータなのです。@kbd{C-k} でグループバッファーからグループを消去
するのは、その行は消え去りますが、それは実際の動作---問題のグループ
を Gnus の内部構造体から削除すること、の単なる副作用でしかありません。こ
れらのやり直しは、通常の Emacs の @code{undo} 関数では行なうことができま
せん。

Gnus は、利用者が何をするかを憶えておき、その利用者の動作の逆を行なう動
作を提供することによって、これを何とか救済しようとします。そして利用者
が @code{undo} キーを押したとき、Gnus はその一つ手前の動作あるいは動作群
の逆のコードを実行します。しかし、すべての動作が簡単に可逆であるわけでは
ないので、Gnus は現在、やり直し可能なキー関数は僅かしか提供していません。
これらは、グループの削除、グループの貼り付け、グループの既読記事のリスト
の変更、それだけなんです。将来はもっと関数が追加されるかもしれませんが、
関数の追加はそれぞれ保存するべきデータを増やすことになるので、Gnus は決
して完全やり直し可能にはならないでしょう。

@findex gnus-undo-mode
@vindex gnus-use-undo
@findex gnus-undo
やり直し機能は @code{gnus-undo-mode} マイナーモードによって提供されます。
これは @code{gnus-use-undo} が @code{nil} 以外であれば使用され、これがディ
フォルトです。@kbd{C-M-_} キーが @code{gnus-undo} 命令を実行します。これ
は通常の Emacs の @code{undo} 命令にいくぶん似ているはずです。

@node Predicate Specifiers
@section 述語の設定
@cindex predicate specifiers

いくつかの Gnus の変数
は @dfn{述語指示子} (@dfn{predicate specifiers}) です。これは述語の仕様
に融通を効かせることができる特別な形式です。

これらの指示子は関数によるリスト、シンボルまたはリストです。

これは例です:

@lisp
(or gnus-article-unseen-p
    gnus-article-unread-p)
@end lisp

利用できるシンボルは @code{or}、@code{and} および @code{not} です。関数
はすべて一つのパラメーターを受け取ります。

@findex gnus-make-predicate
内部的に、Gnus は呼ぶことができる関数を作るために、これらの指示子につい
て @code{gnus-make-predicate} を使います。この関数へのこの入力パラメーター
は、述語指示子のすべての関数に渡されます。

@node Moderation
@section 司会役
@cindex moderation

もしあなたが司会者 (モデレーター) ならば、@file{gnus-mdrtn.el} パッケー
ジを使うことができます。これは標準 Gnus パッケージには含まれません。
@samp{larsi@@gnus.org} に、どのグループの司会を行なうのかを述べたメール
を書いて下さい。そうすればコピーを手に入れられます。

司会者用パッケージは概略バッファーのマイナーモードとして実装されています。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-moderate)
@end lisp

をあなたの @file{~/.gnus.el} ファイルに入れて下さい。

あなたが @samp{rec.zoofle} の司会者だとすると、これは以下のように動作す
るようになっています。

@enumerate
@item
@samp{Newsgroups:.*rec.zoofle} に合致する受信メールを分離します。これは
投稿されようとしている記事をすべてあるメールグループ---例え
ば @samp{nnml:rec.zoofle} に入れます。

@item
あなたは時折このグループに入り、@kbd{e} (edit-and-post) あるい
は @kbd{s} (just send unedited) 命令を使って記事を投稿します。

@item
@samp{rec.zoofle} ニュースグループを読んでいる途中で、もしあなたが承認し
ていない記事をたまたま見つけたとしたら、@kbd{c} 命令で取り消しできます。
@end enumerate

二つのグループで司会者モードを使うとすれば、こうなります。

@lisp
(setq gnus-moderated-list
      "^nnml:rec.zoofle$\\|^rec.zoofle$")
@end lisp

@node Fetching a Group
@section グループを取得する
@cindex fetching a group

@findex gnus-fetch-group
時々、“このグループを読みたいのであって、Gnus が起動しているかどうかを
気にしたくない。”ということができれば便利なことがあります。これは、利用
者よりもプログラムのコードを書く人に便利な機能ですが、どちらにしろ、
@code{gnus-fetch-group} コマンドはこの機能を提供します。そのコマンドは、
グループの名前を引数としてとります。

@node Image Enhancements
@section 画像の拡張

XEmacs それに Emacs 21@footnote{MS ウィンドウズの Emacs 21 はまだ画像を
サポートしていません。} は絵やその他のものを表示することができるので、
Gnus はこれを利用することにします。

@menu
* X-Face::                      ファンキーでちっちゃな白黒の絵を表示する
* Face::                        よりファンキーでちっちゃなカラーの絵を表示する
* Smileys::                     表示されるべく生まれた幸せそうな顔を表示する方法
* Picons::                      あなたが読んでいるものの絵を表示する方法
* XVarious::                    その他の XEmacs で Gnus な変数
@end menu

@node X-Face
@subsection X-Face
@cindex x-face

@code{X-Face} ヘッダーは、メッセージの著者を表わすことになっている 48×
48 画素の白黒 (1 bit の深さ) の絵を描きます。これは進化し続けるあまたの
メールとニュースリーダーによってサポートされるでしょう。

@cindex x-face
@findex gnus-article-display-x-face
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
@iftex
@iflatex
\include{xface}
@end iflatex
@end iftex
@c @anchor{X-Face}

@code{X-Face} ヘッダーのデコードには、Emacs が @samp{compface} をサポー
ト (XEmacs のほとんどがサポート) しているか、あなたのシステム
に @samp{compface} がインストールされている必要があります。もしどちらか
が真ならば、Gnus はディフォルトで @code{X-Face} ヘッダーを表示します。

これを制御するのは変数 @code{gnus-article-x-face-command} です。この変数
が文字列ならば、この文字列がサブシェルで実行されます。関数ならば、この関
数が顔を引数として呼ばれます。も
し @code{gnus-article-x-face-too-ugly} (これは正規表現で
す) が @code{From} 欄に合致すれば、顔は表示されません。

Emacs 20 でのディフォルトの動作は @code{display} プログラ
ム @footnote{@code{display} は ImageMagick パッケージに含まれています。
@code{uncompface} と @code{icontopbm} の両プログラムについては、
`compface' や GNU/Linux システムにおける `faces-xface' のようなパッケー
ジを探して下さい。} をフォークして見ようとします。

XEmacs か静止画をサポートしている Emacs 21+ でのディフォルトの動作
は @code{From} 欄の前に顔を表示することです。(XEmacs が X-Face 機能付き
でコンパイルされていると良いでしょう---それは表示を少し早くします。もし
根本的 X-Face 機能がないのであれば、Gnus は @code{pbmplus} やその仲間の
外部プログラムを使って @code{X-Face} 欄を変換しようと試みます @footnote{
GNU/Linux システムでは @code{netpbm}、@code{libgr-progs} また
は @code{compface} のような名前のパッケージを探して下さい。}。)

(注: 変数/関数名には @code{xface} ではなく @code{x-face} が使われます。)

フェースと変数:

@table @code
@item gnus-x-face
@vindex gnus-x-face
X-Face を表示するためのフェース。このフェースの色が表示される X-Face の
前景色と背景色として使われます。ディフォルトの色は白と黒です。

@item gnus-face-properties-alist
@vindex gnus-face-properties-alist
Face (@pxref{Face}) と X-Face 画像に適用される、画像の形式とプロパティの
連想リストです。ディフォルト値は Emacs 用の @code{((pbm . (:face
gnus-x-face)) (png . nil))} または XEmacs 用の @code{((xface . (:face
gnus-x-face)))} です。例を挙げましょう:

@lisp
;; From ヘッダーにおける Face と X-Face の高さを指定します。
(setq gnus-face-properties-alist
      '((pbm . (:face gnus-x-face :ascent 80))
        (png . (:ascent 80))))

;; Face と X-Face を凹んだボタンのように表示します。
(setq gnus-face-properties-alist
      '((pbm . (:face gnus-x-face :relief -2))
        (png . (:relief -2))))
@end lisp

いろいろな画像の形式で利用可能なプロパティについて
は @xref{Image Descriptors, ,Image Descriptors, elisp, The GNU Emacs
Lisp Reference Manual}, を参照して下さい。今のところ Emacs で
は @code{pbm} が X-Face 画像に使われ、 @code{png} が Face 画像に使われま
す。XEmacs では、それが @samp{libcompface} ライブラリとともに構築されて
いれば、@code{xface} 画像形式に @code{:face} プロパティだけが効果を及ぼ
します。
@end table

Gnus は、外に出すメッセージに X-Face ヘッダーを簡単に挿入するための、便
利な関数と変数を少しばかり提供します。

@findex gnus-random-x-face
@vindex gnus-convert-pbm-to-x-face-command
@vindex gnus-x-face-directory
@code{gnus-random-x-face} は @code{gnus-x-face-directory} にあるすべて
の @samp{pbm} をくまなく探してランダムに一つを選び取り、シェルコマン
ド @code{gnus-convert-pbm-to-x-face-command} を使ってそれを X-Face の形
式に変換します。@samp{pbm} ファイルは 48×48 画素の大きさでなければなり
ません。それは X-Face ヘッダーのデータを文字列で返します。

@findex gnus-insert-random-x-face-header
@code{gnus-insert-random-x-face-header} は @code{gnus-random-x-face} を
呼んで、ランダムに生成されたデータによる X-Face ヘッダーを挿入します。

@findex gnus-x-face-from-file
@vindex gnus-convert-image-to-x-face-command
@code{gnus-x-face-from-file} はパラメーターとして GIF ファイルを受け取り、
シェルコマンド @code{gnus-convert-image-to-x-face-command} を使ってその
ファイルを X-Face の形式に変換します。

一番目は一般的に使うであろう関数です。以下のようなもの
を @file{~/.gnus.el} ファイルに書いて下さい:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . gnus-random-x-face))))
@end lisp

最後の関数を使うのは、このようになるでしょう:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . (lambda ()
                                (gnus-x-face-from-file
                                 "~/My-face.gif"))))))
@end lisp

@node Face
@subsection Face
@cindex face

@c #### FIXME: faces and x-faces'implementations should really be harmonized.

@code{Face} ヘッダーは、本質的によりファンキーな @code{X-Face} の変形で
す。それらは、メッセージを書いた人を象徴していることが期待される、
48×48 画素のカラー画像を描きます。

@cindex face
@findex gnus-article-display-face
@code{Face} ヘッダーの内容は、base64 でエンコードされた PNG の画像でなけ
ればなりません。正確な仕様について、
@uref{http://quimby.gnus.org/circus/face/} を参照して下さい。

変数 @code{gnus-face-properties-alist} は表示される Face 画像の外観に影
響します。@xref{X-Face}.

送信するメッセージに簡単に Face ヘッダーを挿入できるようにするために、
Gnus は 2〜3 の関数と変数を提供します。

@findex gnus-convert-png-to-face
@code{gnus-convert-png-to-face} は 726-byte 以下の 48×48 の PNG の画像
を読み込んで、それを Face に変換します。

@findex gnus-face-from-file
@vindex gnus-convert-image-to-face-command
@code{gnus-face-from-file} は JPEG のファイル名をパラメーターとして受け
取り、シェルコマンド @code{gnus-convert-image-to-face-command} を使って
そのファイルを Face フォーマットに変換します。

この関数の代表的な使い方を挙げておきましょう。以下のようなもの
を @file{~/.gnus.el} ファイルに入れて下さい:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(Face . (lambda ()
                              (gnus-face-from-file "~/face.jpg"))))))
@end lisp

@node Smileys
@subsection スマイリー
@cindex smileys

@iftex
@iflatex
\gnusfig{-3cm}{0.5cm}{\epsfig{figure=ps/BigFace,height=20cm}}
\input{smiley}
@end iflatex
@end iftex

スマイリー @dfn{smiley} は Gnus とは別のパッケージですが、スマイリーを使っ
ているパッケージは現在 Gnus だけなので、ここで説明します。

ひとことで言えば---Gnus でスマイリーを使うには、以下
を @file{~/.gnus.el} ファイルに書いて下さい。

@lisp
(setq gnus-treat-display-smileys t)
@end lisp

スマイリーは、文字の顔マーク---@samp{:-)}, @samp{8-)}, @samp{:-(} などと
いったもの---を絵に対応させ、文字の顔マークの代わりにその絵を表示します。
この変換は文字に合致する正規表現とそれのファイル名への対応のリストで制御
されます。

@vindex smiley-regexp-alist
使われる連想リストは、変数 @code{smiley-regexp-alist} で設定します。各要
素の最初の項目は合致させたい正規表現で、二番目の要素は絵で置き換えたいグ
ループに合致する正規表現、そして三番目の要素は表示させたいファイルの名前
です。

以下の変数は、スマイリーがこれらのファイルを探す場所をカスタマイズします:

@table @code
@item smiley-data-directory
@vindex smiley-data-directory
スマイリーが顔ファイルを探す場所。

@item gnus-smiley-file-types
@vindex gnus-smiley-file-types
スマイリーのファイル名として試してみる拡張子のリストです。
@end table

@node Picons
@subsection Picons

@iftex
@iflatex
\include{picons}
@end iflatex
@end iftex

それで…、あなたはこのニュースリーダーをさらにもっと遅くしたいってわけだ
ね! これはそうするのにぴったりな方法です。さらにこれは、あなたがニュース
を読んでいるんだということを、あなたの肩越しに見つめている人に印象づける
ための素晴らしい方法でもあります。

Picon とはなんでしょう? Picons ウェブサイトから直接引用しましょう。

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

@quotation
@dfn{Picon} とは、``個人アイコン (personal icons)'' の略です。これは、ネッ
ト上の利用者やドメインを表現するのに使われるための小さな画像で、データベー
スを持たせて、ある電子メールアドレスがあったら、それに適切な画像を見つけ
られるようにしておくものです。利用者とドメイン以外にも、Usenet ニュース
グループや天気予報のためのpicon データベースがあります。picon は白黒
の @code{XBM} 形式でもカラーの @code{XPM} 形式でも @code{GIF} 形式でも構
いません。
@end quotation

@vindex gnus-picon-databases
Picon データベースの入手とインストールの手順については、ウェブブラウザー
で @uref{http://www.cs.indiana.edu/picons/ftp/index.html} を訪ねてみて下
さい。

もし Debian GNU/Linux を使っているのなら、@samp{apt-get install
picons.*} と言えば Gnus が見つけることができる picon がインストールされ
ます。

Picon の表示ができるようにするためには、picon データベースがあるディレク
トリーが、ただ単に @code{gnus-picon-databases} に設定されているようにし
て下さい。

@vindex gnus-picon-style
変数 @code{gnus-picon-style} は picon をどのように表示するかを制御します。
@code{inline} だったらテキスト形式の表現が置き換えられます。
@code{right} だったら、テキスト形式の表現の右側に picon が加えられます。

ものごとの所在を管理するために、以下の変数を設けています。

@table @code
@item gnus-picon-databases
@vindex gnus-picon-databases
Picon データベースの場所です。これは @file{news}, @file{domains},
@file{users} (などなど) のサブディレクトリーが含まれているディレクトリー
のリストです。@code{("/usr/lib/picon" "/usr/local/faces")} がディフォル
トです。

@item gnus-picon-news-directories
@vindex gnus-picon-news-directories
@code{gnus-picon-databases} からニュースグループ用のフェースを探すための
サブディレクトリーのリストです。ディフォルトは @code{("news")} です。

@item gnus-picon-user-directories
@vindex gnus-picon-user-directories
@code{gnus-picon-databases} から利用者のフェースを探すためのサブディレク
トリーのリストです。@code{("local" "users" "usenix" "misc")} がディフォ
ルトです。

@item gnus-picon-domain-directories
@vindex gnus-picon-domain-directories
@code{gnus-picon-databases} からドメイン名のフェースを探すためのサブディ
レクトリーのリストです。ディフォルトは @code{("domains")} です。このリス
トに @samp{"unknown"} を追加しておきたくなる人もいるでしょう。

@item gnus-picon-file-types
@vindex gnus-picon-file-types
Picon のファイル名として試してみる拡張子の順番リストです。ディフォルトは、
@code{("xpm" "gif" "xbm")} から Emacs に組み込まれていないものを除外した
ものです。
@end table

@node XVarious
@subsection さまざまな XEmacs 変数

@table @code
@item gnus-xmas-glyph-directory
@vindex gnus-xmas-glyph-directory
これは Gnus が絵を探す場所です。Gnus は通常このディレクトリーを自動検出
しますが、もし標準的でないディレクトリー構造を持っている場合は、これを手
動で設定することができます。

@item gnus-xmas-logo-color-alist
@vindex gnus-xmas-logo-color-alist
これは連想リストで、キーは種別シンボル、値はタイトルページの絵文字の前面
色と背景色です。

@item gnus-xmas-logo-color-style
@vindex gnus-xmas-logo-color-style
これは前記の連想リストで色を検索するのに使われるキーです。有効な値に
は @code{flame}, @code{pine}, @code{moss}, @code{irish}, @code{sky},
@code{tin}, @code{velvet}, @code{grape}, @code{labia}, @code{berry},
@code{neutral}, @code{september} があります。

@item gnus-xmas-modeline-glyph
@vindex gnus-xmas-modeline-glyph
すべての Gnus モード行で表示される絵文字。これはディフォルトではちいさな
ヌー (gnu) の頭です。
@end table

@subsubsection ツールバー

@table @code
@item gnus-use-toolbar
@vindex gnus-use-toolbar
@code{nil} ならばツールバーを表示しません。@code{nil} 以外の場合は、
@code{default-toolbar}, @code{top-toolbar}, @code{bottom-toolbar},
@code{right-toolbar}, @code{left-toolbar} のどれかでなくてはなりません。

@item gnus-group-toolbar
@vindex gnus-group-toolbar
グループバッファー内のツールバーです。

@item gnus-summary-toolbar
@vindex gnus-summary-toolbar
概略バッファー内のツールバーです。

@item gnus-summary-mail-toolbar
@vindex gnus-summary-mail-toolbar
メールグループの概略バッファー内のツールバーです。
@end table

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

@node Fuzzy Matching
@section ファジーな一致
@cindex fuzzy matching

Gnus は、スコア付け、スレッドの形成、スレッド比較などを行なうときに、
@code{Subject} 行のファジーな一致 @dfn{fuzzy matching} 方法を提供してい
ます。

正規表現一致とは違って、ファジーな一致はとってもファジーです。あまりにも
ファジーすぎて、何がファジー @dfn{fuzziness} であるかという定義さえ無い
し、実装も何度も変更されています。

基本的には、これは比較の前に行から邪魔物を取り除こうとします。
@samp{Re: } や挿入句の印や空白文字等々は文字列から除去され、その結果を比
較します。これはほとんどの場合妥当な結果を出します---たとえニュースリー
ダーの仮面をかぶった文字列切り刻み機で生成された文字列が差し出されても、
です。

@node Thwarting Email Spam
@section spam メールの裏をかく
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

ここ最近の USENET では、宣伝のハゲタカどもが、彼らの詐欺や製品を押し付け
るための電子メールアドレスを探そうとして、気違いのようにニュース上をうろ
ついて grep しまくっています。これに対する反動として、多くの人々
が @code{From} 行に無意味なアドレスを入れはじめるようになってしまいまし
た。これは非生産的なことだと私は思います---あなたが書いたことに対する返
信として正当なメールを送ることを面倒にさせ、また誰が書いたものなのかを分
かりづらくします。こんな書き換えは結局は、押し付け宣伝メールそれ自身より
も大きな脅威となるかもしれません。

私にとっての spam メールの最大の問題は、嘘の口実で入ってくるからです。私
が @kbd{g} を押したとすると、Gnus は十通の新着メールがありますと陽気に私
に教えてくれます。私は ``おおっ、わーい! 僕って幸せ!'' と言ってメールグ
ループを選択します。しかしそこには、二つのネズミ講と、七つの広
告 (``最新! 奇跡の増毛トニック、ふさふさでつやつやの髪を、あなたのつま先
まで!'') と、悔い改め神を信じよ、という一つのメールがあるだけなのです。

これは不愉快です。あなたがそれに関してできることがあります。

@menu
* The problem of spam::         背景、そして解決
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する
* Filtering Spam Using The Spam ELisp Package::
* Filtering Spam Using Statistics with spam-stat::
@end menu

@node The problem of spam
@subsection Spam の問題
@cindex email spam
@cindex spam filtering approaches
@cindex filtering approaches, spam
@cindex UCE
@cindex unsolicited commercial email

初めに spam の背景から。

あなたが電子メールを使っているならば、spam (専門用語としては Unsolicited
Commercial E-mail---望まれない商用電子メール---の頭文
字 @acronym{UCE}) のことはよく知っているでしょう。簡単に言えばそれは紙の
メールに比べて電子メールの配送がとても安くつくために存在し、非常に小さな
割合の人々が UCE に応答するだけで広告主に利益をもたらすのです。皮肉なこ
とに最も一般的な spam の一つは、さらに spam を助長するための電子メールア
ドレスのデータベースを提供します。Spam の送信者はふつ
う @emph{spammers} と呼ばれますが、@emph{vermin}、@emph{scum}、
@emph{sociopaths} および @emph{morons} のような用語もよく使われています。

Spam は種々さまざまな出どころからやって来ます。有用なメッセージを捨てず
にすべての spam を単に始末することは不可能です。良い例は TMDA (訳注: 送
信する度にユニークなアドレスを使う) システムで、それはあなたが知らない送
信者に、彼らの電子メールが届く前に彼らが正当な送信者であることの確認を求
めます。正当な出どころからの電子メールが TMDA システムによってそれらの出
どころが確認できない、または行なわれない場合は捨てられてしまうかもしれな
いというマイナス面は、TMDA の技術的な側面に立ち入らなくても明白です。も
う一つの TMDA の問題は、電子メールの配送と処理への基本的な理解を利用者に
求めていることです。

Spam の除去 (filtering) への最も単純な取り組みは、メールサーバーで、ある
いは入ってきたメールを分類するときに濾過すること (filtering) です。毎
日 @samp{random-address@@vmadmin.com} から 200通の spam メッセージを受け
取るのならば、@samp{vmadmin.com} を阻止すればよろしい。
@samp{バイアグラ} に関するメッセージを 200通受け取るのならば、
@samp{バイアグラ} を含むすべてのメッセージを捨ててしまえばよろしい。例え
ばブルガリアからたくさんの spam がやって来るのならば、ブルガリアの IP か
ら来るすべてのメールを濾過すればよろしい。

これは、残念ながら正当な電子メールを捨てるためのすぐれた方法です。あなた
に接触しようとする国 (ブルガリア、ノルウェー、ナイジェリア、中国、等) 全
体、または大陸 (アジア、アフリカ、ヨーロッパ、等) さえも封じ込めてしまう
危険は明らかなので、あなたに選択権があるのならば、そんなことはしないで下
さい。

もう一つの例として、とても示唆に富んで有益な RISKS ダイジェストは、それ
が spam メッセージと共通の語を @strong{含んで} いるために、熱心すぎるメー
ル濾過器によって阻止されてしまいます。それでもなお孤立した環境では、注意
深く使うことによって直接の濾過は有益になり得ます。

もう一つの電子メール濾過への取り組みは分散型 spam 処理で、DCC (訳
注: Distributed Checksum
Clearinghouse---@uref{http://www.rhyolite.com/anti-spam/dcc/}) がそのよ
うなシステムを導入しています。本質的には、世界中の @var{N} 個のシステム
が、ガーナ、エストニアあるいはカリフォルニアにあるマシ
ン @var{X} が spam 電子メールを送出していることを認めたら、それ
ら @var{N} 個のシステムは @var{X} または @var{X} からやって来た spam メー
ルをデータベースに記入します。Spam 検出の基準は変わります。それは送られ
たメッセージの数やメッセージの内容などであるかもしれません。メッセージ
が spam かどうかを分散処理システムの利用者が知りたい場合、彼はそれら
の @var{N} 個のシステムのうちの一つを調べます。

分散型 spam 処理は同時に多くのメッセージを送る spammers と非常によく戦っ
てくれますが、それは利用者がかなり複雑なチェックを設定することを求めます。
商用と、フリーな分散型 spam 処理システムがあります。分散型 spam 処理は、
それ自体の危険もはらんでいます。例えば、正当な送信者が spam を送ったかど
で非難され、彼らのウェブサイトやメーリングリストがその事件のために暫くの
間閉鎖されてしまう、とか。

Spam 濾過への統計的な取り組みもまた普及しています。それは過去の spam メッ
セージの統計分析に基づいています。通常その分析は、おそらく単語の対か三つ
の単語の組合せの合成による、単語の出現頻度の単純な計数です。Spam の統計
分析はほとんどの場合にとてもよく働くのですが、時として正当な電子メール
を spam として分類してしまうことがあります。分析には時間がかかります。す
べてのメッセージを分析しなければなりません。そして利用者は spam を分析す
るためのデータベースを用意しなければなりません。サーバーでの統計分析は人
気を得ています。これには、利用者は単にメールを読めば良いという長所と、し
かしサーバーにそれが過ってメールを分類したことを伝えるのが困難だという短
所があります。

余人の言を待たずとも、spam との戦いは楽ではありません。ママからの電子メー
ルとバイアグラ広告を区別する魔法のスイッチはありません。人々は
非-spam と spam を区別するのに手を焼いているというのに。それは、
spammers が懸命にそれらをママだと思わせようとしているのが本質だからです。
Spamming は、世界が彼らに恩義があると思っている人々の一団からの、腹立た
しく、無責任で、ばかげた行為です。以下の各項が spam なる疫病との戦いの助
けになることを望みます。

@node Anti-Spam Basics
@subsection Spam 退治の基礎
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

Spam に対処する一つの方法は、Gnus にすべての spam を @samp{spam} メール
グループに分離させてしまうことです (@pxref{Splitting Mail})。

最初に、あなたに到達性のある正しいメールアドレスを一つ選び、それをすべて
のあなたのニュース記事の @code{From} ヘッダーに入れます。(ここで
は @samp{larsi@@trym.ifi.uio.no} を選びましたが、
@samp{larsi+usenet@@ifi.uio.no} 形式のたくさんのアドレスの方が良い選択で
す。あなたのサイトの sendmail の設定がメールアドレスのローカル部としてど
んなキーワードを受け付けるかは、あなたのサイトのシステム管理者に聞いて下
さい。)

@lisp
(setq message-default-news-headers
      "From: Lars Magne Ingebrigtsen <larsi@@trym.ifi.uio.no>\n")
@end lisp

そして @code{nnmail-split-fancy} に以下の分離規則を入れま
す (@pxref{Fancy Mail Splitting})。

@lisp
(...
 (to "larsi@@trym.ifi.uio.no"
     (| ("subject" "re:.*" "misc")
        ("references" ".*@@.*" "misc")
        "spam"))
 ...)
@end lisp

この意味は、このアドレスに届いたすべてのメールをまず疑いますが、
@samp{Re:} で始まる @code{Subject} がついているか、@code{References} ヘッ
ダーがついていればおそらく OK だろう、ということです。残りはすべ
て @samp{spam} グループに行きます (このアイデアはおそらく Tim Pierce 氏
によるものです)。

これに加えて、多くのメール spam 屋は、あなたのところの @acronym{SMTP} サー
バーと直接話し、@code{To} ヘッダーにあなたのメールアドレスが明示されない
ようにします。なんでそんなことをするのかはわかりませんが---おそらく私た
ちの裏をかく機構の裏をかくためかな? どちらにしても、対処は簡単なことで
す---あなた宛てでないものを全部 @samp{spam} グループにいれるだけです。こ
れはお好み分離規則の最後にこんな風に入れることでできます。

@lisp
(
 ...
 (to "larsi" "misc")
 "spam")
@end lisp

私の経験では、これで事実上すべてが正しいグループに分類されます。まあ、そ
れでもときどき @samp{spam} グループをチェックして、正しいメールがあるか
チェックしなくてはいけませんけどね。もしあなたは自分が良いネットワーク市
民であると思っているなら、それぞれの押し付け宣伝メールの関係当局に苦情を
送り付けることさえもできます---暇なときにでもね。

これで私のところでは動いています。これでみんなは簡単な方法で私に連絡を取
ることができ (普通に @kbd{r} を押すだけでできる)、私は spam に煩わされる
ことはまったくありません。得々状態です。私の意見としては、@code{From} ヘッ
ダーを偽造して存在しないドメインに送らせるのはキタナイです。

この手法には注意して下さい。Spammers はそれに気付いています。

@node SpamAssassin
@subsection SpamAssassin, Vipul's Razor, DCC, etc
@cindex SpamAssassin
@cindex Vipul's Razor
@cindex DCC

Spam を避けるための前項のヒントが十分だった日々は過ぎ去りました。今では
受け取ったたくさんの spam を減らすための多くの道具があります。この項は新
旧置き換えによってすぐに時代遅れになってしまうでしょうが、幸いなことにほ
とんどの道具は類似のインターフェースを持っています。この項は例とし
て SpamAssassin を使っていますが、他のほとんどの道具にも簡単に適合するは
ずです。

この項は @code{spam.el} パッケージとは関係無いことに注意して下さい。それ
は次の項で論じられます。すべての @code{spam.el} の機能に関心が無いのなら
ば、これらの単純なレシピで間に合わせることができます。

もしあなたが使う道具がメールサーバーにインストールされていないならば、あ
なた自身がそれを呼び出す必要があります。以下に @code{:postscript} メール
ソース指示子 (@pxref{Mail Source Specifiers}) を使う場合の考え方を示しま
す。

@lisp
(setq mail-sources
      '((file :prescript "formail -bs spamassassin < /var/mail/%u")
        (pop :user "jrl"
             :server "pophost"
             :postscript
             "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))
@end lisp

いったん、メールを受けるスプールをどうにかして処理する、例えば@: メール
に spam であることを表示するヘッダーを含める、ようにすれば、それをふるい
落とす準備は完了です。使うのは普通の分割方式 (@pxref{Splitting Mail}) で
す:

@lisp
(setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                             ...))
@end lisp

または特級分割方式 (@pxref{Fancy Mail Splitting}) です:

@lisp
(setq nnmail-split-methods 'nnmail-split-fancy
      nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                             ...))
@end lisp

いくらかの人たちは @code{:prescript} を使ってメールをいろんなプログラム
にパイプすることを嫌うかもしれません (もし何かのプログラムにバグがあった
ら、すべてのメールを失ってしまうかもしれません)。あなたがそれらの一人な
らば、別の解は分割するときに外部の道具を呼ぶことです。特級分割方式の例で
す:

@lisp
(setq nnmail-split-fancy '(| (: kevin-spamassassin)
                             ...))
(defun kevin-spamassassin ()
  (save-excursion
    (widen)
    (if (eq 1 (call-process-region (point-min) (point-max)
                                   "spamc" nil nil nil "-c"))
        "spam")))
@end lisp

さらに nnimap バックエンドの場合、ディフォルトでは記事のボディーがダウン
ロードされないことに注意して下さい。それをするためには、
@code{nnimap-split-download-body} を @code{t} に設定する必要がありま
す (@pxref{Splitting in IMAP})。

以上がこれに関することです。いくつかの spam はどうしても素通りしてしまう
ので、spam を読むはめになったときに呼ぶための気の利いた関数が欲しいでしょ
う。これがその気の利いた関数です:

@lisp
 (defun my-gnus-raze-spam ()
  "Submit SPAM to Vipul's Razor, then mark it as expirable."
  (interactive)
  (gnus-summary-show-raw-article)
  (gnus-summary-save-in-pipe "razor-report -f -d")
  (gnus-summary-mark-as-expirable 1))
@end lisp

@node Hashcash
@subsection Hashcash
@cindex hashcash

Spam と戦うための新しい技法は、いくばくかの負担にはなるが明らかに独特な
ことを、送信するメッセージに対して送信者が行なうことを求めることです。こ
れはインターネット標準の一部ではないので、世界中のすべての人がこの技法を
使うことは当てにできないという明らかな欠点がありますが、小規模な共同体で
は役に立つでしょう。

前項の道具類が実際にうまく働いたとしても、それらは新しい形式の spam が現
れるたびにしょっちゅう更新かつ整備されることによってのみ動作します。この
ことは、小さなパーセンテージの spam がいつも素通りしてしまうことを意味し
ます。それはまた、どこかでだれかがそれらの道具を更新するために、たくさん
の spam を読まなければならないことをも意味します。Hashcash はそれを回避
しますが、代わりにあなたが電子メールで連絡するすべての人たちに、なるべく
その仕組みを使ってもらう必要があります。あなたは実用 (pragmatic) と教
条 (dogmatic) の二つの取り組みを考えることができます。それらの取り組みに
は利点もあれば不利な点もありますが、それは世の中では普通のことで、それら
を連係させたものが他のばらばらなものより強力なのです。

@cindex X-Hashcash
「いくばくかの負担」とは CPU 時間を消費することで、具体的には一定数のビッ
トまでハッシュの衝突 (hash collision) を計算することです。その結果として
の hashcash クッキーは @samp{X-Hashcash:} ヘッダーに挿入されます。もっと
詳しいこと、そしてこの機能を使うためにインストールする必要がある外部アプ
リケーションの @code{hashcash} について
は @uref{http://www.hashcash.org/} を参照して下さい。さらなる情報
が @uref{http://www.camram.org/} で見つかるでしょう。

送信するメッセージのそれぞれについて hashcash を生成させようと思うなら、
以下のように @code{message-generate-hashcash} (@pxref{Mail Headers,
,メールヘッダー, message-ja, The Message Manual}) をカスタマイズして下さ
い:

@lisp
(setq message-generate-hashcash t)
@end lisp

いくつかの追加の変数の設定もしなければなりません:

@table @code
@item hashcash-default-payment
@vindex hashcash-default-payment
この変数はハッシュの衝突を成すディフォルトのビット数を示します。規定値
は 20 です。提唱されている有効な値は 17 から 29 までの数です。

@item hashcash-payment-alist
@vindex hashcash-payment-alist
何人かの受取人は、あなたにディフォルトより多くの CPU 時間を費やすことを
要求するかもしれません。この変数は @samp{(@var{addr} @var{amount})} の形
式の要素のリストで、@var{addr} は受取人 (メールアドレスかニュースグルー
プ)、@var{amount} は必要とされる衝突のビット数です。これはま
た @samp{(@var{addr} @var{string} @var{amount})} の要素を持つことも可能
で、@var{string} は文字列 (通常はメールアドレスかニュースグループ名) と
して使われます。

@item hashcash-path
@vindex hashcash-path
@code{hashcash} バイナリがインストールされている場所。この変数
は @code{executable-find} によって自動的に設定されるはずですが、それ
が @code{nil} だった (ありがちなのは @code{hashcash} バイナリが実
行 path 中に無い) 場合は、hashcash payments をチェックするときに警告され、
hashcash payments を生成するときはエラーになるでしょう。
@end table

Gnus は hashcash クッキーを認証することができますが、手でカスタマイズし
たメール濾過スクリプトで行なうこともできます。メッセージ中の hashcash クッ
キーを認証するには、@code{hashcash.el} ライブラリ
の @code{mail-check-payment} 関数を使って下さい。入ってきたメール
の hashcash クッキーを確認し、それによってメールを濾過するために、
@code{spam-use-hashcash} バックエンドで @code{spam.el} を使うこともでき
ます (@pxref{Anti-spam Hashcash Payments})。

@node Filtering Spam Using The Spam ELisp Package
@subsection Spam ELisp パッケージを使った Spam の濾過
@cindex spam filtering
@cindex spam

@code{spam.el} の真の目的は spam 検出と濾過のための官制センター
を Gnus の中に持つことです。そのために @code{spam.el} は二つのことを行な
います: 新しいメールを濾過し、spam または ham として知られるメールを分析
することです。@dfn{Ham} は @code{spam.el} のいたる所で spam ではないメッ
セージを示すために使う名前です。

@code{spam.el} シーケンスのイベントの項をちゃんと読みましょう。
@ref{Spam ELisp Package Sequence of Events} を参照して下さい。

@cindex spam-initialize
@code{spam.el} を使うには、@file{spam.el} を自動読み込み (autoload) し
て @code{spam.el} の各フックをインストールするために、関
数 @code{spam-initialize} を @strong{実行しなければなりません}。一つ例外
があります: もし @code{spam-use-stat} の設定を使う (@pxref{spam-stat
spam filtering}) のであれば、それを @code{spam-initialize} より前
に on にしておかなければなりません:

@example
(setq spam-use-stat t) ;; 必要なら
(spam-initialize)
@end example

では @file{spam.el} を読み込むと何が起きるでしょうか?

第一に @code{spam-initialize} によっていくつかのフックが動作するようにな
ります。@code{spam-stat} がそれらのデータベースをセーブできるようにする
フックと、グループに入るときと抜けるときに興味深いものごとを起こすフック
があります。シーケンスのイベントについての詳細は後述 (@pxref{Spam ELisp
Package Sequence of Events})。

以下のキーボード命令が使えるようになります:

@table @kbd
@item M-d
@itemx M s x
@itemx S x
@kindex M-d
@kindex S x
@kindex M s x
@findex gnus-summary-mark-as-spam
@code{gnus-summary-mark-as-spam}。

現在の記事に spam として印を付け、それを @samp{$} 印で表示します。
Spam 記事を見たときはいつでも、グループを抜ける前に必ず @kbd{M-d} でその
概略行に印を付けるようにして下さい。これは @emph{spam} グループの未読記
事に対しては自動的に行なわれます。

@item M s t
@itemx S t
@kindex M s t
@kindex S t
@findex spam-bogofilter-score
@code{spam-bogofilter-score}。

このコマンドがちゃんと働くためには Bogofilter をインストールしなければな
りません。

@xref{Bogofilter}.

@end table

また、@file{spam.el} を読み込むと、その変数群をカスタマイズすることがで
きるようになります。@samp{spam} 変数グループについ
て @code{customize-group} を試してみて下さい。

@menu
* Spam ELisp Package Sequence of Events::
* Spam ELisp Package Filtering of Incoming Mail::
* Spam ELisp Package Global Variables::
* Spam ELisp Package Sorting and Score Display in Summary Buffer::
* Spam ELisp Package Configuration Examples::
* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* SpamAssassin back end::
* ifile spam filtering::
* spam-stat spam filtering::
* SpamOracle::
* Extending the Spam ELisp package::
@end menu

@node Spam ELisp Package Sequence of Events
@subsubsection Spam ELisp Package Sequence of Events
@cindex spam filtering
@cindex spam filtering sequence of events
@cindex spam

どのように @code{spam.el} が働くかを理解するために、必ずこの項を読んで下
さい。読み飛ばし、速読、または斜め読みしてはいけません。

@code{spam.el} と Gnus の間には、二つの @emph{接点} があると考えられます。
Spam のために新着メールを検査するとき、およびグループを抜けるときです。

Gnus における新着メールの取得は、二つの方法の一方で行なわれます。新着メー
ルを分割するか、グループに入るときに新しい記事を ham と spam に分類する
かの、どちらでも可能です。

新着メールの分割は、@code{nnml} や @code{nnimap} のように、新しいメール
が @dfn{Spool File} と呼ばれる一つのファイルになるバックエンドに、より適
しています。@ref{Spam ELisp Package Filtering of Incoming Mail} を参照し
て下さい。

@vindex gnus-spam-autodetect
@vindex gnus-spam-autodetect-methods
@code{nntp} のようなバックエンドには新着メールのスプールが無いので、代わ
りの機構を使わなければなりません。これは、サーバーが新着メールの分割を担
当していて、Gnus がさらにまた分割を行なわないバックエンドでも、(代わりの
機構が) 必要になるかもしれません。グループパラメー
ター @code{spam-autodetect} と @code{spam-autodetect-methods} (普
通 @kbd{G c} and @kbd{G p} で操作可)、そしてそれらに対応する変
数 @code{gnus-spam-autodetect} およ
び @code{gnus-spam-autodetect-methods} (@kbd{M-x customize-variable} で
操作可) が役立ちます。

@code{spam-autodetect} が使われる場合 (それはグループ/トピックについて、
あるいは必要に応じて、正規表現の合致によって十把ひとからげに ON にできま
す)、それはグループに入る (そのグループの概略バッファーに移動する) 処理
において実行されます。したがって、まだ読まれたことが無い、または未読の記
事があるグループに入ることは、新着メールの検査の代わりになります。まだ読
まれたことが無い記事、またはすべての未読の記事が処理されるかどうかは、
@code{spam-autodetect-recheck-messages} によって決まります。@code{t} に
設定されると、未読のメッセージが再検査されます。おそらく、まだ読まれたこ
とが無いメッセージのディフォルトの検査だけは、着実に行なわなければならな
いでしょう。

@code{spam-autodetect} は、多少なりとも spam 濾過の管理を利用者に許可し
ます。利用者は各グループの spam 検出の手段をより多く管理することができる
でしょう。したがって、@samp{疑わしい} (@samp{suspect}) グループ
で @code{spam-use-blacklist} および @code{spam-use-bogofilter} の手段が
有効になっていても、例えば @samp{ding} グループは自動検出手段とし
て @code{spam-use-BBDB} を持つことができます。Spam として検出されるすべ
ての記事には spam 印 @samp{$} が付けられ、グループを抜けるときに通常
の spam として処理されます。彼が @code{spam-split} で行なっても良いよう
に、利用者は検査の @emph{sequence} をより少なく管理します。

新たに分割されたメールがグループに入った、またはメッセージが ham また
は spam として自動検出された場合、後に spam 処理を行なわせるために、それ
らのグループを (必要なら入った後で) 抜け出なくてはなりません。グループが
その @code{spam-content} パラメーター (@pxref{Spam ELisp Package Global
Variables}) に基づいて ham または spam グループと考えられるか、未分類か
どうかは重要です。Spam グループは、そこに入ると、まだ読まれたことが無い、
または未読の記事に spam の印が付けられる (変
数 @code{spam-mark-only-unseen-as-spam} に依存) という付加的な特性を持ち
ます。このように、分割されて spam グループに入れられた記事には、あなたが
そのグループに入ったときに自動的に spam の印が付けられます。

したがって、グループ (の概略バッファー) を抜ける
と @code{spam-processors} が (何であれ設定されていれば) 適用され、処理さ
れたメールは記事の分類に基づい
て @code{ham-process-destination} か @code{spam-process-destination} に
移動させられます。@code{ham-process-destination} また
は @code{spam-process-destination} のどちらかが (訳註: 移動先として) ふ
さわしい場合でも、それらが @code{nil} だった場合、その記事は現在のグルー
プに残されます。

どれかのグループで spam が見つかったら (非-spam グループに限っ
ては @code{spam-move-spam-nonspam-groups-only} で変更可)、グループを抜け
るときに活きている @code{spam-processors} (@pxref{Spam ELisp Package
Global Variables}) で処理されます。さらに、後でトレーニングまたは削除す
るために、spam は @code{spam-process-destination} (@pxref{Spam ELisp
Package Global Variables}) に移動させられます。Spam が再三処理されること
を望まないならば、@file{gnus-registry.el} パッケージを読み込み、
@code{spam-log-to-registry} 変数を有効にしなければなりません。このよう
に spam はどこでも検出され処理されます。それはほとんどの人々が、そうした
いと思うことです。@code{spam-process-destination} が @code{nil} だった場
合、spam には期限切れ消去の印が付けられます。普通それは正しい行ないです。

Spam が移動できない場合 (例えば @acronym{NNTP} のような読み込み専用バッ
クエンドであるために)、それはコピーされます。

Ham グループで @code{ham-marks} パラメーターで決定される ham メールが見
つかったら、グループを抜けるときに活きている ham @code{spam-processor}
で処理されます。さらに、変数 @code{spam-process-ham-in-spam-groups} およ
び @code{spam-process-ham-in-nonham-groups} によって、どこで見つかっ
た ham でも処理できるように動作を変更することができます。Ham が再三処理
されることを望まないならば、@file{gnus-registry.el} パッケージを読み込み、
@code{spam-log-to-registry} 変数を有効にしなければなりません。このよう
に ham は必要な場合だけ検出され処理されます。それはほとんどの人々が、そ
うしたいと思うことです。これに関する詳細は @xref{Spam ELisp Package
Configuration Examples}.

Ham が移動できない場合 (例えば @acronym{NNTP} のような読み込み専用バック
エンドであるために)、それはコピーされます。

これらのすべてがわけがわからなくても、心配は要りません (訳注: でも訳文が
正確ではないかもしれないので、変だと思ったら原文を見てね :-p)。すぐにそ
れは神経インターフェース上に Lisp で小話を書くように自然なことになりま
す@dots{} え゛ごめん、それにはまだ 50年早いですね。ただ私たちを信頼して
下さい。それは捨てたものではありません。

@node Spam ELisp Package Filtering of Incoming Mail
@subsubsection Spam ELisp Package Filtering of Incoming Mail
@cindex spam filtering
@cindex spam filtering incoming mail
@cindex spam

入ってくるメールを濾過する目的で @code{spam.el} を使うには、特級分割リス
ト @code{nnmail-split-fancy} または @code{nnimap-split-fancy} に以下を追
加しなければなりません:

@example
(: spam-split)
@end example

特級分割は、メールの取り込みに nnmail か nnimap のどちらのバックエンドを
使っているかに応じて、@code{nnmail-split-fancy} また
は @code{nnimap-split-fancy} から呼ばれることに注意して下さい。

さらに、@code{spam-split} はいかなる方法によっても新着メールを改変しませ
ん。

@code{spam-split} 関数は入ってくるメールを処理し、spam と思われるメール
を変数 @code{spam-split-group} で与えられる名前のグループに送ります。ディ
フォルトではそのグループ名は @samp{spam} ですが、
@code{spam-split-group} をカスタマイズすることが可能です。
@code{spam-split-group} の内容が @emph{絶対} グループ名であること、例え
ば @samp{your-server} という @code{nnimap} サーバーの場合は、
@samp{spam} 変数が最終的に @samp{nnimap+your-server:spam} になることを確
かめて下さい。従って @samp{nnimap+server:spam} という値は間違いで、それ
は実際には @samp{nnimap+your-server:nnimap+server:spam} というグループに
なり、それが働くか働かないかは、あなたのサーバーが奇妙なグループ名に対し
て寛容かどうかに依存するでしょう。

また、@code{spam-split} にパラメーター、例え
ば @code{spam-use-regex-headers} または @code{"maybe-spam"} を与えること
もできます。なぜこれが有用なのでしょうか?

これらの (@code{spam-use-regex-headers} と @code{spam-use-blackholes} の
設定による) 分割の規則を見て下さい:

@example
 nnimap-split-fancy '(|
                      (any "ding" "ding")
                      (: spam-split)
                      ;; @r{ディフォルトのメールボックス。}
                      "mail")
@end example

さて、問題は ding 宛てのメッセージをすべて ding フォルダーに入れようとし
ていることです。でもそれは ding メーリングリスト宛てに送られた spam (例
えば SpamAssassin と @code{spam-use-regex-headers} によって検出され
る spam) を許してしまうでしょう。一方、いくつかの ding 宛てのメッセージ
はブラックホールリストに載っているメールサーバーからやって来るので、
ding の規則より前に @code{spam-split} を発動することができません。

SpamAssassin ヘッダーに ding の規則を置き換えさせることはできますが、他
のすべての @code{spam-split} の規則 (第二の正規表現ヘッダー検査を含
む) は ding の規則の後になってしまうでしょう。

@example
 nnimap-split-fancy '(|
;;; @r{@code{spam-use-regex-headers} で検出された}
;;; @r{すべての spam は @samp{regex-spam} へ。}
                      (: spam-split "regex-spam" 'spam-use-regex-headers)
                      (any "ding" "ding")
;;; @r{spam-split で検出された他のすべての spam は}
;;; @r{@code{spam-split-group} へ。}
                      (: spam-split)
                      ;; @r{ディフォルトのメールボックス。}
                      "mail")
@end example

基本的に、これは特にあなたの必要に依存した特定の @code{spam-split} 検
査を起動させ、それらの検査の結果は特定の spam グループを指し示します。す
べてのメールをすべての spam テストに投げる必要はありません。これが良い別
の理由は、規則を持っているメーリングリストへのメッセージに対して、資源集
約的なブラックホール・チェックを実行する必要がないということです。さら
に nnmail 分割に対して nnimap 分割のための、異なる spam 検査を指定するこ
ともできます。気が狂うー。

検査と同時に明らかに @code{spam-split} を実行するとしても、今までとお
り @code{spam-use-regex-headers} を @code{t} に設定するような検査を行なっ
ていなければなりません。なぜなら @file{spam.el} を読み込むときに、あなた
が何の @code{spam-use-xyz} 変数を設定しているかに応じた、いくつかの条件
付きの読み込みが行なわれるからです。

@emph{@acronym{IMAP} 利用者への注意}

ヘッダーだけではなくてメッセージ全体に基づいて分割を行ないたい場合は、ブー
ル変数 @code{nnimap-split-download-body} が設定される必要があります。ディ
フォルトでは、nnimap バックエンドはメッセージヘッダーだけを取り込みます。
例えば @code{spam-check-bogofilter}、@code{spam-check-ifile} また
は @code{spam-check-stat} (それらの分割器はメッセージの本文全体から情報
を得る) のような @emph{統計的な} 濾過器を使うならば、この変数は自動的に
設定されるでしょう。それは @acronym{IMAP} の動作を遅くしてしまうので、統
計的ではないバックエンドに対してディフォルトでは設定されていません。

@xref{Splitting in IMAP}.

@node Spam ELisp Package Global Variables
@subsubsection Spam ELisp Package Global Variables
@cindex spam filtering
@cindex spam filtering variables
@cindex spam variables
@cindex spam

@vindex gnus-spam-process-newsgroups
Ham プロセッサーと spam プロセッサーの概念は非常に重要です。あるグループ
の ham プロセッサーと spam プロセッサーは、@code{spam-process} グループ
パラメーターか @code{gnus-spam-process-newsgroups} 変数で設定することが
できます。後で同様のメールを spam ではないと解釈できるようにするために、
ham プロセッサーは非 spam (@emph{ham}) であることがわかっているメールを
受け取って、何らかの方法で処理します。Spam プロセッサーは、後で同様
の spam が検出されるように、spam であることがわかっているメールを受け取っ
て処理します。

Spam または ham プロセッサーを指定する形式を、かつてはシンボルで表してい
たのですが、現在は @sc{cons} セルになっています。詳しくは個々の spam プ
ロセッサーの項を参照して下さい。

@vindex gnus-spam-newsgroup-contents
Gnus はあなたが受け取った spam から学びます。あなたは一つ以上の spam グ
ループに spam 記事を集めて、変数 @code{spam-junk-mailgroups} を適切に設
定もしくはカスタマイズしなければなりません。また、spam を含めるグループ
を、そのグループパラメー
ター @code{spam-contents} を @code{gnus-group-spam-classification-spam} に
設定するか、またはそれに対応する変
数 @code{gnus-spam-newsgroup-contents} をカスタマイズすることによって宣
言することができます。@code{spam-contents} グループパラメーター
と @code{gnus-spam-newsgroup-contents} 変数は、それらの種別
を @code{gnus-group-spam-classification-ham} に設定することによって、
@emph{ham} グループであることを宣言するために使うこともできます。グルー
プが @code{spam-junk-mailgroups}, @code{spam-contents} また
は @code{gnus-spam-newsgroup-contents} であることを示す分類が行なわれて
いないと、それらは @emph{未分類} であると解釈されます。すべてのグループ
はディフォルトでは未分類です。

@vindex gnus-spam-mark
@cindex $
Spam グループでは、ディフォルトですべてのメッセージが spam であると解釈
されます: そのグループに入ると、それら
に @samp{$} 印 (@code{gnus-spam-mark}) が付きます。メッセージを見ていっ
たんそれに spam の印を付けても、後で取り消せば、その後そのグループに入っ
たときに、それには spam 印は付きません。ただ
し @code{spam-mark-only-unseen-as-spam} パラメーターを @code{nil} にすれ
ば、そういう動作をやめさせる、つまりすべての未読メッセージに spam 印が付
くようにすることができます。そのグループの概略バッファーにいるとき、やっ
ぱり spam ではなかったすべての 記事から @samp{$} 印を消さなければなりま
せん。@samp{$} 印を消すには @kbd{M-u} でその記事を ``未読'' にするか、あ
るいは @kbd{d} で spam ではないものとして読んだことを宣言すれば良いでしょ
う。グループを抜けるとき、すべての spam 印 (@samp{$}) が付いた記事
は spam プロセッサーに送られ、それらを spam の標本として学習します。

メッセージは他のいろいろな方法によっても消去されるかもしれないし、
@code{ham-marks} グループパラメーターが無効にされなければ、低いスコアの
ための @samp{Y} 印と同様、ディフォルトの既読か明示的な消去のため
の @samp{R} と @samp{r} 印、自動または明示的な削除のため
の @samp{X} と @samp{K} 印、それらすべてが spam 記事とは無関係であると解
釈されます。この仮定は、本物の spam を検出するために消去 (kill) ファイル
かスコアファイルを特別に使っている場合は間違っているかもしれません。そう
であれば @code{ham-marks} グループパラメーターを調整するべきです。

@defvar ham-marks
このグループまたはトピックパラメーターを ham であると解釈したい印のリス
トに設定することができます。ディフォルトでは、消去 (deleted)、既
読 (read)、削除 (killed)、kill ファイルにあるもの (kill-filed) および低
いスコア (low-score、既読だけれども spam ではないと考える) 印のリストで
す。Ham 印のリストに可視 (tick) 印を含めることが役立つこともあります。未
読印を ham 印にすることは、通常それが分類が足りていないことを表すので、
勧められません。しかし、あなたがそれを行なうことはできるし、私たちに不満
はありません。
@end defvar

@defvar spam-marks
このグループまたはトピックパラメーターを spam であると解釈したい印のリス
トに設定することができます。ディフォルトでは spam 印だけを持つリストです。
それを変更することは勧めませんが、本当にそうしたいのならご勝手に。
@end defvar

グループを抜けるときに (そのグループが @emph{何} であっても)、そ
の @code{spam-contents} の分類にかかわらず、spam 印が付いているすべての
記事は spam プロセッサーに送られ、それらを spam の標本として学習します。
意図的にたくさんの消去を行なうと、たまにそれは見ていない @samp{K} 印が付
いた記事で終わるかもしれません。そしてそれらは偶然に spam を含んでいるか
もしれません。最も良いのは、本当の spam に @samp{$} が付いていて、他に何
も無いことを確かめることです。

@vindex gnus-ham-process-destinations
@emph{Spam} グループを抜けるときに、spam 印が付いているすべての記事
には spam プロセッサーで処理した後で期限切れ消去の印が付けられます。これ
は @emph{未分類} または @emph{ham} グループに対しては行なわれません。さ
らに spam グループにあるどの @strong{ham} 記事も、
@code{ham-process-destination} グループパラメーター
か @code{gnus-ham-process-destinations} 変数のどちらかに合致する場所に移
されます。それらはグループ名に合致する正規表現のリストで
す (@kbd{M-x customize-variable @key{RET}
gnus-ham-process-destinations} によってこの変数をカスタマイズするのが最
も簡単です)。変数を手でカスタマイズする方が好きな人のために言っておくと、
それぞれのグループ名のリストは普通の Lisp の list です。
@code{ham-process-destination} パラメーターが設定されていないと、ham 記
事はそこに留め置かれます。
@code{spam-mark-ham-unread-before-move-from-spam-group} パラメーターが設
定されていると、ham 記事は移動させられる前に未読の印が付けられます。

Ham が移動できない場合 (例えば @acronym{NNTP} のような読み込み専用バック
エンドであるために)、それはコピーされます。

グループまたは正規表現ごとに複数の移動先を指定できることに注目して下さい!
これによって ham 記事を正規のメールグループと @emph{ham トレーニング} グ
ループに送ることができます。

@emph{Ham} グループを抜けるときに、ham 印が付いているすべての記事
は ham プロセッサーに送られ、それらを spam ではない標本として学習します。

@vindex spam-process-ham-in-spam-groups
変数 @code{spam-process-ham-in-spam-groups} はディフォルトで
は @code{nil} です。Spam グループで見つかった ham がプロセッサーに送られ
るようにしたい場合は @code{t} にして下さい。通常これは行なわれません。あ
なたが自分で ham 記事を ham グループに送って、そこで処理することが期待さ
れています。

@vindex spam-process-ham-in-nonham-groups
変数 @code{spam-process-ham-in-nonham-groups} はディフォルトで
は @code{nil} です。Ham ではない (spam または未分類の) グループで見つかっ
た ham がプロセッサーに送られるようにしたい場合は @code{t} にして下さい。
通常これは行なわれません。あなたが自分で ham 記事を ham グループに送って、
そこで処理することが期待されています。

@vindex gnus-spam-process-destinations
@emph{Ham} または @emph{未分類} グループを抜けるときに、すべて
の @strong{spam} 記事は、@code{spam-process-destination} グループパラメー
ターか @code{gnus-spam-process-destinations} 変数のどちらかに合致する場
所に移されます。それらはグループ名に合致する正規表現のリストで
す (@kbd{M-x customize-variable @key{RET}
gnus-spam-process-destinations} によってこの変数をカスタマイズするのが最
も簡単です)。変数を手でカスタマイズする方が好きな人のために言っておくと、
それぞれのグループ名のリストは普通の Lisp の list です。
@code{spam-process-destination} パ
ラメーターが設定されていないと、spam 記事は単に期限切れ消去されます。グ
ループ名は完全形であること、すなわちグループバッファーでグループ名の前
に @samp{nntp:servername} のようなものが見える場合は、ここでもそれを使う
必要があります。

Spam が移動できない場合 (例えば @acronym{NNTP} のような読み込み専用バッ
クエンドであるために)、それはコピーされます。

グループまたは正規表現ごとに複数の移動先を指定できることに注目して下さい!
これによって spam 記事を正規のメールグループ
と @emph{spam トレーニング} グループに送ることができます。

@vindex spam-log-to-registry
Ham と spam に関する問題は、Gnus がディフォルトではこの処理を追跡してく
れないことです。処理された記事を追跡し、かつ複数回にわたって処理すること
を回避するために @code{spam.el} が @code{gnus-registry.el} を使うように、
@code{spam-log-to-registry} 変数を有効にして下さい。登録数を制限すると、
制限が無い場合のように動作しないことを覚えておいて下さい。

@vindex spam-mark-only-unseen-as-spam
Spam グループにある、まだ読まれたことが無い記事だけに spam の印を付けた
い場合は、この変数をセットして下さい。ディフォルトではセットされています。
これを @code{nil} にすると、未読の記事にも spam 印が付けられます。

@vindex spam-mark-ham-unread-before-move-from-spam-group
Ham が spam グループから移動される前に印を消したい場合は、この変数をセッ
トして下さい。これは ham に印を付けるために可視 (tick) 印のようなものを
使う場合に、とても役に立ちます。記事はあたかもそれがメールサーバーを出た
ばかりのように、無印で @code{ham-process-destination} に置かれるでしょう。

@vindex spam-autodetect-recheck-messages
この変数は @code{spam.el} が spam の自動検出を行なう場合に、まだ読まれた
ことが無い記事だけ、またはすべての未読記事の spam 検査を行なうかどうかを
指示します。これはそのままにしておくことを勧めます。

@node Spam ELisp Package Sorting and Score Display in Summary Buffer
@subsubsection Spam ELisp Package Sorting and Score Display in Summary Buffer
@cindex spam scoring
@cindex spam sorting
@cindex spam score summary buffer
@cindex spam sort summary buffer
@cindex spam

概略バッファーに spam のスコアを表示することができます。また、それら
の spam のスコアによって、記事を並べ替えることもできます。

最初に、どのバックエンドを使うかを決める必要があります。
@code{spam-use-spamassassin}、@code{spam-use-spamassassin-headers} また
は @code{spam-use-regex-headers} バックエンドを使う場合、
@code{X-Spam-Status} ヘッダーが使われます。@code{spam-use-bogofilter} を
使う場合は、@code{X-Bogosity} が使われます。@code{spam-use-crm114} を使
うのならば、CRM114 スコア・フォーマットに合致する、いずれかのヘッダーが
使われます。@file{spam.el} をロードする @emph{前} に、適切なバックエンド
変数を t に設定する限り、うまくいくでしょう。@code{spam.el} は、Gnus が
内部的に必要とするヘッダーのリストに、正しいヘッダーを自動的に追加します。

概略バッファーに spam のスコアを表示させるには、この行
を @code{~/.gnus.el} ファイルに加えて下さい (注: @code{spam.el} はディフォ
ルトではそれを行なわないので、あなたが持っているかもしれない、存在するど
んな @code{S} フォーマットよりも優先されません)。

@lisp
(defalias 'gnus-user-format-function-S 'spam-user-format-function-S)
@end lisp

では、概略バッファーの行書法仕様 (summary line format) が @code{%uS} を
使うように設定しましょう。以下は spam のスコアを 5桁のフィールドに表示す
る例です:

@lisp
(setq gnus-summary-line-format
 "%U%R %10&user-date; $%5uS %6k  %B %(%4L: %*%-25,25a%) %s \n")
@end lisp

最後に、spam の状態による並べ替えを全グループで行なわせるようにしましょ
う:

@lisp
(setq
 gnus-show-threads nil
 gnus-article-sort-functions
  '(spam-article-sort-by-spam-status))
@end lisp

グループ毎に行なわせたい場合は @ref{Sorting the Summary Buffer} を参照し
て下さい。

@node Spam ELisp Package Configuration Examples
@subsubsection Spam ELisp Package Configuration Examples
@cindex spam filtering
@cindex spam filtering configuration examples
@cindex spam configuration examples
@cindex spam

@subsubheading Ted の設定

From Ted Zlatanov <tzz@@lifelogs.com>.
@example

;; @r{@code{gnus-registry-split-fancy-with-parent} と spam の}
;; @r{自動検出のため。詳細は @file{gnus-registry.el} を参照。}
(gnus-registry-initialize)
(spam-initialize)

;; @r{私は spam 印を付けるのに @kbd{C-s} を好む。}
(define-key gnus-summary-mode-map "\C-s" 'gnus-summary-mark-as-spam)

(setq
 spam-log-to-registry t ;; @r{Spam の自動検出のため。}
 spam-use-BBDB t
 spam-use-regex-headers t ;; @r{X-Spam-Flag (SpamAssassin) をつかまえる。}
 ;; @r{名前に @samp{spam} を含むすべてのグループには spam 記事がある。}
 gnus-spam-newsgroup-contents '(("spam" gnus-group-spam-classification-spam))
 ;; @r{これらの docstring を参照。}
 spam-move-spam-nonspam-groups-only nil
 spam-mark-only-unseen-as-spam t
 spam-mark-ham-unread-before-move-from-spam-group t
 nnimap-split-rule 'nnimap-split-fancy
 ;; @r{あなたの設定に追加する前に、これが何をするか理解せよ!}
 nnimap-split-fancy '(|
                      ;; @r{References を親まで辿って}
                      ;; @r{それらのグループを入れる。}
                      (: gnus-registry-split-fancy-with-parent)
                      ;; @r{これはサーバー側の SpamAssassin}
                      ;; @r{タグをつかまえる。}
                      (: spam-split 'spam-use-regex-headers)
                      (any "ding" "ding")
                      ;; @r{Spam 記事はディフォルトで}
                      ;; @r{@samp{spam} に行くことに注意。}
                      (: spam-split)
                      ;; @r{ディフォルトのメールボックス。}
                      "mail"))

;; @r{@kbd{G p} で設定した私のパラメーター。}

;; @r{すべての nnml グループと、@samp{nnimap+mail.lifelogs.com:train}}
;; @r{と @samp{nnimap+mail.lifelogs.com:spam} を除いたすべての nnimap}
;; @r{グループでは、どの spam も nnimap トレーニングに行く。}
;; @r{それは手動で検出しなければならないから。}

((spam-process-destination . "nnimap+mail.lifelogs.com:train"))

;; @r{すべての @acronym{NNTP} グループ。}
;; @r{Spam を blacklist で、ham を BBDB で自動検出。}
((spam-autodetect-methods spam-use-blacklist spam-use-BBDB)
;; @r{すべての spam をトレーニンググループに送る。}
 (spam-process-destination . "nnimap+mail.lifelogs.com:train"))

;; @r{私が spam を自動検出させたい、いくつかの @acronym{NNTP} グループ。}
((spam-autodetect . t))

;; @r{私の nnimap @samp{nnimap+mail.lifelogs.com:spam} グループ。}

;; @r{これは spam グループ。}
((spam-contents gnus-group-spam-classification-spam)

 ;; @r{どんな spam も私は ham 印を付けなければ}
 ;; @r{@samp{nnimap+mail.lifelogs.com:train} に行く}
 ;; @r{(前述の @code{gnus-spam-newsgroup-contents} 設定により、すべての}
 ;; @r{まだ読まれたことが無いメッセージを読むとそうなる)。}

 (spam-process-destination "nnimap+mail.lifelogs.com:train")

 ;; @r{どんな ham も私の @samp{nnimap+mail.lifelogs.com:mail} フォルダ}
 ;; @r{に行くが、私の @samp{nnimap+mail.lifelogs.com:trainham} フォルダ}
 ;; @r{にもトレーニングのために行く。}

 (ham-process-destination "nnimap+mail.lifelogs.com:mail"
                          "nnimap+mail.lifelogs.com:trainham")
 ;; @r{このグループでは @samp{!} 印が付いているものだけが ham。}
 (ham-marks
  (gnus-ticked-mark))
 ;; @r{出かける間際に blacklist に送信者を覚えさせる - これは明らかに}
 ;; @r{不要で、単に私の鬱憤を晴らすためにあります。}
 (spam-process (gnus-group-spam-exit-processor-blacklist)))

;; @r{その後 @acronym{IMAP} サーバー上で、私は SpamAssassin が spam を}
;; @r{認識するトレーニングのために @samp{train} グループを、ham を認識}
;; @r{するトレーニングのために @samp{trainham} グループを使います。でも}
;; @r{Gnus はそういうことはやってくれません。}

@end example

@subsubheading サーバー上の IMAP サーバーで、統計的な濾過器と @code{spam.el} を使う
From Reiner Steib <reiner.steib@@gmx.de>.

私のプロバイダは (@acronym{IMAP}) メールサーバー上で (@acronym{DCC} と連
係した) bogofilter を稼働させています。認識され
た spam は @samp{spam.detected} へ行き、残りには通常の濾過規則が適用され
る、 すなわち @samp{some.folder} か @samp{INBOX} に行きます。肯定の失敗
あるいは否定のトレーニングは、@samp{training.ham} また
は @samp{training.spam} それぞれに記事をコピーするか移動させることによっ
て行なわれます。サーバー上の cron ジョブが、それらを適切な ham また
は spam オプションとともに bogofilter に与え、@samp{training.ham} およ
び @samp{training.spam} フォルダからそれらを削除します。

以下の @code{gnus-parameters} の項によって、@code{spam.el} はほとんどの
仕事を私のためにこなします:

@lisp
   ("nnimap:spam\\.detected"
    (gnus-article-sort-functions '(gnus-article-sort-by-chars))
    (ham-process-destination "nnimap:INBOX" "nnimap:training.ham")
    (spam-contents gnus-group-spam-classification-spam))
   ("nnimap:\\(INBOX\\|other-folders\\)"
    (spam-process-destination . "nnimap:training.spam")
    (spam-contents gnus-group-spam-classification-ham))
@end lisp

@itemize

@item @b{The Spam folder:}

@samp{spam.detected} フォルダにおいて、私は肯定の失敗 (すなわち、
bogofilter か DCC が spam であると誤って判定した正当なメール) のチェック
をしなければなりません。

@code{gnus-group-spam-classification-spam} の項のために、すべてのメッセー
ジには spam の印 (@code{$}) が付けられます。肯定に失敗したものを見つけた
ら、私は記事にいくつかの他の ham 印 (@code{ham-marks}, @ref{Spam ELisp
Package Global Variables}) を付けます。グループを出るとき、それらの記事
は @samp{INBOX} (私が記事を置いておきたいとこ
ろ) と @samp{training.ham} (bogofilter のトレーニング用) の両方のグルー
プにコピーされ、@samp{spam.detected} フォルダから削除されます。

@code{gnus-article-sort-by-chars} の項は、私の失敗した肯定の検出を単純に
します。私は、すべて似たサイズの、たくさんのワーム (sweN, @dots{}) を受
け取ります。それらをサイズ (つまり文字数) でまとめると、他の間違った肯定
を見つけやすくなるのです。(もちろん厳密にはワームは @i{spam}
(@acronym{UCE}, @acronym{UBE}) ではありません。ともあれ、それらの要らな
いメールを濾過するのに bogofilter は私にとって優秀な道具です。)

@item @b{Ham folders:}

私の ham フォルダで、認識されなかった spam メール (否定の失敗) を見たと
きはいつでも、私は単に @kbd{S x} (@code{gnus-summary-mark-as-spam}) を叩
きます。グループを出るとき、それらのメッセージは @samp{training.spam} に
移されます。
@end itemize

@subsubheading @code{spam-report.el} で Gmane グループの spam を報告する

From Reiner Steib <reiner.steib@@gmx.de>.

以下の @code{gnus-parameters} に納めた項目によって、@kbd{S x}
(@code{gnus-summary-mark-as-spam}) で @code{gmane.*} グループの spam 記
事に印を付け、グループを出るときに Gmane に報告します:

@lisp
   ("^gmane\\."
    (spam-process (gnus-group-spam-exit-processor-report-gmane)))
@end lisp

加えて、私は news.gmane.org からではなくローカルニュースサー
バー (leafnode) を通して記事を読んでいるので、
@code{(setq spam-report-gmane-use-article-number nil)} を使っています。
つまり、記事番号が news.gmane.org におけるものと異なるので、正しい記事番
号を見つけるために @code{spam-report.el} に @code{X-Report-Spam} ヘッダー
を検査させなければなりません。

@node Blacklists and Whitelists
@subsubsection ブラックリストとホワイトリスト
@cindex spam filtering
@cindex whitelists, spam filtering
@cindex blacklists, spam filtering
@cindex spam

@defvar spam-use-blacklist

入ってくるメールを分割するときにブラックリストを使いたい場合は、この変数
を @code{t} に設定して下さい。送信者がブラックリストに載っているメッセー
ジは @code{spam-split-group} に送られます。これは、送信者が spammer であ
ることが定義されているメールに対してだけ動作する、明示的な濾過器です。

@end defvar

@defvar spam-use-whitelist

入ってくるメールを分割するときにホワイトリストを使いたい場合は、この変数
を @code{t} に設定して下さい。送信者がホワイトリストに載っていないメッセー
ジは、次の spam-split 規則に送られます。これは、ホワイトリストに載ってい
ない誰かのメッセージは spam とも ham とも見なされないことを意味する、明
示的な濾過器です。

@end defvar

@defvar spam-use-whitelist-exclusive

送信者がホワイトリストに載っていないすべてのメッセージが spam だと見なさ
れることを意味する暗黙の濾過器としてホワイトリストを使いたい場合は、この
変数を @code{t} にして下さい。注意して使って下さい。

@end defvar

@defvar gnus-group-spam-exit-processor-blacklist

このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、spam 印が付
いた記事の送信者がブラックリストに追加されます。

@emph{警告}

廃れた @code{gnus-group-spam-exit-processor-blacklist} の代わりに、
@code{(spam spam-use-blacklist)} を使うことを推奨します。すべて同等に動
作することは保証されます。

@end defvar

@defvar gnus-group-ham-exit-processor-whitelist

このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、ham 印が付
いた @emph{ham} グループの記事の送信者がホワイトリストに追加されます。

@emph{警告}

廃れた @code{gnus-group-ham-exit-processor-whitelist} の代わりに、
@code{(ham spam-use-whitelist)} を使うことを推奨します。すべて同等に動作
することは保証されます。

@end defvar

ブラックリストは、あなたが spam の送信者だと考えるアドレスに合致する正規
表現のリストです。例えば @samp{vmadmin.com} の誰からでも来るメールを阻止
するには、あなたのブラックリストに @samp{vmadmin.com} を入れて下さい。空
のブラックリストで始めましょう。ブラックリストの各項目は Emacs の正規表
現シンタックスを使います。

逆に、ホワイトリストは何のアドレスが正当だと考えられるかを告げます。ホワ
イトリストにあるアドレスからやって来たすべてのメッセージは、非-spam だと
見なされます。@ref{BBDB Whitelists} も見て下さい。ホワイトリストの各項目
は Emacs の正規表現シンタックスを使います。

ブラックリストとホワイトリストのファイルの所在は、
@code{spam-directory} 変数 (ディフォルトは @file{~/News/spam}) また
は直接 @code{spam-whitelist} と @code{spam-blacklist} 変数でカスタマイズ
することができます。ホワイトリストとブラックリストのファイルは、ディフォ
ルトでは @code{spam-directory} のディレクトリーにあり、それぞ
れ @file{whitelist} と @file{blacklist} という名前が付けられます。

@node BBDB Whitelists
@subsubsection BBDB ホワイトリスト
@cindex spam filtering
@cindex BBDB whitelists, spam filtering
@cindex BBDB, spam filtering
@cindex spam

@defvar spam-use-BBDB

@code{spam-use-whitelist} (@pxref{Blacklists and Whitelists}) に似ていま
すが、ホワイトリストのアドレスの源として、正規表現ではない BBDB を使いま
す。@code{spam-use-BBDB} をちゃんと動作させるには BBDB を load しなけれ
ばなりません。その送信者が BBDB に載っていないメッセージは、次
の spam-split 規則に送られます。これは、BBDB に載っていない誰かのメッセー
ジは spam とも ham とも見なされないことを意味する、明示的な濾過器です。

@end defvar

@defvar spam-use-BBDB-exclusive

送信者が BBDB に載っていないすべてのメッセージが spam だと見なされること
を意味する暗黙の濾過器として BBDB を使いたい場合は、この変数
を @code{t} にして下さい。注意して使って下さい。BBDB に載っている送信者
だけが通行を許され、他のすべては spammers として分類されます。

@code {spam.el} に関する限りは、@code{spam-use-BBDB} の別名とし
て @code{spam-use-BBDB-exclusive} を使うことができますが、それは別のバッ
クエンドではありません。@code{spam-use-BBDB-exclusive} を @code{t} に設
定すれば、BBDB による分割はすべて排他的になります。

@end defvar

@defvar gnus-group-ham-exit-processor-BBDB

このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、ham 印が付
いた @emph{ham} グループの記事の送信者が BBDB に追加されます。

@emph{警告}

廃れた @code{gnus-group-ham-exit-processor-BBDB} の代わりに、
@code{(ham spam-use-BBDB)} を使うことを推奨します。すべて同等に動作する
ことは保証されます。

@end defvar

@node Gmane Spam Reporting
@subsubsection Gmane Spam 報告
@cindex spam reporting
@cindex Gmane, spam reporting
@cindex Gmane, spam reporting
@cindex spam

@defvar gnus-group-spam-exit-processor-report-gmane

グループパラメーターか変数 @code{gnus-spam-process-newsgroups} をカスタ
マイズして、このシンボルをグループの @code{spam-process} パラメーターに
加えて下さい。これが加えられると、spam 印が付いた記事のグループ
が HTTP 経由で Gmane の管理者に報告されます。

Gmane は @uref{http://gmane.org} で見つけることができます。

@emph{警告}

廃れた @code{gnus-group-spam-exit-processor-report-gmane} の代わりに、
@code{(spam spam-use-gmane)} を使うことを推奨します。すべて同等に動作す
ることは保証されます。

@end defvar

@defvar spam-report-gmane-use-article-number

この変数はディフォルトで @code{t} です。あなた自身がニュースサーバーを運
営している、すなわちローカルな記事番号が Gmane の記事番号と合わない場合
は、@code{nil} に設定して下さい。
@code{spam-report-gmane-use-article-number} が @code{nil} であると、
@file{spam-report.el} は Gmane が提供する @code{X-Report-Spam} ヘッダー
を使います。

@end defvar

@node Anti-spam Hashcash Payments
@subsubsection 非-spam Hashcash 印
@cindex spam filtering
@cindex hashcash, spam filtering
@cindex spam

@defvar spam-use-hashcash

@code{spam-use-whitelist} (@pxref{Blacklists and Whitelists}) に似ていま
すが、送信者のアドレスの代わりに、潔白なメッセージのための hashcash の
印 (tokens) を使います。Hashcash 印が無いメッセージは次の spam-分
割 (spam-split) 規則に送られます。これは hashcash 印が見当たらないメッセー
ジは spam とも ham とも見なされないことを意味する、明示的な濾過器です。

@end defvar

@node Blackholes
@subsubsection ブラックホール
@cindex spam filtering
@cindex blackholes, spam filtering
@cindex spam

@defvar spam-use-blackholes

このオプションはディフォルトで無効になっています。このオプションをセット
すると、Gnus にブラックホール型の分散 spam 処理システム (例えば DCC) を
調べさせることができます。変数 @code{spam-blackhole-servers} は、Gnus が
意見を求めるブラックホール・サーバーのリストを持ちます。現在のリストはか
なり広範囲に渡っていますが、もし時代遅れなサーバーを含んでいたら私たちに
知らせるために、確認して下さい。

ブラックホール・チェックは @file{dig.el} パッケージを使います。しか
し @code{spam-use-dig} を @code{nil} に設定すれば、より良い性能のため
に @file{dns.el} を代わりに使うことを @code{spam.el} に指示することがで
きます。現状では @code{spam-use-dig} を @code{nil} に設定することは、い
く人かの利用者が使えないかもしれないので、それが可能な性能改善であるにも
かかわらず推奨されません。しかし、それが動くかどうかを確かめることはでき
ます。

@end defvar

@defvar spam-blackhole-servers

ブラックホール・チェックのために意見を求めるサーバーのリストです。

@end defvar

@defvar spam-blackhole-good-server-regex

ブラックホール・サーバーのリストと照合されてはならない IP の正規表現。
@code{nil} に設定されると無効です。

@end defvar

@defvar spam-use-dig

@file{dns.el} パッケージの代わりに @file{dig.el} パッケージを使います。
ディフォルトの設定である @code{t} が推奨されます。

@end defvar

ブラックホール・チェックは入って来るメールに対してだけ行なわれます。ブラッ
クホールに spam または ham プロセッサーはありません。

@node Regular Expressions Header Matching
@subsubsection 正規表現によるヘッダーの合致検査
@cindex spam filtering
@cindex regular expressions header matching, spam filtering
@cindex spam

@defvar spam-use-regex-headers

このオプションはディフォルトで無効になっています。このオプションをセット
すると、Gnus に正規表現のリストとメッセージヘッダーを照合させることがで
きます。変数 @code{spam-regex-headers-spam} およ
び @code{spam-regex-headers-ham} が正規表現のリストを持ちます。メッセー
ジが spam または ham かどうかを決めるために、Gnus はメッセージヘッダーの
それぞれを検査します。

@end defvar

@defvar spam-regex-headers-spam

メッセージヘッダーの中で一致した時に、それが明らかに spam であることを見
分けるための正規表現のリストです。

@end defvar

@defvar spam-regex-headers-ham

メッセージヘッダーの中で一致した時に、それが明らかに ham であることを見
分けるための正規表現のリストです。

@end defvar

正規表現によるヘッダーの検査は、入ってきたメールに対してだけ行なわれます。
正規表現のために特有な spam または ham プロセッサーはありません。

@node Bogofilter
@subsubsection Bogofilter
@cindex spam filtering
@cindex bogofilter, spam filtering
@cindex spam

@defvar spam-use-bogofilter

Eric Raymond の迅速な Bogofilter を @code{spam-split} に使用したい場合は、
この変数をセットして下さい。

Spam 記事だけの @samp{$} 印を関連付ける最小の世話によって、Bogofilter ト
レーニングはすべてかなり自動的になります。各カテゴリーの spam かそうでな
い数百の記事を入手するまで、これをやらなければなりません。概略モードにお
けるデバッグのための、あるいは好奇心のための @kbd{S t} コマンドは、現在
の記事の @emph{spamicity} (訳注: spam 度?) スコア (0.0〜1.0) を表示しま
す。

Bogofilter は、ある一定の閾値に基づいて、メッセージが spam かどうかを見
極めます。閾値はカスタマイズできます。Bogofilter のドキュメントを調べて
下さい。

Path に @code{bogofilter} の実行ファイルが無い場合、Bogofilter の処理は
取り消されます。

@code{spam-use-bogofilter-headers} を使う場合は、これを有効にしてはいけ
ません。

@end defvar

@defvar spam-use-bogofilter-headers

メッセージヘッダーだけを調べるために Eric Raymond の迅速
な Bogofilter を @code{spam-split} に使用したい場合は、この変数をセット
して下さい。これは @code{spam-use-bogofilter} と同じように動作しますが、
あらかじめ @code{X-Bogosity} ヘッダーがメッセージに存在しなければなりま
せん。通常これは procmail の技法か、何かそれに似たもので行なうことになる
でしょう。Bogofilter のインストールに関する文書を調べて下さい。

@code{spam-use-bogofilter} を使う場合は、これを有効にしてはいけません。

@end defvar

@defvar gnus-group-spam-exit-processor-bogofilter
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、spam 印が付
いた記事が bogofilter の spam データベースに加えらます。

@emph{警告}

廃れた @code{gnus-group-spam-exit-processor-bogofilter} の代わりに、
@code{(spam spam-use-bogofilter)} を使うことを推奨します。すべて同等に動
作することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-bogofilter
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、ham 印が付
いた @emph{ham} グループの記事が非-spam 記事用の Bogofilter データベース
に追加されます。

@emph{警告}

廃れた @code{gnus-group-ham-exit-processor-bogofilter} の代わりに、
@code{(ham spam-use-bogofilter)} を使うことを推奨します。すべて同等に動
作することは保証されます。
@end defvar

@defvar spam-bogofilter-database-directory

これは Bogofilter がそのデータベースを格納するディレクトリーです。ディフォ
ルトでは設定されていないので、Bogofilter はそれ自身のディフォルトのデー
タベース・ディレクトリーを使います。

@end defvar

Bogofilter のメール分類器は、意図と目的の点で @command{ifile} に似ていま
す。Spam と ham のプロセッサーが提供され、加えて spam-分
割 (spam-split) にも Bogofilter が使われるべきであること、またはすでに記
事に使われたことを示す @code{spam-use-bogofilter} およ
び @code{spam-use-bogofilter-headers} 変数が提供されます。この機能を検査
するために Bogofilter のバージョン 0.9.2.1 が使われました。

@node SpamAssassin back end
@subsubsection SpamAssassin back end
@cindex spam filtering
@cindex spamassassin, spam filtering
@cindex spam

@defvar spam-use-spamassassin

@code{spam-split} に SpamAssassin を使いたい場合は、この変数をセットして
下さい。

SpamAssassin は、ベイジアンフィルタを内包する規則と分析のセットに基づい
て、それぞれの記事のスコアを裁定します。ベイジアンフィルタは、spam 記事
の @samp{$} 印を関連させることにより訓練することができます。Spam のスコ
アは、概略モードで @kbd{S t} コマンドを使うことによって見ることができま
す。

この変数をセットすると、それぞれの記事は @code{spam-split} が呼ばれると
きに SpamAssassin によって処理されます。メールが SpamAssassin で処理され
るようになっている場合に、単に SpamAssassin ヘッダーを使いたいのならば、
代わりに @code{spam-use-spamassassin-headers} をセットして下さい。

@code{spam-use-spamassassin-headers} を使う場合、これを有効にしてはいけ
ません。

@end defvar

@defvar spam-use-spamassassin-headers

メールが SpamAssassin で処理されるようになっている場合に、
SpamAssassin ヘッダーに基づいて @code{spam-split} に分割を行なわせたいの
ならば、この変数をセットして下さい。

@code{spam-use-spamassassin} を使う場合、これを有効にしてはいけません。

@end defvar

@defvar spam-spamassassin-path

この変数は SpamAssassin の実行形式を指します。@code{spamd} を稼働してい
るならば、より速い処理のために、この変数に @code{spamc} の実行形式を設定
することができます。@code{spamd}/@code{spamc} の更なる情報は、
SpamAssassin のドキュメントを見て下さい。

@end defvar

SpamAssassin は、spam を同定するために広範な分析を行なう、強力で融通性の
ある spam 濾過器です。SpamAssassin が提供する ham と spam のプロセッサー
を使うか、あるいはすでにそれらが記事に適用済みかどうかを、
@code{spam-use-spamassassin} と @code{spam-use-spamassassin-headers} 変
数で @code{spam-split} に指示します。この機能を検査するため
に SpamAssassin のバージョン 2.63 が使われました。

@node ifile spam filtering
@subsubsection ifile による spam の濾過
@cindex spam filtering
@cindex ifile, spam filtering
@cindex spam

@defvar spam-use-ifile

Bogofilter に似た統計分析器であ
る @command{ifile} を @code{spam-split} に使いたい場合は、この変数を有効
にして下さい。

@end defvar

@defvar spam-ifile-all-categories

@code{spam-use-ifile} に、単なる spam/非-spam ではなくて ifile のすべて
のカテゴリーを与えてもらいたいならば、この変数を有効にして下さい。これを
使う場合は、その文献に書かれているように ifile をトレーニングしておかな
ければなりません。

@end defvar

@defvar spam-ifile-spam-category

ifile に関する限り、これは spam メッセージのカテゴリーです。実際に使われ
る文字列は無関係ですが、たぶんあなたは @samp{spam} の値を残しておきたい
でしょう。
@end defvar

@defvar spam-ifile-database-path

これは ifile データベースのファイル名です。ディフォルトでは定義されてい
ないので、ifile はそれ自身のディフォルトのデータベース名を使います。

@end defvar

ifile のメール分類器は、意図と目的の点で Bogofilter に似ています。
Spam と ham のプロセッサー、それに spam-分割 (spam-split) に ifile が使
われるべきであることを示す @code{spam-use-ifile} 変数を提供します。この
機能を検査するために ifile のバージョン 1.2.1 が使われました。

@node spam-stat spam filtering
@subsubsection spam-統計 (spam-stat) による spam の濾過
@cindex spam filtering
@cindex spam-stat, spam filtering
@cindex spam-stat
@cindex spam

@xref{Filtering Spam Using Statistics with spam-stat}.

@defvar spam-use-stat

Emacs Lisp による統計分析器である spam-stat.el を @code{spam-split} に使
わせたいならば、この変数を有効にして下さい。

@end defvar

@defvar gnus-group-spam-exit-processor-stat
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、spam 印が付
いた記事が spam 記事用の spam-stat データベースに追加されます。

@emph{警告}

廃れた @code{gnus-group-spam-exit-processor-stat} の代わりに、
@code{(spam spam-use-stat)} を使うことを推奨します。すべて同等に動作する
ことは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-stat
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、ham 印が付
いた @emph{ham} グループの記事が非-spam 記事用の spam-stat データベース
に追加されます。

@emph{警告}

廃れた @code{gnus-group-ham-exit-processor-stat} の代わりに、
@code{(ham spam-use-stat)} を使うことを推奨します。すべて同等に動作する
ことは保証されます。
@end defvar

これは @code{spam.el} が @file{spam-stat.el} と働き合うことを可能にしま
す。@file{spam-stat.el} は (Lisp だけの) spam 内部データベースを提供しま
すが、それは ifile や Bogofilter と違って外部プログラムを必要としません。
Spam と ham のプロセッサーと @code{spam-split} のため
の @code{spam-use-stat} 変数が提供されます。

@node SpamOracle
@subsubsection Gnus で SpamOracle を使うには
@cindex spam filtering
@cindex SpamOracle
@cindex spam

気軽に spam を濾過する一つのやり方は SpamOracle を使うことです。統計的に
メールを濾過するための道具である SpamOracle は、Xavier Leroy によって書
かれました。これは別にインストールする必要があります。

Gnus で SpamOracle を使うには、いくつかのやり方があります。すべての場合
に、メールは @emph{mark} モードで動作している SpamOracle にパイプされま
す。すると SpamOracle は、そのメールを spam だと見なしたかどうかを示
す @samp{X-Spam} ヘッダーを記入します。

実現可能な一つは、SpamOracle を @code{:prescript} として @ref{Mail
Source Specifiers} から走らせることです。この方法には、利用者
が @emph{X-Spam} ヘッダーを見ることができるという利点があります。

もっとも手軽な方法は、@code{spam.el} (@pxref{Filtering Spam Using The
Spam ELisp Package}) が SpamOracle を呼ぶようにすることです。

@vindex spam-use-spamoracle
@code{spam.el} が SpamOracle を使えるようにするには、変
数 @code{spam-use-spamoracle} を @code{t} にして、@ref{Filtering Spam
Using The Spam ELisp Package} の項で述べられているよう
に @code{nnmail-split-fancy} か @code{nnimap-split-fancy} を設定して下さ
い。この例では @code{nnimap} サーバーの @samp{INBOX} が SpamOracle によっ
て濾過されます。Spam だと見なされたメールは @code{spam-split-group}、こ
の場合は @samp{Junk} に移動させられます。Ham なメッセージ
は @samp{INBOX} に残ります:

@example
(setq spam-use-spamoracle t
      spam-split-group "Junk"
      nnimap-split-inbox '("INBOX")
      nnimap-split-rule 'nnimap-split-fancy
      nnimap-split-fancy '(| (: spam-split) "INBOX"))
@end example

@defvar spam-use-spamoracle
Gnus に SpamOracle を使って spam の濾過をさせたい場合に @code{t} にして
下さい。
@end defvar

@defvar spam-spamoracle-binary
Gnus は利用者の PATH で見つかった @file{spamoracle} という SpamOracle の
バイナリを使います。これにはカスタマイズ可能な変
数 @code{spam-spamoracle-binary} を使います。
@end defvar

@defvar spam-spamoracle-database
SpamOracle はその解析結果をデータベースとして格納するために、ディフォル
トで @file{~/.spamoracle.db} ファイルを使います。これは変
数 @code{spam-spamoracle-database} で制御され、ディフォルト
は @code{nil} です。それは、ディフォルトの SpamOracle データベースが使わ
れることを意味します。データベースがどこか特別な場所にある場合は、
@code{spam-spamoracle-database} をそのパスに設定して下さい。
@end defvar

SpamOracle はメッセージが spam か ham かを見極めるために統計的な手法を使
います。間違いや見逃しの少ない良い結果を得るために、SpamOracle はトレー
ニングを必要とします。SpamOracle は spam メールの特徴を学びます。
@emph{add} モード (トレーニング・モード) を使って、良いメー
ル (ham) と spam を SpamOracle に与えなければなりません。これは、概略バッ
ファーで @kbd{|} を押すことによってメールを SpamOracle のプロセスにパイ
プするか、または @code{spam.el} の spam および ham プロセッサーを使うこ
とによって行なうことができます、@xref{Filtering Spam Using The Spam
ELisp Package}.

@defvar gnus-group-spam-exit-processor-spamoracle
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、spam 印が付
いた記事が spam のサンプルとして SpamOracle に送られます。

@emph{警告}

廃れた @code{gnus-group-spam-exit-processor-spamoracle} の代わりに、
@code{(spam spam-use-spamoracle)} を使うことを推奨します。すべて同等に動
作することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-spamoracle
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えて下さい。このシンボル
がグループの @code{spam-process} パラメーターに加えられると、
@emph{ham} グループにある ham 印が付いた記事が ham の記事のサンプルとし
て SpamOracle に送られます。

@emph{警告}

廃れた @code{gnus-group-ham-exit-processor-spamoracle} の代わりに、
@code{(ham spam-use-spamoracle)} を使うことを推奨します。すべて同等に動
作することは保証されます。
@end defvar

@emph{例:} これらは ham グループとして分類された、つまり ham の記事しか
ないグループのグループパラメーターです。

@example
 ((spam-contents gnus-group-spam-classification-ham)
  (spam-process ((ham spam-use-spamoracle)
                 (spam spam-use-spamoracle))))
@end example

このグループでは @code{spam-use-spamoracle} が ham と spam 両方の処理を
行ないます。このグループに spam 記事があって (SpamOracle が十分なサンプ
ルを食べさせてもらっていなければ、そうなりますね)、かつ利用者がいくつか
の記事に spam の印を付けたならば、それらの記事は SpamOracle によって処理
されます。そのプロセッサーは、新しい spam のサンプルとして SpamOracle に
記事を送ります。

@node Extending the Spam ELisp package
@subsubsection Spam ELisp パッケージの拡張
@cindex spam filtering
@cindex spam elisp package, extending
@cindex extending the spam elisp package

新しいバックエンド blackbox を追加したいあなたは、入ってくるメールを濾過
するために以下を用意して下さい:

@enumerate

@item
コード

@lisp
(defvar spam-use-blackbox nil
  "Blackbox を使うときは t にする。")
@end lisp

Blackbox が、入ってくるメールを検査できるのであれば、
@code{spam-check-blackbox} を書いて下さい。

Blackbox が spam と ham を register/unregister できるのであれば、手始め
に、bogofilter の register/unregister ルーチンか、より Blackbox にふさわ
しい他の restister/unregister ルーチンを使っ
て @code{spam-blackbox-register-routine} およ
び @code{spam-blackbox-unregister-routine} を書いて下さい。

@item
関数

@code{spam-check-blackbox} 関数は、他の習慣に倣っ
て @samp{nil} か @code{spam-split-group} を返さなければなりません。あな
たにできることの例は、既存の @code{spam-check-*} 関数を参照して下さい。
また、あなたがそうでない理由を完全に理解していないならば、テンプレートに
齧り付いて下さい。

@end enumerate

Spam と ham メッセージを処理するには、以下を用意して下さい:

@enumerate

@item
コード

Spam または ham のプロセッサーを用意する必要はありません。
Blackbox が spam または ham の処理をサポートする場合だけ、それらを用意し
て下さい。

さらに ham と spam のプロセッサーは単一の変数ではなくされつつあり、代わ
りに @code{(spam spam-use-blackbox)} また
は @code{(ham spam-use-blackbox)} の形式が推奨されます。今のとこ
ろ spam/ham プロセッサー変数はまだあちこちにありますが、長くはありません。

@lisp
(defvar gnus-group-spam-exit-processor-blackbox "blackbox-spam"
  "概略を出るときに呼ばれる blackbox の spam プロセッサー。
Spam グループだけに適用される。")

(defvar gnus-group-ham-exit-processor-blackbox "blackbox-ham"
  "概略を出るときに呼ばれる blackbox の ham プロセッサー。
Spam ではない (未分類または ham) グループだけに適用される。")

@end lisp

@item
Gnus のパラメーター

@code{gnus.el} にあるグループパラメーター @code{spam-process} に

@lisp
(const :tag "Spam: Blackbox" (spam spam-use-blackbox))
(const :tag "Ham: Blackbox"  (ham spam-use-blackbox))
@end lisp

を加えて下さい。それをパラメーターと変数のカスタマイズの二回について行な
うことを確かめて下さい。

Blackbox が、入ってくるメールが spam かどうかを検査できるのであれば、

@lisp
(variable-item spam-use-blackbox)
@end lisp

を @code{gnus.el} のグループパラメー
ター @code{spam-autodetect-methods} に加えて下さい。

最後に、@code{spam.el} にある、適切な @code{spam-install-*-backend} 関数
を使って下さい。利用できる関数は次の通りです。

@enumerate

@item
@code{spam-install-backend-alias}

この関数は、オリジナルのバックエンドとすべてが似たバックエンドの別名を用
意します。今のところ、これ
は @code{spam-use-BBDB-exclusive} を @code{spam-use-BBDB} のように働かせ
るためだけに使われます。

@item
@code{spam-install-nocheck-backend}

この関数は、検査する機能は無いが ham また
は spam を register/unregister することができるバックエンドを用意します。
@code{spam-use-gmane} がそのようなバックエンドです。

@item
@code{spam-install-checkonly-backend}

この関数は、入ってくるメールが spam かどうかの検査だけを行なうことができ
るバックエンドを用意します。それはメッセージを register また
は unregister することができません。@code{spam-use-blackholes} およ
び @code{spam-use-hashcash} がそのようなバックエンドです。

@item
@code{spam-install-statistical-checkonly-backend}

この関数は、入ってくるメールの検査だけを行なうことができる、統計処理を行
なうバックエンド (検査のためにメッセージの本文全体を必要とする) を用意し
ます。@code{spam-use-regex-body} がそのような濾過器です。

@item
@code{spam-install-statistical-backend}

この関数は、入ってくるメールの検査と registration/unregistration ルーチ
ンを持つ、統計処理を行なうバックエンドを用意します。
@code{spam-use-bogofilter} は、そのように仕立てられています。

@item
@code{spam-install-backend}

これは最も普通なバックエンドを用意します。それは検査とメッセージ
の register/unregister を行なうことができ、統計処理の能力はありません。
@code{spam-use-BBDB} がそのようなバックエンドです。

@item
@code{spam-install-mover-backend}

移動させる (Mover) バックエンドは、概略バッファーを出るときに
@code{spam.el} の内部で、ある一定のやり方で記事を移動させます。おそらく、
そのようなバックエンドは、あまりインストールしないでしょう。
@end enumerate

@end enumerate

@node Filtering Spam Using Statistics with spam-stat
@subsection Spam の濾過に spam-stat による統計を使う
@cindex Paul Graham
@cindex Graham, Paul
@cindex naive Bayesian spam filtering
@cindex Bayesian spam filtering, naive
@cindex spam filtering, naive Bayesian

Paul Graham は、統計を使った spam の濾過に関する優れたエッセイを書きまし
た: @uref{http://www.paulgraham.com/spam.html,A Plan for Spam}。そこで彼
は SpamAssassin によって使われているようなルールベースの濾過に固有な欠陥
について述べています。例えば: 誰かがルールを書かなければならないし、他の
すべての人はこれらのルールをインストールしなければなりません。あなたはい
つも遅れをとってしまいます。それよりも、それが spam または非-spam に何と
なく似ているかどうかに基づいてメールを濾過するほうがはるかに良いだろうと
彼は主張します。これを測定する一つの手段は単語の分布です。その後彼は、新
着メールがあなたの他の spam メールに似ているかどうかをチェックする方法の
記述に進みます。

基本的な案はこれです: あなたのメールの二つのコレクションを作ります。一つ
は spam、もう一つは非-spam で。両方のコレクションにおける各単語の出現頻
度を数えて、コレクションのメールの総数で重み付けを行ない、この情報を辞書
に格納します。新着メールのすべての単語について、spam か非-spam メールに
属する確率を決定します。15 の最も顕著な単語を使って、そのメール
が spam であることの確率の総計を計算します。この確率がある閾値より高かっ
たら、そのメールは spam であると考えられます。

Gnus はこの種の濾過をサポートします。しかしそれにはいくつかの設定が必要
です。第一に、あなたのメールの二つのコレクションが要ります。一つは spam、
もう一つは非-spam で。そして、それらの二つのコレクションを使って辞書を作
り、それをセーブして下さい。そして特に最後に、あなたの特級分割の規則でこ
の辞書を使って下さい。

@menu
* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::
@end menu

@node Creating a spam-stat dictionary
@subsubsection spam-統計 (spam-stat) 辞書を作る

統計に基づいた spam 濾過を始めるには、あなたは二つのメールのコレクション
に基づいた統計を作らなければなりません。一つは spam もう一つは非-spam で。
そしてそれらの統計は、後で利用するために辞書に格納されます。それらの統計
を意味のあるものにするために、両方のコレクションにつき数百通のメールが必
要です。

今のところ Gnus は nnml バックエンドでだけ辞書の自動生成をサポートします。
nnml バックエンドは一通のメールにつき一つのファイルで、すべてのメールを
ディレクトリーに格納します。以下を使って下さい。

@defun spam-stat-process-spam-directory
このディレクトリーにあるすべてのファイルについて spam の統計を生成します。
すべてのファイルは一つの spam メールとして扱われます。
@end defun

@defun spam-stat-process-non-spam-directory
このディレクトリーにあるすべてのファイルについて非-spam の統計を生成しま
す。すべてのファイルは一つの spam ではないメールとして扱われます。
@end defun

普通は @file{~/Mail/mail/spam} のようなディレクトリー (通
常 @samp{nnml:mail.spam} グループに対応) に対し
て @code{spam-stat-process-spam-directory} を呼ぶでしょう。ま
た @file{~/Mail/mail/misc} のようなディレクトリー (通
常 @samp{nnml:mail.misc} グループに対応) に対し
て @code{spam-stat-process-non-spam-directory} を呼ぶでしょう。

あなたが @acronym{IMAP} を使っているならメールをローカルには持っていない
ので、それは動かないでしょう。一つの解決策は、Gnus エージェントで記事を
キャッシュすることです。そうすれ
ば @code{spam-stat-process-spam-directory} とし
て @file{"~/News/agent/nnimap/mail.yourisp.com/personal_spam"} のような
ものが使えます。@xref{Agent as Cache}.

@defvar spam-stat
この変数はすべての統計のハッシュテーブル---辞書と言っているもの---を持ち
ます。このハッシュテーブルは、双方のコレクションのすべての単語につい
て spam および非-spam メールにおける出現頻度を表すベクトルを格納します。
@end defvar

統計を最初から作り直したいときは、辞書をリセットする必要があります。

@defun spam-stat-reset
@code{spam-stat} ハッシュテーブルをリセットし、すべての統計を削除します。
@end defun

行なったら辞書をセーブしなければなりません。辞書はかなり大きくなるかもし
れません。辞書を追加更新しない場合 (言い換えると、例えば毎月一回作り直す
場合)、頻繁に現れないか、または spam か非-spam のどちらに属するかがはっ
きりしないすべての単語を削除することによって、辞書のサイズを小さくするこ
とができます。

@defun spam-stat-reduce-size
辞書のサイズを小さくします。これは辞書を追加更新したくない場合だけ使って
下さい。
@end defun

@defun spam-stat-save
辞書をセーブします。
@end defun

@defvar spam-stat-file
辞書の格納に使うファイル名です。ディフォルトは @file{~/.spam-stat.el} で
す。
@end defvar

@node Splitting mail using spam-stat
@subsubsection spam-統計 (spam-stat) を使ってメールを分割する

@code{spam-stat} を使ってメールを分割するために、@file{~/.gnus.el} ファ
イルに以下を追加する必要があります。

@lisp
(require 'spam-stat)
(spam-stat-load)
@end lisp

これは必要な Gnus のコードとあなたが作った辞書を load します。

次に、特級分割の規則を適合させる必要があります: どうやっ
て @code{spam-stat} を使うかを決めて下さい。以下の例は nnml バックエンド
用です。nnimap バックエンドでもまったく同様に動作します。単
に @code{nnmail-split-fancy} の代わりに @code{nnimap-split-fancy} を使っ
て下さい。

では @samp{mail.misc} と @samp{mail.spam} の二つのグループだけがある最も
単純な事例ではどうなるか。以下の式はメールが spam であるか、またはそれ
が @samp{mail.misc} に行くべきだと言っています。もし spam だった
ら @code{spam-stat-split-fancy} は @samp{mail.spam} を返します。

@lisp
(setq nnmail-split-fancy
      `(| (: spam-stat-split-fancy)
          "mail.misc"))
@end lisp

@defvar spam-stat-split-fancy-spam-group
Spam 用のグループです。ディフォルトは @samp{mail.spam} です。
@end defvar

特定の表題を持つメールを他のグループに入れる濾過をも行ないたいならば、以
下の式を使って下さい。正規表現に合致しないメールだけを spam かもしれない
と考えます。

@lisp
(setq nnmail-split-fancy
      `(| ("Subject" "\\bspam-stat\\b" "mail.emacs")
          (: spam-stat-split-fancy)
          "mail.misc"))
@end lisp

最初に spam の濾過をしたい場合、辞書を作るときに十分に注意しなければなり
ません。
@code{spam-stat-split-fancy} は @samp{mail.emacs} と @samp{mail.misc} の
どちらのメールも非-spam であると解釈しなければならないので、辞書を作ると
きの非-spam コレクションに両方とも入っていなければならないことに注意して
下さい。

@lisp
(setq nnmail-split-fancy
      `(| (: spam-stat-split-fancy)
          ("Subject" "\\bspam-stat\\b" "mail.emacs")
          "mail.misc"))
@end lisp

これを伝統的な濾過と組み合わせることもできます。ここではすべての HTML だ
けのメールを @samp{mail.spam.filtered} グループに入れるものとしましょう。
@code{spam-stat-split-fancy} はそれらのメールを見ないので、辞書を作ると
きに、@samp{mail.spam.filtered} のメールが spam または非-spam コレクショ
ンのどちらにも入るべきではないことに注意して下さい!

@lisp
(setq nnmail-split-fancy
      `(| ("Content-Type" "text/html" "mail.spam.filtered")
          (: spam-stat-split-fancy)
          ("Subject" "\\bspam-stat\\b" "mail.emacs")
          "mail.misc"))
@end lisp

@node Low-level interface to the spam-stat dictionary
@subsubsection spam-統計 (spam-stat) 辞書への低階層インターフェース

@code{spam-stat} を使うための主インターフェースは以下の関数です:

@defun spam-stat-buffer-is-spam
Spam であると考えられる新着メールがあるバッファーで呼ばれます。処理前の
新着メールに対して使って下さい。
@end defun

@defun spam-stat-buffer-is-no-spam
非-spam であると考えられる新着メールがあるバッファーで呼ばれます。処理前
の新着メールに対して使って下さい。
@end defun

@defun spam-stat-buffer-change-to-spam
Spam ではない通常のメールだとはもはや考えられないメールがあるバッファー
で呼ばれます。すでに非-spam であるものとして処理されてしまったメールの地
位の変更に使って下さい。
@end defun

@defun spam-stat-buffer-change-to-non-spam
通常のメールではない spam だとはもはや考えられないメールがあるバッファー
で呼ばれます。すでに spam であるものとして処理されてしまったメールの地位
の変更に使って下さい。
@end defun

@defun spam-stat-save
ハッシュテーブルをファイルにセーブします。変数 @code{spam-stat-file} で
設定されたファイル名が使われます。
@end defun

@defun spam-stat-load
ハッシュテーブルをファイルから load します。変
数 @code{spam-stat-file} で設定されたファイル名が使われます。
@end defun

@defun spam-stat-score-word
単語の spam スコアを返します。
@end defun

@defun spam-stat-score-buffer
バッファーの spam スコアを返します。
@end defun

@defun spam-stat-split-fancy
特級メール分割のためにこの関数を使って下さい。
@code{nnmail-split-fancy} に規則 @samp{(: spam-stat-split-fancy)} を追加
します。
@end defun

それを使う前に、必ず辞書が load されているようにして下さい。これに
は @file{~/.gnus.el} ファイルに以下が必要です:

@lisp
(require 'spam-stat)
(spam-stat-load)
@end lisp

代表的なテストは以下の関数呼出しを必要とします:

@example
Reset: (setq spam-stat (make-hash-table :test 'equal))
Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
Save table: (spam-stat-save)
File size: (nth 7 (file-attributes spam-stat-file))
Number of words: (hash-table-count spam-stat)
Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")
Reduce table size: (spam-stat-reduce-size)
Save table: (spam-stat-save)
File size: (nth 7 (file-attributes spam-stat-file))
Number of words: (hash-table-count spam-stat)
Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")
@end example

辞書を生成する方法:

@example
Reset: (setq spam-stat (make-hash-table :test 'equal))
Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
Repeat for any other non-spam group you need...
Reduce table size: (spam-stat-reduce-size)
Save table: (spam-stat-save)
@end example

@node Other modes
@section 他のモードとの相互作用

@subsection Dired
@cindex dired

@code{gnus-dired-minor-mode} は dired バッファーで使えるいくつかの便利な
機能を提供します。これは次の式で有効になります:

@lisp
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
@end lisp

@table @kbd
@item C-c C-m C-a
@findex gnus-dired-attach
Dired で印を付けたものを添付ファイルとして送信しま
す (@code{gnus-dired-attach})。Message バッファーで確認を求められます。

@item C-c C-m C-l
@findex gnus-dired-find-file-mailcap
適切な mailcap 項目に従ってファイルを開きま
す (@code{gnus-dired-find-file-mailcap})。接頭引数を付けると、ファイルを
新しいバッファーで開きます。

@item C-c C-m C-p
@findex gnus-dired-print
mailcap 項目に従ってファイルを印刷します (@code{gnus-dired-print})。印刷
コマンドが無い場合は PostScript 画像に印刷します。
@end table

@node Various Various
@section いろいろのいろいろ
@cindex mode lines
@cindex highlights

@table @code
@item gnus-home-directory
@vindex gnus-home-directory
すべての Gnus のファイル名とディレクトリー名の変数は、これによって初期化
されます。ディフォルト値は @file{~/} です。

@item gnus-directory
@vindex gnus-directory
Gnus が格納するたくさんのファイル名とディレクトリー名の変数は、これによっ
て初期化されます。ディフォルト値は @env{SAVEDIR} 環境変数の値か、その変
数が設定されていない場合は @file{~/News/} です。

@file{~/.gnus.el} ファイルが読まれたときは Gnus のほとんどはすでに読み込
まれているということに注意して下さい。これはつまり、この変数
を @file{~/.gnus.el} の中で設定しても、この変数によって初期化される他の
ディレクトリー変数は正しく設定されないだろうということです。この変数は代
わりに @file{.emacs} で設定して下さい。

@item gnus-default-directory
@vindex gnus-default-directory
上記の変数にはまったく関係ありません---この変数はすべての Gnus バッファー
のディフォルトディレクトリーをどうすべきかを設定します。も
し @kbd{C-x C-f} のような命令を実行すると、現在のバッファーのディフォル
トディレクトリーを起点にしたプロンプトが出てくるでしょう。

この変数が @code{nil} (これがディフォルト値) であれば、Gnus を起動したと
きにあなたがいたバッファーのディフォルトディレクトリーがディフォルトディ
レクトリーになるでしょう。

@item gnus-verbose
@vindex gnus-verbose
この変数は 0 から 10 まで間の整数です。大きい数値ほどたくさんのメッセー
ジが表示されます。この変数が 0 であれば Gnus は何のメッセージも見せませ
ん。これが 7 (ディフォルト値) であれば特に重要なメッセージが表示され、
10 であれば Gnus は決してお喋りを止めず、たくさんのメッセージであなたに
めまいを起こさせるでしょう。

@item gnus-verbose-backends
@vindex gnus-verbose-backends
この変数は @code{gnus-verbose} と同様に動作しますが、Gnus 本体ではな
く Gnus のバックエンドに対して適用されます。

@item nnheader-max-head-length
@vindex nnheader-max-head-length
バックエンドが記事のヘッダーをまっすぐ読んでいるときは、できる限り少ない
量だけを読もうと努力します。この変数 (ディフォルト値 4096) は、バックエ
ンドがヘッダーと本文の間の区切り行を見つけるまでに読み込もうとする絶対最
大長を指定します。この変数が @code{nil} であれば、読み込み上限はありませ
ん。もし @code{t} であれば、バックエンドは記事を部分部分で読み込もうとは
せず、記事全体を読み込みます。これは @code{ange-ftp} や @code{efs} のあ
るバージョンで意味をもちます。

@item nnheader-head-chop-length
@vindex nnheader-head-chop-length
この変数 (ディフォルト値 2048) は、前記の操作を行なっているときに、どれ
くらいの大きさの単位で各記事を読み込むかを設定します。

@item nnheader-file-name-translation-alist
@vindex nnheader-file-name-translation-alist
@cindex file names
@cindex invalid characters in file names
@cindex characters in file names
これはファイル名の文字をどのように変換するかを指定する連想リストです。例
えば、もし @samp{:} があなたのシステムではファイル名の文字としては使えな
い場合 (あなたは OS/2 利用者です)、以下のようにすることができます。

@lisp
@group
(setq nnheader-file-name-translation-alist
      '((?: . ?_)))
@end group
@end lisp

実際には、これは OS/2 と (くそ) MS Windows システム上でのこの変数のディ
フォルト値です。

@item gnus-hidden-properties
@vindex gnus-hidden-properties
これは ``不可視'' テキストを隠すために使われる属性のリストです。ほとんど
のシステムではディフォルト値は @code{(invisible t intangible t)} で、こ
れは不可視テキストを見えなくしてさわれなくします。

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
ヘッダーを解釈する前に呼び出されるフック。これは例えば、取得したヘッダー
の統計情報を取るとか、あるいはある種のヘッダーを取り除くことに使うことが
できます。まあ、私は何でこんなものが欲しいかよくわかんないんだけどね。

@item gnus-shell-command-separator
@vindex gnus-shell-command-separator
二つのシェル命令を区切るのに使用される文字列。ディフォルト値
は @samp{;} です。

@item gnus-invalid-group-regexp
@vindex gnus-invalid-group-regexp

利用者にグループ名を確認するときに使う、``使えない'' グループ名に合致す
る正規表現です。既定値は Gnus の内部動作 (選択方法とグループの境界に、通
常 @samp{:} を使っている) をめちゃめちゃにしてしまうかもしれない、いくつ
かの @strong{本当に} 使えないグループ名を捕まえます。

@acronym{IMAP} 利用者はグループ名に @samp{/} を使いたいと思うでしょうけ
れど。
@end table

@node The End
@chapter 終わり

はい、以上がマニュアルです---あなたはもう自分自身の人生を送ることができ
ます。連絡をとって下さい。あなたの猫によろしく伝えて下さい。

おお、@strong{神よ}---さよならを耐えることはできません。(すすり泣き。)

Ol' Charles Reznikoff はそれを非常によく現しているので、ここは彼のために
譲ります:

@quotation
@strong{Te Deum}

@sp 1
Not because of victories @*
I sing,@*
having none,@*
but for the common sunshine,@*
the breeze,@*
the largess of the spring.

@sp 1
Not for victory@*
but for the day's work done@*
as well as I was able;@*
not for a seat upon the dais@*
but at the common table.@*
@end quotation

試訳:

@quotation
@strong{Te Deum}

@sp 1
勝利したからではなく @*
私は歌う @*
何も無いけれど @*
あの日光や @*
息吹や @*
春の大きさのために @*

@sp 1
勝利のためではなく @*
一日の労働のために @*
また、それを達成できたことに @*
高座の上の席のためではなく @*
普通のテーブルのところで @*
@end quotation

@node Appendices
@chapter 付録

@menu
* XEmacs::                      XEmacs でインストールするための要件
* History::                     どうやって Gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 ここにあるような本当に難しい語を使う
* Customization::               あなたの要求に沿って Gnus を仕立てる
* Troubleshooting::             うまくいかなかったときに試すかもしれないこと
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短な導入
* Frequently Asked Questions::  Gnus の FAQ
@end menu

@node XEmacs
@section XEmacs
@cindex XEmacs
@cindex installing under XEmacs

XEmacs はパッケージの蒐集として配布されています。Gnus の XEmacs パッケー
ジが必要とするものは何であれ、あなたはインストールすべきです。今のところ
必要なのは @samp{gnus}, @samp{mail-lib}, @samp{xemacs-base},
@samp{eterm}, @samp{sh-script}, @samp{net-utils}, @samp{os-utils},
@samp{dired}, @samp{mh-e}, @samp{sieve}, @samp{ps-print}, @samp{w3},
@samp{pgg}, @samp{mailcrypt}, @samp{ecrypto} および @samp{sasl} です。

@node History
@section 歴史

@cindex history
@sc{gnus} は梅田政信氏によって書かれました。1994年の夏が忍び寄ってくるこ
ろ、退屈していたラルス・マッグヌ・イングブリグットスン (Lars Magne
Ingebrigtsen) は Gnus を書き直そうと決心しました。

この無礼を行なった人物を調べてみたいのなら、あなたの (くそ!) ウェブブラ
ウザーを @uref{http://quimby.gnus.org/} に向けることができます。これは新
しくて粋な版の Gnus の第一配布場所で、Newsrc をぶっ壊して人々を激怒させ
るサイトとして知られています。

最初のアルファ版の開発期間に、新しい Gnus は ``(ding) Gnus'' と呼ばれて
いました。@dfn{(ding)} はもちろん、@dfn{ding is not Gnus} の短縮形で、こ
れはまったく完全な嘘ですが、だれがそんなことを気にするでしょうか? (とこ
ろで、この短縮形の ``Gnus'' はおそらく梅田さんの意図通り ``ニュース'' と
発音されるべきで、そうするともっと適切な名前になります。そう思いませんか?)

どちらにせよ、すべてのエネルギーを新しい元気の良い名前を付けるのに使い果
たした後、その名前は @emph{あまりに} 元気が良すぎるということになり、そ
れを ``Gnus'' と再び命名しました。でも、今回は大文字と小文字を混ぜていま
す。``Gnus'' と ``@sc{gnus}'' です。新しいもの と 古いもの。

@menu
* Gnus Versions::               どんなバージョンの Gnus がリリースされているか
* Other Gnus Versions::         リリースされている他のバージョンの Gnus
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性があるの?
* Conformity::                  Gnus はすべての標準を満たそうとする
* Emacsen::                     Gnus はいくつかの現代的な Emacs 環境で実行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                大量の人々
* New Features::                Gnus の新しいことに関する手がかり
@end menu

@node Gnus Versions
@subsection Gnus Versions
@cindex ding Gnus
@cindex September Gnus
@cindex Red Gnus
@cindex Quassia Gnus
@cindex Pterodactyl Gnus
@cindex Oort Gnus
@cindex No Gnus
@cindex Gnus versions

最初の ``適切な'' Gnus 5 のリリースは 1995年11月に Emacs 19.30 の配布に
含まれたときになされました (132 の (ding) Gnus のリリース 足すこと
の Gnus5.0 の 15 リリース)。

1996年3月に次の世代の Gnus (別名 ``September Gnus'' (99 リリースの後
で)) が ''Gnus 5.2`` という名前でリリースされました (40 リリース)。

1996年の 7月28日に Red Gnus の作業が始まり、それは 1997年1月25日
に (84 リリースの後で) ``Gnus 5.4'' としてリリースされました (67 リリー
ス)。

1997年9月13日に、Quassia Gnus が開始され、37 リリース続きました。それ
は ``Gnus 5.6'' として 1998年3月8日にリリースされました (46 リリース)。

1998年8月29日に Gnus 5.6 から Pterodactyl Gnus が生まれ、1999年12月3日
に (99 リリースと CVS リポジトリでの作業の後) ``Gnus 5.8'' としてリリー
スされました。

2000年10月26日に Oort Gnus が開始されました。

もし接頭語を持った版の Gnus---``(ding) Gnus'', ``September Gnus'',
``Red Gnus'', ``Quassia Gnus'', ``Pterodactyl Gnus'',
``Oort Gnus''---に出会っても、混乱しないで下さい。あなたが恐がっているこ
とを知られてはいけません。後ろに下がりなさい。ゆっくりと。他に何をしても、
走ってはいけません。それが届かくなるまで、静かに歩き去りなさい。適切にリ
リースされた版の Gnus を見つけて、代わりにそれに寄り添って下さい。

@node Other Gnus Versions
@subsection 他の Gnus のバージョン
@cindex Semi-gnus

Lars さんが調製してリリースした Gnus に加えて、日本では Semi-gnus の開発
が行なわれています。これは @acronym{SEMI} という @acronym{MIME} の機能を
実現するためのライブラリを使うことを前提としています。

これらの Gnus は、主に Gnus 5.6 と Pterodactyl Gnus を元にしています。そ
れらは ``Semi-gnus'' と総称され、T-gnus, Nana-gnus および Chaos の異なっ
た系統があります。これらは強力な @acronym{MIME} の機能と各国語対応の機能
を提供するもので、特に日本人の利用者にとって大事なものです。

@node Why?
@subsection なぜ?

Gnus の目的は何ですか?

私は、あなたの考え付くことをすべてでき
る ``すばらしい'' ``かっこいい'' ``いかす'' ``はやりの'' ニュースリーダ
を提供したいと思います。これは私の大元の動機ですが、Gnus の作業をしてい
る間に、この世代のニュースリーダーは本当に石器時代に属しているということ
が明らかになりました。ニュースリーダーは、インターネットの幼児期からほと
んど発展していませんでした。もし現在の増加率で量が増加しつづければ、すべ
ての現在のニュースリーダーはまったく役に立たなくなるでしょう。一日
に 1000 やもっとたくさんの新しい記事のあるニュースグループを扱うにはどう
すれば良いのでしょう? 投稿をする百万やそれより多い人々に遅れないように付
いていくにはどうすれば良いのでしょう?

Gnus はこれらの質問に本当の解決を提案しますが、私は Gnus がニュースを読
み、取得するための新しい方法を実験する場として使われて欲しいです。梅田さ
んのニュースリーダーをバックエンドから分離するという賢明な方針を拡張する
ことによって、Gnus はメールを取得したり、違ったところからニュースを取得
するための新しいバックエンドを書きたい人のために、簡単で単純なインター
フェースを提供しています。私は、役に立つであろうという部分にすべて、カス
タマイズのためのフックを加えました。それをすることによって、探検し、発明
したいすべての人を招いているのです。

おそらく Gnus は完成することはないのかもしれません。
@kbd{C-u 100 M-x all-hail-emacs} と @kbd{C-u 100 M-x all-hail-xemacs} で
す。

@node Compatibility
@subsection 互換性

@cindex compatibility
Gnus は @sc{gnus} と完全に互換性があるように設計されています。ほとんどす
べてのキーバインディングはそのまま残っています。もちろん、多くのキーバイ
ンディングが追加されましたが、一つか二つのあいまいな場合を除いて、古いバ
インディングが変更されたことはありません。

私たちのモットーは:
@quotation
@cartouche
@center 鋼鉄の骨組みの空高く。
@end cartouche
@end quotation
です。

すべての命令はその名前が変わっていません。いくつかの内部関数は名前を変え
ました。

@code{gnus-uu} パッケージは劇的に変化しています。@xref{Decoding
Articles}.

一つの主要な互換性の質問は、いくつかの概略バッファーが存在することです。
すべてのグループを読み込むときに関連する変数はそれが属する概略バッファー
のバッファー固有です。多くの重要な変数はそれの全体の版にも複製されますが、
概略バッファーで命令が実行されると、この変更は、あなたが注意していないと、
正しくない値になるかもしれません。

@sc{gnus} の内部の知識に依存したすべてのコードは実行できないでしょう。二
つ例を挙げます: @code{gnus-newsrc-alist} の並べ替え (もしくは、実際は何
らかの方法でそれを変更すること) は絶対に禁止されています。Gnus はこの連
想リストの登録を指し示すハッシュテーブルを保持しており (それは多くの関数
の速度を上げます)、直接連想リストを変更することは異常な結果をもたらすで
しょう。

@cindex hilit19
@cindex highlighting
古い hilit19 のコードはまったく動作しません。実際のところ、おそらくすべ
ての hilit コードをすべての Gnus のフッ
ク (@code{gnus-group-prepare-hook} およ
び @code{gnus-summary-prepare-hook}) から取り除くべきでしょう。Gnus はハ
イライトのためのいろいろな統合された関数を提供します。これらはもっと速く
もっと正確です。すべての人の人生を楽にするために、Gnus はディフォルトで
すべての hilit フックからすべての hilit 呼び出しを取り除きます。きたない
もの! とんでけ!

@code{expire-kill} のようなパッケージはもう動作しません。実際、Gnus を使
い始めたときには、おそらくすべての古い @sc{gnus} パッケージ (と他のコー
ド) を消去するべきでしょう。@sc{gnus} に実行させるために書いたコードは、
Gnus がすでに実行しているということは良くあることです。(くすくす。)

ものごとを実行する古い方法はまだ使用できますが、新しい方法だけがこのマニュ
アルに記載されています。もしこのマニュアルを読んでいる間に何かをする新し
い方法を発見しても、古い方法を止めなければならないということではありませ
ん。

Gnus はすべての @sc{gnus} 起動ファイルを理解します。

@kindex M-x gnus-bug
@findex gnus-bug
@cindex reporting bugs
@cindex bugs
全体として、@sc{gnus} の内部に依存したコードをほとんど書いていない普通の
利用者は問題に苦しむことはないでしょう。問題が起これば、魔法
の @kbd{M-x gnus-bug} 命令を実行することによって私に知らせて下さい。

@vindex gnus-bug-create-help-buffer
@emph{非常に} よくバグ報告を送る癖があるのであれば、しばらくすると役に立
つ help バッファーがうるさいと感じるかもしれません。そうであれば、それが
表示されるのを避けるために、
@code{gnus-bug-create-help-buffer} を @code{nil} に設定して下さい。

@node Conformity
@subsection 一致性

これは理由無き反抗、じゃないですよ、奥さん。私たちはすべての知られている
標準に沿っています。もちろん私たちが賛成できない標準と/もしくは習慣は除
きますが。

@table @strong
@item RFC (2)822
@cindex RFC 822
@cindex RFC 2822
この標準への知られている違反はありません。

@item RFC 1036
@cindex RFC 1036
この標準も知られている違反はありません。

@item Son-of-RFC 1036
@cindex Son-of-RFC 1036
これにはいくつかの違反があります。

@table @emph
@item X-Newsreader
@item User-Agent
これは ``つまらないヘッダー'' と考えられていますが、私は消費者の情報であ
ると見なしています。@code{tin} と @code{Netscape} から送られてくる非常に
多くの様式に沿っていない記事を見た後で、私はそれらを記事を投稿するために
は使わない方が良いということを知りました。もし @code{X-Newsreader} ヘッ
ダーが無ければ私はその情報を得ることはなかったでしょう。
@end table

@item USEFOR
@cindex USEFOR
USEFOR は、IETF の working group が Son-of-RFC 1036 に基づいて、
RFC 1036 の後継として書いているものです。ニュース記事の様式に対して、い
ろいろな変更を提案した draft を作成しました。Gnus タワー
は draft が RFC として認められたときに変更の実装を調べることになるでしょ
う。

@item MIME - RFC 2045-2049 etc
@cindex @acronym{MIME}
@acronym{MIME} 関連のすべての RFC がサポートされています。

@item Disposition Notifications - RFC 2298
Message Mode は受信者に開封確認を要求することができます。

@item PGP - RFC 1991 and RFC 2440
@cindex RFC 1991
@cindex RFC 2440
RFC 1991 は最初の @acronym{PGP} メッセージの規格で、Informational
RFC (訳注: 後述の標準化トラックではないが有用な情報) として発行されまし
た。現在 Open PGP と呼ばれる後継の RFC 2440 が、標準化トラック (訳注:
Standards Track---国際標準とすべき仕様) に乗せられました。どちらも
非-@acronym{MIME} メッセージのための @acronym{PGP} の様式を定義します。
Gnus はエンコード (署名および暗号化) とデコード (認証および暗号のデコー
ド) の両方をサポートします。

@item PGP/MIME - RFC 2015/3156
RFC 2015 (RFC 1991 の代わりに RFC 2440 に基づいた 3156 で置き換えられま
した) は、RFC 1991/2440 を @acronym{MIME} で囲う様式について述べています。
Gnus はエンコードとデコードの両方をサポートします。

@item S/MIME - RFC 2633
RFC 2633 は @acronym{S/MIME} の形式について述べています。

@item IMAP - RFC 1730/2060, RFC 2195, RFC 2086, RFC 2359, RFC 2595, RFC 1731
RFC 1730 は @acronym{IMAP} バージョン 4 で、RFC 2060 (@acronym{IMAP}
4 改定 1) で多少更新されています。
RFC 2195 は @acronym{IMAP} の CRAM-MD5 認証について述べています。
RFC 2086 は @acronym{IMAP} の使用制限一覧 (ACL) について述べています。
RFC 2359 は @acronym{IMAP} のプロトコルの拡張について述べています。
RFC 2595 は @acronym{IMAP} における適切な @acronym{TLS} の統
合 (STARTTLS) について述べています。
RFC 1731 は @acronym{IMAP} の GSSAPI/Kerberos4 の手法について述べていま
す。
@end table

上に書かれている文章に関することで、Gnus がそれを満たしていないような動
作をしていることに気付いたら、ためらわずに Gnus タワーと私たちに知らせて
下さい。

@node Emacsen
@subsection Emacsen
@cindex Emacsen
@cindex XEmacs
@cindex Mule
@cindex Emacs

Gnus は以下のもので動作します:

@itemize @bullet

@item
Emacs 21.1 とそれ以上。

@item
XEmacs 21.4 以上の Mule 機能付き

@end itemize

この Gnus の版はこれより古いどんな Emacsen でも完全に動作しないでしょう。
少なくとも、信頼できる動作はしないでしょう。古い版の Gnus は古
い Emacs の版でも動作するでしょう。

いろいろなプラットフォームの Gnus の間にはいくつかの漠然とした違いがあり
ます---XEmacs はもっと画像機能 (ロゴとツールバー) を特徴にしていま
す---しかし、その他は、すべての Emacsen でほとんど同じはずです。

@node Gnus Development
@subsection Gnus の開発

Gnus は二つの段階の循環で開発されています。最初の段階
は @samp{ding@@gnus.org} でのたくさんの議論があり、そこで変更や新しい機
能を提案します。この段階は @dfn{アルファ} 段階と呼ばれます。というのは、
この段階でリリースされた Gnusae は @dfn{アルファリリース} もしくは (他
の団体ではより良く使われる) @dfn{スナップショット} と呼ばれるものだから
です。この段階では、Gnus は不安定であると考えられており、一般の利用者に
よって使われるものではありません。Gnus アルファリリース
は ``Red Gnus'' や ``Quassia Gnus'' のような名前になっています。

50-100 くらいのリリースの後で、Gnus は @dfn{凍結} されたと宣言され、バグ
修正のみが適用されます。Gnus は接頭語が取れ、その代わり
に ``Gnus 5.6.32'' のように呼ばれます。これら普通の人が使うことのできる
ものと考えられ、主に @samp{gnu.emacs.gnus} ニュースグループで議論されて
います。

@cindex Incoming*
@vindex mail-source-delete-incoming
アルファ Gnusae とリリースされた Gnusae では変数のディフォルト値が違うも
のがあります。特に、@code{mail-source-delete-incoming} はアル
ファ Gnusae では @code{nil} で、リリースされた Gnusae では @code{t} です。
これはメールを扱っている際に、アルファリリースの齟齬によりメールを失なう
ことを避けるためです。

ding メーリングリストと Gnus ニュースグループにおける議論の分離は純粋に
公衆の関心によってなされているわけではありません。アルファ Gnus リリース
が (ときどき) するかもしれない恐ろしいことを公衆の場で書くのは、皆を恐れ
させるというのも事実ですが、もっと重要なことは、導入された新しい実験的な
機能について話すことは一般の使用者を混乱させる可能性があります。新しい機
能は頻繁に導入され、いじくられ、不十分であると判断され、そうすると捨てら
れるか、完全に書き換えられるかのどちらかです。メーリングリストを読んでい
る人は普通はこの速い変更に付いていきますが、ニュースグループの人もそうで
あるとみなすことはできません。

@node Contributors
@subsection 貢献者
@cindex contributors

新しい Gnus の版は (ding) メーリングリストのすべての人の助けが無ければで
きなかったでしょう。一年以上、私は毎日とてもたくさんの素敵なバグレポート
を受け取り、そのそれぞれが私を喜びで満たしました。愛撫。このリストの人々
は忍耐を超えて私の ``あぁ、それはすばらしい考えだ <type type>、うん、私
は待たずにそれをすぐリリースしよう <ship off>、それはまったく動作しな
い <type type>、うん、私はすぐに出そう <ship off> いや、纏う、それはまっ
たく動作しないぞ''' というリリースに関する主義を変えて試してきた人々です。
Micro$oft---あぁ。アマチュア。私は @emph{もっと} 悪い。(もしくは、``より
悪い''? ``もっと悪い''? ``最悪''?)

私はこの機会にこの学会に@dots{} おおっと、違った。

@itemize @bullet

@item
梅田政信---元の @sc{gnus} を書いた人です。

@item
Shenghuo Zhu---uudecode.el, mm-uu.el, rfc1843.el, webmail.el,
nnwarchive と @acronym{MIME} と他の形式のエンコード/デコードやバグ修正、
新しい機能などのほんとうに多くのもの。

@item
Per Abrahamsen---custom、スコア、ハイライトと @sc{soup} コード (他の多く
のことと共に)。

@item
Luis Fernandes---デザインとグラフィック。

@item
Joe Reiss---スマイリーの顔の作者。

@item
Justin Sheehy---@acronym{FAQ} のメインテイナー。

@item
Erik Naggum---援助、考え、サポート、コードとその他。

@item
Wes Hardaker---@file{gnus-picon.el} と @dfn{picon} の部分のマニュア
ル (@pxref{Picons})。

@item
Kim-Minh Kaplan---picon コードに置ける更なる作業。

@item
Brad Miller---@file{gnus-gl.el} と Grouplens の部分のマニュアル。

@item
Sudish Joseph---数え切れないほどのバグの修正。

@item
Ilja Weis---@file{gnus-topic.el}。

@item
Steven L. Baur---たくさんのたくさんのたくさんのバグの発見と修正。

@item
Vladimir Alexiev---refcard とリファレンスの小冊子。

@item
Felix Lee & Jamie Zawinski---私は Felix Lee と JWZ の XGnus 配布からいく
つかの部分を盗みました。

@item
Scott Byer---@file{nnfolder.el} の拡張と改訂。

@item
Peter Mutsaers---古事記事のスコアコード。

@item
Ken Raebburn---@acronym{POP} メールサポート。

@item
Hallvard B Furuseth---いろいろな小さな物や部分、特に .newsrc ファイルを
扱う部分。

@item
Brian Edmonds---@file{gnus-bbdb.el}。

@item
David Moore---@file{nnvirtual.el} の改訂と多くの他のこと。

@item
Kevin Davidson---@dfn{ding} の名前を思い付きました。ですから、彼を責めて
下さい。

@item
Fran,Agois Pinard---多くの、多くの興味深く完全なバグレポートと autoconf の
サポート。
@end itemize

このマニュアル (Gnus 英語版) は Adrian Aichner と Ricardo Nassif, Mark
Borges によって校正され、Jost Krieger によって一部分を校正されました。

以下の人々は多くのパッチと提案で貢献しました:

Christopher Davis,
Andrew Eskilsson,
Kai Grossjohann,
Kevin Greiner,
Jesper Harder,
Paul Jarc,
Simon Josefsson,
David K,Aegedal,
Richard Pieri,
Fabrice Popineau,
Daniel Quinlan,
Michael Shields,
Reiner Steib,
Jason L. Tibbitts, III,
Jack Vinson,
山岡 克美,
and
Teodor Zlatanov.

それと、以下の人にもパッチやその他のものを感謝します:

Jari Aalto,
Adrian Aichner,
Vladimir Alexiev,
Russ Allbery,
Peter Arius,
Matt Armstrong,
Marc Auslander,
Miles Bader,
Frank Bennett,
Alexei V. Barantsev,
Robert Bihlmeyer,
Chris Bone,
Mark Borges,
Mark Boyns,
Rob Browning,
Lance A. Brown,
Kees de Bruin,
Martin Buchholz,
Joe Buehler,
Kevin Buhr,
Alastair Burt,
Joao Cachopo,
Zlatko Calusic,
Massimo Campostrini,
Castor,
David Charlap,
Dan Christensen,
Kevin Christian,
Jae-you Chung, @c ?
James H. Cloos, Jr.,
Laura Conrad,
Michael R. Cook,
Glenn Coombs,
Andrew J. Cosgriff,
Neil Crellin,
Frank D. Cringle,
Geoffrey T. Dairiki,
Andre Deparade,
Ulrik Dickow,
Dave Disser,
Rui-Tao Dong, @c ?
Joev Dubach,
Michael Welsh Duggan,
Dave Edmondson,
Paul Eggert,
Mark W. Eichin,
Karl Eichwalder,
榎並　嗣智,
Michael Ernst,
Luc Van Eycken,
Sam Falkner,
Nelson Jose dos Santos Ferreira,
Sigbjorn Finne,
Sven Fischer,
Paul Fisher,
Decklin Foster,
Gary D. Foster,
Paul Franklin,
Guy Geens,
Arne Georg Gleditsch,
David S. Goldberg,
Michelangelo Grigni,
Dale Hagglund,
D. Hall,
Magnus Hammerin,
半田 剣一,
Raja R. Harinath,
林 芳樹,
P. E. Jareth Hein,
久重 Kenji,
Scott Hofmann,
Marc Horowitz,
Gunnar Horrigmo,
Richard Hoskins,
Brad Howes,
Miguel de Icaza,
Fran,Agois Felix Ingrand,
市川 達
哉, 石川 一郎,
Lee Iverson,
岩室 元典,
Rajappa Iyer,
Andreas Jaeger,
Adam P. Jenkins,
Randell Jesup,
Fred Johansen,
Gareth Jones,
Greg Klanderman,
Karl Kleinpaste,
Michael Klingbeil,
Peter Skov Knudsen,
小林 修平,
Petr Konecny,
小関 吉則,
Thor Kristoffersen,
Jens Lautenbacher,
Martin Larose,
Seokchan Lee, @c Lee
Joerg Lenneis,
Carsten Leonhardt,
James LewisMoss,
Christian Limpach,
Markus Linnala,
Dave Love,
Mike McEwan,
Tonny Madsen,
Shlomo Mahlab,
Nat Makarevitch,
Istvan Marko,
David Martin,
Jason R. Mastaler,
Gordon Matzigkeit,
Timo Metzemakers,
Richard Mlynarik,
Lantz Moore,
守岡 知彦,
Erik Toubro Nielsen,
Hrvoje Niksic,
Andy Norman,
Fred Oberhauser,
C. R. Oldham,
Alexandre Oliva,
Ken Olstad,
大西 雅
晴, 小野 秀貴,
Ettore Perazzoli,
William Perry,
Stephen Peters,
Jens-Ulrik Holger Petersen,
Ulrich Pfeifer,
Matt Pharr,
Andy Piper,
John McClary Prevost,
Bill Pringlemeir,
Mike Pullen,
Jim Radford,
Colin Rafferty,
Lasse Rasinen,
Lars Balker Rasmussen,
Joe Reiss,
Renaud Rioboo,
Roland B. Roberts,
Bart Robinson,
Christian von Roques,
Markus Rost,
Jason Rumney,
Wolfgang Rupprecht,
Jay Sachs,
Dewey M. Sasser,
Conrad Sauerwald,
Loren Schall,
Dan Schmidt,
Ralph Schleicher,
Philippe Schnoebelen,
Andreas Schwab,
Randal L. Schwartz,
Justin Sheehy,
Danny Siu,
Matt Simmons,
Paul D. Smith,
Jeff Sparkes,
Toby Speight,
Michael Sperber,
Darren Stalder,
Richard Stallman,
Greg Stark,
Sam Steingold,
Paul Stevenson,
Jonas Steverud,
Paul Stodghill,
須藤 清一,
Kurt Swanson,
Samuel Tardieu,
Teddy,
戸沢 晶彦,
Chuck Thompson,
Philippe Troin,
James Troup,
Trung Tran-Duc,
Jack Twilley,
Aaron M. Ucko,
Aki Vehtari,
Didier Verna,
Vladimir Volovich,
Jan Vroonhof,
Stefan Waldherr,
Pete Ware,
Barry A. Warsaw,
Christoph Wedler,
Joe Wells,
Lee Willis,
and
Lloyd Zusman.

それぞれの人々が行なったことの完全な概観を得るために、
ChangeLog が Gnus のアルファ配布には含まれていて、豊富な読み物を与えるで
しょう。(550KB といくらか)。

私が忘れたすべての人に謝罪します。間違いなくたくさんの人を忘れていること
でしょう。

わぁ、こんなに人がいるとは思わなかった。これは本当に Gnus を使っている人
がいるということなんでしょう。そんなことを誰が想像したでしょうか!

@node New Features
@subsection 新しい機能
@cindex new features

@menu
* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の新しいこと
* September Gnus::              公式に Gnus 5.2/5.3 として知られているもの
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            五番目、P で始まる、もしくは Gnus 5.8/5.9 として知られているもの
* Oort Gnus::                   巨大な。遠く遥かな。Gnus 5.10/5.11。
* No Gnus::                     Lars さん、直して!
@end menu

このリストは、もちろん、@emph{たいていの} 重要な新しい機能に関す
る @emph{短い} 概観でしかありません。いいえ、本当はそうではありません。
もっともっとたくさんのものがあります。はい、私たちは創造性の完全な効果を
感じているのです。

@node ding Gnus
@subsubsection (ding) Gnus

Gnus 5.0/5.1 の新しい機能:

@itemize @bullet

@item
すべてのバッファーの外観はフォーマットのような変数 (@xref{Group Buffer
Format}, @ref{Summary Buffer Format}) によって設定を変えることができるよ
うになりました。

@item
ローカルスプールと、いくつかの @acronym{NNTP} サーバーを同時に使うことが
できるようになりました (@pxref{Select Methods})。

@item
複数のグループを仮想グループに合併できるようになりました (@pxref{Virtual
Groups})。

@item
多くの違ったメール様式 (@pxref{Getting Mail}) を読めるようになりました。
すべてのメールバックエンドは便利なメール期限切れ消去機構を実装していま
す (@pxref{Expiring Mail})。

@item
Gnus は根っこ (root) を失ったスレッドを集めるためのいろいろな戦略 (それ
によってまばらな副スレッドを一つのスレッドにする) を使ったり、いったん戻っ
て完全なスレッドをくみ上げるのに十分なヘッダーを取得しすることができま
す (@pxref{Customizing Threading})。

@item
切られたグループ (killed group) はぐループバッファーに表示することができ
て、それも読むことができます (@pxref{Listing Groups})。

@item
Gnus は部分的グループ更新をすることができます---2,3 のグループの新しい記
事を調べるためにアクティブファイル全体を取得する必要はありませ
ん (@pxref{The Active File})。

@item
Gnus はグループの段階的購読度を実装しました (@pxref{Group Levels})。

@item
任意の数の基準に従って記事にスコアを付けることができます (@pxref{Scoring})。
あなたのために記事をどのようにスコアを付けるかを Gnus に見つけさせること
もできます (@pxref{Adaptive Scoring})。

@item
Gnus は普通の Emacs の方法で自動保存されるドリブルバッファーを保持してい
るので、あなたのマシンが落っこちたときでもあまりデータを失わないでしょ
う (@pxref{Auto Save})。

@item
Gnus は今や @file{.emacs} ファイルをぐちゃぐちゃにすることを避けるために
専用の起動ファイル (@file{~/.gnus.el}) を持つようになりました。

@item
グループと記事の両方にプロセス印を付けることができ、すべての印の付いた項
目に演算をすることができます (@pxref{Process/Prefix})。

@item
グループの一部を grep して、その結果からグループを作ることができま
す (@pxref{Kibozed Groups})。

@item
えーと、すべてにしたがって、グループの一覧を挙げることができま
す (@pxref{Listing Groups})。

@item
外部サーバーを概観して、それらのサーバーのグループを購読することができま
す (@pxref{Browse Foreign Server})。

@item
Gnus はサーバーとの二つ接続で、記事を非同期にとってくることができま
す (@pxref{Asynchronous Fetching})。

@item
記事をローカルにキャッシュすることができます (@pxref{Article Caching})。

@item
uudecode の関数が拡張され、一般化されました (@pxref{Decoding Articles})。

@item
過去の @sc{gnus} のあまり知られていない機能の uuencode された記事をまだ
投稿することができます (@pxref{Uuencoding and Posting})。

@item
親記事 (と他の記事) の取得は、今や実際に突然故障することなく動作するよう
になりました (@pxref{Finding the Parent})。

@item
Gnus は @acronym{FAQ} とグループの記述を取得することができま
す (@pxref{Group Information})。

@item
記事をハイライトし、カスタマイズすることができます (@pxref{Customizing
Articles})。

@item
URL と他の外部参照がボタンになるようになりました (@pxref{Article
Buttons})。

@item
Gnus のウィンドウとフレームの設定でたくさんの変なことをできるようになり
ました (@pxref{Window Layout})。

@item
キーボードを使う代わりに、ボタンをクリックできるようになりまし
た (@pxref{Buttons})。
@end itemize

@node September Gnus
@subsubsection September Gnus

@iftex
@iflatex
\gnusfig{-28cm}{0cm}{\epsfig{figure=ps/september,height=20cm}}
@end iflatex
@end iftex

Gnus 5.2/5.3 の新しい機能:

@itemize @bullet

@item
新しいメッセージ作成モードが使われます。
@code{mail-mode}, @code{rnews-reply-mode} と @code{gnus-msg} のすべての
古いカスタマイズ変数は今や旧式になりました。

@item
Gnus は @dfn{まばら} スレッドを作成することができるようになりました---ス
レッドの失われた記事があるところは空の節で表現されるようになっていま
す (@pxref{Customizing Threading})。

@lisp
(setq gnus-build-sparse-threads 'some)
@end lisp

@item
外に出ていく記事は特別な保管サーバーに保存されるようになりまし
た (@pxref{Archived Messages})。

@item
記事が参照されたときに、スレッドの部分作成が起こるようになりました。

@item
Gnus は GroupLens の予言を使うことができるようになりました。

@item
Picons (personal icons) (個人アイコン) が XEmacs で表示できるようになり
ました (@pxref{Picons})。

@item
@code{trn} のような木バッファーが表示されるようになりました (@pxref{Tree
Display})。

@lisp
(setq gnus-use-trees t)
@end lisp

@item
@code{nn} のような取って読むマイナーモードが概略バッファーで使うことがで
きるようになりました (@pxref{Pick and Read})。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@item
バイナリーグループで特別なバイナリーマイナーモードを使うことができるよう
になりました (@pxref{Binary Groups})。

@item
Group が折り畳みトピック階層にグループ分けできるようになりまし
た (@pxref{Group Topics})。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@item
Gnus が失敗メールを再送できるようになりました (@pxref{Summary Mail
Commands})。

@item
グループがスコアを持つことができるようになり、訪れる回数に基づいて並べ替
えをできるようになりました (@pxref{Group Score})。

@lisp
(add-hook 'gnus-summary-exit-hook 'gnus-summary-bubble-group)
@end lisp

@item
グループにプロセス印を付けられるようになり、グループのぐループに命令が実
行できるようになりました (@pxref{Marking Groups})。

@item
仮想グループでキャッシュができるようになりました。

@item
@code{nndoc} はすべての集配配送、メールボックス、rnews ニュース一括、
ClariNet 短収集、そしてすべてのその他を理解できるようになりまし
た (@pxref{Document Groups})。

@item
Gnus は SOUP パケットを作成/読み込みをするための新しいバックエン
ド (@code{nnsoup}) を持っています。

@item
Gnus キャッシュがずっと速くなりました。

@item
グループを多くの基準に従って並べ替えできるようになりまし
た (@pxref{Sorting Groups})。

@item
アドレスのリストと期限切れ消去の時間を設定する新しいグループパラメーター
が導入されました (@pxref{Group Parameters})。

@item
すべてのフォーマット指定が使われるフェースを指定できるようになりまし
た (@pxref{Formatting Fonts})。

@item
@kbd{M P} 副マップにプロセス印の付いた記事の設定/削除/実行のためのいくつ
かの命令があります (@pxref{Setting Process Marks})。

@item
広い範囲の基準に基づいて、概略バッファーが可能な記事の部分の表示に制限で
きるようになりました。これらの命令は @kbd{/} 副マップのキーにバインドさ
れています (@pxref{Limiting})。

@item
@kbd{*} 命令によって、記事を永続にすることができるようになりまし
た (@pxref{Persistent Articles})。

@item
記事の要素を隠すすべての関数は切り替え関数になりました。

@item
記事のヘッダーがボタンにすることができるようになりました (@pxref{Article
Washing})。

@item
すべてのメールバックエンドで @code{Message-ID} による記事の取得を使用で
きるようになりました。

@item
重複メールを適切に扱うことができるようになりました (@pxref{Duplicates})。

@item
すべての概略モード命令が記事バッファーから直接使用できるようになりまし
た (@pxref{Article Keymap})。

@item
フレームが @code{gnus-buffer-configuration} の部分になることができま
す (@pxref{Window Layout})。

@item
デーモンのプロセスでメールを再走査することができるようになりまし
た (@pxref{Daemons})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fseptember,height=5cm}]{\epsfig{figure=ps/fseptember,height=5cm}}
@end iflatex
@end iftex

@item
Gnus は spam を根絶やしにするために NoCeM ファイルを使うことができるよう
になりました (@pxref{NoCeM})。

@lisp
(setq gnus-use-nocem t)
@end lisp

@item
グループを永久可視にすることができるようになりました (@pxref{Listing
Groups})。

@lisp
(setq gnus-permanently-visible-groups "^nnml:")
@end lisp

@item
カスタマイズを簡単にするために多くの新しいフックが導入されました。

@item
Gnus は @code{Mail-Copies-To} ヘッダーに注意を払うようになりました。

@item
@code{References} ヘッダーを集めることによりスレッドを集めることができる
ようになりました (@pxref{Customizing Threading})。

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@item
既読記事は再取得を避けるために特別なバックログバッファーに貯められるよう
になりました (@pxref{Article Backlog})。

@lisp
(setq gnus-keep-backlog 50)
@end lisp

@item
簡単にトリートメントができるようにするために、現在の記事のきれいな複製が
いつも別バッファーに蓄積されるようになりました。

@item
Gnus がどこに記事を保存するかを提案できるようになりました (@pxref{Saving
Articles})。

@item
Gnus は保存するときに同じくらいの入力要求をしなくても良いようになりまし
た (@pxref{Saving Articles})。

@lisp
(setq gnus-prompt-before-saving t)
@end lisp

@item
@code{uu} は記事を取得している間に非同期でデコードされたファイルを表示で
きるようになりました (@pxref{Other Decode Variables})。

@lisp
(setq gnus-uu-grabbed-file-functions 'gnus-uu-grab-view)
@end lisp

@item
引用された文章に対して、記事バッファーでの折り返しが適切に動作するように
なりました (@pxref{Article Washing})。

@item
隠された引用文は隠すことを切り替えるボタンを加え、どのくらいの引用文を隠
すかをカスタマイズできるようになりました (@pxref{Article Hiding})。

@lisp
(setq gnus-cited-lines-visible 2)
@end lisp

@item
退屈なヘッダーを隠すことができます (@pxref{Article Hiding})。

@item
スコアのディフォルト値がメニューバーから設定できるようになりました。

@item
出て行く記事の更なる構文チェックができるようになりました。
@end itemize

@node Red Gnus
@subsubsection Red Gnus

Gnus 5.4/5.5 の新しい機能:

@iftex
@iflatex
\gnusfig{-5.5cm}{-4cm}{\epsfig{figure=ps/red,height=20cm}}
@end iflatex
@end iftex

@itemize @bullet

@item
@file{nntp.el} は非同期の流儀で完全に改訂されました。

@item
スコア付けは @code{and}, @code{or}, @code{not} のような論理演算子と、親
の再方向で実行できるようになりました (@pxref{Advanced Scoring})。

@item
記事の洗濯状態が記事モード行に表示されるようになりまし
た (@pxref{Misc Article})。

@item
@file{gnus.el} が多くの小さいファイルに分割されました。

@item
Message-ID に基づいた、重複記事の抑制がなされるようになりまし
た (@pxref{Duplicate Suppression})。

@lisp
(setq gnus-suppress-duplicates t)
@end lisp

@item
どのスコアと適応ファイルがホームのスコアと適応ファイルであるかを指定す
る (@pxref{Home Score File}) 新しい変数が加えられました。

@item
@code{nndoc} が簡単に拡張可能になるように改訂されまし
た (@pxref{Document Server Internals})。

@item
グループは親のトピックからグループパラメーターを継承できるようになりまし
た (@pxref{Topic Parameters})。

@item
記事編集が改訂され、実際に使用可能になりました。

@item
署名がもっと知的な方法で認識されるようになりました (@pxref{Article
Signature})。

@item
概略ピックモードがもっと @code{nn} のようになりました。行数が表示されて、
@kbd{.} 命令が記事を取るために使うことができるようになりまし
た (@code{Pick and Read})。

@item
あるサーバーから別のサーバーへ @file{.newsrc.eld} を移動する命令が加えら
れました (@pxref{Changing Servers})。

@item
今や、バッファーの行を作成するときに、抑制される ``おもしろくない'' 部分
を指定する方法があります (@pxref{Advanced Formatting})。

@item
グループバッファーでのいくつかの命令は @kbd{C-M-_} で元に戻すことができ
るようになりました (@pxref{Undo})。

@item
新しいスコアの型 @code{w} を使うことで、語にスコア付けをすることが可能に
なりました (@pxref{Score File Format})。

@item
表題に一語一語を基にして適応スコアをできるようになりまし
た (@pxref{Adaptive Scoring})。

@lisp
(setq gnus-use-adaptive-scoring '(word))
@end lisp

@item
スコアが腐敗できるようになりました (@pxref{Score Decays})。

@lisp
(setq gnus-decay-scores t)
@end lisp

@item
日付のヘッダーに正規表現を使ってスコア付けを実行できるようになりました。
日付はまず短縮 ISO 8601 様式で正規化されます (@pxref{Score File Format})。

@item
基本サーバーの記事に関するすべてのデータを取り除く命令が加えられまし
た (@pxref{Changing Servers})。

@item
文書の集合を読むための新しい命令 (@code{nndoc} と @code{nnvirtual} の上
で) が加えられました---@kbd{C-M-d} (@pxref{Really Various Summary
Commands})。

@item
プロセス印の設定が push と pop できるようになりました (@pxref{Setting
Process Marks})。

@item
新しいメールからニュースへのバックエンドが @acronym{NNTP} サーバーが投稿
を許可していない場合でも、投稿できるようになりまし
た (@pxref{Mail-To-News Gateways})。

@item
ウェブ検索エンジ
ン (@dfn{DejaNews}, @dfn{Alta Vista}, @dfn{InReference}) からの検索結果
を読む新しいバックエンドが加えられました (@pxref{Web Searches})。

@item
標準の並べ替え関数を使ってグループの中のトピックを並び代えすることができ、
それぞれのトピックが独立して並べ替えできるようになりまし
た (@pxref{Topic Sorting})。

@item
グループの一部分が独立して並べ替えできるようになりまし
た (@code{Sorting})。

@item
キャッシュされた記事がグループに入れられるようになりまし
た (@pxref{Summary Generation Commands})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fred,width=3cm}]{\epsfig{figure=ps/fred,width=3cm}}
@end iflatex
@end iftex

@item
スコアファイルがもっと信頼できる順番で適用できるようになりまし
た (@pxref{Score Variables})。

@item
メールメッセージがどこに行くかの報告を作成することができるようになりまし
た (@pxref{Splitting Mail})。

@item
入って来たメールを保存する前にがらくたを取り除くフックと関数がもっと追加
されました (@pxref{Washing Mail})。

@item
強調文が適切にフォントが変更されるようになりました:
@end itemize

@node Quassia Gnus
@subsubsection Quassia Gnus

Gnus 5.6 の新しい機能:

@itemize @bullet

@item
Gnus をオフラインニュースリーダーとして使う新機能が加えられました。過剰
なほどの新しい命令とモードが追加されました。完全な話に付いて
は @ref{Gnus Unplugged} を見て下さい。

@item
@code{nndraft} バックエンドが戻ってきましたが、依然とは違うように動作す
るようになりました。すべてのメッセージバッファーは @code{nndraft} グルー
プの記事でもあり、それは自動的に作成されます。

@item
@code{gnus-alter-header-function} がヘッダーの値を変えるために使われるよ
うになりました。

@item
@code{gnus-summary-goto-article} が Message-ID を受け付けるようになりま
した。

@item
リージョンの外のメッセージの本文の文章を消去するための新しいメッセージ命
令があります: @kbd{C-c C-v}。

@item
@kbd{C-u C-c C-c} によって @code{nnvirtual} グループを生成しているグルー
プに投稿できるようになりました。

@item
@code{nntp-rlogin-program}---カスタマイズを簡単にするための新しい変数で
す。

@item
@code{gnus-article-edit-mode} の @code{C-u C-c C-c} は記事バッファーの再
ハイライトを禁止するようになりました。

@item
@code{gnus-boring-article-headers} に新しい要素がありま
す---@code{long-to}。

@item
@kbd{M-i} シンボル接頭引数命令があります。詳細
は @ref{Symbolic Prefixes} を見て下さい。

@item
概略バッファーの @kbd{L} と @kbd{I} は @file{all.SCORE} ファイルにスコア
法則を加えるためにシンボル接頭引数 @kbd{a} を受け付けるようになりました。

@item
変数 @code{gnus-simplify-subject-functions} により単純化をもっと制御でき
るようになりました。

@item
@kbd{A T}---現在のスレッドを取得するための新しい命令です。

@item
@kbd{/ T}---現在のスレッドを制限に含めるための新しい命令です。

@item
@kbd{M-RET} は引用文を止めるための新しいメッセージ命令です。

@item
@samp{\\1} 表現が @code{nnmail-split-methods} で有効になりました。

@item
関数 @code{custom-face-lookup} が取り除かれました。あなたの初期化ファイ
ルでこの関数を使っているのなら、代わりに @code{face-spec-set} を使うよう
に書き直さなければなりません。

@item
投稿取り消しは現在の選択方法を使うようになりました。シンボル接頭
引数 @kbd{a} は普通の投稿方法を強制します。

@item
M******** sm*rtq**t*s を適切な文章に翻案する新しい命令があります---
@kbd{W d}。

@item
@code{nntp} のより簡単なデバッグのために、
@code{nntp-record-commands} を @code{nil} でない値に設定することができま
す。

@item
@code{nntp} は @file{~/.authinfo} を使うようになり、これ
は @file{.netrc} のようなファイルで、どこでどのよう
に @sc{authinfo} を @acronym{NNTP} サーバーに送るかを制御するためのもの
です。

@item
概略バッファーのグループパラメーターを編集するための命令が加えられました。

@item
メールがどこに分割されたかの履歴を使用可能になりました。

@item
新しい記事日付命令が加えられました---@code{article-date-iso8601}。

@item
@code{gnus-score-thread-simplify} を設定することによりスレッドを作成して
いるときは表題が単純化されるようになりました。

@item
メッセージで引用をするための新しい関数が加えられました---
@code{message-cite-original-without-signature}。

@item
@code{article-strip-all-blank-lines}---新しい記事命令です。

@item
記事の終わりまでを切る新しいメッセージ命令が加えられました。

@item
変数 @code{gnus-adaptive-word-minimum} を使うことにより最小限適応スコア
を指定することができます。

@item
@code{gnus-start-date-timer} 命令により ``記事が投稿されたときからの経過
時間'' ヘッダーが継続的に更新されるようになりました。

@item
ウェブ listserv アーカイブが @code{nnlistserv} バックエンドにより読むこ
とができるようになりました。

@item
古い dejanews アーカイブが @code{nnweb} から読むことができるようになりま
した。
@end itemize

@node Pterodactyl Gnus
@subsubsection Pterodactyl Gnus

Gnus 5.8 の新しい機能:

@itemize @bullet

@item
メールを取り込む機能が変わりました。たくさんの詳細についてはマニュアルを
見て下さい。特に、procmail で取り込むためのすべての変数が無くなっていま
す。

このような procmail の使い方は

@lisp
(setq nnmail-use-procmail t)
(setq nnmail-spool-file 'procmail)
(setq nnmail-procmail-directory "~/mail/incoming/")
(setq nnmail-procmail-suffix "\\.in")
@end lisp

現在は次のように変わっています。

@lisp
(setq mail-sources
      '((directory :path "~/mail/incoming/"
                   :suffix ".in")))
@end lisp

@xref{Mail Source Specifiers}.

@item
Gnus は @acronym{MIME} に対応したリーダーになりました。これは Gnus の多
くの部分に影響していて、たくさんの新しいコマンドが追加されています。詳細
はマニュアルを参照して下さい。

@item
Gnus はまた各国語対応になりました。ここでは要約できないくらいに Gnus の
多くの部分に影響していて、新しいたくさんの変数が追加されています。

@item
@code{gnus-auto-select-first} が関数であってもよくなりました。

@item
Summary バッファーと @acronym{NOV} ファイルに含める追加のヘッダーを、利
用者が決めることができるようになりました。

@item
@code{gnus-article-display-hook} が削除されました。代わり
に @code{gnus-treat-} で始まるたくさんの変数が追加されました。

@item
Gnus posting styles が再び改装されました。現在は微妙に違う規則で動作しま
す。

@item
新しいウェブに基づいたバックエンドが追加されました。@code{nnslashdot},
@code{nnwarchive} および @code{nnultimate} です。nnweb は再び改作され、
常に変化する構成を続けます。

@item
Gnus は @code{nnimap} によって @acronym{IMAP} メールを読むことができます。
@end itemize

@node Oort Gnus
@subsubsection Oort Gnus
@cindex Oort Gnus

Gnus 5.10 の新しい機能:

@itemize @bullet

@item
領域が活性化されている場合、
@kbd{F} キー (@code{gnus-article-followup-with-original}) およ
び @kbd{R} キー (@code{gnus-article-reply-with-original}) は、その領域に
あるテキストだけを yank します。

@item
@code{gnus-group-read-ephemeral-group} を @kbd{G M} キーで対話的に呼ぶこ
とができます。

@item
ドラフト・グループで @kbd{e} キーが @code{gnus-draft-edit-message} コマ
ンドに割り当てられました。@code{gnus-summary-edit-article} コマンドには、
代わりに @kbd{B w} キーを使って下さい。

@item
改定された Gnus @acronym{FAQ} がマニュアルに含まれています。
@xref{Frequently Asked Questions}.

@item
Oort を使ったことがある場合の、以前の (安定な) 版からのグレードアップ。

Oort (このリリースに先立つ安定ではない Gnus の枝) を使ってみたものの、安
定版に戻してしまったならば、この版にグレードアップするときに注意して下さ
い。特に、おそらくすべて
の @file{.marks} (nnml) と @file{.mrk} (nnfolder) ファイルを消去する必要
があるでしょう。この版 (の Gnus) がフラグを格納す
る @file{.marks}/@file{.mrk} ファイルではなくて @file{.newsrc.eld} から
フラグが読まれるようになっていたからです。後述の項目で、印 (marks) に関
するより多くの情報を読んで下さい。グレードを下げても一般には助けにならな
いことに注意して下さい。

@item
記事のボタン

URL、メールアドレス、Message-ID、Info へのリンク、man ページと Emacs ま
たは Gnus に関連した参考文献のための、より多くのボタン。@xref{Article
Buttons}. すべての記事のボタンの見栄えを制御するため
に @code{gnus-button-@var{*}-level} 変数を使うことができます。
@xref{Article Button Levels}.

@item
Dired の統合

@code{gnus-dired-minor-mode} (@ref{Other modes} 参照) は、dired のバッファー
でキー設定---添付ファイルの送信、mailcap の適切な項目を使ってファイルを
開く、それに mailcap の項目を使ってファイルを印刷する---を行ないます。

@item
Gnus は RSS のニュース配送を、ニュースグループとして表示します。
@xref{RSS}.

@item
単一の yenc でエンコードされた添付パートがデコードできます。

@item
Picons

Picon のコードが、GNU Emacs で動作させるために再実装されました。以前のい
くつかのオプションが、削除または改名されています。

Picon は、利用者、ドメイン、それにニュースグループを表現するための「個人
的なアイコン (personal icons)」で、記事バッファーに表示することができま
す。@xref{Picons}.

@item
新しいオプション @code{gnus-treat-body-boundary} を非-@code{nil} にする
と、ヘッダーのおしまいに境界線が描かれます。

@item
憲章とコントロールメッセージの取得

二つのコマンド---ニュースグループの憲章を取り込む (@kbd{H c})、コントロー
ルメッセージを取得 (@kbd{H C})---があります。

@item
遅延記事

Message バッファーにおける @kbd{C-c C-j} で、メッセージの送信を遅らせる
ことができます。メッセージは指定された時刻に配送されます。これはあなた自
信のための忘備録として役に立つでしょう。@xref{Delayed Articles}.

@item
@code{auto-compression-mode} が有効になっていると、添付ファイルを見ると
きに自動で圧縮が解かれます。

@item
新しいオプション @code{nnml-use-compressed-files} を非-@code{nil} にする
ことによって、nnml が圧縮されたメッセージファイルを扱うことができるよう
になります。

@item
記事の署名ヘッダー (X-PGP-Sig) を、@kbd{W p} で認証することができます。

@item
概略バッファーは fringe の中の矢印で現在の記事を示します。これを無効にす
るには @code{(setq gnus-summary-display-arrow nil)} を使って下さい。

@item
ニュースにメールで返信しようとしたら警告

間違ってニュースにメールで返信しようとしてしまうことが、しょっちゅうあり
ませんか?  そんなあなたに新オプショ
ン @code{gnus-confirm-mail-reply-to-news}。

@item
新しいオプション @code{gnus-summary-display-while-building} を
非-@code{nil} にすると、概略バッファーが作られていく様子が表示されます。

@item
新しい @code{recent} 印 @samp{.} で、新規に届いたメッセージを (未読だけ
れども古い記事とは区別して) 表示します。

@item
新しいオプション @code{gnus-gcc-mark-as-read} は、Gcc の記事に自動的に既
読の印を付けます。

@item
nndoc バックエンドは、mailman のまとめ送りと exim が弾いたメッセージをサ
ポートするようになりました。

@item
Gnus は RFC 2369 のメーリングリストのヘッダーをサポートします。また、メー
リングリストのグループ用に数々のコマンドを用意しました。@xref{Mailing
List}.

@item
日付ヘッダーを、英語で発音できる形式で表示することができます。
@xref{Article Date}.

@item
Sendmail を使うときのエンベロープ送信者 (envelope sender) のアドレスが、
カスタマイズできるようになりました。@xref{Mail Variables, ,メール変数,
message-ja, The Message Manual}.

@item
@code{mm-uu-diff-groups-regexp} に合致するグループでは、差分 (diffs) が
自動的にハイライトされます。

@item
@acronym{TLS} ラッパーが Gnus に同梱

@acronym{TLS}/@acronym{SSL} が、@file{tls.el} と GNUTLS を介し
て @acronym{IMAP} と @acronym{NNTP} でサポートされるようになりました。
(サードパーティーの) @file{ssl.el} と OpenSSL による古
い @acronym{TLS}/@acronym{SSL} は、まだ使えます。

@item
MS ウィンドウズで Gnus をコンパイルしてインストールするための、新し
い @file{make.bat}

MS ウィンドウズで Gnus をインストールするには @file{make.bat} を使って下
さい。このバッチ・プログラムの第一引数はディレクトリーです。そこ
で @file{xemacs.exe} と @file{emacs.exe} が順に捜し出されます。コンパイ
ルしてから Gnus をインストールしたいときは、@file{make.bat} の第二引数
に @code{/copy} を与えて下さい。

@file{make.bat} はゼロから書き直されました。XEmacs と GNU Emacs を自動認
識し、@file{gnus-load.el} を生成し、コンパイル中と info ファイルの生成中
にエラーが起きたら構築処理の最後に報告します。@code{makeinfo} が利用可能
であればそれを使い、さもなければ @file{infohack.el} に頼ります。今
や @file{make.bat} は Gnus を動作させるために必要なすべてのファイルをイ
ンストールするはずで、大体において Unix システムにおけ
る @code{configure; make; make install} サイクルの完全な置き換えになりま
した。

新しい @file{make.bat} は @file{make-x.bat} を不要にしたので、それは削除
されました。

@item
非-@acronym{ASCII} ドメイン名のサポート

Message は From:, To: および Cc: にある非-@acronym{ASCII} ドメイン名をサ
ポートし、メッセージの送信を試みるときにエンコードするかどうかを尋ねます。
@code{message-use-idna} 変数でこれを制御します。Gnus もまた、メッセージ
を見るときに From:, To: および Cc: にある非-@acronym{ASCII} ドメイン名を
デコードします。これを制御するのは @code{gnus-use-idna} 変数です。

@item
マイクロソフト引用様式のより良い取り扱い

いくつかのマイクロソフトのメイラーが、メッセージの残りの部分が引用である
ことを示すために使う台無しにされたヘッダーブロックを、たとえそれが引用符
で囲まれていなくても、Gnus は認識しようとします。変
数 @code{gnus-cite-unsightly-citation-regexp} は、それらの引用の先頭に合
致します。

@item
@code{gnus-article-skip-boring}

@code{gnus-article-skip-boring} を @code{t} に設定すると、Gnus はうんざ
りする文しか含んでいないページを見せるために、下方にスクロールしません。
@code{gnus-article-boring-faces} を使って、何を読み飛ばしてしまっても良
いかをカスタマイズすることができます。

長くて刈り込まれていない引用が、てっぺんに少しだけある新規な内容に続いて
いるたくさんの記事を読む場合に、これは特に役に立ちます。

@item
ポイントの位置決めのためのフォーマットの仕様 (format spec) であ
る @code{%C} は、@code{%*} に変更されました。

@item
新しい変数 @code{gnus-parameters} が、グループパラメーターを設定するため
に使うことができます。

これは初期には、パラメーターを @file{~/.newsrc.eld} に格納する @kbd{G p}
(または @kbd{G c}) でしか行なうことができませんでしたが、この変数によっ
てカスタマイズの威力を堪能することができます。また、その変数
は @file{~/.newsrc.eld} ではなくて @file{~/.emacs} で設定するので、バッ
クアップが簡単になります。その変数は、グループ名に合致する正規表現を、以
下のような流儀でグループパラメーターに割り当てます:
@lisp
(setq gnus-parameters
      '(("mail\\..*"
         (gnus-show-threads nil)
         (gnus-use-scoring nil))
        ("^nnimap:\\(foo.bar\\)$"
         (to-group . "\\1"))))
@end lisp

@item
スマイリー (@samp{:-)}, @samp{;-)} など) が Emacs でもアイコン化されるよ
うになりました。

これを働かないようにするには、@code{(setq gnus-treat-display-smileys
nil)} を @file{~/.emacs} に置いて下さい。

@item
Gnus は今では Sender: ヘッダーを自動では生成しません。

初期のころ、それは利用者が設定できる email アドレスが、Gnus が想定した利
用者のディフォルトのアドレスと違っていた場合に生成されました。今日ではそ
の想定アルゴリズムが正しいことはまれで、Sender: ヘッダーの唯一の (議論の
的になる) 用途は、ニュースを cancel/supersede する資格があるかどうかを検
査すること (これは代わりに、他の項で述べられる Cancel Locks によって解決
された) なので、そのヘッダーの生成はディフォルトで抑制されています。変
数 @code{message-required-headers}、
@code{message-required-news-headers} およ
び @code{message-required-mail-headers} を参照して下さい。

@item
サードパーティーによる @file{message-utils.el} の機能
が @file{message.el} に加えられました。

Message は表題 (subject) の行から @samp{(was: <old subject>)} を削除する
かどうかを尋ねるようになりまし
た (@code{message-subject-trailing-was-query} 参照)。
@kbd{C-c M-m} と @kbd{C-c M-f} は挿入されたテキストを示す印を挿入します。
@kbd{C-c C-f a} は X-No-Archive: ヘッダーを付け加えます。@kbd{C-c C-f
x} は、適切なヘッダーと、クロスポストとフォロー先についての注意書きを本
文に挿入します (@code{message-cross-post-@var{*}} 変数群を見て下さい)。

@item
今や @code{message-generate-headers-first} が @code{nil} だったら、メッ
セージの作成を始めるときに References と X-Draft-Headers は生成されませ
ん。

@item
改良された spam 対抗機能。

Gnus は非常に変化に富んだプログラムと濾過の規則を使って、メールやニュー
スの奔流から spam を抜き取ってしまうことができるようになりました。対応し
ている方式は、RBL blocklists、bogofilter それにホワイト/ブラックリストで
す。また SpamAssassin や Hashcash のような外部パッケージを簡単に使うため
の hook も新しくなりました。@xref{Thwarting Email Spam}.

@item
X-Faces ヘッダーの挿入が簡単になりました。

@item
Face ヘッダーを扱えるようになりました。

@item
概略バッファーに、新しいコマンド @kbd{/ N} は新着メッセージを挿入し、
@kbd{/ o} は古いメッセージを挿入します。

@item
@kbd{W m} を押すと、Gnus はモールスでエンコードされたメッセージをデコー
ドします。

@item
nnimap のグループにおける未読の数が正確になりました。

グループバッファーで、nnimap グループの未読記事の数の見積りが正確になっ
たはずです。これは @code{gnus-setup-news-hook} (起動時に呼ばれ
る) と @code{gnus-after-getting-new-news-hook} (新しいメールを取得した直
後に呼ばれる) から @code{nnimap-fixup-unread-after-getting-new-news} を
呼ぶことによって成し遂げられます。これらの変数をディフォルトから変えてい
る場合は、再び @code{nnimap-fixup-unread-after-getting-new-news} を追加
する必要があるかもしれません。見積りに満足していて、新しいメールを取得す
るときにいくらか (最小限度の) 時間を節約したいのであれば、その関数を外し
て下さい。

@item
グループカーボンコピー (GCC) を引用符で囲む

空白や他の変な文字を含むグループを扱えるようにするために、グループ
は Gcc: header に置かれる前に引用符で囲まれます。これは、空白を含むグルー
プが使えるようにするために、もはや @code{gnus-message-archive-group} の
ような変数に引用文字を含めるべきではないことを意味します。さらに、文字
列 @samp{nnml:foo, nnml:bar} (二つのグループに Gcc を格納することを示
す) を使っているならば、リスト @code{("nnml:foo" "nnml:bar")} を返すよう
に変更しなければなりません。さもないと、Gcc: 行は間違った囲まれ方をされ
てしまうでしょう。初期のころに文字列 @samp{nnml:foo, nnml:bar} を返すよ
うにしたことが間違いだったことに着目して下さい。それは直接挿入されたので、
まったく問題を生じませんでした。

@item
@file{~/News/overview/} は不要。

以下の変更の結果、今後は @file{~/News/overview/} ディレクトリーは要りま
せん。すべての階層を安全に削除することができます。

@item
@code{gnus-agent}

Gnus エージェントは大規模な更新を経て、今やディフォルトで活性化されます。
そし
て @code{gnus-select-method} と @code{gnus-secondary-select-method} で指
定されるすべての nntp と nnimap のサーバーが、ディフォルトでエージェント
化されます。初期においては @code{gnus-select-method} のサーバーだけがディ
フォルトでエージェント化され、エージェントはディフォルトで不活性化されて
いました。エージェントが活性化されると、可能ならばバックエンドに代わって
エージェントのキャッシュからヘッダーが取り寄せられます。初期には、これは
オフライン (unplugged) の状態でのみ行なわれていました。サーバーバッファー
で @kbd{J a} と @kbd{J r} を使うことによって、サーバーの登録と削除を行な
うことができます。グループバッファーから @kbd{J u} か @kbd{J s} を使って
命令しない限り、Gnus は記事をエージェントのキャッシュにダウンロードしま
せん。@code{(setq gnus-agent nil)} でもって、エージェントが不活性化され
ていた昔の振る舞いに戻すことができます。今後
は @file{~/.gnus.el} に @code{(gnus-agentize)} を置いておく必要が無いこ
とに注意して下さい。

@item
@code{gnus-summary-line-format}

ディフォルト値が @samp{%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n} に変わりまし
た。さらに、受信者の名前か @acronym{NNTP} グループに投稿したグループ名で
利用者名を置き換えるために、@code{gnus-extra-headers}、
@code{nnmail-extra-headers} および @code{gnus-ignored-from-addresses} の
デフォルト値が変わりました。

@item
@file{deuglify.el} (@code{gnus-article-outlook-deuglify-article})

いかれた Outlook (Express) の記事を醜くなくするための、Raymond Scholz
@email{rscholz@@zonix.de} によって新設されたファイルです。

@item
@code{(require 'gnus-load)}

単独で配布されている Gnus を使う場合には、
@code{load-path} に Gnus の lisp ディレクトリーを追加してから、
@file{~/.emacs} に @code{(require 'gnus-load)} を加えるのが良いです。

@file{gnus-load.el} ファイルは、そのうちのいくつかは Emacsen の配布に入っ
ていないかもしれない自動読み込み (autoload) コマンド、関数および変数を含
んでいます。

@item
@code{gnus-slave-unplugged}

オフラインの Gnus をスレーブモードで起動する新しいコマンドです。

@item
@code{message-insinuate-rmail}

@code{(message-insinuate-rmail)} と @code{(setq mail-user-agent
'gnus-user-agent)} を @file{.emacs} に加えることで、
@code{message-mode} でメッセージの作成、返信および転送を行なうよう
に Rmail を説得することができます。そこでは @acronym{MML} の威力を堪能で
きます。

@item
@code{message-minibuffer-local-map}

下の行で、メッセージを再送するときに BBDB が使えます:
@lisp
(define-key message-minibuffer-local-map [(tab)]
  'bbdb-complete-name)
@end lisp

@item
添付ファイル (attachments) の切り離し (externalizing) と消去。

@code{gnus-gcc-externalize-attachments} また
は @code{message-fcc-externalize-attachments} が非-@code{nil} になってい
ると、ローカルファイルを外部パートとして添付します。

@code{gnus-mime-save-part-and-strip} コマンド (@acronym{MIME} ボタン上
で @kbd{C-o} に割り当てられている) は、パートをセーブしてから外部のそれ
と置き換えます。@code{gnus-mime-delete-part} (@acronym{MIME} ボタン上
で @kbd{d} に割り当てられている) は、パートを削除します。これは編集をサ
ポートしているバックエンドでだけ動作します。

@item
@code{gnus-default-charset}

デフォルト値は @code{iso-8859-1} に代わっ
て @code{current-language-environment} 変数によって決定される値になりま
す。また、@code{gnus-group-charset-alist} にあった @samp{.*} の項目は削
除されました。

@item
@code{gnus-posting-styles}

このような合致の様式が加わりました。
@lisp
((header "to" "larsi.*org")
 (Organization "Somewhere, Inc."))
@end lisp
下記のような古い様式は時代遅れになりましたが、まだ受け入れられます。
@lisp
(header "to" "larsi.*org"
        (Organization "Somewhere, Inc."))
@end lisp

@item
@code{message-ignored-news-headers} と @code{message-ignored-mail-headers}

@samp{X-Draft-From} と @samp{X-Gnus-Agent-Meta-Information} が、これら二
つの変数に加えられています。それらをカスタマイズする場合に、もしかすると
それら二つのヘッダーを加える必要があります。

@item
Gnus は差し込まれている (@dfn{plugged}) ときに、エージェントか
ら @acronym{NOV} と記事を読み込みます。

差し込まれているときに記事を読む場合に、その記事がすでにエージェントにあ
るならば、もう一度ダウンロードすることはありません。@code{(setq
gnus-agent-cache nil)} は旧式の動作に戻します。

@item
Gnus は ``format=flowed'' (RFC 2646) パラメーターをサポートします。メッ
セージを作成するときに、それは @code{use-hard-newlines} で活性化されます。
format=flowed のデコードは以前からできましたが、初期の版では説明の文書が
ありませんでした。

@item
Gnus は RFC 2298 の開封確認要求の生成をサポートします。

これはメッセージモードの @kbd{C-c M-n} キーで起動されます。

@item
Gnus は Maildir グループをサポートします。

Gnus は新バックエンドである @file{nnmaildir.el} を含んでいます。
@xref{Maildir}.

@item
印刷の性能が向上しました。

Gnus はそれ自身が、概略と記事バッファーにおけ
る @kbd{O P} で Muttprint をサポートします。さらに @acronym{MIME} ボタン
上で @kbd{p} を使うことによって、個々の @acronym{MIME} パートのそれぞれ
を印刷することができます。

@item
Message は Importance: ヘッダー (RFC 2156) をサポートするようになりまし
た。

メッセージバッファーで @kbd{C-c C-f C-i} か @kbd{C-c C-u} を使うと、可能
な値が循環します。

@item
Gnus はニュースの Cancel Locks をサポートします。

投稿するニュース記事に @samp{Cancel-Lock} ヘッダーが挿入されることです。
これは、記事をあなたが書いたのかどうかを確かめるために使います (キャンセ
ルと置き換えのとき)。最初に記事を投稿するときに、Gnus はランダムなパスワー
ド文字列を生成し、カスタムの機構を使って @file{~/.emacs} にセーブします。
その変数は @code{canlock-password} と呼ばれますが、機密を気にするデータ
ではありません。ウェブ上で canlock を公開しても、以前から彼女ができなかっ
た何かを、誰かができるようにするものではありません。
@code{message-insert-canlock} をカスタマイズすることによって、振る舞いを
変更するができます。

@item
Gnus は Sieve を使ったサーバー側でのメールの濾過をサポートします。

Sieve の規則はグループパラメーターとして加えることができ、グループバッファー
で @kbd{D g} を使うと完全な Sieve スクリプトが生成されます。そうしたら、
生成された Sieve バッファーで @kbd{C-c C-l} を使って、サーバーにアップロー
ドして下さい。@ref{Sieve Commands}、それに新しい Sieve のマニュア
ル (@pxref{Top, ,Top, sieve-ja, Emacs Sieve}) を参照して下さい。

@item
拡張されたフォーマットの仕様 (format specs)。

フォーマットの仕
様 @samp{%&user-date;} が @code{gnus-summary-line-format-alist} に追加さ
れました。それに、利用者定義による拡張されたフォーマットの仕様もサポート
されています。拡張されたフォーマットの仕様は @samp{%u&foo;} のようなもの
で、関数 @code{gnus-user-format-function-@var{foo}} を起動します。
@samp{&} がエスケープ文字に使われているので、古い利用者定義フォーマット
である @samp{%u&} は今やサポートされていません。

@item
@kbd{/ *} (@code{gnus-summary-limit-include-cached}) が書き直されました。

これは @kbd{Y c} (@code{gnus-summary-insert-cached-articles}) の別名でし
た (訳注: 以前は)。新しい関数は他の記事を濾過して除去します。

@item
いくつかのコマンドは @kbd{C-u} 接頭引数で合致の否定を扱うことができます。

@kbd{C-u} を subject、author または extra ヘッダーをこの順に使う---すな
わち @kbd{/ s}、@kbd{/ a} およ
び @kbd{/ x} (@code{gnus-summary-limit-to-@{subject,author,extra@}})---
と、結果としてその表現に合致しないすべての記事が表示されます。

@item
グループ名は、ディフォルトで UTF-8 であるものとして取り扱われます。

これは USEFOR が移行しようとしていると想定されるものです。カスタマイズす
るには @code{gnus-group-name-charset-group-alist} およ
び @code{gnus-group-name-charset-method-alist} を参照して下さい。

@item
nnml と nnfolder バックエンドは、グループ毎に印 (marks) を格納するように
なりました。

これは nnml/nnfolder サーバー/グループ を @file{~/.newsrc.eld} と切り離
して、しかし印は守りつつ、バックアップすることを可能にします。さらに、例
えば研究室や職場などの組織内で、(@file{~/.newsrc.eld} ファイルを共有する
こと無しに) 利用者間で記事と印を共有することをも可能にします。これは、
@file{~/.newsrc.eld} に格納される印を、グループ毎の @file{.marks} ファイ
ル (nnml 用) と @file{@var{groupname}.mrk} ファイル (@var{groupname} の
名前を持つ nnfolder 用) に格納することによって動作します。
nnml/nnfolder を他のマシンに引っ越しても、
Gnus は @file{~/.newsrc.eld} にある情報の代わりに、自動的
に @file{.marks} か @file{.mrk} ファイルを使います。新しいサーバー変数で
ある @code{nnml-marks-is-evil} と @code{nnfolder-marks-is-evil} が、この
機能を抑制するために使うことができます。

@item
グループと概略バッファーのメニュー項目の名前 ``Misc'' は ``Gnus'' に改名
されました。

@item
Message mode で ``@acronym{MML}'' と名付けられたメニュー項目は、
``Attachments'' に改名されました。このメニューは、署名と暗号
化 (@pxref{Security, ,セキュリティー, message-ja, The Message
Manual}) のような、保安に関連したものも含んでいることに着目して下さい。

@item
@code{gnus-group-charset-alist} と @code{gnus-group-ignored-charsets-alist}。

これらの変数に設定された正規表現は、完全な (full) グループ名と比較されま
す。Gnus 5.8 では実際の (real) グループ名が比較の対象でした。したがって、
これらの変数をカスタマイズしている利用者は、正規表現を変更しなければなり
ません。例です:
@lisp
("^han\\>" euc-kr) -> ("\\(^\\|:\\)han\\>" euc-kr)
@end lisp

@item
Gnus は @acronym{PGP} (RFC 1991/2440)、@acronym{PGP/MIME} (RFC
2015/3156) および @acronym{S/MIME} (RFC 2630-2633) をサポートします。

これには @acronym{S/MIME} と OpenPGP が実装されている必要があります。で
も追加の Lisp ライブラリは要りません。メッセージの作成時に、いくつかのメ
ニューと @kbd{C-c RET} キーの割り当てが Attachments メニューに追加されま
す。これはまた、@code{gnus-article-hide-pgp-hook} を時代遅れにしました。

@item
Gnus は外部パート (message/external) をインライン表示します。

@item
@acronym{MML} (Mime 作成) コマンドの接頭キーが、@kbd{M-m} から @kbd{C-c
C-m} に変わりました。

この変更によって、標準キー割り当ての @code{back-to-indentation} との衝突
が回避されました。このコマンドもまた、メッセージモードでは役に立つのです。

@item
@code{message-forward-show-mml} のディフォルトが @code{best} に変わりま
した。

値 @code{best} の振る舞いは、それがふさわしい場合は @acronym{MML} を表示
する (すなわち @acronym{MIME} に変換する) ことです。変換がディジタル署名
を無効にしてしまうので、署名された、または暗号化されたメッセージを転送す
るときは @acronym{MML} は使われません。
@end itemize

@node No Gnus
@subsubsection No Gnus
@cindex No Gnus

No Gnus の新しい機能:
@c FIXME: Gnus 5.12?

@include gnus-news-ja.texi

@iftex

@page
@node The Manual
@section マニュアル
@cindex colophon
@cindex manual

このマニュアルは TeXinfo ファイルから作成され、それか
ら @code{texi2dvi}
@iflatex
もしくは、Lars さんの作られた Texinfo to \LaTeX 変換を通り、それから、
@code{latex} と @code{dvips}
@end iflatex
を実行して、手元にあるもになりました。

以下の習慣が用いられました:

@enumerate
これは @kbd{キー打鍵} です。

@item
これは @file{ファイル} です。

@item
これは @code{シンボル} です。

@end enumerate

ですから、私が ``@code{flargnoze} を @samp{yes} に設定する'' と言ったと
きは、次のような意味です:

@lisp
(setq flargnoze "yes")
@end lisp

もし、私が ``@code{flargnoze} を @code{yes} に設定する'' と言ったときは、
次のような意味です:

@lisp
(setq flumphel 'yes)
@end lisp

@samp{yes} と @code{yes} は二つの @emph{まったく} 違ったものです---絶対
に混同しないで下さい。

@iflatex
@c @head
もちろん、このマニュアルにあるすべては極めて重要なので、あなたは全部を読
むべきです。何度も。しかしマニュアルを斜め読みしたいのであれば、そこの欄
外に見えるはずのヌーの頭を探して下さい---それはそこで議論されているのが
残りのものより重要であるということです。(一方、すべてが最高に重要なので
あれば、どうすればそれよりもっと重要なものができるのでしょう? この世界の
不思議の一つでしょう、たぶん。)
@end iflatex

@end iftex

@node On Writing Manuals
@section マニュアルを書く

おそらく、たいていのマニュアルは事実の後で書かれていると思います。すでに
あるプログラムを文書化しています。このマニュアルはそういう方法で書かれて
いません。何かを実装するときは、何かをそのままマニュアルの一節に書きます。
それから機能の説明が難しいことを発見して、それがどのようにあるべきである
かを書き、それから実装を変更します。文書とコードを書くのは一緒に行なわれ
ていきます。

もちろん、これはこのマニュアルには流れ構造がほとんど無いか、あっても少し
だということです。Gnus の完全にすべてのことが説明されていますが、探して
いる場所ではないということがよくあります。これはリファレンスマニュアルで
あり、Gnus を始めるための手引きではありません。

それはまったく違った本になり、このリファレンスマニュアルを元として使って
書かれたものになるでしょう。とても違ったものになるはずです。

@page
@node Terminology
@section 用語

@cindex terminology

@table @dfn
@item ニュース (news)
@cindex news
これはあなたがそのためにこのものを使いたいと思っているものです---ニュー
スを読むことです。ニュースは一般的には近くの @acronym{NNTP} サーバーから
取得され、普通はすべての人に広く利用可能なものです。もしニュースを投稿す
れば、全世界があなたがちょうど書いたものを読む可能性があり、それらはすべ
ていたずらっぽくクスクス笑われるでしょう。あなたの知らないところで。

@item メール (mail)
@cindex mail
あなたに個人的に配送されるものすべてがメールです。いくつかのニュース/メー
ルリーダー (Gnus のような) はメールとニュースの違いをぼやけさせますが、
そこには違いは存在します。メールは私的です。ニュースは公的です。メールを
送信することは投稿ではなく、返信はフォローアップではありません。

@item 返信 (reply)
@cindex reply
あなたが読んでいるものを書いた人にメールを送ることです。

@item フォローアップ (follow up)
@cindex follow up
あなたが読んでいる記事に応答して現在のニュースグループに記事を投稿するこ
とです。

@item バックエンド (back end)
@cindex back end
Gnus はメールとニュースがほとんど同じだとみなします。本当に。違いは実際
の記事にどのようにアクセスするかだけです。メールメッセージはローカルディ
スクのファイルから読めるのに対して、ニュース記事は一般
に @acronym{NNTP} プロトコルで取得します。Gnus の内部構造は、それらのた
めに ``フロントエンド'' と数々の ``バックエンド'' から成り立っています。
内部的に、あなたがグループに入る (そう、@key{RET} をたたく) とき、そのた
めに Gnus のフロントエンドの機能を呼び出します。フロントエンドはそこでバッ
クエンドに「foo グループの記事のリストをくれ」とか「4711 番の記事を見せ
てよ」と ``話す'' のです。

そういうわけで、バックエンドは主にプロトコルか、ファイルの形式とディレク
トリーの配置を定義します。前者は @code{nntp} バックエンド
が @acronym{NNTP} でニュースにアクセスしたり @code{nnimap} バックエンド
が @acronym{IMAP} でメールにアクセスすることを指します。また、後者
は @code{nnspool} バックエンドが共通の ``スプールディレクトリー'' 形式に
アクセスしたり、それととてもよく似た @code{nnml} バックエンドがファイル
の形式とディレクトリーの配置によってメールにアクセスすることを指します。

Gnus は基本的なメディアを扱いません。すべてはバックエンドによって行なわ
れるということができます。バックエンドは記事にアクセスするための機能の集
成です。

しかし、``バックエンド'' という用語はしばしば ``サーバー'' という意味で
も使われてきました。そして ``選択方法'' (``select method'') も同じ意味で
使うことができます。かように、Gnus の用語はとても混乱しています。

@item 基本 (native)
@cindex native
Gnus はいつも一つの方法 (とバックエンド) をニュースを得るための @dfn{基
本} もしくはディフォルトとして使います。

@item 外部 (foreign)
@cindex foreign
同時に任意の数の外部グループを活動状態にすることもできます。これらはニュー
スを取得するための、基本でなく、二番目でもないバックエンドを使うグループ
です。

@item 二番目 (secondary)
@cindex secondary
二番目のバックエンドは、基本と外部の間くらいにあるバックエンドで、ほとん
ど基本と同じように動作するものです。

@item 記事 (article)
@cindex article
ニュースとして投稿されたメッセージです。

@item メールメッセージ (mail message)
@cindex mail message
メールで送られたメッセージです。

@item メッセージ
@cindex message
メールメッセージもしくはニュース記事です。

@item ヘッド (head)
@cindex head
メッセージの最上部で、認証情報 (等) が入れられているところです。

@item 本文 (body)
@cindex body
記事の残りの部分です。ヘッドでないものはすべて本文です。

@item ヘッダー (header)
@cindex header
記事のヘッドからの行です。

@item ヘッダー群 (headers)
@cindex headers
そのような行の集合もしくは、ヘッドの集合です。もしくは、@acronym{NOV} 行
の集合です。

@item @acronym{NOV}
@cindex @acronym{NOV}
Gnus がグループに入ると、グループのすべての未読記事のヘッダーをバックエ
ンドに求めます。ほとんどのサーバーは News OverView 様式が使用可能で、そ
れは普通の @sc{head} 様式よりもっと手短でもっと速く読んで解析 (parse) す
ることができます。

@item レベル (level)
@cindex levels
それぞれのグループは何らかの @dfn{レベル} か他のもの (1-9) で購読されて
います。低いレベルのものは高いレベルのものより ``より'' 購読されています。
実際のところ、レベル 1-5 のグループは @dfn{購読}; 6-7 は @dfn{未購
読}; 8 は @dfn{ゾンビ}; 9 は @dfn{切られた} と見なされます。グループをリ
ストしたり、新しいグループを走査したりする命令はすべて数値接頭引数
を @dfn{動作レベル} として使います。

@item 切られたグループ (killed groups)
@cindex killed groups
切られたグループの情報は蓄積されたり更新されたりしないので、切られたグルー
プを購読されたグループより簡単に扱えるようになります。

@item ゾンビグループ (zombie groups)
@cindex zombie groups
ほとんど切られたグループと同じで、それより少し死んでいるだけです。

@item アクティブファイル (active file)
@cindex active file
ニュースサーバーはどの記事を運んでいるか、どのグループが存在するかを記録
しておかなければなりません。すべてのこの情報は現状ファイルに蓄積され、そ
れはあなたが想像するように比較的大きいです。

@item 偽グループ (bogus groups)
@cindex bogus groups
@file{.newsrc} ファイルに存在するグループですが、サーバーに知られていな
いグループ (すなわち、それはアクティブファイルにありませ
ん) は @emph{偽グループ} です。これは、おそらく (すでに) そのグループは
存在していないのでしょう。

@item 活動化 (activating)
@cindex activating groups
サーバーにグループの情報を尋ね、未読記事の数を演算する行為は @dfn{グルー
プを活動化する} と呼ばれています。非活動グループはグループバッファー
に @samp{*} とともに一覧表示されます。

@item スプール (spool)
@cindex spool
ニュースサーバーは、あるやり方、または他の流儀で記事をローカルに保存しま
す。ある古い流儀の保存方法は、記事毎にたった一つのファイルを持つことです。
それは伝統的なスプール (traditional spool) と呼ばれます。

@item サーバー (server)
@cindex server
接続して、ニュース (もしくはメール) を取得することのできるグループです。

@item 選択方法 (select method)
@cindex select method
バックエンド、サーバーと、仮想サーバーの設定を指定する構造です。

@item 仮想サーバー (virtual server)
@cindex virtual server
命名された選択方法です。選択方法は (物理的) サーバーに接続するために必要
な方法を定義するため、ものごとを全体として受けるのは仮想サーバーになりま
す。

@item 洗濯 (washing)
@cindex washing
バッファーを持ってきて、何らかの種類の選別機にかけることです。結果は (多
かれ少なかれ) 元のものよりもよりきれいで喜ばしいものになるでしょう。

@item 一時グループ (ephemeral groups)
@cindex ephemeral groups
@cindex temporary groups
たいていのグループはどの記事を読んだかのデータを蓄積します。
@dfn{一時} グループはデータが溜められないグループです---グループを出ると、
それは天空に消え去ります。

@item 固定グループ (solid groups)
@cindex solid groups
これは一時グループの反対です。グループバッファーに挙げられているすべての
グループは固定グループです。

@item まばら記事 (sparse articles)
@cindex sparse articles
@code{gnus-build-sparse-threads} の機能を使用しているときは、概略バッファー
に記事の入れ場所が表示されます。

@item スレッド作り (threading)
@cindex threading
それが応答した記事の直後にその記事への応答を置くことです---階層的流儀で。

@item 根 (root)
@cindex root
@cindex thread root
スレッドの最初の記事が根です。それはスレッドのすべての記事の祖先です。

@item 親 (parent)
@cindex parent
応答のある記事です。

@item 子 (child)
@cindex child
違った記事---その親 に応答する記事です。

@item 集配 (digest)
@cindex digest
複数のメッセージを一つのファイルに集めたものです。もっとも普通の集配様式
は RFC1153 で指定されています。

@item 分割 (splitting)
@cindex splitting, terminolgy
@cindex mail sorting
@cindex mail filtering (splitting)
ある規則によってメールを分類する行為です。ときどき間違ってメールの濾
過 (mail filtering) と呼ばれます。
@end table

@page
@node Customization
@section カスタマイズ
@cindex gereral customization

すべての変数はこのマニュアルのどこか別のところで適切に説明されています。
この部分は非常に良くある状況でどのように Gnus をカスタマイズすれば良いか
の総合適指示先を与えるために考案されています。

@menu
* Slow/Expensive Connection::   ローカルの Emacs を立ち上げて、他のところからニュースを得ることができる
* Slow Terminal Connection::    遠隔 Emacs を実行する
* Little Disk Space::           大きな起動ファイルを持つことはまずい
* Slow Machine::                速い機械を買おうと感じるであろう
@end menu

@node Slow/Expensive Connection
@subsection 遅い/高い NNTP 接続

もし Emacs をローカルのマシンで実行していて、非常に細い線の向こうのマシ
ンからニュースを取得しているのであれば、Gnus が @acronym{NNTP} サーバー
から取得するデータの総量を減らしたいと思うでしょう。

@table @code
@item gnus-read-active-file
これを @code{nil} にして下さい。そうすれば、Gnus にサーバーからアクティ
ブファイル全体を要求することを禁止できます。このファイルはしばしば非常に
大きくなっています。それに加えて、Gnus が突然とにかく現状ファイルを取得
しようと決定しないことを確実にするために、
@code{gnus-check-new-newsgroups} およ
び @code{gnus-check-bogus-newsgroups} も @code{nil} に設定しなければなり
ません。

@item gnus-nov-is-evil
これも @code{nil} にしていなければなりません。もしそうでなければ、
@acronym{NNTP} サーバーから記事のヘッダーをつかんでくるのがあまり速くな
りません。すべての @acronym{NNTP} サーバーが @sc{xover} の機能を提供して
いるわけではありません。Gnus が自分自身でそれを検査します。
@end table

@node Slow Terminal Connection
@subsection 遅いターミナル接続。

あなたは、ホームコンピューターを Emacs と Gnus を実行しているシステムに
ダイアルアップするために使っているとしましょう。もしあなたのモデムが遅け
れば、(可能な限り) 線を伝って送られているデータの総量を減らしたいと思う
でしょう。

@table @code
@item gnus-auto-center-summary
Gnus が常に概略バッファーを中心再設定をすることを禁止するためにこれ
を @code{nil} に設定して下さい。これが @code{vertical} であると、垂直方
向の (vertical) 中心再設定のみをします。@code{nil} で
も @code{vertical} でも無ければ、水平方向と垂直方向の両方の中心再設定を
行ないます。

@item gnus-visible-headers
記事に含まれるヘッダーを最小限に減らします。実際のところ、全部なくしてし
まっても何とかなります---とにかく、たいていの役に立つデータは概略バッファー
にあります。この変数を @samp{^NEVVVVER} や @samp{From:} や、何でも好きな
ものに設定して下さい。

このフックにすべての使用可能な隠匿命令を設定します:
@lisp
(setq gnus-treat-hide-headers 'head
      gnus-treat-hide-signature t
      gnus-treat-hide-citation t)
@end lisp

@item gnus-use-full-window
これを @code{nil} に設定することで、すべてのウィンドウを小さくすることが
できます。これは総じてそんなに減らしません。これは、記事をどっちにしろ読
みたくないということを決定する前に、少しの部分しか見る必要が無いというこ
とです。

@item gnus-thread-hide-subtree
これが @code{nil} でなければ、すべての概略バッファーのスレッドは初めに隠
されます。

@item gnus-updated-mode-lines
これが @code{nil} であると、Gnus はバッファーのモード行に情報を入れない
ので、時間を節約できるでしょう。
@end table

@node Little Disk Space
@subsection 少しのディスク容量
@cindex disk space

起動ファイルは比較的大きくなるので、空き容量が少なくなってきているときは
その大きさを少し小さくする必要があるでしょう。

@table @code
@item gnus-save-newsrc-file
これが @code{nil} であると、Gnus は決して @file{.newsrc} を保存しませ
ん---それは @file{.newsrc.eld} のみを保存します。これは、Gnus の他のニュー
スリーダーを使えないということです。この変数はディフォルトで @code{t} で
す。

@item gnus-read-newsrc-file
これが @code{nil} であれば、Gnus は @file{.newsrc} を決して読みませ
ん---@file{.newsrc.eld} だけを読みます。これは、Gnus 以外のニュースリー
ダーを使えなくなる、ということです。この変数はディフォルトで
は @code{t} です。

@item gnus-save-killed-list
これが @code{nil} であると、Gnus は死んだグループのリストを保存しません。
この変数を @code{nil} に設定したときは、
@code{gnus-check-new-newsgroups} を @code{ask-server} に、
@code{gnus-check-bogus-newsgroups} を @code{nil} に設定するべきでしょう。
この変数はディフォルトで @code{t} です。
@end table

@node Slow Machine
@subsection 遅い機械
@cindex slow machine

もし遅い機械を持っているか、もしくは単に本当に忍耐力がない時は、Gnus の
実行を把握するためにできることが少しあります。

起動を速くするために @code{gnus-check-new-newsgroups} およ
び @code{gnus-check-bogus-newsgroups} を @code{nil} に設定して下さい。概
略バッファーに入ることと抜けることを速くするため
に @code{gnus-show-threads} と @code{gnus-use-cross-reference}、それ
に @code{gnus-nov-is-evil} を @code{nil} に設定して下さい。

@page
@node Troubleshooting
@section 問題解決
@cindex troubleshooting

Gnus は箱から出してすぐに @emph{非常に} よく動作します---何も問題の起こ
ることは想像できません、本当に。

オッホン。

@enumerate

@item
あなたのコンピュータのスイッチが入っていることを確かめて下さい。

@item
本当に現行の Gnus 版を読み込んでいることを確認して下さい。今ま
で @sc{gnus} を実行してきたのであれば、Gnus が動作するように一
度 Emacs を終了して再起動する必要があります。

@item
@kbd{M-x gnus-version} を試して下さい。もし @samp{Gnus v5.10.6} のような
ものが出てきたなら、正しいファイルが読み込まれています。そうならない場合
は、古い @file{.el} ファイルが散らかっています。それらを消して下さい。

@item
@acronym{FAQ} と how-to を読むためにヘルプグループ (グループバッファー
で @kbd{G h}) を読んで下さい。

@item
@vindex max-lisp-eval-depth
Gnus は多くの多くの再帰構造で動作し、何らかの極端な (そして非常にまれ
な) 事例では、Gnus は再帰を ``あまりに深く'' 降りすぎて、Emacs があなた
にビープ音を鳴らすことがあります。もしこれが起こったなら、
@code{max-lisp-eval-depth} を 500 かそれくらいの値に設定して下さい。
@end enumerate

もし他のすべてが失敗したなら、バグとして問題を報告して下さい。

@cindex bugs
@cindex reporting bugs

@kindex M-x gnus-bug
@findex gnus-bug
もし Gnus のバグを見つけたなら、@kbd{M-x gnus-bug} 命令によってそれを報
告することができます。
@kbd{M-x set-variable RET debug-on-error RET t RET} として、それから私に
バックトレースを送って下さい。私はバグを修正しようとしますが、あなたがバ
グを再現させる方法を正確に書いてくれたときのみ、それを修正することができ
ます。

バグ報告では、詳細すぎることは決してありません。バグ報告をするときは、い
つも @kbd{M-x gnus-bug} 命令を使って下さい。それを使うたびに 10Kb のメー
ルができてしまっても、そしてあなたの環境を以前私に 500 回送ったとしても
です。

私は、記憶という種類のものはまったく持っていないことを覚えておくことも重
要です。もしあなたがバグ報告を送ると、私が返答を送ります。そして、それか
らあなたが ``いや、そうではない! このばか者!'' とだけ送り返してくると、
私はあなたが何に対して私を侮辱しているかがわかりません。常に、すべてを説
明しすぎて下さい。それは私たちすべてにとってもっと簡単になります---もし
私が必要なすべての情報を得られなかったら、私はあなたにメールを送ってさら
なる情報を求め、その結果すべてがより多くの時間を取ることになります。

もしあなたの直面している問題が非常に視覚的で、それをうまく説明できない場
合は、Emacs のウィンドウをファイルにコピーして (例えば、@kbd{xwd} で)、
それをどこか手の届くどこかにおいて、その画像の URL をバグ報告に含めて下
さい。

@cindex patches
もしあなたがバグの修正や改善のためのパッチを寄稿して下さるのでしたら、す
みませんがそのパッチは @samp{diff -u} で作って下さい。

@cindex edebug
問題を報告する前にもっとデバッグしたければ、あなた自身で問題を解決してパッ
チを送るために edebug を使うことができるでしょう。Lisp コードのデバッグ
については Elisp マニュアル (@pxref{Debugging, ,Debugging Lisp Programs,
elisp, The GNU Emacs Lisp Reference Manual}) に書かれています。edebug を
始めるには、もし @kbd{c} を押したときにある変な振舞いが発見されるならば、
第一歩は @kbd{C-h k c} をタイプし、ドキュメンテーション・バッファー中で
ハイパーリンクをクリック (Emacsのみ) して、その関数定義を参照することで
す。そしてその関数名の場所で @kbd{M-x edebug-defun RET} をタイプし
て Gnus に戻り、そのコードを起動するために @kbd{c} を押します。Lisp バッ
ファーでは、@kbd{SPC} でシングルステップ動作、@kbd{M-:} で式を評価、
@kbd{C-h v} で変数を検査、@kbd{q} で実行を中断、あるい
は @kbd{c} か @kbd{g} で実行を再開することができます。

@cindex elp
@cindex profile
@cindex slow
ときどき、直接に elisp のエラーを起こさないものの、Gnus が非常に遅くなる
ために明らかになる問題があります。そんな場合には @kbd{M-x
toggle-debug-on-quit} を使って、遅くなったときに @kbd{C-g} を押し、しか
る後にバックトレースを解析して下さい (その手続きを繰り返すことは、真の問
題領域の分離に役立ちます)。より上等な取り組みは elisp プロファイラー (訳
注: プログラムの実行時の動きを分析する道具) ELP を使用することです。プロ
ファイラーについてはどこか他の場所で完全に文書化されているはずですが、そ
れを始めるために必要な手順を少々書いておきましょう。第一に、プロファイル
してみたい Gnus の部分を計測するための設定を、例えば @kbd{M-x
elp-instrument-package RET gnus} や @kbd{M-x elp-instrument-package RET
message} で行なって下さい。そして、遅い動作を行なわせてから @kbd{M-x
elp-results} を押しましょう。すると、どの動作が時間を食っているかを見て、
後でそれらをデバッグすることができます。動作全体が、プロファイラーの出力
の中で最も遅い関数で費やされた時間よりはるかに長くかかるのは、たぶ
ん Gnus の間違っている部分をプロファイルしたせいでしょう。プロファイルの
統計をリセットするには @kbd{M-x elp-reset-all} を使って下さい。@kbd{M-x
elp-restore-all} はプロファイルする動作を取り除くことになっていますが、
Gnus によって複雑にされかつ動的なコード生成の影響を受けるため、それは必
ずしも完全に動作するとは限らないかもしれません。

もし援助が欲しいだけであれば、@samp{gnu.emacs.gnus} で尋ねるのが良いでしょ
う。私はあまり役に立ちません。

@cindex gnu.emacs.gnus
@cindex ding mailing list
また、ding メーリングリスト---@email{ding@@gnus.org} に訊ねることもでき
ます。購読するためには @email{ding-request@@gnus.org} に書いて下さい。

@page
@node Gnus Reference Guide
@section Gnus の参照ガイド

私の願いは、他の誰かが Gnus でできる何か賢いものを考え出し、その上その賢
いものを書いてくれるということです。これを容易にするためには、Gnus の内
部動作を記述するのが良い方法だろうと私は思いました。あと、そんなに内部じゃ
ない動作をいくつかと、私が今やってることと。

プログラムの内部構造が変更されることはない、などと思ってはいけませんが、
Gnus とそのバックエンド間のインターフェース (これは完全に記述されてい
る) や、スコアファイルの形式 (これも同様)、データ構造 (これは他より変更
されやすいものもある)、操作用の一般メソッド、などを (細部にわたって) 定
義していきます。

@menu
* Gnus Utility Functions::      使用できる共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル規格の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報形式
* Extended Interactive::        記号接頭引数など
* Emacs/XEmacs Code::           Gnus はすべての近代 Emacsen で動作する
* Various File Formats::        Gnus の使用するファイルの形式
@end menu

@node Gnus Utility Functions
@subsection Gnus の有用な関数
@cindex Gnus utility functions
@cindex utility functions
@cindex functions
@cindex internal variables

フックなどから実行される小さな関数を書くときは、Gnus の内部関数
や変数にアクセスすることは絶対必要です。以下が最もよく使われるも
のの一覧です。

@table @code
@item gnus-newsgroup-name
@vindex gnus-newsgroup-name
この変数は現在のニュースグループの名前を保持しています。

@item gnus-find-method-for-group
@findex gnus-find-method-for-group
@var{group} の選択方法を返す関数です。

@item gnus-group-real-name
@findex gnus-group-real-name
正規の (接頭語付きの) Gnus グループ名を受け取り、接頭語無しの名前を返し
ます。

@item gnus-group-prefixed-name
@findex gnus-group-prefixed-name
接頭語無しのグループ名と選択方法を受け取り、正規の (接頭語付きの)
Gnus グループ名を返します。

@item gnus-get-info
@findex gnus-get-info
@var{group} のグループ情報一覧を返します。

@item gnus-group-unread
@findex gnus-group-unread
@var{group} の未読記事の数か、もしくはそれが分からない場合は @code{t} で
す。

@item gnus-active
@findex gnus-active
@var{group} の活動登録です。

@item gnus-set-active
@findex gnus-set-active
@var{group} に活動登録を設定します。

@item gnus-add-current-to-buffer-list
@findex gnus-add-current-to-buffer-list
Gnus 終了時に消去するバッファーの一覧に現在のバッファーを追加します。

@item gnus-continuum-version
@findex gnus-continuum-version
引数として Gnus のバージョン文字列を受け取り、浮動小数点数を返し
ます。古いバージョンは必ず新しいバージョンよりも小さい数になりま
す。

@item gnus-group-read-only-p
@findex gnus-group-read-only-p
@var{group} が読み出し専用であるかどうかを示します。

@item gnus-news-group-p
@findex gnus-news-group-p
@var{group} がニュースバックエンドであるかどうかを示します。

@item gnus-ephemeral-group-p
@findex gnus-ephemeral-group-p
@var{group} が短期グループであるかどうかを示します。

@item gnus-server-to-method
@findex gnus-server-to-method
@var{server} に対応している選択方法を返します。

@item gnus-server-equal
@findex gnus-server-equal
二つの仮想サーバーが同一のものであるかどうかを示します。

@item gnus-group-native-p
@findex gnus-group-native-p
@var{group} が基本グループであるかどうかを示します。

@item gnus-group-secondary-p
@findex gnus-group-secondary-p
@var{group} が二次グループであるかどうかを示します。

@item gnus-group-foreign-p
@findex gnus-group-foreign-p
@var{group} が外部グループであるかどうかを示します。

@item gnus-group-find-parameter
@findex gnus-group-find-parameter
@var{group} のパラメーター一覧を返します。二つ目の引数を与えると、
@var{group} 用のそのパラメーターの値を返します。

@item gnus-group-set-parameter
@findex gnus-group-set-parameter
三つの引数 @var{group}, @var{parameter}, @var{value} を取ります。

@item gnus-narrow-to-body
@findex gnus-narrow-to-body
現在のバッファーの記事の本文を制限表示します。

@item gnus-check-backend-function
@findex gnus-check-backend-function
二つの引数 @var{function}, @var{group} を取ります。@var{group} バックエ
ンドが @var{function} をサポートしているなら、@code{nil} 以外を返します。

@lisp
(gnus-check-backend-function "request-scan" "nnml:misc")
@result{} t
@end lisp

@item gnus-read-method
@findex gnus-read-method
利用者に選択方法をプロンプト入力してもらいます。
@end table

@node Back End Interface
@subsection バックエンドインターフェース

Gnus は @acronym{NNTP} やスプール、メール、仮想グループについては何にも
知りません。ただ仮想サーバー @dfn{virtual servers} と対話する方法を知っ
ているだけです。仮想サーバーはバックエンド @dfn{back end} といくつかのバッ
クエンド変数 @dfn{back end variables} からなります。前者の例として
は @code{nntp}, @code{nnspool}, @code{nnmbox} などがあります。後者の例と
しては @code{nntp-port-number} や @code{nnmbox-directory} があります。

Gnus がバックエンド---例えば @code{nntp}---に何かの情報を要求するときは、
通常関数の引数として仮想サーバー名を含めます。(もしなければ、バックエン
ドは ``現在の'' 仮想サーバーを使用します。) 例えば、
@code{nntp-request-list} はその唯一の (省略可能な) 引数として仮想サーバー
を取ります。もしこの仮想サーバーが開かれていなければ、この関数は失敗しま
す。

仮想サーバー名は、物理的なサーバー名とは何の関係も無いことに注意して下さ
い。この例を見て下さい。

@lisp
(nntp "odd-one"
      (nntp-address "ifi.uio.no")
      (nntp-port-number 4324))
@end lisp

ここで、物理サーバー名は @samp{ifi.uio.no} であるのに対し、仮想サーバー
名は @samp{odd-one} です。

バックエンドは複数の仮想サーバーを切り替え可能でなければなりません。標準
のバックエンドはこれを、仮想サーバー環境を必要なときに取り出し・押し込み
を行なう連想リストを保持することによって実現しています。

インターフェース関数は二つのグループがあります。必ず存在しなければならな
い必須関数 @dfn{required functions} と、Gnus が呼び出しを行なう前にそれ
が存在するかを常に確認する任意関数 @dfn{optional functions} です。

これらの関数はすべて、その戻り値のデータを
を @code{nntp-server-buffer} (@samp{*nntpd*}) バッファーに返すことが求め
られます。これはちょっと不運な名前付けですが、これで我慢しなければなりま
せん。私が結果のデータ @dfn{resulting data} と言ったときは、そのバッファー
の中のデータを指しています。戻り値 @dfn{return value} と言ったときは、関
数呼び出しによって返される関数の値のことを言っています。関数が失敗したと
きは戻り値として @code{nil} を返さなくてはいけません。

バックエンドにはサーバー形式 @dfn{server-forming} のバックエンドであると
呼ばれるものがあり、またそう呼ばれないものもあります。後者は一般には、同
時には一つだけしか操作しないバックエンドで、``サーバー'' の概念がありま
せん。このサーバーとは、グループを持ち、そのグループに情報を配送するもの
で、それ以上のものではありません。

Gnus はグループ名と記事番号によってそれぞれのメッセージを特定します。そ
れら記事番号に関するちょっとした説明をすることは有益かもしれません。まず
第一に、その数値は正の整数です。第二に、Gnus を混乱させることなく古い記
事番号を後で ``再使用'' することは普通はできません。それは、もしあるグルー
プがかつて 42 番の記事を持っていたとしたら、その番号で他の記事を持つこと
はできないか、または Gnus が混乱してしまうかもしれないということです。
@footnote{See the function @code{nnchoke-request-update-info},
@ref{Optional Back End Functions}。} 第三に、記事番号はそのグループでの
到着順になっていなければならないことです。とは言えメッセージの日付も到着
順である必要はありませんが。

すでに前の節で、記事番号は一回使われただけで役目を終わらなければならな
い ``厳しい'' 制限について説明しました。しかし、記事番号の並びに抜けがあ
ると Gnus はとても混乱してしまうので、@emph{通し} 番号を付けることが有用
なのかもしれません。ただし ``再使用不可'' の制限があるので、いつでも番号
の抜けを回避できるとは限りません。また、可能な限り記事番号を 1 から始め
ることは、番号を使い切ってしまうことを避けるために役立ちます。

慣例として、バックエンドは @code{nnなんたら} と名付けられますが、
Gnus には @file{nnheader.el}、@file{nnmail.el} および @file{nnoo.el} の
ように、いくつかのバックエンドではない @code{nnかんたら} があることに注
意して下さい。

ここでの例と定義では、想像上のバックエンド @code{nnchoke} を引き合いに出
すことにします。

@cindex @code{nnchoke}

@menu
* Required Back End Functions::  実装しなければならない関数
* Optional Back End Functions::  実装しなくてもよい関数
* Error Messaging::             メッセージやエラー報告を得る方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言
@end menu

@node Required Back End Functions
@subsubsection 必須バックエンド関数

@table @code
@item (nnchoke-retrieve-headers ARTICLES &optional GROUP SERVER FETCH-OLD)

@var{articles} は記事番号の範囲かあるいは @code{Message-ID} のリストです。
現在のバックエンドではどちらも完全にはサポートしていません---連続した記
事番号 (のリスト) だけで、多くのバックエンドでは @code{Message-ID} によ
る取得はサポートしていません。でもどちらもサポートしていくべきでしょう。

結果のデータは HEAD か @acronym{NOV} 行のいずれかであり、戻り値はこれを
反映した @code{headers} か @code{nov} のいずれかでなくてはなりません。こ
れは今後、HEAD と @acronym{NOV} 行が混在する @code{various} に拡張される
かもしれませんが、現在の Gnus ではサポートされていません。

@var{fetch-old} が @code{nil} 以外であれば、ある意味での ``余分なヘッ
ダー'' を取得しようとします。これは通常、@code{articles} の中の最小番号
の記事よりも小さい記事から (少なくとも) @var{fetch-old} 個の余分なヘッダー
を取得し、空所を埋めることを行ないます。もしバックエンドがこの要求に従う
ことを煩わしいと思った場合には、このパラメーターの存在は無視されることも
あります。この値が @code{nil} でも数値でもなければ、最大限の取得を行ない
ます。

これが HEAD の例です。

@example
221 1056 Article retrieved.
Path: ifi.uio.no!sturles
From: sturles@@ifi.uio.no (Sturle Sunde)
Newsgroups: ifi.discussion
Subject: Re: Something very droll
Date: 27 Oct 1994 14:02:57 +0100
Organization: Dept. of Informatics, University of Oslo, Norway
Lines: 26
Message-ID: <38o8e1$a0o@@holmenkollen.ifi.uio.no>
References: <38jdmq$4qu@@visbur.ifi.uio.no>
NNTP-Posting-Host: holmenkollen.ifi.uio.no
.
@end example

つまり、戻り値が @code{headers} であるときは、データバッファーにこれらヘッ
ダーがいくつかあるということを意味します。

これがそのバッファーの BNF 定義です。

@example
headers        = *head
head           = error / valid-head
error-message  = [ "4" / "5" ] 2number " " <error message> eol
valid-head     = valid-message *header "." eol
valid-message  = "221 " <number> " Article retrieved." eol
header         = <text> eol
@end example

@cindex BNF
(ここで使った BNF の版は RFC822 で使われているものです。)

もし戻り値が @code{nov} であれば、データバッファーに
は @dfn{network overview database} 行が含まれてなくてはなりません。
これは基本的には複数の欄をタブで区切ったものです。

@example
nov-buffer = *nov-line
nov-line   = field 7*8[ <TAB> field ] eol
field      = <text except TAB>
@end example

これらの欄にどのようなものが含まれるかをより詳しく見たければ、
@ref{Headers} を参照して下さい。

@item (nnchoke-open-server SERVER &optional DEFINITIONS)

ここでの @var{server} は仮想サーバー名です。@var{definitions} はこの仮想
サーバーを定義する @code{(VARIABLE VALUE)} 組のリストです。

もしサーバーを開くことができなければ、エラーはシグナルでは通知されません。
そしてバックエンドは、それ以後のこのサーバーへの接続要求を拒否することも
できます。実際、そうすべきです。

もしそのサーバーがすでに開いていれば、この関数は @code{nil} 以外の値を返
さなければなりません。このとき、返される結果のデータはありません。

@item (nnchoke-close-server &optional SERVER)

@var{server} への接続を閉じ、これに関連するすべてのソースを開放します。
もし何らかの理由でサーバーを閉じることができなければ、@code{nil} を返し
ます。

返される結果のデータはありません。

@item (nnchoke-request-close)

すべてのサーバーの接続を閉じ、バックエンドが保有しているすべてのソースを
開放します。このバックエンドによって作成されたバッファーはすべて削除され
ます。(@code{nntp-server-buffer} は削除されませんが。) この関数は通
常 Gnus が終了するときにのみ呼び出されます。

返される結果のデータはありません。

@item (nnchoke-server-opened &optional SERVER)

もし @var{server} が現在の仮想サーバーで、その物理サーバーへの接続が生き
ていれば、この関数は @code{nil} 以外の値を返します。この関数はどんな場合
でも、接続が失われたサーバーへの再接続を行なうことはありません。

返される結果のデータはありません。

@item (nnchoke-status-message &optional SERVER)

この関数は @var{server} からの最後のエラーメッセージを返します。

返される結果のデータはありません。

@item (nnchoke-request-article ARTICLE &optional GROUP SERVER TO-BUFFER)

この関数の結果のデータは、@var{article} で指定された記事です。この指定
は @code{Message-ID} か番号のいずれかです。@code{Message-ID} による記事
の取得を実装するかどうかは任意ですが、可能であると嬉しいですね。

@var{to-buffer} が @code{nil} 以外であれば、結果のデータは通常のデータバッ
ファーの代わりに、このバッファーに返されます。これにより多量のデータをあ
るバッファーから別のバッファーにコピーすることを避けることができ、そし
て Gnus は通常、記事バッファーに直接記事を挿入するように要求しています。

もし可能であるのなら、この関数は、@code{car} が取得した記事のあるグルー
プ名で、@code{cdr} が記事番号である cons セルを返すべきです。これによ
り @code{Message-ID} によって記事を取得したとき、Gnus が本当のグループと
記事番号を知ることができるようになるでしょう。これが不可能な場合には、記
事の取得が成功したときは @code{t} を返します。

@item (nnchoke-request-group GROUP &optional SERVER FAST)

@var{group} のデータを取得します。この関数は、@var{group} を現在のグルー
プにする、という副作用もあります。

@var{fast} があれば、便利なデータを返す面倒を行なわずに、単に
@var{group} を現在のグループにします。

これが結果のデータの例と、それの定義です。

@example
211 56 1000 1059 ifi.discussion
@end example

最初の数値は状態で、これは 211 でなくてはなりません。次はそのグループに
ある記事の総数、最小の記事番号、最大の記事番号、そして最後がグループ名で
す。記事の総数は、最大・最小記事番号から単純に考えられる数よりも小さいこ
とがあることに注意して下さい。いくつかの記事は取り消されているかもしれま
せん。Gnus は総数は単に捨ててしまっているので、(もしそれが問題となるとき
に) 正しい値を生成する面倒を負うべきかどうかは、読者への課題として残して
あります。もしそのグループに記事が無ければ、最小記事番号は 1、最大
は 0 として報告されなければなりません。

@example
group-status = [ error / info ] eol
error        = [ "4" / "5" ] 2<number> " " <Error message>
info         = "211 " 3* [ <number> " " ] <string>
@end example

@item (nnchoke-close-group GROUP &optional SERVER)

@var{group} を閉じ、それに接続されているすべてのソースを開放します。これ
はほとんどのバックエンドでは何もすることがないでしょう。

返される結果のデータはありません。

@item (nnchoke-request-list &optional SERVER)

@var{server} 上で利用可能なすべてのグループの一覧を返します。これ
は @emph{全部} という意味です。

これが、たった二つしかグループを持っていないサーバーからの例です。

@example
ifi.test 0000002200 0000002000 y
ifi.discussion 3324 3300 n
@end example

各行にはグループ名があり、そしてそのグループ内の最大の記事番号、最小の記
事番号、そして最後にフラグです。もしそのグループに記事が無ければ、最小記
事番号は 1、最大は 0 として報告されなければなりません。

@example
active-file = *active-line
active-line = name " " <number> " " <number> " " flags eol
name        = <string>
flags       = "n" / "y" / "m" / "x" / "j" / "=" name
@end example

フラグは、そのグループが読み出し専用 (@samp{n}) であるか、司会者付
き (@samp{m}) であるか、死んでいる (@samp{x}) か、どこか他のグループの別
名 (@samp{=other-group}) であるか、上記のどれでもない (@samp{y}) か、と
いうことを示しています。

@item (nnchoke-request-post &optional SERVER)

この関数は、現在のバッファーを投稿します。これは投稿が成功したかどうかを
返しても構いませんが、必須ではありません。例えば、投稿が非同期に行なわれ
るのであれば、この関数が終了した時点では投稿は普通完了していません。その
場合この関数は、投稿を完了させることができないとき、それをはっきりと利用
者に知らせる見張り関数のようなものを設定するべきでしょう。

この関数から返される結果のデータはありません。
@end table

@node Optional Back End Functions
@subsubsection 任意バックエンド関数

@table @code
@item (nnchoke-retrieve-groups GROUPS &optional SERVER)

@var{groups} はグループのリストであり、この関数はそれら全部のグループの
データを要求します。どうやってそれを行なうかは Gnus の知ったことではあり
ませんが、これはできるだけ迅速な方法で行なわなければなりません。

この関数の戻り値は @code{active} か @code{group} のいずれかで、結果のデー
タの形式が何であるかを示します。前者は @code{nnchoke-request-list} によ
るデータと同じ形式であり、一方後者は @code{nnchoke-request-group} が与え
るものと同じ形式の行でバッファーは埋められます。

@example
group-buffer = *active-line / *group-status
@end example

@item (nnchoke-request-update-info GROUP INFO &optional SERVER)

Gnus グループ情報 (@pxref{Group Info}) が変更箇所としてバックエンドに渡
されます。これはバックエンドが (仮想グループや imap グループの場合のよう
に) 本当にすべての情報を持っている場合に便利になります。この関数は、その
要求に適合させる情報を破壊的に置き換え、@code{nil} ではない値を返さなけ
ればなりません (例外的に、@code{nntp-request-update-info} はネットワーク
資源を浪費しないように、常に @code{nil} を返します)。

この関数から返される結果のデータはありません。

@item (nnchoke-request-type GROUP &optional ARTICLE)

利用者が ``ニュースを送信する'' 命令 (例えば、概略バッファー
で @kbd{F}) を実行したとき、Gnus は利用者がフォローアップしようとしてい
る記事がニュースであるかメールであるかを知らなくてはなりません。この関数
は @var{group} の中の @var{article} がニュースであれば @code{news} を、
メールであれば @code{mail} を、その種別を決定できなけれ
ば @code{unknown} を返します。(@var{article} 引数は、メールグループとニュー
スグループがごちゃまぜになってるかもしれない @code{nnvirtual} において必
要です。) @var{group} と @var{article} は両方とも @code{nil} であるかも
しれません。

この関数から返される結果のデータはありません。

@item (nnchoke-request-set-mark GROUP ACTION &optional SERVER)

記事の印を設定/消去/追加します。普通は Gnus は記事の印 (既読、可視、期限
切れ消去など) を内部で扱い、@file{~/.newsrc.eld} に保存します。しかし、
バックエンドには (@acronym{IMAP} のように) 記事のすべての情報をサーバー
に収めるので、Gnus は印の情報をサーバーに伝達しなければならないものがあ
ります。

@var{action} はこのような様式の印設定の要求のリストです:

@example
(RANGE ACTION MARK)
@end example

@var{range} は印を付けたい記事の範囲です。@var{action} は @code{add} ま
たは @code{del} で、印を追加したり消します (言及されていないすべての印は
保存します)、印の消去 (言及されていない印は保存します) です。
@var{mark} は印のリストです。それぞれの印はシンボルです。現在使われてい
る印は @code{read}, @code{tick}, @code{reply}, @code{expire},
@code{killed}, @code{dormant}, @code{save}, @code{download},
@code{unsend}, @code{forward} および @code{recent} ですが、もし可能なら、
あなたのバックエンドはこれらに制限をするべきではありません。

矛盾する動作が指定されたとき、リストの最後の動作が効力を持つものになりま
す。すなわち、動作に記事 1 に @code{可視} 印を追加する要求があり、リスト
の後で同じ記事から印を消去することを要求していれば、印は実際に消去される
べきです。

動作リストの例です:

@example
(((5 12 30) 'del '(tick))
 ((10 . 90) 'add '(read expire))
 ((92 94) 'del '(read)))
@end example

関数は印を設定できなかった記事の範囲を返すべきです (現在はまったく使われ
ていません)。

この関数からは結果のデータはありません。

@item (nnchoke-request-update-mark GROUP ARTICLE MARK)

もし利用者が、このバックエンドの気に入らない印を設定しようとしたら、この
関数が印を変更することができます。Gnus はもとの @var{mark} の代わりに、
この関数が返したものを @var{article} への印として使います。バックエンド
が気にすることが特になければ、元の @var{mark} を返さなければなりません。
@code{nil} やその他のゴミを返してはいけません。

私が知っているこれのこれの利用法は、@code{nnvirtual} が行なっていること
だけです---もし構成グループが自動期限切れ消去可能であれば、この仮想グルー
プで既読の印を付けると、結果としてその記事に期限切れ消去の印が付けられま
す。

この関数から返される結果のデータはありません。

@item (nnchoke-request-scan &optional GROUP SERVER)

この関数は、バックエンドが到着記事を確認する要求を行なうときにいつで
も (Gnus かそれ以外によって)、あれやこれやと呼び出されることがあります。
メールバックエンドはこの関数が起動されたとき、典型的にはスプールファイル
を読むか @acronym{POP} サーバーに問い合わせにいきます。@var{group} は特
に気に留める必要はありません---もしバックエンドが、一つだけのグループを
走査するのは大変すぎると判断した場合には、全グループの全走査を行なっても
構いません。ですが、実用的にできればそれを局所的に閉じておく方が良いでしょ
う。

この関数に返される結果のデータはありません。

@item (nnchoke-request-group-description GROUP &optional SERVER)

この関数によって返される結果のデータは、@var{group} の説明です。

@example
description-line = name <TAB> description eol
name             = <string>
description      = <text>
@end example

@item (nnchoke-request-list-newsgroups &optional SERVER)

この関数によって返される結果のデータは、サーバー上で利用できるグループす
べての説明です。

@example
description-buffer = *description-line
@end example

@item (nnchoke-request-newgroups DATE &optional SERVER)

この関数から返される結果のデータは、@samp{date} 以降に作成されたすべての
グループです。@samp{date} は通常の人間が読める日付の形式 (すなわち、メー
ルやニュースのヘッダーで使われる形式で、ディフォルトでは関
数 @code{message-make-date} から返されたもの) です。データは active バッ
ファーの形式でなければなりません。

この関数が ``多すぎる'' グループを返してもオーケイです。いくつかのバック
エンドは新しいグループを見つけるよりも、楽をしてすべてのグループのリスト
を返すかもしれません。しかしバックエンドが返す多くのグループに対してこ
れ (訳注: 新しいグループとして扱うこと) をしてはいけません。普通、利用者
自身が作ったグループならば多すぎることはないでしょう。ですか
ら @code{nnml} とそれに類するものはたぶん心配ありません。しか
し @code{nntp} のようなバックエンドではグループはサーバーによって作られ
ていますから、多くのグループが返ってくることがありえます。

@item (nnchoke-request-create-group GROUP &optional SERVER)

この関数は、@var{group} という名前の空のグループを作成します。

返される結果のデータはありません。

@item (nnchoke-request-expire-articles ARTICLES &optional GROUP SERVER FORCE)

この関数は、@var{articles} の範囲のすべての記事に対して期限切れ消去処理
を行ないます。(@var{articles} は現在は記事番号の単純なリストです。) この
関数で消去される前の、記事がどれだけ古い記事であるかの決定はバックエンド
に任されています。@var{force} が @code{nil} 以外であれば、それがどんなに
新しいものであっても、すべての @var{articles} が消去されます。

この関数は削除しなかった、あるいは削除することができなかった記事のリスト
を返します。

返される結果のデータはありません。

@item (nnchoke-request-move-article ARTICLE GROUP SERVER ACCEPT-FORM &optional LAST)

この関数は @var{article} (番号) を、@var{group} か
ら @var{accept-form} を呼び出して移動します。

この関数は、問題の記事を移動させるための準備として、記事に付加されたヘッ
ダー行をすべて削除し、一般に記事を「きれいさっぱり」にします。そし
て ``きれいな'' 記事のあるバッファー
で @var{accept-form} を @code{eval} します。これは本当に複製を行ないます。
もし @code{eval} が @code{nil} 以外の値を返したら、その記事は削除されま
せん。

@var{last} が @code{nil} であれば、この直後にさらに要求が発行される見込
みが高い、という意味になり、これによって最適化がいくらかできるようになり
ます。

この関数は、グループ名が @code{car} で、その記事の移動先の記事番号が
@code{cdr} である cons セルを返します。

そのグループは、バックエンドがそのグループへの記事の収納を要求する前に存
在しなけれまなりません。

返される結果のデータはありません。

@item (nnchoke-request-accept-article GROUP &optional SERVER LAST)

この関数は、現在のバッファーを取り、それを @var{group} の中に挿入します。
@var{last} が @code{nil} であれば、この関数へのさらなる呼び出しが直ちに
行なわれるという意味です。

この関数はグループ名が @code{car} で、その記事の移動先の記事番号が
@code{cdr} である cons セルを返します。

返される結果のデータはありません。

@item (nnchoke-request-replace-article ARTICLE GROUP BUFFER)

この関数は @var{article} (番号) を @var{group} から削除し、代わりに
@var{buffer} をそこに挿入します。

返される結果のデータはありません。

@item (nnchoke-request-delete-group GROUP FORCE &optional SERVER)

この関数は @var{group} を消去します。もし @var{force} があれば、そのグ
ループ内のすべての記事を本当に消去し、そしてそのグループ自身を消去します。
(もし ``グループ自身'' というものがあれば。)

返される結果のデータはありません。

@item (nnchoke-request-rename-group GROUP NEW-NAME &optional SERVER)

この関数は @var{group} から @var{new-name} に名前を変更します。
@var{group} 内にある記事はすべて @var{new-name} に移動します。

返される結果のデータはありません。
@end table

@node Error Messaging
@subsubsection エラーメッセージ表示

@findex nnheader-report
@findex nnheader-get-report
バックエンドはエラー状況を報告するのに @code{nnheader-report} を使わなく
てはなりません---要求を実行できないときにエラーを生起させてはいけません。
この関数の最初の引数はバックエンド名のシンボルで、残りは、複数の引数があ
れば @code{format} への引数として解釈され、一つであればただの文字列にな
ります。この関数は常に @code{nil} を返さなくてはなりません。

@lisp
(nnheader-report 'nnchoke "You did something totally bogus")

(nnheader-report 'nnchoke "Could not request group %s" group)
@end lisp

一方 Gnus は、サーバーから @code{nil} を返されたとき
に @code{nnheader-get-report} を呼び出し、そしてこの関数が問題のバックエ
ンドに対して最後に報告されたメッセージを返します。この関数は一つの引
数---サーバーのシンボルを取ります。

内部的には、これらの関数は @var{back-end}@code{-status-string} にアクセ
スます、つまり @code{nnchoke} バックエンドはそのエラーメッセージ
を @code{nnchoke-status-string} に格納します。

@node Writing New Back Ends
@subsubsection 新しいバックエンドを書く

多くのバックエンドはとても類似しています。
@code{nnml} は @code{nnspool} にとても似ていますが、サーバー上の記事を編
集することができます。@code{nnmh} は @code{nnml} にとても似ていますが、
これはアクティブファイルを使わず、概要データベースも保持しません。
@code{nndir} は @code{nnml} にとても似ていますが、これに
は ``グループ'' の概念はなく、記事の修正はできません。

新しいバックエンドを書くときに他のバックエンドから関数を ``継承'' するこ
とが可能であってほしい、と思うのは理に適っています。そしてまさに、あなた
がそうしたければ、それができるのです。(あなたがそうしたくなければしなく
ても良いですよ、もちろん。)

すべてのバックエンドは公開変数と公開関数を、@code{nnoo} と呼ばれるパッケー
ジを使って宣言します。

他のバックエンドから関数を継承するには (そして現在のバックエンドから他の
バックエンドに関数を継承できるようにするには)、以下のマクロを使用しなけ
ればなりません。

@table @code
@item nnoo-declare
このマクロは、最初の引数を、その後に続く引数の子供であることを宣言します。
例えば、

@lisp
(nnoo-declare nndir
  nnml nnmh)
@end lisp

これで @code{nndir} は、@code{nnml} と @code{nnmh} の両方から関数を継承
しようとしていることを宣言します。

@item defvoo
このマクロは @code{defvar} と同義ですが、その変数を公開サーバー変数とし
て登録します。ほとんどの状態指向型の変数は @code{defvar} ではな
く @code{defvoo} によって宣言するべきです。

通常の @code{defvar} 引数に加えて、このマクロは親バックエンドの変数のリ
ストを取り、この関数がそのバックエンド内で実行されるときに変数を置き換え
ます。

@lisp
(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)
@end lisp

これは @code{nndir} のために @code{nnml} の関数が呼び出されたときに、
@code{nnml-current-directory} は @code{nndir-directory} に設定されるとい
う意味です。(@code{nnmh} も同様です。)

@item nnoo-define-basics
このマクロは、ほとんど全部のバックエンドが持つべき共通関数をいくつか定義
します。

@lisp
(nnoo-define-basics nndir)
@end lisp

@item deffoo
このマクロはまさに @code{defun} のようなもので、同一の引数を取ります。通
常の @code{defun} 処理に加えて、このマクロはその関数を公開しているものと
して登録し、他のバックエンドがそれを継承できるようにします。

@item nnoo-map-functions
このマクロは現在のバックエンドの関数から親バックエンドの関数への置き換え
を行なえるようにします。

@lisp
(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0))
@end lisp

これは @code{nndir-retrieve-headers} が呼び出されたとき、一番目、三番目、
四番目の引数が @code{nnml-retrieve-headers} に渡され、一方、二番目の引数
は @code{nndir-current-group} の値として設定される、という意味です。

@item nnoo-import
このマクロは他のバックエンドから関数を取り込みます。これは単にまだ定義さ
れていない関数を定義するだけなので、ソースファイルの最後の処理として書か
なければなりません。

@lisp
(nnoo-import nndir
  (nnmh
   nnmh-request-list
   nnmh-request-newgroups)
  (nnml))
@end lisp

これは、@code{nndir-request-list} への呼び出しは単
に @code{nnmh-request-list} に引き渡され、一方、@code{nnml} の公開関数で
まだ @code{nndir} で定義されていないものをここで定義します。
@end table

以下は @code{nndir} バックエンドのちょっと短縮した版です。

@lisp
;;; @r{nndir.el --- single directory newsgroup access for Gnus}
;; @r{Copyright (C) 1995,96 Free Software Foundation, Inc.}

;;; @r{Code:}

(require 'nnheader)
(require 'nnmh)
(require 'nnml)
(require 'nnoo)
(eval-when-compile (require 'cl))

(nnoo-declare nndir
  nnml nnmh)

(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)

(defvoo nndir-nov-is-evil nil
  "*Non-nil means that nndir will never retrieve NOV headers."
  nnml-nov-is-evil)

(defvoo nndir-current-group ""
  nil
  nnml-current-group nnmh-current-group)
(defvoo nndir-top-directory nil nil nnml-directory nnmh-directory)
(defvoo nndir-get-new-mail nil nil nnml-get-new-mail nnmh-get-new-mail)

(defvoo nndir-status-string "" nil nnmh-status-string)
(defconst nndir-version "nndir 1.0")

;;; @r{Interface functions.}

(nnoo-define-basics nndir)

(deffoo nndir-open-server (server &optional defs)
  (setq nndir-directory
        (or (cadr (assq 'nndir-directory defs))
            server))
  (unless (assq 'nndir-directory defs)
    (push `(nndir-directory ,server) defs))
  (push `(nndir-current-group
          ,(file-name-nondirectory
            (directory-file-name nndir-directory)))
        defs)
  (push `(nndir-top-directory
          ,(file-name-directory (directory-file-name nndir-directory)))
        defs)
  (nnoo-change-server 'nndir server defs))

(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0)
  (nnmh-request-group nndir-current-group 0 0)
  (nnmh-close-group nndir-current-group 0))

(nnoo-import nndir
  (nnmh
   nnmh-status-message
   nnmh-request-list
   nnmh-request-newgroups))

(provide 'nndir)
@end lisp

@node Hooking New Back Ends Into Gnus
@subsubsection 新しいバックエンドを Gnus に繋げる

@vindex gnus-valid-select-methods
@findex gnus-declare-backend
あなたの新しいバックエンドを Gnus で使いはじめるのはとても簡単で
す---単に @code{gnus-declare-backend} 関数で宣言するだけです。これはバッ
クエンドを @code{gnus-valid-select-methods} 変数に追加します。

@code{gnus-declare-backend} は二つの引数を取ります---バックエンドの名前
と適当な数の能力 @dfn{abilities} です。

これが例です。

@lisp
(gnus-declare-backend "nnchoke" 'mail 'respool 'address)
@end lisp

そして上記の行は @file{nnchoke.el} ファイルに入れます。

能力には以下のものがあります。

@table @code
@item mail
これはメール風バックエンドです---フォローアップは (たいていは) メールで
送られます。
@item post
これはニュース風バックエンドです---フォローアップは (たいていは) ニュー
スで送られます。
@item post-mail
このバックエンドはメールとニュースの両方をサポートします。
@item none
これはニュースでもメールでもないバックエンドです---まったく違った何かで
す。
@item respool
これは再スプールをサポートします---というよりは、その元の記事とグループ
を修正することができます。
@item address
仮想サーバー名の中にサーバーの名前が含まるということです。これはほとんど
全部のバックエンドで必要になります。
@item prompt-address
グループバッファーで @kbd{B} などでこの命令を実行したとき、利用者はアド
レスのプロンプト入力を求められます。これは例えば、@code{nntp} のようなバッ
クエンドでは必要で、@code{nnmbox} では必要ではありません。
@end table

@node Mail-like Back Ends
@subsubsection メール風バックエンド

メールバックエンドがその他のバックエンドに対して一線を画している点は、ほ
とんどのメールバックエンドは @file{nnmail.el} の中の共通関数に強く依存し
ているという点です。例えば、@code{nnml-request-scan} の定義はこのように
なります。

@lisp
(deffoo nnml-request-scan (&optional group server)
  (setq nnml-article-file-alist nil)
  (nnmail-get-new-mail 'nnml 'nnml-save-nov nnml-directory group))
@end lisp

単に @code{nnmail-get-new-mail} にいくつか引数を与えて呼び出すだけで、
@code{nnmail} がメールの移動や分離をすべての面倒を見てくれます。

この関数は四つの引数を取ります。

@table @var
@item method
これは、この呼び出しをどのバックエンドが責任を負うかを指示するシンボルで
す。

@item exit-function
この関数は分離が実行された後に呼び出されます。

@item temp-directory
一時ファイルを格納する場所です。

@item group
この省略可能な引数は、分離が一つのグループに対してのみ実行されるべきであ
るときのグループ名です。
@end table

@code{nnmail-get-new-mail} は各記事を保存するため
に @var{back-end}@code{-save-mail} を呼び出します。
@var{back-end}@code{-active-number} はこの記事に割り当てられた記事番号を
調べるために呼び出されます。

この関数は次の変数も使用します。
@var{back-end}@code{-get-new-mail} (このバックエンドの新着メールを調べる
かどうか) と、新しいアクティブファイルを生成するため
の @var{back-end}@code{-group-alist} およ
び @var{back-end}@code{-active-file} です。
@var{back-end}@code{-group-alist} グループのアクティブ連想リストで、以下
のようなものです。

@example
(("a-group" (1 . 10))
 ("some-group" (34 . 39)))
@end example

@node Score File Syntax
@subsection スコアファイルの構文

スコアファイルは簡単に分析可能で、しかし非常に柔軟なように意図されていま
す。それには Emacs Lisp のリストと同じ読み込み構文な様なものがその指定に
合うだろうということが決定されました。

これは良くあるスコアファイルです:

@lisp
(("summary"
  ("win95" -10000 nil s)
  ("Gnus"))
 ("from"
  ("Lars" -1000))
 (mark -100))
@end lisp

スコアファイルの BNF 定義です。

@example
score-file      = "" / "(" *element ")"
element         = rule / atom
rule            = string-rule / number-rule / date-rule
string-rule     = "(" quote string-header quote space *string-match ")"
number-rule     = "(" quote number-header quote space *number-match ")"
date-rule       = "(" quote date-header quote space *date-match ")"
quote           = <ascii 34>
string-header   = "subject" / "from" / "references" / "message-id" /
                  "xref" / "body" / "head" / "all" / "followup"
number-header   = "lines" / "chars"
date-header     = "date"
string-match    = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space string-match-t ] ] ] ] ] ")"
score           = "nil" / <integer>
date            = "nil" / <natural number>
string-match-t  = "nil" / "s" / "substring" / "S" / "Substring" /
                  "r" / "regex" / "R" / "Regex" /
                  "e" / "exact" / "E" / "Exact" /
                  "f" / "fuzzy" / "F" / "Fuzzy"
number-match    = "(" <integer> [ "" / [ space score [ "" /
                  space date [ "" / [ space number-match-t ] ] ] ] ] ")"
number-match-t  = "nil" / "=" / "<" / ">" / ">=" / "<="
date-match      = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space date-match-t ] ] ] ] ")"
date-match-t    = "nil" / "at" / "before" / "after"
atom            = "(" [ required-atom / optional-atom ] ")"
required-atom   = mark / expunge / mark-and-expunge / files /
                  exclude-files / read-only / touched
optional-atom   = adapt / local / eval
mark            = "mark" space nil-or-number
nil-or-number   = "nil" / <integer>
expunge         = "expunge" space nil-or-number
mark-and-expunge = "mark-and-expunge" space nil-or-number
files           = "files" *[ space <string> ]
exclude-files   = "exclude-files" *[ space <string> ]
read-only       = "read-only" [ space "nil" / space "t" ]
adapt        = "adapt" [ space "ignore" / space "t" / space adapt-rule ]
adapt-rule      = "(" *[ <string> *[ "(" <string> <integer> ")" ] ")"
local           = "local" *[ space "(" <string> space <form> ")" ]
eval            = "eval" space <form>
space           = *[ " " / <TAB> / <NEWLINE> ]
@end example

スコアファイルの認識不可能な要素は無視されるべきですが、捨てられるわけで
はありません。

ご覧の通り、空白が必要ですが、空白の量と型は無関係です。これはスコアファ
イルの様式はプログラマーに任されているということです---すべてを一つの長ーー
い行に吐き出すのが簡単であれば、それは構いません。

いろいろなアトムの意味はこのマニュアルのどこかで説明されていま
す (@pxref{Score File Format})。

@node Headers
@subsection ヘッダー

内部的には Gnus は不思議な流儀で、@acronym{NOV} 様式に対応する記事のヘッ
ダーを溜めておく様式を使います。ある人は、作者が @acronym{NOV} の仕様を
見て恥じること無くすべてを @emph{盗んだ} と思うかもしれませんが、その人
は正しいです。

@dfn{ヘッダー} は非常に負担のかけられすぎた語です。
``ヘッダー'' は RFC1036 では記事の頭の行のこと (例えば、@code{From}) を
話すのに用いられています。それは多くの人か
ら ``ヘッド''---``ヘッダーと本文'' の同義語として使われています。(これ
は、私の意見では避けられるべきです。) そして、Gnus は内部で
は ``ヘッダー'' と呼ぶ様式を使っており、私はここでそれについて説明します。
これは九つの要素からなるベクトルで、基本的に、それぞれのヘッ
ダー (あ痛) が一つの空き場所を占めています。

これらの空き場所は、順番に: @code{number}, @code{subject}, @code{from},
@code{date}, @code{id}, @code{chars}, @code{lines}, @code{xref},
@code{extra} です。これらの空き場所に触って設定するマクロがありま
す---それらはすべて、それぞ
れ @code{mail-header-} と @code{mail-header-set-} いう予想される名前を持っ
ています。

@code{extra} の場所はヘッダー/値の対の連想リストである以外はこれらのすべ
ての場所は文字列です (@pxref{To From Newsgroups})。

@node Ranges
@subsection 範囲

@sc{gnus} は私には非常に役に立つと思われる概念を導入しましたので、私はそ
れをたくさん使い、かなり念入りに作り上げてきました。

質問は単純です: もしあなたが大量の数値により同一性を保証される も
の (object) (@emph{乱暴な} 例を挙げると、記事がそうで
す) を ``含まれている'' として見なしたいときは、普通の連続的行為はあまり
役に立ちません。(長さ 200,000 の連続物は少し息が長すぎます。)

これの解決策は質問と同じくらい単純です。単にその連続物を壊せば良いだけで
す。

@example
(1 2 3 4 5 6 10 11 12)
@end example

は次のものに変形されます。

@example
((1 . 6) (10. 12))
@end example

あの嫌な @samp{(13. 13)} のような要素を避けるために、それのみの も
の (object) を示すために @samp{13} は有効な要素になっています。

@example
((1 . 6) 7 (10 . 12))
@end example

これは二つの範囲を比較してそれが等価 (equal) であるかを調べることは少し
手のこんだことになります:

@example
((1 . 5) 7 8 (10 . 12))
@end example

と

@example
((1 . 5) (7. 8) (10 . 12))
@end example

は等価です。実際のところ、下降しないリストは範囲です:

@example
(1 2 3 4 5)
@end example

は完全に有効な範囲です。とても息の長いものですが。これも有効です:

@example
(1 . 5)
@end example

そして、これは前の範囲と等価です。

これは範囲の BNF 定義です。もちろん、数値の意味上の要求は下降していない
ということは覚えておく必要があります。(任意の回数の同じ数値の繰り返しは
許されていますが、範囲の扱いからは消え去る傾向があります。)

@example
range           = simple-range / normal-range
simple-range    = "(" number " . " number ")"
normal-range    = "(" start-contents ")"
contents        = "" / simple-range *[ " " contents ] /
                  number *[ " " contents ]
@end example

Gnus は現在のところ既読記事と記事の印の情報を付けておくために範囲を使っ
ています。私は 次の権力者 が私にさせてくれるのであれば、C で数の範囲の実
装を計画しています。(私はまだその人に尋ねていません。と言うのは、私はそ
れを普通の連続物に変換し直さないで世の中を完全に範囲に基づいたものにする
ためにもう少し考える必要があるからです。)

@node Group Info
@subsection グループ情報

Gnus はグループのすべての永続情報を @dfn{group info} リストに保存します。
このリストの長さは 3 から 6 (もしくはもっと) の要素で徹底的にグループを
記述します。

ここにあるのはグループ情報 (group info) の二つの例です。一つは非常に単純
なグループで、二つめはもっと複雑なものです:

@example
("no.group" 5 ((1 . 54324)))

("nnml:my.mail" 3 ((1 . 5) 9 (20 . 55))
                ((tick (15 . 19)) (replied 3 6 (19 . 3)))
                (nnml "")
                ((auto-expire . t) (to-address . "ding@@gnus.org")))
@end example

最初の要素は @dfn{グループ名} です---どのようにしろ、Gnus がそれによって
グループを知っているものです。二番目の要素は @dfn{購読度} で、普通は小さ
な整数です。(それは @dfn{階級} になることもできます。それは、コンスセル
で、@code{car} がレベルで、@code{cdr} がスコアです。) 三番目の要素は既読
記事の範囲のリストです。四番目の要素はいろいろな種類の記事の印のリストの
リストです。五番目の要素は選択方法です (もしくは、こちらの方が良いのであ
れば仮想サーバーです)。六番目の要素は @dfn{グループパラメーター} のリス
トで、この部分はそのためにあります。

最後の三つの要素はどれでも、必要が無ければ存在しないこともあります。実際、
グループの非常に大部分は最初の三つの要素だけを持ち、それはたくさんのコン
スセルを節約することができます。

これはグループ情報様式の BNF 定義です:

@example
info          = "(" group space ralevel space read
                [ "" / [ space marks-list [ "" / [ space method [ "" /
                space parameters ] ] ] ] ] ")"
group         = quote <string> quote
ralevel       = rank / level
level         = <integer in the range of 1 to inf>
rank          = "(" level "." score ")"
score         = <integer in the range of 1 to inf>
read          = range
marks-lists   = nil / "(" *marks ")"
marks         = "(" <string> range ")"
method        = "(" <string> *elisp-forms ")"
parameters    = "(" *elisp-forms ")"
@end example

実のところ法則 @samp{marks} は嘘です。
@samp{marks} は @samp{<string>} が @samp{range} の上に構成されているもの
ですが、疑似 BNF でそれを現すのは不愉快なものです。

もし Gnus 情報を持っていて、要素を調べたいのときは、Gnus はそれらの要素
を取得/設定 (get/set) するための一連のマクロを提供しています。

@table @code
@item gnus-info-group
@itemx gnus-info-set-group
@findex gnus-info-group
@findex gnus-info-set-group
グループ名を取得/設定 (get/set) します。

@item gnus-info-rank
@itemx gnus-info-set-rank
@findex gnus-info-rank
@findex gnus-info-set-rank
グループの階級 (rank) を取得/設定します (@pxref{Group Score})。

@item gnus-info-level
@itemx gnus-info-set-level
@findex gnus-info-level
@findex gnus-info-set-level
グループのレベルを取得/設定します。

@item gnus-info-score
@itemx gnus-info-set-score
@findex gnus-info-score
@findex gnus-info-set-score
グループスコアを取得/設定します (@pxref{Group Score})。

@item gnus-info-read
@itemx gnus-info-set-read
@findex gnus-info-read
@findex gnus-info-set-read
既読記事の範囲を取得/設定します。

@item gnus-info-marks
@itemx gnus-info-set-marks
@findex gnus-info-marks
@findex gnus-info-set-marks
印し付き記事の範囲のリストを取得/設定します。

@item gnus-info-method
@itemx gnus-info-set-method
@findex gnus-info-method
@findex gnus-info-set-method
グループ選択方法を取得/設定します。

@item gnus-info-params
@itemx gnus-info-set-params
@findex gnus-info-params
@findex gnus-info-set-params
グループパラメーターを取得/設定します。
@end table

すべての取得関数は一つの引数を取ります---情報のリストです。設定関数は二
つの引数を取ります---情報リストと新しい値です。

グループ情報の最後の三つの要素は強制的なものではないので、要素を設定する
前にグループ情報を拡張する必要があるかもしれません。もしこれが必要な場合
は、これが自動的に起こるために @code{nil} でない三番目の引数を三つの最終
設定関数に与えるだけです。

@node Extended Interactive
@subsection 拡張対話
@cindex interactive
@findex gnus-interactive

Gnus は Emacs の標準の @code{interactive} 指定をシンボル接頭引数を簡単に
使えるために少し拡張しています (@pxref{Symbolic Prefixes})。これはその使
い方の例です:

@lisp
(defun gnus-summary-increase-score (&optional score symp)
  (interactive (gnus-interactive "P\ny"))
  ...
  )
@end lisp

最上の方法は @code{gnus-interactive} を式 @code{interactive} を返すマク
ロとして実装することでしょうが、これは Emacs は関数が対話的であるかどう
かをラムダ式に対して単純に @code{assq} を行なうことにより調べることから
不可能です。

この関数は (ほとんど) すべての @code{interactive} 指定を受付けますが、も
う少し加えます。

@table @samp
@item y
@vindex gnus-current-prefix-symbol
現在の接頭引数シンボル---変数 @code{gnus-current-prefix-symbol} です。

@item Y
@vindex gnus-current-prefix-symbols
現在の接頭引数シンボルのリストです---変
数 @code{gnus-current-prefix-symbol} です。

@item A
現在の記事番号です---関数 @code{gnus-summary-article-number} です。

@item H
現在の記事ヘッダーです---関数 @code{gnus-summary-article-header} です。

@item g
現在のグループ名です---関数 @code{gnus-group-group-name} です。
@end table

@node Emacs/XEmacs Code
@subsection Emacs/XEmacs コード
@cindex XEmacs
@cindex Emacsen

Gnus は Emacs, XEmacs と Mule で動作するので、そのうちの一つを主環境とす
ることに決めました。私は Emacs を選びました。私が XEmacs や Mule を好き
ではないということではなく、それがアルファベットで最初に来たからです。

これは Gnus は Emacs でまったく警告なくバイトコンパイルできるのに対して、
XEmacs はバイトコンパイルをしている間にギガバイトくらいの警告を出すとい
うことです。私は些細な失敗を見つけ出すことを助けるためにバイトコンパイル
の警告を使っているので、それは非常に役に立ちます。

私は継続的に Emacs の関数の界面 (interface) を使ってきましたが、関数に
は Gnus の別名関数 (alias) を使ってきました。例を出しましょう: Emacs は
関数 @code{run-at-time} を定義していますが、XEmacs は関
数 @code{start-itimer} を定義しています。そこで私
は @code{gnus-run-at-time} と呼ばれる関数を定義し、それ
は Emacs の @code{run-at-time} と同じ引数を取ります。Gnus を Emacs で実
行しているときは、前の関数は単に後のものの別名関数 (alias) になっていま
す。しかし、XEmacs で実行したときは、前者は次の関数の別名関数 (alias) と
なっています:

@lisp
(defun gnus-xmas-run-at-time (time repeat function &rest args)
  (start-itimer
   "gnus-run-at-time"
   `(lambda ()
      (,function ,@@args))
   time repeat))
@end lisp

この種類のものが多くの関数に対してなされています。Gnus は XEmacs で実行
しているときに、元からある Emacs の関数を再定義しません---それは、代わり
に Gnus の等価なものと @code{defalias} をすることによって実行します。全
体的に、よりきれいになります。

XEmacs の関数界面の方が明らかにきれいな場合は、私は代わりにそれを使いま
す。例えば、@code{gnus-region-active-p} は XEmacs で
は @code{region-active-p} の別名であるのに対して、Emacs では関数です。

もちろん、私は XEmacs を私の基本プラットフォームに選んで、関数の割り当て
を逆にすることもできました。でも、私はそうしませんでした。
XEmacs で Gnus を実行するときに、こういう逆向きのための速度低下は少しで
しょう。

@node Various File Formats
@subsection いろいろなファイル様式

@menu
* Active File Format::          使用可能な記事グループの情報
* Newsgroups File Format::      グループの記述
@end menu

@node Active File Format
@subsubsection アクテイブファイル様式

アクティブファイルは当のサーバーのすべての使用可能なグループの一覧を挙げ
ます。それはそれぞれのグループの最低と最高の記事番号の一覧もあります。

これは普通のアクティブファイルからの抜粋です:

@example
soc.motss 296030 293865 y
alt.binaries.pictures.fractals 3922 3913 n
comp.sources.unix 1605 1593 m
comp.binaries.ibm.pc 5097 5089 y
no.general 1000 900 y
@end example

これはこのファイルの疑似 BNF 定義です。

@example
active      = *group-line
group-line  = group spc high-number spc low-number spc flag <NEWLINE>
group       = <non-white-space string>
spc         = " "
high-number = <non-negative integer>
low-number  = <positive integer>
flag        = "y" / "n" / "m" / "j" / "x" / "=" group
@end example

このファイルの完全な記述を得るためには、@samp{innd} のマニュアルページ、
特に @samp{active(5)} を見て下さい。

@node Newsgroups File Format
@subsubsection ニュースグループファイル様式

ニュースグループファイルはグループをその記述と共に一覧を挙げます。サーバー
にあるすべてのグループが一覧にされなければならないのではなく、また、ファ
イルのすべてのグループがサーバーに存在しなければならないのではありません。
このファイルは純粋に利用者の情報のためにあります。

様式は非常に簡単です: グループ名、タブ、そして記述です。これは定義です:

@example
newsgroups    = *line
line          = group tab description <NEWLINE>
group         = <non-white-space string>
tab           = <TAB>
description   = <string>
@end example

@page
@node Emacs for Heathens
@section 異教徒への Emacs

信じるかどうかは知りませんが、Gnus を使う人の中には Gnus Love Boat での
旅に搭乗する前にあまり Emacs を使ったことが無いという人がいます。もしあ
なたが ``@kbd{C-M-a}'' や ``リージョンを切る''、そし
て ``@code{gnus-flargblossen} を連想リストに設定して下さい。そのキーはグ
ループ名に合致するために使われる正規表現です'' が少しの意味かまったく意
味の無い魔法の言葉である不幸な人であれば、この付録はあなたのためにありま
す。もしあなたがすでに Emacs に親しんでいるのであれば、これを無視して車
を可愛がりに行って下さい。

@menu
* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語
@end menu

@node Keystrokes
@subsection 打鍵

@itemize @bullet
@item
Q: 経験のある Emacs の利用者とは何ですか?

@item
A: 端末がペダルを持っていたらなぁと願う人のことです。
@end itemize

はい、あなたが Emacs を使うと、あなたはコントロールキー、シフトキー、メ
タキーをたくさん使うようになるでしょう。これは一部の人 (主に、
@code{vi} 利用者) には非常にうるさく感じられるでしょう。残りの人々は、そ
れによりもたらされる地獄を愛します。あきらめて服従して下さい。Emacs は本
当は ``Escape-Meta-Alt-Control-Shift'' の略で、他の評判の悪い出
所 (Emacs の作者のような) から聞いた ``Editing Macros'' ではありません。

シフトキーは普通は小指の近くに位置しており、普通は大文字やその他のもを得
るために使われます。あなたはずっとそれを使うことでしょう。コントロールキー
は普通は ``CTRL'' やそのようなもので印が付いています。メタキーは、おもし
ろいことに、どのキーボードでもそのように印が付けられていません。それは普
通はキーボードの左手側に位置していて、普通は最下段にあります。

これから、私たち Emacs 人は、それがあまりに不便なため、
``meta-control-m キーを押す'' とは言いません。私たちは ``@kbd{C-M-m} を
押す'' と言います。@kbd{M-} は ``メタ'' を現す接頭語で、``C-'' は ``コン
トロール'' を意味する接頭語です。ですから、``@kbd{C-k} を押
す'' は ``コントロールキーを下に押し、@kbd{k} を押している間、それを下に
保ちなさい'' ということです。``@kbd{C-M-k} を押す'' は``メタキーとコント
ロールキーを押して下に保った後で @kbd{k} を押す'' ということです。簡単で
しょ。ね?

これはすべてのキーボードがメタキーを持っているわけではないという事実によ
り少し複雑になっています。そのような場合は、``エスケープ'' キーを使うこ
とができます。それはメタキーを持っているときよりもっと作業が大変になるの
で、そういう場合は、私はメタキーのあるキーボードを手に入れることを恭しく
お勧め致します。それ無しでは生きて行けないでしょう。

@node Emacs Lisp
@subsection Emacs Lisp

Emacs はそれが本当は Lisp インタープリターであることから、エディターの王
様です。あなたが叩く、それぞれのすべてのキーは何らかの Emacs Lisp のコー
ドの小片を実行し、Emacs Lisp はインタープリターで実行される言語であるこ
とから、それはどんなキーでも任意のいろいろなコードを実行するように設定で
きるということです。あなたは、単に、そうすれば良いだけです。

Gnus は Emacs Lisp によって書かれていて、それはたくさんの逐次解釈実行さ
れる関数により実行されます。(これらは速度のためにバイトコンパイルされて
いますが、それでもまだ逐次解釈されます。) もし Gnus がするあることを好き
ではないと思ったなら、違ったように実行させるのは取るに足らないことです。
(えーと、少なくとも Lisp コードの書き方を知っていれば。) しかし、それは
このマニュアルの範囲外なので、私たちは単に Gnus をカスタマイズするため
に @file{.emacs} ファイルで普通使われるいくつかの普通の構文についてだけ
話をします。

もし変数 @code{gnus-florgbnize} を四 (4) に設定したいのであれば、以下の
ものを書きます:

@lisp
(setq gnus-florgbnize 4)
@end lisp

この関数 @code{setq} (本当は ``特殊形式'' (special form)) を使って、変数
を何かの値に設定することができます。これは本当にあなたが知るべきすべての
ことです。これからは Gnus の動作を変更するために、たくさんのこのようなも
ので @file{.emacs} ファイルを埋め尽くすことができます。

もしあなたがそのようなものを @file{.emacs} ファイルに入れたら、それは次
回に Emacs を起動したときに読み込まれ @code{評価} (それは ``実
行'' の lisp 語です) されます。もし変数をすぐに変更したいのであれば、閉
じ括弧の後で単に @kbd{C-x C-e} とするだけです。それは前にあ
る ``式'' を @code{評価} し、それはここでは簡単な @code{setq} 文です。

がんばって---もしあなたが Emacs の前にあるのであればちょっと試して下さい。
@kbd{C-x C-e} の後で、反響区域 (echo area) に @samp{4} が現われるのが見
えるでしょう。それはあなたが @code{評価} した式の返り値です。

いくつかの落とし穴:

もしマニュアルが ``@code{gnus-read-active-file} を @code{some} に設定し
なさい'' と言ったなら、それは:

@lisp
(setq gnus-read-active-file 'some)
@end lisp

ということです。

一方、マニュアル
が ``@code{gnus-nntp-server} を @samp{nntp.ifi.uio.no} に設定しなさ
い'' と言ったなら、それは:

@lisp
(setq gnus-nntp-server "nntp.ifi.uio.no")
@end lisp

ということです。

ですから、文字列 (後者) を シンボル (前者) と混同しないように注意して下
さい。マニュアルは明確に区別していますが、混乱しやすいかもしれません。

@page
@include gnus-faq-ja.texi

@node Index
@chapter Index
@printindex cp

@node Key Index
@chapter Key Index
@printindex ky

@summarycontents
@contents
@bye

@iftex
@iflatex
\end{document}
@end iflatex
@end iftex

@c Local Variables:
@c coding: iso-2022-7bit
@c fill-column: 72
@c mode: texinfo
@c use-kuten-for-period: t
@c use-touten-for-comma: t
@c End:
