\input texinfo-ja

@setfilename gnus-ja.info
@settitle Gnus Manual
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex pg cp
@documentencoding UTF-8
@documentlanguage ja

@copying
Copyright @copyright{} 1995--2019 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual'',
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License''.

この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契約書
第 1.3 版またはそれ以降の版が定める条件の下で複製、配布、あるいは変更す
ることを許可します。変更不可部分は指定しません。“A GNU Manual”は表表紙
テキスト、以下の (a) は裏表紙テキストです。この利用許諾契約書の複写は
「GNU フリー文書利用許諾契約書」という章に含まれています。

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.''

(a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を複製したり変更す
る自由があります。」
@end quotation
@end copying

@iftex
@iflatex
\documentclass[twoside,a4paper,openright,11pt]{book}
\usepackage[latin1]{inputenc}
\usepackage{pagestyle}
\usepackage{epsfig}
\usepackage{pixidx}
\input{gnusconfig.tex}

\ifx\pdfoutput\undefined
\else
\usepackage[pdftex,bookmarks,colorlinks=true]{hyperref}
\usepackage{thumbpdf}
\pdfcompresslevel=9
\fi

\makeindex
\begin{document}

\newcommand{\gnusversionname}{Gnus v5.13}
\newcommand{\gnuschaptername}{}
\newcommand{\gnussectionname}{}

\newcommand{\gnusbackslash}{/}

\newcommand{\gnusref}[1]{``#1'' on page \pageref{#1}}
\ifx\pdfoutput\undefined
\newcommand{\gnusuref}[1]{\gnustt{#1}}
\else
\newcommand{\gnusuref}[1]{\href{#1}{\gnustt{#1}}}
\fi
\newcommand{\gnusxref}[1]{See ``#1'' on page \pageref{#1}}
\newcommand{\gnuspxref}[1]{see ``#1'' on page \pageref{#1}}

\newcommand{\gnuskindex}[1]{\index{#1}}
\newcommand{\gnusindex}[1]{\index{#1}}

\newcommand{\gnustt}[1]{{\gnusselectttfont{}#1}}
\newcommand{\gnuscode}[1]{\gnustt{#1}}
\newcommand{\gnusasis}[1]{\gnustt{#1}}
\newcommand{\gnusurl}[1]{\gnustt{#1}}
\newcommand{\gnuscommand}[1]{\gnustt{#1}}
\newcommand{\gnusenv}[1]{\gnustt{#1}}
\newcommand{\gnussamp}[1]{``{\fontencoding{OT1}\gnusselectttfont{}#1}''}
\newcommand{\gnuslisp}[1]{\gnustt{#1}}
\newcommand{\gnuskbd}[1]{`\gnustt{#1}'}
\newcommand{\gnuskey}[1]{`\gnustt{#1}'}
\newcommand{\gnusfile}[1]{`\gnustt{#1}'}
\newcommand{\gnusdfn}[1]{\textit{#1}}
\newcommand{\gnusi}[1]{\textit{#1}}
\newcommand{\gnusr}[1]{\textrm{#1}}
\newcommand{\gnusstrong}[1]{\textbf{#1}}
\newcommand{\gnusemph}[1]{\textit{#1}}
\newcommand{\gnusvar}[1]{{\fontsize{10pt}{10}\selectfont\textsl{\textsf{#1}}}}
\newcommand{\gnussc}[1]{\textsc{#1}}
\newcommand{\gnustitle}[1]{{\huge\textbf{#1}}}
\newcommand{\gnusversion}[1]{{\small\textit{#1}}}
\newcommand{\gnusauthor}[1]{{\large\textbf{#1}}}
\newcommand{\gnusresult}[1]{\gnustt{=> #1}}
\newcommand{\gnusacronym}[1]{\textsc{#1}}
\newcommand{\gnusemail}[1]{\textit{#1}}

\newcommand{\gnusbullet}{{${\bullet}$}}
\newcommand{\gnusdollar}{\$}
\newcommand{\gnusampersand}{\&}
\newcommand{\gnuspercent}{\%}
\newcommand{\gnushash}{\#}
\newcommand{\gnushat}{\symbol{"5E}}
\newcommand{\gnusunderline}{\symbol{"5F}}
\newcommand{\gnusnot}{$\neg$}
\newcommand{\gnustilde}{\symbol{"7E}}
\newcommand{\gnusless}{{$<$}}
\newcommand{\gnusgreater}{{$>$}}
\newcommand{\gnusbraceleft}{{$>$}}
\newcommand{\gnusbraceright}{{$>$}}

\newcommand{\gnushead}{\raisebox{-1cm}{\epsfig{figure=ps/gnus-head,height=1cm}}}
\newcommand{\gnusinteresting}{
\marginpar[\mbox{}\hfill\gnushead]{\gnushead}
}

\newcommand{\gnuscleardoublepage}{\ifodd\count0\mbox{}\clearpage\thispagestyle{empty}\mbox{}\clearpage\else\clearpage\fi}

\newcommand{\gnuspagechapter}[1]{
{\mbox{}}
}

\newdimen{\gnusdimen}
\gnusdimen 0pt

\newcommand{\gnuschapter}[2]{
\gnuscleardoublepage
\ifdim \gnusdimen = 0pt\setcounter{page}{1}\pagestyle{gnus}\pagenumbering{arabic} \gnusdimen 1pt\fi
\chapter{#2}
\renewcommand{\gnussectionname}{}
\renewcommand{\gnuschaptername}{#2}
\thispagestyle{empty}
\hspace*{-2cm}
\begin{picture}(500,500)(0,0)
\put(480,350){\makebox(0,0)[tr]{#1}}
\put(40,300){\makebox(500,50)[bl]{{\Huge\bf{#2}}}}
\end{picture}
\clearpage
}

\newcommand{\gnusfigure}[3]{
\begin{figure}
\mbox{}\ifodd\count0\hspace*{-0.8cm}\else\hspace*{-3cm}\fi\begin{picture}(440,#2)
#3
\end{picture}
\caption{#1}
\end{figure}
}

\newcommand{\gnusicon}[1]{
\marginpar[\mbox{}\hfill\raisebox{-1.5cm}{\epsfig{figure=ps/#1-up,height=1.5cm}}]{\raisebox{-1cm}{\epsfig{figure=ps/#1-up,height=1cm}}}
}

\newcommand{\gnuspicon}[1]{
\margindex{\epsfig{figure=#1,width=2cm}}
}

\newcommand{\gnusxface}[2]{
\margindex{\epsfig{figure=#1,width=1cm}\epsfig{figure=#2,width=1cm}}
}

\newcommand{\gnussmiley}[2]{
\margindex{\makebox[2cm]{\hfill\epsfig{figure=#1,width=0.5cm}\hfill\epsfig{figure=#2,width=0.5cm}\hfill}}
}

\newcommand{\gnusitemx}[1]{\mbox{}\vspace*{-\itemsep}\vspace*{-\parsep}\item#1}

\newcommand{\gnussection}[1]{
\renewcommand{\gnussectionname}{#1}
\section{#1}
}

\newenvironment{codelist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{asislist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{kbdlist}%
{\begin{list}{}{
\labelwidth=0cm
}
}{\end{list}}

\newenvironment{dfnlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{stronglist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{samplist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{varlist}%
{\begin{list}{}{
}
}{\end{list}}

\newenvironment{emphlist}%
{\begin{list}{}{
}
}{\end{list}}

\newlength\gnusheadtextwidth
\setlength{\gnusheadtextwidth}{\headtextwidth}
\addtolength{\gnusheadtextwidth}{1cm}

\newpagestyle{gnuspreamble}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\mbox{}}\textbf{\hfill\roman{page}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\roman{page}\hfill\mbox{}}}
}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnusindex}%
{
{
\ifodd\count0
{
\hspace*{-0.23cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\gnuschaptername\hfill\arabic{page}}}}
}
\else
{
\hspace*{-3.25cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\newpagestyle{gnus}%
{
{
\ifodd\count0
{
\makebox[12cm]{\hspace*{3.1cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{chapter}.\arabic{section}} \textbf{\gnussectionname\hfill\arabic{page}}}}}
}
\else
{
\makebox[12cm]{\hspace*{-2.95cm}\underline{\makebox[\gnusheadtextwidth]{\textbf{\arabic{page}\hfill\gnuschaptername}}}}
}
\fi
}
}
{
\ifodd\count0
\mbox{} \hfill
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\else
\raisebox{-0.5cm}{\epsfig{figure=ps/gnus-big-logo,height=1cm}}
\hfill \mbox{}
\fi
}

\pagenumbering{roman}
\pagestyle{gnuspreamble}

@end iflatex
@end iftex

@iftex
@iflatex

\begin{titlepage}
{

%\addtolength{\oddsidemargin}{-5cm}
%\addtolength{\evensidemargin}{-5cm}
\parindent=0cm
\addtolength{\textheight}{2cm}

\gnustitle{\gnustitlename}\hfill\gnusversion{\gnusversionname}\\
\rule{15cm}{1mm}\\
\vfill
\hspace*{0cm}\epsfig{figure=ps/gnus-big-logo,height=15cm}
\vfill
\rule{15cm}{1mm}\\
\gnusauthor{by Lars Magne Ingebrigtsen}
\newpage
}

\mbox{}
\vfill

\thispagestyle{empty}

@c @insertcopying
\newpage
\end{titlepage}
@end iflatex
@end iftex

@dircategory Emacs network features
@direntry
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
@end direntry
@iftex
@finalout
@end iftex

@titlepage
@ifset WEBHACKDEVEL
@title Gnus Manual (DEVELOPMENT VERSION)
@end ifset
@ifclear WEBHACKDEVEL
@title Gnus Manual
@end ifclear

@author by Lars Magne Ingebrigtsen
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@summarycontents
@contents

@node Top
@top The Gnus Newsreader

@ifinfo
Gnus を使うことによって Emacs でニュースを (それにメールも) 読むことがで
きます。ニュースは @acronym{NNTP}、ローカルスプール、mbox ファイルなどの
あらゆる極悪な手段を駆使して手に入れることができます。運試しをしてみよう
と思うならば、すべてを同時に用いることもできます。

この説明書は Emacs 26.0.91 に付属する Gnus v5.13 に対応します。

@ifnottex
@insertcopying
@end ifnottex
@end ifinfo
@iftex

@iflatex
\tableofcontents
\gnuscleardoublepage
@end iflatex

Gnus は先進的で、説明不用で、カスタマイズ可能で、拡張可能な、リアルタイ
ムでない GNU Emacs のニュースリーダーです。

おおっと。不思議なことに以前にも似たようなことを聞いたことがあるような気
がします。真似をしたと非難されないうちに説明を始めましょう:

Gnus はメッセージを読むことに関する実験場です。Gnus はすべてをニュースグ
ループのように表示します。Gnus でメールを読み、ディレクトリーをブラウズ
し、@code{ftp} をすることができます。ああ、それに、ニュースを読むことさ
えできます!

Emacs が文章を編集する人に力を与えるように、Gnus はニュースを読む人に力
を与えようとしています。Gnus は利用者が実行可能なことに制限を設けません。
利用者が自分で望む動作をするように Gnus を拡張することを奨励しています。
プログラムが人を操作するべきではありません。人がプログラムを使う (もしく
は濫用する) ことによって、やりたいことをできるようになっているべきなので
す。
@c
@c 以下の行を変更するときは ../Makefile.in を調整してください。
この説明書は Emacs 26.0.91 に付属する Gnus v5.13 に対応します。

@heading 関連する他のマニュアル
@itemize
@item Message manual: メッセージの作成
@item Emacs-MIME:     メッセージの作成; @acronym{MIME} パート
@item Sieve:          Sieve スクリプトを Emacs で管理
@item EasyPG:         @acronym{PGP/MIME} を Gnus で
@item SASL:           @acronym{SASL} 認証を Emacs で
@end itemize
@end iftex

@menu
* Starting Up::              ニュースを見つけるのには苦労が伴うかもしれない
* Group Buffer::             グループを選択し、購読し、削除する
* Summary Buffer::           記事を読み、保存し、投稿する
* Article Buffer::           記事を表示し、扱う
* Composing Messages::       メールとニュースを送るための情報
* Select Methods::           Gnus はすべてのメッセージをいろいろな選択方法で読む
* Scoring::                  記事に値を付ける
* Searching::                メールとニュースの検索エンジン
* Various::                  一般的な設定
* The End::                  さらば、そしてさようなら
* Appendices::               用語、Emacs 入門、@acronym{FAQ}、歴史、内部構造
* GNU Free Documentation License:: この文書の利用許諾契約書
* Index::                    変数、関数、概念の索引
* Key Index::                キー索引

@c Doesn't work right in html.
@c FIXME Do this in a more standard way.
@ifinfo
関連する他のマニュアル

* Message:(message-ja).      メッセージの作成
* Emacs-MIME:(emacs-mime-ja). メッセージの作成; @acronym{MIME} パート
* Sieve:(sieve-ja).          Emacs で Sieve スクリプトを管理する
* EasyPG:(epa-ja).           Gnus で @acronym{PGP/MIME} を使う
* SASL:(sasl-ja).            Emacs で @acronym{SASL} の認証を行なう
@end ifinfo

@detailmenu
 --- The Detailed Node Listing ---

Starting Gnus

* Finding the News::            ニュースを取得する方法を選ぶ
* The Server is Down::          そんなとき、どうすればメールを読めるか
* Slave Gnusae::                同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* New Groups::                  Gnus が新しいグループに対して何をするか
* Changing Servers::            あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::               やっかいなスタートアップファイル---@file{.newsrc}
* Auto Save::                   クラッシュからの回復
* The Active File::             遅い回線からのファイルの取得には時間がかかる
* Startup Variables::           変更したいと思うかもしれない変数

New Groups

* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる

Group Buffer

* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュースを読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Non-ASCII Group Names::       英字以外の名前のグループへのアクセス
* Misc Group Stuff::            他にできること

Group Buffer Format

* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける

Group Topics

* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター

Misc Group Stuff

* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理

Summary Buffer

* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Sticky Articles::             再利用しない記事バッファー
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード

Summary Buffer Format

* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする

Choosing Articles

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数

Reply, Followup and Post

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::

Marking Articles

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方

Threading

* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令

Customizing Threading

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう@dots{} でもあなたは間違っていた!

Decoding Articles

* Uuencoded Articles::          記事を uudecode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?

Decoding Variables

* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数

Article Treatment

* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys, Gravatars を表示する
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの

Alternative Approaches

* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする

Various Summary Stuff

* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令

Article Buffer

* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を @acronym{MIME} に通す
* HTML::                        @acronym{HTML} メッセージを読む
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他

Composing Messages

* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?

Select Methods

* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Using IMAP::                  @acronym{IMAP} からメールを読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* Other Sources::               ディレクトリー、ファイルを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む

Server Buffer

* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない

Getting News

* NNTP::                        @acronym{NNTP} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む

@acronym{NNTP}

* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数

Getting Mail

* Mail in a Newsreader::        ニュースリーダーでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを鬼のように分割することができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる

Mail Sources

* Mail Source Specifiers::      メールのソースがどこかを指定する
* Mail Source Functions::
* Mail Source Customization::   ものごとに影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使う

Choosing a Mail Back End

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Babyl::                       Rmail の旧バージョンは Babyl を使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察

Browsing the Web

* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* RSS::                         RDF Site Summary を読む

Other Sources

* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する
* The Empty Backend::           ニュースを何も取得しないバックエンド

Document Groups

* Document Server Internals::   あなた独自の文書種別を追加する方法

Combined Groups

* Virtual Groups::              たくさんのグループの記事を合併する

Email Based Diary

* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      NNDiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること

The NNDiary Back End

* Diary Messages::              メッセージを NNDiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル

The Gnus Diary Library

* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで

Gnus Unplugged

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               概略バッファーが変化するかもしれないエージェントの所業
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を追い払う方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and flags::             エージェントはどうフラグを維持するのか
* Agent and IMAP::              エージェントを @acronym{IMAP} で使う方法
* Outgoing Messages::           ニュースやメールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{~/.gnus.el} の例
* Batching Agents::             @code{cron} ジョブでニュースを取得する方法
* Agent Caveats::               あなたが予想することと、それが実際にすること

Agent Categories

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス

Agent Commands

* Group Agent Commands::        グループの設定とそれらの内容の取得
* Summary Agent Commands::      手動で選択した記事を取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択

Scoring

* Summary Score Commands::      現在のグループのためのスコア・エントリーを追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
* Score File Format::           スコアファイルには何が入っているか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            Big Sister Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア・エントリーがどこへ行くかを指示する方法
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                効果的にスコアを付ける方法
* Reverse Scoring::             歳をとった問題児は問題ではない
* Global Score Files::          地を覆い、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに翻訳する
* Advanced Scoring::            スコアの規則を作るために論理表現を使う
* Score Decays::                スコアを減衰させるのは役に立つこともある

Advanced Scoring

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する

Searching

* nnir::                        いろんなエンジンで検索する
* nnmairix::                    Mairix で検索する

nnir

* What is nnir?::               @code{nnir} は何をするか?
* Basic Usage::                 簡単な検索のしかた
* Setting up nnir::             @code{nnir} の設定方法

Setting up nnir

* Associating Engines::         エンジンと関連付ける方法

Various

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Image Enhancements::          Emacs の最新バージョンは画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける簡単な方法
* Spam Package::                Spam を濾過して処理するためのパッケージ
* The Gnus Registry::           記事を Message-ID で辿るためのパッケージ
* The Gnus Cloud::              Gnus の印を同期するためのパッケージ
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの

Formatting Variables

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を変化させる
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

Image Enhancements

* X-Face::                      ファンキーなちっちゃな白黒の絵を表示する
* Face::                        よりファンキーでちっちゃなカラーの絵を表示する
* Smileys::                     幸せな顔をまさにそのように表示する
* Picons::                      あなたが読んでいるものの絵を表示する方法
* Gravatars::                   あなたが読んでいる人々のアバターを表示します

Thwarting Email Spam

* The problem of spam::         背景、そして解決
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する

Spam Package

* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::

Spam Statistics Package

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::

Appendices

* History::                     どうやって Gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 ここにあるような本当に難しい語を使う
* Customization::               あなたの要求に沿って Gnus を仕立てる
* Troubleshooting::             うまくいかないときに何を試すか
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短かな紹介
* Frequently Asked Questions::  Gnus の FAQ

History

* Gnus Versions::               どんなバージョンの Gnus がリリースされているか
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性があるの?
* Conformity::                  Gnus はすべての標準を満たそうとする
* Emacsen::                     Gnus は少数の現代的な Emacs で実行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                たくさんの人々
* New Features::                Gnus の新しいことに関する手がかり

New Features

* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の新しいこと
* September Gnus::              公式に Gnus 5.2/5.3 として知られているもの
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            神秘の数も P で始まるけれど。Gnus 5.8/5.9 の別名
* Oort Gnus::                   巨大な。遠く遥かな。Gnus 5.10/5.11。
* No Gnus::                     超やばい。Gnus 5.12/5.13
* Ma Gnus::                     祝 Gnus 25 周年。

Customization

* Slow/Expensive Connection::   ローカルの Emacs で、どこかからニュースを得る
* Slow Terminal Connection::    遠くにあるホストの Emacs を実行する
* Little Disk Space::           大きな設定ファイルを持つことは良くない
* Slow Machine::                速いマシンを買いたい気がする

Gnus Reference Guide

* Gnus Utility Functions::      共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル標準の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報の形式
* Extended Interactive::        シンボル接頭引数など
* Various File Formats::        Gnus が使用するファイルの形式

Back End Interface

* Required Back End Functions:: 実装しなければならない関数
* Optional Back End Functions:: 実装しなくてもよい関数
* Error Messaging::             メッセージを発したりエラーを報告する方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言

Various File Formats

* Active File Format::          使用可能な記事とグループの情報
* Newsgroups File Format::      グループの説明

Emacs for Heathens

* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語
@end detailmenu
@end menu

@node Starting Up
@chapter Gnus の起動
@cindex starting up

Gnus を使う以前にあまり Emacs を使っていないのならば、最初に @ref{Emacs
for Heathens} を読んでください。

@findex gnus
システム管理者が適切な設定をしていたならば、Gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で @kbd{M-x gnus} と打つだけです。さも
なければ、変数 @code{gnus-select-method} をカスタマイズしなければなりま
せん。これは @ref{Finding the News} で説明されています。また、投稿するた
めの最低限の設定を行なうために、変数 @code{user-full-name} およ
び @code{user-mail-address} もカスタマイズしなければなりません。

@findex gnus-other-frame
別のフレーム (frame) で Gnus を起動したいときは、
@kbd{M-x gnus-other-frame} 命令を使うことができます。

開始時に何かがうまくいかないときは @file{~/.gnus.el} ファイルの中で変数
をいくつかいじくりまわさなければならないでしょう。このファイル
は @file{~/.emacs} と似ていますが、こちらは Gnus が起動するときに読み込
まれます。

この説明書でよくわからない用語がでてきたときは、用語の
章 (@ref{Terminology}) を参照してください。

@menu
* Finding the News::      ニュースを取得する方法を選ぶ
* The Server is Down::    そんなとき、どうすればメールを読めるか
* Slave Gnusae::          同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::      グループを読むためだけに Gnus を起動する
* New Groups::            Gnus が新しいグループに対して何をするか
* Changing Servers::      あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::         やっかいなスタートアップファイル---@file{.newsrc}
* Auto Save::             クラッシュからの回復
* The Active File::       遅い回線からのファイルの取得には時間がかかる
* Startup Variables::     変更したいと思うかもしれない変数
@end menu

@node Finding the News
@section ニュースを見つける
@cindex finding news

第一に、Gnus が認知しているすべてのサーバーを列挙してい
る @file{*Server*} という特別なバッファーがあることを知っていなければな
りません。それを見るにはグループバッファーで @kbd{^} を押してください。
サーバーバッファーでは、定義されているあるサーバーで @kbd{@key{RET}} を
押すことによって、それが取り扱っているすべてのグループを (講読しているか
どうかにかかわらず!) 見ることができます。そこでサーバーを追加または削除
したり、外部 (foreign) サーバーの定義を編集したり、サーバーをエージェン
ト化したり解除したり、さらに他の多くのことを手際良く行なうことができます。
@xref{Server Buffer}.  @xref{Foreign Groups}.  @xref{Agent Basics}.

@vindex gnus-select-method
@c @head
変数 @code{gnus-select-method} は Gnus がどこでニュースを探すべきかを示
します。この変数ははじめの要素が「方法」、二番目の要素が「場所」を表すリ
ストである必要があります。この方法はあなたの基本方法 (native method) に
なります。この方法で取ってこないグループはすべて第二の (secondary) 選択
方法で取得するグループか、または外部 (foreign) グループです。

例えば @acronym{NNTP} サーバー @samp{news.somewhere.edu} から毎日 (薬の
ように) 一定の量のニュースを摂取したいのであれば、

@lisp
(setq gnus-select-method '(nntp "news.somewhere.edu"))
@end lisp

@noindent
のようにすることができます。

ローカル・スプールのディレクトリーを読み込みたい場合は、

@lisp
(setq gnus-select-method '(nnspool ""))
@end lisp

@noindent
のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速いで
しょうし、それを使うべきでしょう。でも、もしあなたのサーバー
が Leafnode (それは簡単な個人用のニュースサーバーです) であるならばロー
カルスプールを使ってはいけません。この場合
は @code{(nntp "localhost")} にしましょう。

@vindex gnus-nntpserver-file
@cindex NNTPSERVER
@cindex @acronym{NNTP} server
もしこの変数が設定されていなければ、Gnus は @env{NNTPSERVER} 環境変数を
読みにいきます。もしその変数が設定されていなければ、
Gnus は @code{gnus-nntpserver-file} (設定されていない場合
は @file{/etc/nntpserver}) がこの件に関して何かを言っていないかを調べま
す。もしそれも失敗したなら、Gnus は Emacs が動作しているサーバー
を @acronym{NNTP} サーバーとして使おうとします。随分な当て推量ですけどね。

@findex gnus-group-browse-foreign-server
@kindex B @r{(グループ)}
しかし、普段日常的には一つの @acronym{NNTP} サーバーを使い、違ったサーバー
には興味のあるグループが少ししかない場合、グループバッファー
で @kbd{B} 命令を使うことの方が良いでしょう。それは、選択可能なグループ
を表示し、その中からどれでも好きなものを購読することができます。これ
は @file{.newsrc} の保持をずっとやりやすくします。
@xref{Foreign Groups, 外部グループ}.

@vindex gnus-secondary-select-methods
@c @head
外部グループに対する少し違ったやり方は、変
数 @code{gnus-secondary-select-methods} を設定する方法です。この変数に表
されている選択方法は、多くの点で @code{gnus-select-method} サーバーの選
択方法と同じように扱われます。起動中にアクティブファイルを探しにいき (も
し要求されていれば)、これらのサーバー上にできた新しいニュースグループは
元々のグループと同じように購読されます (もしくは、されません)。

例えばメールを読むために @code{nnmbox} バックエンド (back end) を使いた
いときは、普通この変数を、

@lisp
(setq gnus-secondary-select-methods '((nnmbox "")))
@end lisp

@noindent
と設定します。

@node The Server is Down
@section サーバーが落ちている
@cindex server errors

ディフォルトのサーバーが落ちているときは、当然 Gnus の起動にいくつかの問
題が発生します。しかし、ニュースグループの他にいくつかメールのグループが
あるのならば、それにもかかわらず Gnus を起動する必要があるかもしれません。

信頼できるプログラムの一つである Gnus は、サーバーと接続できないときは基
本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存在し
ないとき (例えば、アドレスを間違えた場合) やサーバーが何らかの理由で一時
的に調子がおかしくなっているときに起こります。もしそのまま続行することに
して、外部グループが一つも無い場合、実はグループバッファーではほとんど何
もできないということに気が付くでしょう。でも、ねぇ、それはあなたの問題で
す。ブブーッ!

@findex gnus-no-server
@c @head
サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなくメー
ルだけを読みたいときは、Gnus を起動するのに @code{gnus-no-server} 命令を
使うことができます。急いでいるときにもぴったりでしょう。この命令は本来の
サーバーには接続しません---その代わりに、レベル 1 と 2 にあるすべてのグ
ループを活動状態にします (基本グループでないグループはその二つのレベルに
しておくのが望ましいでしょう)。@ref{Group Levels} も参照してください (訳
注: @code{gnus-no-server} は @code{gnus-group-use-permanent-levels} 変数
の値を 2 に設定することに注意してください)。

@node Slave Gnusae
@section Gnus をスレーブにする
@cindex slave

あなたには二つ以上の Gnus をそれぞれ別の Emacs 上で同時に動かす必要が生
じるかもしれません。違った @file{.newsrc} ファイルを使っているなら (例え
ば、二つの違ったサーバーから読み込むために、二つの違った Gnus を動作させ
ている場合)、まったく問題はありません。それを行なえば良いだけです。

問題は、同じ @file{.newsrc} ファイルを使う二つの Gnus を動かそうとしたと
きに起こります。

この問題に対処するために Gnus タワーのシンクタンクにいる私たちは、新しい
概念にたどりつきました。「マスター」と「スレーブ」です。(私たちはこの概
念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに関連
してこれらの言葉を使いたいなら、一回使う毎に、私に $1 を送らなければなり
ません。もっちろん「コンピューターアプリケーションのマスター/スレーブ関
係」の使用料はもっと高くなります。)

@findex gnus-slave
とにかく、@kbd{M-x gnus} (もしくは、普段やっている方法) で Gnus を普通に
起動します。その後のスレーブ Gnus はそれぞれ @kbd{M-x gnus-slave} で起動
します。スレーブは普通の @file{.newsrc} は保存しませんが、代わりに「スレー
ブファイル」にスレーブの起動中にどのようなグループが読まれたかという情報
だけを保存します。マスター Gnus が起動するとき、それはそれらのスレーブファ
イルを読み込み (そして消し)、それらからすべての情報を取り込みます。(スレー
ブファイルは、最終的な変更が優先されるようにそれらが作られた順番で読まれ
ます。)

もちろん、スレーブファイルからの情報は普通の (すなわち、マスター
の) @file{.newsrc} ファイルよりも優先されます。

スレーブを起動するときにもしマスターの @file{.newsrc*} ファイル群がセー
ブされていなかったら、自動保存されたファイルを読むかどうかを尋ねられるか
もしれません。“yes”と答えると、マスターにセーブされていない変更はスレー
ブに反映されません。“no”と答えると、マスターで読まれたいくつかの記事が、
スレーブでは未読であると見なされるかもしれません。

@node New Groups
@section 新しいグループ
@cindex new groups
@cindex subscription

@vindex gnus-check-new-newsgroups
新しいニュースグループをまったく見なくても満足ならば、
@code{gnus-check-new-newsgroups} を @code{nil} に設定することができます。
これを設定した場合、起動にかかる時間が短くなります。この変数
が @code{nil} に設定されていても、グループバッファーで @kbd{U} を押せば
いつでも新しいグループを購読することができます (@pxref{Group
Maintenance})。ディフォルトではこの変数は @code{ask-server} です。この変
数が @code{always} に設定されていると、@kbd{g} 命令を実行したときで
も Gnus はバックエンドに新しいグループを探すことを求めま
す (@pxref{Scanning New Messages})。

@menu
* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる
@end menu

@node Checking New Groups
@subsection 新しいグループを調べる

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除さ
れているグループのリストとアクティブファイルを比較することにより判定して
います。この方法は特に速いというわけではありません。
@code{gnus-check-new-newsgroups} が @code{ask-server} であると、Gnus は
サーバーに、最後に接続してから新しいグループができているかどうかを尋ねま
す。この方法は速いし、安上がりです。これにより、削除されたグルー
プ (@pxref{Group Levels}) のリストを保持しておくことからから完全に開放さ
れます。ですから、@code{gnus-save-killed-list} を @code{nil} にすること
ができるでしょう。そうすれば、起動、終了の両方、そして全体にわたって時間
を節約できます。ディスク消費量も少なくなります。それなら、どうしてこれが
ディフォルトではないのでしょう? 残念ながら、すべてのサーバーがこの命令を
理解するわけではないのです。

私は今あなたが何を考えているかを当てられます。どうすればサーバー
が @code{ask-server} を理解するかがわかるのでしょう? え、違うのです
か? あぁ、良かった。というのは、確実な答は存在しないのです。私に言えるこ
とは、この変数を @code{ask-server} に設定して、数日間新しいグループが現
れるかどうかを調べてください、ということだけです。もしいくつかのグループ
が現れたなら、それで動作しています。一つも現れなければ、それは動作してい
ません。私は、Gnus にサーバーが @code{ask-server} を理解するかどうかを推
量させる関数を書くこともできますが、それは単に推量しているにすぎません。
ですから、その関数を書くことはないでしょう。他の方法としては、サーバー
に @code{telnet} をして、@code{HELP} と打ち、サーバーが理解するコマンド
の中に @samp{NEWGROUPS} があるかどうかを調べることもできます。もしあれば、
おそらく動作するでしょう (しかし、適切に機能を提供することな
く @samp{NEWGROUPS} をリストに含めるサーバーもあります)。

この変数は、選択方法のリストであることもできます。そのときは、
Gnus は @code{ask-server} 命令をそれぞれの選択方法に対して実行し、普通の
方法で購読します (もしくは、しません)。これの副作用は、起動にかなり時間
がかかるので、待っている間に瞑想できることです。永久の幸福を達成するため
に、マントラ“dingnusdingnusdingnus”を使ってください。

@node Subscription Methods
@subsection 購読方法

@vindex gnus-subscribe-newsgroup-method
新しいグループに遭遇したときに Gnus が何をするかは、変
数 @code{gnus-subscribe-newsgroup-method} によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名前
を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

@table @code
@item gnus-subscribe-zombies
@vindex gnus-subscribe-zombies
すべての新しいグループをゾンビ (zombie) にします (@pxref{Group Levels})。
これがディフォルトになっています。後でゾンビを (@kbd{A z} によって) 概観
したり、(@kbd{S z} によって) 適切にすべてを削除したり、(@kbd{u} によっ
て) 購読したりできます。

@item gnus-subscribe-randomly
@vindex gnus-subscribe-randomly
任意の順番ですべての新しいグループを購読します。実際には、すべての新しい
グループはグループバッファーの『一番上』に加えられます。

@item gnus-subscribe-alphabetically
@vindex gnus-subscribe-alphabetically
すべての新しいグループをアルファベット順に購読します。

@item gnus-subscribe-hierarchically
@vindex gnus-subscribe-hierarchically
すべての新しいグループを階層的に購読します。この関数
と @code{gnus-subscribe-alphabetically} の違いは少ししかありません。
@code{gnus-subscribe-alphabetically} は新しいグループを厳密にアルファベッ
ト順にならべますが、この関数はグループをその階層の中に入れます。ですから、
@samp{rec} の階層を @samp{comp} の階層の前に持ってきたい場合、この関数は
その配置をぐちゃぐちゃにはしません。もしくは、そのようなものです。

@item gnus-subscribe-interactively
@vindex gnus-subscribe-interactively
新しいグループを対話的に購読します。これは Gnus が @strong{すべて} のグ
ループに対して尋ねることを意味しています。購読するグループは階層的に購読
されます。

@item gnus-subscribe-killed
@vindex gnus-subscribe-killed
すべての新しいグループを削除します。

@item gnus-subscribe-topics
@vindex gnus-subscribe-topics
グループを、それに合致する @code{subscribe} トピックパラメーターを持って
いるグループに入れます (@pxref{Topic Parameters})。例えば、以下のよう
な @code{subscribe} パラメーター

@example
"nnml"
@end example

は、その正規表現に合致するすべてのグループはそのトピックの下で購読される
ということです。

グループに合致するトピックが無い場合、グループは最上位のトピックで購読さ
れます。
@end table

@vindex gnus-subscribe-hierarchical-interactive
上の変数と密接に関係する変数は、
@code{gnus-subscribe-hierarchical-interactive} です。この変数
が @code{nil} でないと、Gnus は階層的な方法で新しいグループを購読するか
どうかを尋ねます。Gnus はそれぞれの階層で、それを下に降りるかどうかを尋
ねます。

よくある間違いは、数段落前の (@code{gnus-subscribe-newsgroup-method}) 変
数を @code{gnus-subscribe-herarchical-interactive} に設定することです。
これは誤りです。これは動作しません。これはおめでたい人のすることです。で
すから、絶対にしないでください。

@node Filtering New Groups
@subsection 新しいグループを選別する

どの新しいグループが購読 (もしくは、無視) されるべきかを管理する快適で手
軽な方法は、@file{.newsrc} ファイルの先頭に @dfn{options} 行を挿入するこ
とです。次は、例です。

@example
options -n !alt.all !rec.all sci.all
@end example

@vindex gnus-subscribe-options-newsgroup-method
この行は、明らかにまじめで理知的で科学的な人間 (あるいは彼女はどこにでも
いる単につまらない人かもしれないけれど) が書いたものです。なぜなら、これ
は @samp{alt} と @samp{rec} で始まる名前を持つグループはすべて無視され、
@samp{sci} で始まる名前を持つグループはすべて購読する、ということを表し
ているからです。Gnus はこれらのグループを購読するのに普通の購読方法を使
いません。代わりに @code{gnus-subscribe-options-newsgroup-method} が使わ
れます。この変数はディフォルトで @code{gnus-subscribe-alphabetically} に
なります。

``options -n'' の形式は単純過ぎます。上記の構文はサポートしているものの
すべてです: つまり、あるニュース階層を強いて講読することもできるし、ある
ニュース階層を講読対象から除外することもできるということです。

@vindex gnus-options-not-subscribe
@vindex gnus-options-subscribe
@file{.newsrc} ファイルをいじりたくない場合は、
@code{gnus-options-subscribe} と @code{gnus-options-not-subscribe} の二
つの変数だけを設定することもできます。この二つの変数は @file{.newsrc} ファ
イルの @samp{optinos -n} 行とまったく同じことをします。どちらの変数も正
規表現で、新しいグループは前者に合致すれば無条件に購読され、後者に合致す
ると無視されます。

@vindex gnus-auto-subscribed-groups
さらにここでおせっかいをする変数は、
@code{gnus-auto-subscribed-groups} です。それ
は @code{gnus-options-subscribe} とまったく同じように動作するので、本当
は余分なものです。しかし、私はこの二つがあった方が良いと思いました。もう
一方の変数は利用者がいじくるのに使われるのに対して、この変数はいくつかの
基本的な規則を設定するためのものです。ディフォルトではこの変数はメールバッ
クエンド (@code{nnml}, @code{nnbabyl}, @code{nnfolder}, @code{nnmbox},
@code{nnmh}, @code{nnimap} および @code{nnmaildir}) からできるすべての新
しいグループを購読するようになっています。それが嫌であれば、この変数を
@code{nil} に設定してください。

@vindex gnus-auto-subscribed-categories
これだけでも十分ですが、さらに @code{gnus-auto-subscribed-categories} は、
それらの選択方法が属するカテゴリーに基づいて講読されるべきであることを明
示できるようにします。ディフォルトは @samp{(mail post-mail)} で、メール
のようなバックエンドに基づく新しいグループは、すべて自動的に講読されるは
ずです。

これらの変数に合致する新しいグループ
は @code{gnus-subscribe-options-newsgroup-method} を使って購読されます。

@node Changing Servers
@section サーバーを換える
@cindex changing servers

ときどき、ある @acronym{NNTP} サーバーから別のサーバーへ移動しなければな
らないことがあります。このようなことはめったにおきませんが、おそらくあな
たが仕事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換
えたいというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね? @code{gnus-select-method} を新
しいサーバーを指し示すように変更すればいいだけですね?

@emph{違います!}

記事の番号は違った @acronym{NNTP} サーバーでも (どうにかして) 同じにして
あるということはありません。そして、Gnus がどの記事を読んだかを記録する
唯一の方法は、記事番号を記録することです。ですか
ら @code{gnus-select-method} を変更したときは、@file{.newsrc} ファイルは
役に立たなくなります。

@findex gnus-group-clear-data-on-native-groups
@kbd{M-x gnus-group-clear-data-on-native-groups} コマンドを使って、基本
グループに関するデータをすべて消去することができます。注意して使ってくだ
さい。

@findex gnus-group-clear-data
@code{gnus-group-clear-data} コマンドは現在のグループのすべてのデータを
クリアします---印と既読記事のリストを消し去ります。

サーバーを変更した後で、キャッシュ階層を移動させなけれ
ば @strong{なりません}。というのは、キャッシュ記事は間違った記事番号になっ
ており、それは Gnus がどの記事を読んだとみなすかに影響します。
@code{gnus-group-clear-data-on-native-groups} はそれを自動で行なってしま
うかどうかを尋ねます。@code{gnus-group-clear-data} では @kbd{M-x
gnus-cache-move-cache} が使えます (でも気を付けて、それはすべてのグルー
プのキャッシュを移動してしまいますから)。

@node Startup Files
@section 起動ファイル
@cindex startup files
@cindex .newsrc
@cindex .newsrc.el
@cindex .newsrc.eld

最もありふれた Unix のニュースリーダーは、@file{.newsrc} と呼ばれる共用
の起動ファイルを使います。このファイルは、講読しているグループと、それら
のグループにおいてどの記事が読まれたかの、すべての情報を持っています。

@sc{gnus} ではものごとが少々複雑になっています。@file{.newsrc} ファイル
を最新のものにするだけではなく、@file{.newsrc} ファイルには合わない情報
を保存しておくために @file{.newsrc.el} と呼ばれるファイルを使います。(実
際は @file{.newsrc} ファイルのすべての情報を複製して保持しています。)
@sc{gnus} はこれらの中で一番最後に保存されたものを使います。これをするこ
とにより、@sc{gnus} と他のニュースリーダーを切り替えて使うことができます。

これはちょっと間が抜けているので、Gnus はもっと良い方法を編み出しました。
@file{.newsrc} と @file{.newsrc.el} ファイルに加えて、
Gnus は @file{.newsrc.eld} と呼ばれるファイルも持っています。Gnus はこれ
らの中で一番新しいファイルを読みますが、@file{.newsrc.el} ファイルに書き
込むことはありません。@file{.newsrc.eld} ファイルは絶対に消すべきではあ
りません。---それは @file{.newsrc} ファイルにはないたくさんの情報を保持
しています。

@vindex gnus-save-newsrc-file
@vindex gnus-read-newsrc-file
@code{gnus-save-newsrc-file} を @code{nil} にすることによっ
て @file{.newsrc} ファイルに書き込むのを止めることができます。そうすれば、
そのファイルを削除することができ、ディスク容量を節約することができ、
Gnus の終了が速くなります。しかし、そうすると他のニュースリーダーを使え
なくなります。でも、ちょっと、誰かそうしたい人がいるでしょうか。同じよう
に @code{gnus-read-newsrc-file} を @code{nil} にすることによって、
Gnus は @file{.newsrc} ファイルとすべての @file{.newsrc-SERVER} ファイル
を無視するようになります。そのことは、あなたが時々違うニュースリーダーを
使ったり、利用可能なグループの異なるサブセットをそれらのニュースリーダー
で読みたい場合に、便利なことがあります。

@vindex gnus-save-killed-list
@code{gnus-save-killed-list} (ディフォルトは @code{t}) が @code{nil} で
あると、Gnus は削除されたグループを起動ファイルに保存しません。これ
は (起動時と終了時の) 時間と、(ディスクの) 容量を節約します。こうする
と Gnus がどのグループが新しいかの記録を持っていないことになるので、新し
いグループの自動購読方法は意味が無くなります。この変数を @code{nil} にし
たときは、@code{gnus-check-new-newsgroups} を常
に @code{nil} か @code{ask-server} にしておくべきでしょう (@pxref{New
Groups})。この変数は正規表現であることもできます。そのような場合は、ファ
イルを保存する直前にその正規表現に合致しないすべてのグループを消去します。
これは、すべてのサーバーが @code{ask-server} を理解するわけではない、と
いったような、いくらかあいまいな状況のときに役に立つでしょう。

@vindex gnus-startup-file
@vindex gnus-backup-startup-file
@vindex version-control
変数 @code{gnus-startup-file} は起動ファイルがどこにあるかを指定します。
ディフォルト値は @file{~/.newsrc} で、それがどのようなものであれ、末尾
に @samp{.eld} を付けたものが Gnus (El Dingo) の起動ファイルになります。
このファイルの番号付きバックアップを残しておきたいとき
は @code{gnus-backup-startup-file} をセットしてください。それ
は @code{version-control} 変数と同じ値を取ります。

@vindex gnus-save-newsrc-hook
@vindex gnus-save-quick-newsrc-hook
@vindex gnus-save-standard-newsrc-hook
@code{gnus-save-newsrc-hook} は各種の newsrc ファイルのどれかを保存する
前に実行されるのに対し、
@code{gnus-save-quick-newsrc-hook} は @file{.newsrc.eld} ファイルを保存
する前に実行され、
@code{gnus-save-standard-newsrc-hook} は @file{.newsrc} ファイルを保存す
る前に実行されます。後の二つは普通はバージョン制御を on/off するのに使わ
れます。ディフォルトでは、起動ファイルを保存するときにバージョン制御が行
なわれます。バックアップファイルの作成を止めたいときは、次のようにしてく
ださい。

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
(add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)
@end lisp

@vindex gnus-init-file
@vindex gnus-site-init-file
Gnus が起動すると、@code{gnus-site-init-file} (ディフォルト
で @file{.../site-lisp/gnus-init}) と @code{gnus-init-file} (ディフォル
トで @file{~/.gnus}) のファイルを読み込みます。これらは普通
の Emacs Lisp ファイルで、@file{~/.emacs} や @file{site-init} ファイル
を Gnus 関係のもので乱雑にしないようにするために使うことができます。
Gnus はこれらと同じ名前のファイルに、接尾語 @file{.elc} と @file{.el} が
付いているものも調べます。言い換えれば、
@code{gnus-init-file} を @file{~/.gnus} に設定すると、
Gnus は @file{~/.gnus.elc}, @file{~/.gnus.el} を探し、最後
に @file{~/.gnus} を (この順番に) 探します。@option{-q} また
は @option{--no-init-file} オプション (@pxref{Initial Options, ,Initial
Options, emacs, The Emacs Editor}) が指定されて Emacs が起動された場合、
Gnus は @code{gnus-init-file} を読み込みません。

@node Auto Save
@section 自動保存
@cindex dribble file
@cindex auto-save

何か Gnus のデータを変更すること (記事を読む、印を付ける、グループを削除
または購読する) をしたとき、変更は特別な「ドリブルバッファー」(dribble
buffer) に書き込まれます。このバッファーは Emacs が普通するように自動保
存されます。@file{.newsrc} ファイルを保存する前に Emacs が落ちたときは、
すべての変更をこのファイルから回復することができるでしょう。

起動時に Gnus がこのファイルの存在を発見すると、Gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。

@vindex gnus-use-dribble-file
@code{gnus-use-dribble-file} が @code{nil} であると、Gnus はドリブルバッ
ファーを作ったり、維持したりしません。ディフォルトは @code{t} です。

@vindex gnus-dribble-directory
Gnus はドリブルファイルを @code{gnus-dribble-directory} に置きます。ディ
フォルトではそのようになっていますが、この変数が @code{nil} であると、
Gnus は @file{.newsrc} ファイルの置かれているディレクトリー (これは普通
は利用者のホームディレクトリーです) に入っていってドリブルファイルを作り
ます。ドリブルファイルは @file{.newsrc} と同じ許可属性を与えられます。

@vindex gnus-always-read-dribble-file
もし @code{gnus-always-read-dribble-file} が @code{nil} でなければ、
Gnus は利用者に尋ねること無く、ドリブルファイルを起動時に読み込みます。

@node The Active File
@section アクティブファイル
@cindex active file
@cindex ignored groups

Gnus は起動したときや、実際に新しい記事が到着しているかを判定しようとす
るときに、アクティブファイルを読み込みます。これはとても大きなファイルで、
そのサーバーの活動中のグループと記事のすべてのリストが入っています。

@vindex gnus-ignored-newsgroups
アクティブファイルを検査する前に、Gnus は正規表
現 @code{gnus-ignored-newsgroups} に合うすべての行を削除します。これは主
に偽の名前を持つグループを排除するために使われてきましたが、興味の無いグ
ループの階層を無視するために使うこともできます。しかし、これはお勧めでき
ません。本当のことを言うと、まったく賛成できません。代わりに、そのような
用途に用いられる変数の概略を知るために、@ref{New Groups} を参照してくだ
さい。
@c This variable is
@c @code{nil} by default, and will slow down active file handling somewhat
@c if you set it to anything else.

@vindex gnus-read-active-file
@c @head
アクティブファイルは比較的大きくなる傾向があるので、遅い回線を使っている
ときは、アクティブファイルを読み込まないよう
に @code{gnus-read-active-file} を @code{nil} に設定することができます。
この変数はディフォルトでは @code{some} です。

そのような時は、Gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読していると
きにこの変数を @code{nil} に設定すると、Gnus は速くなるどころか遅くなっ
てしまうということです。現状では、ニュースを 2400bps 以上のモデムを通し
て読んでいるのでない限り、Gnus の速度はかなり遅くなるでしょう。

この変数は @code{some} という値も取ることができます。その時は、Gnus は購
読しているグループに関する情報をだけを得ようとします。いくつかのサー
バー (@code{LIST ACTIVE group} 命令を使うことのできる、最新鋭の INN サー
バー) では、非常に早くなるでしょうが、他のサーバーでは速くはありません。
どのようにせよ、遅い回線では @code{some} は @code{nil} よりも速く、それ
はもちろん @code{t} よりも速くなります。

いくつかのニュースサーバー (例えば古い Leafnode や古い INN) に
は @code{LIST ACTIVE group} 命令がありません。そういうサーバーに
は @code{nil} をこの変数の値に設定するのが、おそらくもっとも有効でしょう。

もしこの変数が @code{nil} であると、Gnus は完全にがんじがらめの方法でグ
ループの情報を得ようとします。そして、これはあまり速くありません。もしそ
れが @code{some} で @acronym{NNTP} サーバーを使っているときは、Gnus はで
きるだけ速く命令を出し、一撃ですべての返答を読み込みます。この方が普通は
より良い結果をもたらしますが、サーバーが @code{LIST ACTIVE group} 命令を
理解しないなら、サーバーにとってはあまり良いとは言えません。

Gnus の起動にあまりに時間がかかると思ったなら、この変数にこれらの三つの
違った値を試してみて、どれが一番良いかを探してください。

@code{some} か @code{nil} を使うのであれば、どちらにしろ速度を上げるため
にすべての興味の無いグループを必ず削除するべきでしょう。

この変数は第二の (secondary) 選択方法のアクティブファイル取得にも影響す
ることに気を付けてください。

@node Startup Variables
@section 起動変数

@table @code
@item gnus-load-hook
@vindex gnus-load-hook
Gnus (のプログラム) が読み込まれるときに実行されるフックです。何
度 Gnus を起動しても、Emacs が起動してから終了するまでに普通はこのフック
は一回しか実行されないことに注意してください。

@item gnus-before-startup-hook
@vindex gnus-before-startup-hook
Gnus が起動するとき、最初に呼ばれるフックです。

@item gnus-before-resume-hook
@vindex gnus-before-resume-hook
一時停止させられていた Gnus が再開するときに最初に呼ばれるフックです。

@item gnus-startup-hook
@vindex gnus-startup-hook
Gnus が起動された後に、一番最後に実行されるフックです。

@item gnus-started-hook
@vindex gnus-started-hook
Gnus の起動に成功した後に、一番最後に実行されるフックです。

@item gnus-setup-news-hook
@vindex gnus-setup-news-hook
@file{.newsrc} ファイルを読み込んだ後で、グループバッファーを作成する前
に実行されるフックです。

@item gnus-check-bogus-newsgroups
@vindex gnus-check-bogus-newsgroups
もし @code{nil} でないと、Gnus は起動時にすべての偽グループを調べて削除
します。「偽グループ」(bogus group) はあなたの @file{.newsrc} ファイルに
は存在するけれど、ニュースサーバーには実際には存在しない、というグループ
のことです。偽グループを調べるのにはかなり時間がかかるので、時間と資源を
節約するために、この機能は使わないほうがいいでしょう。そして、代わりにグ
ループバッファーで時々偽グループを調べるのが良いでしょう (@pxref{Group
Maintenance})。

@item gnus-inhibit-startup-message
@vindex gnus-inhibit-startup-message
もし @code{nil} でないと、起動時のメッセージは表示されません。そのように
すれば、仕事の代わりにニュースを読んでいるのを上司に気付かれにくくなるで
しょう。この変数は @file{~/.gnus.el} がロードされる前に使われるので、
@file{.emacs} に設定するべきである点を注意してください。

@item gnus-no-groups-message
@vindex gnus-no-groups-message
グループが一つも存在しないときに Gnus が表示するメッセージです。

@item gnus-use-backend-marks
@vindex gnus-use-backend-marks
もし @code{nil} でなかったら Gnus は記事の印を @file{.newsrc.eld} ファイ
ルとバックエンドの両方に格納します。これはグループの操作をいくらか遅くし
ます。
@end table

@node Group Buffer
@chapter グループバッファー
@cindex group buffer
@c Alex Schroeder suggests to rearrange this as follows:
@c
@c <kensanata> ok, just save it for reference.  I'll go to bed in a minute.
@c   1. Selecting a Group, 2. (new) Finding a Group, 3. Group Levels,
@c   4. Subscription Commands, 5. Group Maneuvering, 6. Group Data,
@c   7. Group Score, 8. Group Buffer Format
@c <kensanata> Group Levels should have more information on levels 5 to 9.  I
@c   suggest to split the 4th paragraph ("Gnus considers groups...") as follows:
@c <kensanata> First, "Gnus considers groups... (default 9)."
@c <kensanata> New, a table summarizing what levels 1 to 9 mean.
@c <kensanata> Third, "Gnus treats subscribed ... reasons of efficiency"
@c <kensanata> Then expand the next paragraph or add some more to it.
@c    This short one sentence explains levels 1 and 2, therefore I understand
@c    that I should keep important news at 3 and boring news at 4.
@c    Say so!  Then go on to explain why I should bother with levels 6 to 9.
@c    Maybe keep those that you don't want to read temporarily at 6,
@c    those that you never want to read at 8, those that offend your
@c    human rights at 9...

グループバッファー (@dfn{group buffer}) は有効なグループを全部 (あるいは
一部を) 一覧表示します。これは Gnus を起動したときに最初に表示されるバッ
ファーで、Gnus が生きている限り決して消されることはありません。

@iftex
@iflatex
\gnusfigure{The Group Buffer}{320}{
\put(75,50){\epsfig{figure=ps/group,height=9cm}}
\put(120,37){\makebox(0,0)[t]{Buffer name}}
\put(120,38){\vector(1,2){10}}
\put(40,60){\makebox(0,0)[r]{Mode line}}
\put(40,58){\vector(1,0){30}}
\put(200,28){\makebox(0,0)[t]{Native select method}}
\put(200,26){\vector(-1,2){15}}
}
@end iflatex
@end iftex
@menu
* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな @file{.newsrc} の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュース読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Non-ASCII Group Names::       英字以外の名前のグループへのアクセス
* Misc Group Stuff::            他にできること
@end menu

@node Group Buffer Format
@section グループバッファーの形式

@menu
* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける
@end menu

グループモードのツールバーをカスタマイズすることができます。@kbd{M-x
customize-apropos @key{RET} gnus-group-tool-bar} を試してみてください。

ツールバーのアイコンは、今ではカーソルの位置に応じて正しく有効に、または
無効にされるので、グループバッファー内での移動は遅くなります。これは変
数 @code{gnus-group-update-tool-bar} で禁止することができます。そのディ
フォルト値は Emacs のバージョンに依存しています。

@node Group Line Specification
@subsection グループ行の仕様
@cindex group buffer format

グループバッファーのディフォルトの形式はきれいでつまんないけど、これは君
の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

@example
     25: news.announce.newusers
 *    0: alt.fan.andrea-dworkin
@end example

とっても簡単でしょ?

@samp{news.announce.newusers} には 25 の未読記事があるのがわかります。
@samp{alt.fan.andrea-dworkin} には未読記事はないけれども、印を付けた記事
がいくつかあります (行頭のちっちゃなアスタリスクが見える?)。

@vindex gnus-group-line-format
この形式は @code{gnus-group-line-format} 変数をいじることで、どんな風に
でも変えられます。この変数は @code{format} の仕様風に動作します。つま
り (あのクソ) C 言語を使う人たちのための printf の仕様とほぼ同じです。
@xref{Formatting Variables}.

上記の行を生成するのは @samp{%M%S%5y:%B%(%g%)\n} という値です。

コロンは、この行の中に必ず無くてはいけません。カーソルは何かの操作をした
後は常にコロンのところに移動するからです。@xref{Positioning Point}. 他に
は何も必要ではありません---グループ名さえもです。表示されている文字はす
べてただの画面の飾りであり、Gnus がそれを調べることはありません。Gnus は
必要とするすべての実情報を、テキスト属性を使って憶えています。

(もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとした
ら、みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使いし
たりなんかしてない、って信じてくれるよ。)

以下が使用できるフォーマット文字のリストです。

@table @samp
@item M
そのグループに印の付いた記事しか無いときは、アスタリスク文字。

@item S
そのグループが購読されているかどうか。

@item L
購読度のレベル。

@item N
未読記事の数。

@item I
保留記事の数。

@item T
印付き記事の数。

@item R
既読記事の数。

@item U
まだ読まれたことが無い記事の数。

@item t
推定全記事数 (これは実際は @var{max-number} - @var{min-number} + 1)。

Gnus がこの推定を使うのは、@acronym{NNTP} プロトコルは能率の良
い @var{max-number} と @var{min-number} へのアクセスを提供するものの、本
当の未読記事の数を得るには必ずしも能率的ではないからです。ヒステリックな
レーズン (訳注:「歴史的な理由」のモジり) により、メールバックエンドにお
いても、限定された同じインターフェースを使って、本当の未読記事の数を能率
的に得ることはできるかもしれません。この制限を Gnus から取り払うことはバッ
クエンドのインターフェースを変更することを意味し、それは楽な仕事ではあり
ません。

@code{nnml} バックエンド (@pxref{Mail Spool}) には、この欠陥を巧みに補う
「グループ圧縮」(group compaction) という機能があります。それは、記事の
番号を 1 から順に振り直してすきまを取り除けば正しい全記事数を得ることが
できる、という着想によります。将来は他のバックエンドもこれをサポートする
かもしれません。全記事数をまあまあ最新の状態にしておくためには、時々グルー
プを (またはサーバーのディレクトリーを) 圧縮する必要があるでしょう。
@xref{Misc Group Stuff}, @xref{Server Commands}.

@item y
未読でも、印付きでも、保留でもない記事の数。

@item i
印付き記事と保留記事の数。

@item g
グループ名のフルネーム。

@item G
グループ名。

@item C
グループのためのコメント (@pxref{Group Parameters})、またはグループパラ
メーターにコメントの要素が無い場合はグループ名。

@item D
ニュースグループの説明。これらが現れる前に、グループの説明を読む必要があ
ります。それには @code{gnus-read-active-file} を設定するか、グループバッ
ファーで @kbd{M-d} コマンドを使ってください。

@item o
司会者付きの場合 @samp{m}。

@item O
司会者付きの場合 @samp{(m)}。

@item s
選択方法。

@item B
そのグループの概略バッファーが開いているかどうか。

@item n
どこからの選択か。(訳注: バックエンドのシンボル名)

@item z
外部選択方法が使われている場合、@samp{<%s:%n>} と同じ文字列。

@item P
トピック (@pxref{Group Topics}) のレベルに応じた字下げ。

@item c
@vindex gnus-group-uncollapsed-levels
短い (省略した) グループ名。@code{gnus-group-uncollapsed-levels} 変数は、
どのレベルまでグループ名を全部残すかを示します。ディフォルトは 1 で
す---この意味は、@samp{gnu.emacs.gnus} のようなグループ名
を @samp{g.e.gnus} に短縮するということです。

@item m
@vindex gnus-new-mail-mark
@cindex %
そのグループに最近新着メールが届いている場合
は @samp{%} (@code{gnus-new-mail-mark})。

@item p
@samp{#} (@code{gnus-process-mark}) で、そのグループにプロセス印が付いて
いることを示します。

@item d
最後にいつこのグループを読んだかを示す文字列 (@pxref{Group Timestamp})。

@item F
キャッシュとエージェントの両方によって取得された記事がディスクに占める容
量。値はカラム幅を最小にするために、自動的にバイト (B)、キロバイト (K)、
メガバイト (M)、またはギガバイト (G) に縮尺されます。固定幅カラム用に
は %7F の形式で足ります。

@item u
利用者定義指定。フォーマット文字列中で、この次の文字はアルファベット文字
でなければいけません。
Gnus は @code{gnus-user-format-function-}@samp{X} 関数を呼び出します。こ
こで @samp{X} は @samp{%u} に続いている文字です。この関数は引数に一つの
ダミーパラメーターを渡されます。この関数は、他の各指定文字の情報と同様に、
バッファーに挿入される文字列を返さなければなりません。
@end table

@cindex *
すべての「〜の数」の指定は、もしその情報が利用できない場合にはアスタリス
ク (@samp{*}) で埋められます---例えば、起動されていない外部グループや、
不正な基本グループの場合です。

@node Group Mode Line Specification
@subsection グループモード行の仕様
@cindex group mode line

@vindex gnus-group-mode-line-format
モード行
は @code{gnus-group-mode-line-format} (@pxref{Mode Line Formatting}) を
設定することで変更できます。こいつは指定文字をあんまりたくさん知っていま
せん。

@table @samp
@item S
基本ニュースサーバー。
@item M
基本選択方法。
@end table

@node Group Highlighting
@subsection グループのハイライト
@cindex highlighting
@cindex group highlighting

@vindex gnus-group-highlight
グループバッファーのハイライトは @code{gnus-group-highlight} 変数によっ
て制御されます。これは @code{(@var{form} . @var{face})} のようなものを要
素に持つ連想リストです。@var{form} が評価された結果が、@code{nil} 以外の
何かになると、その行に対して @var{face} が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見えるかもし
れません。

@lisp
(cond (window-system
       (setq custom-background-mode 'light)
       (defface my-group-face-1
         '((t (:foreground "Red" :bold t))) "First group face")
       (defface my-group-face-2
         '((t (:foreground "DarkSeaGreen4" :bold t))) "Second group face")
       (defface my-group-face-3
         '((t (:foreground "Green4" :bold t))) "Third group face")
       (defface my-group-face-4
         '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
       (defface my-group-face-5
         '((t (:foreground "Blue" :bold t))) "Fifth group face")))

(setq gnus-group-highlight
      '(((> unread 200) . my-group-face-1)
        ((and (< level 3) (zerop unread)) . my-group-face-2)
        ((< level 3) . my-group-face-3)
        ((zerop unread) . my-group-face-4)
        (t . my-group-face-5)))
@end lisp

@ref{Faces and Fonts} も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のものがあり
ます。

@table @code
@item group
グループ名。
@item unread
そのグループの未読記事の数。
@item method
選択方法。
@item mailp
そのグループがメールのグループかどうか。
@item level
そのグループのレベル。
@item score
そのグループのスコア。
@item ticked
そのグループ中の印の付いた記事の数。
@item total
そのグループ中の全記事数。もっと正確に言うと、@var{max-number} マイナ
ス @var{min_number} プラス 1。
@item topic
トピックマイナーモードを使用している時、この変数は挿入されている現在のト
ピックに束縛されます。
@end table

この form が評価 (@code{eval}) されるときは、ポイントは問題のグループの
行頭にあります。従って、通常の Gnus の関数のほとんどを使ってそのグループ
の情報を取ってくることができます。

@vindex gnus-group-update-hook
@findex gnus-group-highlight-line
@code{gnus-group-update-hook} はグループ行が変更されたときに呼び出されま
す。これは @code{gnus-visual} が @code{nil} のときは呼び出されません。

@node Group Maneuvering
@section グループ操作
@cindex group movement

すべての移動コマンドは数値接頭引数を理解するので、期待する通りの動作をし
ます。たぶんね。

@table @kbd
@item n
@kindex n @r{(グループ)}
@findex gnus-group-next-unread-group
次の未読記事のあるグループに移動しま
す (@code{gnus-group-next-unread-group})。

@item p
@itemx @key{DEL}
@kindex DEL @r{(グループ)}
@kindex p @r{(グループ)}
@findex gnus-group-prev-unread-group
一つ前の未読記事のあるグループに移動しま
す (@code{gnus-group-prev-unread-group})。

@item N
@kindex N @r{(グループ)}
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item P
@kindex P @r{(グループ)}
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item M-n
@kindex M-n @r{(グループ)}
@findex gnus-group-next-unread-group-same-level
一つ前の同じレベル (もしくはそれより小さいレベル) の未読グループに移動し
ます (@code{gnus-group-prev-unread-group-same-level})。

@item M-p
@kindex M-p @r{(グループ)}
@findex gnus-group-prev-unread-group-same-level
次の同じレベル (もしくはそれより小さいレベル) の未読グループに移動しま
す (@code{gnus-group-next-unread-group-same-level})。
@end table

次の三つの命令はグループにジャンプするためのものです:

@table @kbd
@item j
@kindex j @r{(グループ)}
@findex gnus-group-jump-to-group
グループにジャンプします (それが見えるようになっていなかったら見えるよう
にします) (@code{gnus-group-jump-to-group})。kill されているグループも、
生きているグループと同様にジャンプできます。

@item ,
@kindex , @r{(グループ)}
@findex gnus-group-best-unread-group
最も小さいレベルの未読グループにジャンプしま
す (@code{gnus-group-best-unread-group})。

@item .
@kindex . @r{(グループ)}
@findex gnus-group-first-unread-group
最初の未読記事のあるグループにジャンプしま
す (@code{gnus-group-first-unread-group})。
@end table

@vindex gnus-group-goto-unread
@code{gnus-group-goto-unread} を @code{nil} にすると、すべての移動コマン
ドは、次の未読グループではなく次のグループに移動するようになります。その
コマンドが次の未読グループに移動すると言い張っていてもです。ディフォルト
は @code{t} です。

@vindex gnus-summary-next-group-on-exit
概略バッファーを出たときに @code{gnus-summary-next-group-on-exit} が
@code{t} だったら、グループバッファーで次の未読のグループに移動します。
それ以外の場合は出たグループに留まります。ディフォルトは @code{t} です。

@quotation
訳注: @code{gnus-group-goto-unread} が次の未読グループか単に次のグループ
のどちらに移動するかを指定するのに対し
て @code{gnus-summary-next-group-on-exit} は移動するかしないかを指定する
ために使います。ただし後者は @kbd{q} (または @kbd{Z Q},
@code{gnus-summary-exit}) で概略バッファーを出たときだけに効果を及ぼしま
す。
@end quotation

@node Selecting a Group
@section グループの選択
@cindex group selection

@table @kbd
@item @key{SPC}
@kindex SPC @r{(グループ)}
@findex gnus-group-read-group
現在のグループを選択し、概略バッファーに切り替えて最初の未読記事を表示し
ます (@code{gnus-group-read-group})。もしそのグループに未読記事が無い、
もしくはこの命令に数値以外の接頭引数を与えると、Gnus はサーバーからこの
グループのすべての古い記事を取得しようとします。@var{n} の数値接頭引数を
与えると、Gnus の取得する記事数は @var{n} になります。@var{n} が正の数で
あれば Gnus は新しい方から @var{n} 個の記事を取得し、@var{n} が負の数で
あれば Gnus は古い方から @code{abs(@var{n})} 個の記事を取得します。

したがって、@kbd{@key{SPC}} では普通にグループに入り、
@kbd{C-u @key{SPC}} では古い記事が現れます。@kbd{C-u 4 2 @key{SPC}} で
は 42 個の最新の記事を取得し、@kbd{C-u - 4 2 @key{SPC}} では 42 個の最も
古い記事を取得します。

グループにいる (概略バッファーにいる) ときは、@kbd{M-g} で新しい記事を取
得できるし、@kbd{C-u M-g} では古い記事を表示することができます。

@item @key{RET}
@kindex RET @r{(グループ)}
@findex gnus-group-select-group
現在のグループを選択し、概略バッファーに切り替えま
す (@code{gnus-group-select-group})。@code{gnus-group-read-group} と同じ
引数を取ります---唯一の違いは、グループに入ったときに最初の未読記事を表
示しない、ということです。

@item M-@key{RET}
@kindex M-RET @r{(グループ)}
@findex gnus-group-quick-select-group
これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にしようと
します (@code{gnus-group-quick-select-group})。スコア・kill の処理は行な
われず、ハイライトも記事消去もしません。これは、あなたが本当に急いでいて、
どっかのやたらでっかいグループに入らなければいけないときに役に立つかもし
れません。また、接頭引数に 0 を与えれば (すなわち @kbd{0 M-@key{RET}})、
Gnus は概略バッファーを作ろうとさえしません。これは概略バッファーを作る
前にスレッド表示を切り替えたいとき役に立ちます (@pxref{Summary
Generation Commands})。

@item M-@key{SPC}
@kindex M-SPC @r{(グループ)}
@findex gnus-group-visible-select-group
これは @kbd{@key{RET}} コマンドと同じ動作をするさらにもう一つのコマンド
ですが、このコマンドは記事消去と保留記事を隠す処理を行ないませ
ん (@code{gnus-group-visible-select-group})。

@item C-M-@key{RET}
@kindex C-M-RET @r{(グループ)}
@findex gnus-group-select-group-ephemerally
最後にこのコマンドは、現在のグループを一度限り、その内容に一切の処理をす
ることのないように選択しま
す (@code{gnus-group-select-group-ephemerally})。スレッド表示さえも行な
われません。この方法で選択した後にこのグループに対して行なったことはすべ
て、その後に影響を与えることはありません。
@end table

@vindex gnus-large-newsgroup
@code{gnus-large-newsgroup} 変数は、何を大きなグループと考えるべきか
を Gnus に与えます。@code{nil} だったら、どのグループも大きいと考えませ
ん。ディフォルト値は 200 です。グループに (未読と可視の) 記事がこの数以
上あれば、Gnus はそのグループに入る前に利用者に確認を求めます。利用者は
サーバーからいくつの記事を取得するかを指定できます。もし利用者が負の
数 (@minus{}@var{n}) を指定すれば、古い方から @var{n} 個の記事を取得しま
す。正の数であれば、新しく到着した方から @var{n} 個の記事を取得します。

@vindex gnus-large-ephemeral-newsgroup
@code{gnus-large-ephemeral-newsgroup} は @code{gnus-large-newsgroup} と
同じですが、一時ニュースグループのためにだけ使われます。

@vindex gnus-newsgroup-maximum-articles
いくつかのニュースサーバーのとあるグループでは、期限切れ消去されない少数
の非常に古い記事と最新のものとの間に大きな隙間があるかもしれません。そう
いう場合、そのサーバーは @code{LIST ACTIVE group} コマンドに対して例え
ば @code{(1 . 30000000)} のようなデータを返すでしょう。たとえ実際に
は 1〜10 と 29999900〜30000000 の記事しか無くても、Gnus は最初からそのこ
とを知っているわけではないので 30000000 通の記事を受け取るための準備をし
ます。しかしそれでは何百メガバイトのメモリーを消費してしまうし、場合によっ
ては Emacs を立ち往生させてしまうかもしれません。もしそのようなサーバー
を使うのであれば、変数 @code{gnus-newsgroup-maximum-articles} を正の数に
設定してください。値は、あらゆるグループでその数の最新の記事以外
を Gnus が無視することを意味します。例えば 10000 という数
は Gnus に 29990001〜30000000 の記事だけを取得させるようにします (最新の
記事番号が 30000000 だった場合です)。この変数に数値を設定すると、非常に
古い記事を読むことができなくなってしまうかもしれないことに注意してくださ
い。変数 @code{gnus-newsgroup-maximum-articles} のディフォルト値
は @code{nil} で、その場合 Gnus は古い記事を無視しません。

@vindex gnus-select-group-hook
@vindex gnus-auto-select-first
@vindex gnus-auto-select-subject
もし @code{gnus-auto-select-first} が非-@code{nil} だったら、
@kbd{@key{SPC}} コマンドでグループに入ったときに自動的に記事を選択します。
どの記事が選択されるかは、変数 @code{gnus-auto-select-subject} で制御さ
れます。この変数に設定できる有効な値は:

@table @code
@item unread
最初の未読記事の表題の行にポイントを移動させます。

@item first
最初の記事の表題の行にポイントを移動させます。

@item unseen
まだ読まれたことが無い最初の記事の表題の行にポイントを移動させます。

@item unseen-or-unread
まだ読まれたことが無い最初の記事があれば、その記事の表題の行にポイントを
移動させ、無かったら最初の未読記事の表題の行にポイントを移動させます。

@item best
スコアが最も高い未読記事の表題の行にポイントを移動させます。
@end table

この変数は関数であることもできます。その場合、その関数は表題の行にポイン
トを移動させるために呼ばれます。

もしあるグループで自動記事選択をやめたいのであれば (例えばでっかい記事の
あるバイナリーグループでは、とか)、グループが選択されたときに呼び出され
る @code{gnus-select-group-hook} の中で変
数 @code{gnus-auto-select-first} を @code{nil} に設定することができます。

@node Subscription Commands
@section 購読制御コマンド
@cindex subscription

以下のコマンド群は、グループバッファーで (それぞれのグループを) 講読する
かどうかの管理をできるようにします。もしたくさんのグループを講読したいの
であれば @ref{Server Buffer} に行って、そこで @kbd{@key{RET}} また
は @kbd{@key{SPC}} を使ってサーバーを選ぶ方がおそらくもっと便利かもしれ
ません。その後 @ref{Browse Foreign Server} で列挙しているコマンドが、手
元で使えるようになります。

@table @kbd
@item S t
@itemx u
@kindex S t @r{(グループ)}
@kindex u @r{(グループ)}
@findex gnus-group-unsubscribe-current-group
@c @icon{gnus-group-unsubscribe}
現在のグループを購読する/しないを切り替えま
す (@code{gnus-group-unsubscribe-current-group})。

@item S s
@itemx U
@kindex S s @r{(グループ)}
@kindex U @r{(グループ)}
@findex gnus-group-unsubscribe-group
グループを購読するかどうかを確認し、購読します。すでに購読するようになっ
ている場合には、購読を止めます (@code{gnus-group-unsubscribe-group})。

@item S k
@itemx C-k
@kindex S k @r{(グループ)}
@kindex C-k @r{(グループ)}
@findex gnus-group-kill-group
@c @icon{gnus-group-kill-group}
現在のグループを kill します (@code{gnus-group-kill-group})。

@item S y
@itemx C-y
@kindex S y @r{(グループ)}
@kindex C-y @r{(グループ)}
@findex gnus-group-yank-group
最後に kill したグループを yank します (@code{gnus-group-yank-group})。

@item C-x C-t
@kindex C-x C-t @r{(グループ)}
@findex gnus-group-transpose-groups
二つのグループの順序を置き換えます (@code{gnus-group-transpose-groups})。
これは本当は購読コマンドではありませんが、kill と yank を何度か続ける代
わりにこのコマンドが使えます。

@item S w
@itemx C-w
@kindex S w @r{(グループ)}
@kindex C-w @r{(グループ)}
@findex gnus-group-kill-region
リージョン内のすべてのグループを kill しま
す (@code{gnus-group-kill-region})。

@item S z
@kindex S z @r{(グループ)}
@findex gnus-group-kill-all-zombies
すべてのゾンビグループを kill しま
す (@code{gnus-group-kill-all-zombies})。

@item S C-k
@kindex S C-k @r{(グループ)}
@findex gnus-group-kill-level
あるレベルのグループをすべて kill します (@code{gnus-group-kill-level})。
kill した後、これらのグループを yank で戻すことはできないので、このコマ
ンドはいくらか注意して使ってください。このコマンドが本当に便利になるのは、
@file{.newsrc} に捨ててしまいたい未購読のグループがたくさんあるときだけ
です。レベル 7 で @kbd{S C-k} を行なうと、@file{.newsrc} ファイル中にメッ
セージ番号がない未購読グループをすべて kill します。
@end table

@ref{Group Levels} も参照してください。

@node Group Data
@section グループデータ

@table @kbd
@item c
@kindex c @r{(グループ)}
@findex gnus-group-catchup-current
@vindex gnus-group-catchup-group-hook
@c @icon{gnus-group-catchup-current}
そのグループ内のすべての無印の記事を既読にしま
す (@code{gnus-group-catchup-current})。グループバッファーから既読にした
場合は @code{gnus-group-catchup-group-hook} が呼び出されます。

@item C
@kindex C @r{(グループ)}
@findex gnus-group-catchup-current-all
そのグループの全記事を、印付きの記事も含めて既読にしま
す (@code{gnus-group-catchup-current-all})。

@item M-c
@kindex M-c @r{(グループ)}
@findex gnus-group-clear-data
現在のグループのすべてのデータをクリアします---印と既読記事のリストを消
し去ります (@code{gnus-group-clear-data})。

@item M-x gnus-group-clear-data-on-native-groups
@findex gnus-group-clear-data-on-native-groups
もし @acronym{NNTP} サーバーを別のものに切り替えたとすると、すべての印と
既読情報はもう役には立ちません。このコマンドを使って基本グループのすべて
のデータをクリアすることができます。注意して使ってね。
@end table

@node Group Levels
@section グループレベル
@cindex group level
@cindex level

すべてのグループは「購読度」(@dfn{subscribedness}) のレベルを持ちます。
例えば、あるグループがレベル 2 だとすれば、それはレベル 5 のグループより
も「より購読している」ということです。Gnus に対して、あるレベルかそれよ
り小さいレベルのグループのみ一覧表示するように頼むこともできる
し (@pxref{Listing Groups})、あるレベルかそれより小さいレベルのグループ
の新着記事のみを確認することもできます (@pxref{Scanning New Messages})。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

@table @kbd
@item S l
@kindex S l @r{(グループ)}
@findex gnus-group-set-current-level
現在のグループのレベルを設定します。数値の接頭引数が与えられると、そこか
ら @var{n} 個のグループのレベルが設定されます。レベルを入力するためのプ
ロンプトが出ます。
@end table

@vindex gnus-level-killed
@vindex gnus-level-zombie
@vindex gnus-level-unsubscribed
@vindex gnus-level-subscribed
Gnus はレベル 1 から @code{gnus-level-subscribed} (この値を含む) (ディフォ
ルトは 5) までのグループを購読、@code{gnus-level-subscribed} (この値を含
まない) から @code{gnus-level-unsubscribed} (この値を含む) (ディフォルト
は 7) までのグループを非購読、@code{gnus-level-zombie} をゾンビ (歩く屍)
(ディフォルトは 8)、@code{gnus-level-killed} を kill されている (完全に
死んでいる) (ディフォルトは 9) と判断します。Gnus は購読と非購読のグルー
プはまったく同様に扱いますが、ゾンビと kill グループは、どの記事を読んだ
か、存在するかなどの情報を一切記憶しません。この死んでいるグループと生き
ているグループの区別は、別にそれがきれいだからとか賢いからというわけでは
なく、純粋に効率的な理由のためです。

メール用のグループは (もしあれば) 非常に小さいレベル (例えば 1 か 2) に
しておくことをお勧めします。

次の Gnus のディフォルトの動作の説明は、ことによると、これらのレベルのす
べてを理解する助けになるかもしれません。ディフォルトでは、Gnus は講読し
ている空でないグループを表示しますが、@kbd{L} を叩くことによって空のグルー
プや非講読のグループも表示させることができます。つまり、非講読のグループ
は隠されている、と言っても良いでしょう。

@cindex zombie groups
ゾンビと kill グループは、ディフォルトでは隠されている点で非講読のグルー
プに似ています。しかし、Gnus がニュースサーバーに対してゾンビと kill グ
ループに関する情報 (記事数、未読記事数) の問い合わせをしない点で、購読お
よび非購読のグループとは違っています。ふつう、あなたは興味の無いグループ
を @kbd{C-k} で kill しますよね。もし、ほとんどのグループが kill されて
いると、Gnus は速くなります。

なぜ Gnus はゾンビと kill グループを区別するのでしょう?  ええと、サーバー
に新しいグループができると、Gnus はディフォルトでそれをゾンビにします。
これは、あなたがふつうは新しいグループに煩わされないことを意味しますが、
あなたは @kbd{A z} で新しいグループのリストを得ることができます。あなた
は好みのものを講読し、要らないものは kill すれば良いのです。
(@kbd{A k} で kill されたグループのリストを表示します。)

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があります。
いったんそれを設定したら、二度とそれに触らないでください。さらに言えば、
自分で何をやっているかを正確に理解していない限り、一切触らないでください。

@vindex gnus-level-default-unsubscribed
@vindex gnus-level-default-subscribed
身近に関係する二つの変数は @code{gnus-level-default-subscribed} (ディフォ
ルトは 3) と @code{gnus-level-default-unsubscribed} (ディフォルト
は 6) です。これらは新しいグループが (非) 購読されたときのレベルです。も
ちろん、これら二つの変数の値は、意味のある正しい範囲でなくてはなりません。

@vindex gnus-keep-same-level
@code{gnus-keep-same-level} が @code{nil} 以外であれば、移動コマンドのい
くつかは同一 (あるいはそれより小さい) レベルのグループのみの移動になりま
す。特に、あるグループの最後の記事から次のグループに移るとき、次の同
一 (あるいはそれより小さい) レベルのグループに移動します。これは残りのグ
ループを読むより先に、より重要なグループを読んでおきたいときには便利かも
しれません。

もしこの値が @code{best} だったら、最も重要な (最もレベルの値が小さ
い) グループに移動します。

@vindex gnus-group-default-list-level
ディフォルトでは @code{gnus-group-default-list-level} と同じかそれより小
さいレベルのグループが、グループバッファーに一覧表示されます。この変数は
関数であることもできます。その場合、関数が呼ばれてその結果が値として使わ
れます。

@vindex gnus-group-list-inactive-groups
@code{gnus-group-list-inactive-groups} が @code{nil} 以外であれば、未読
のグループにアクティブでないグループも一緒に表示します。この変数はディフォ
ルトでは @code{t} です。もしこれが @code{nil} であれば、アクティブでない
グループは表示されません。

@vindex gnus-group-use-permanent-levels
@code{gnus-group-use-permanent-levels} が @code{nil} 以外であれば、いっ
たん @kbd{g} や @kbd{l} コマンドの接頭引数にレベルを与えると、その後のす
べてのコマンドにおいてそのレベルが「作用する」レベルになります。

@vindex gnus-activate-level
Gnus は通常、@code{gnus-activate-level} かそれより小さいレベルのグループ
のみを起動します (つまりサーバーに問い合わせをする)。購読していないグルー
プを起動したくなければ、この変数を例えば 5 に設定するとよいかもしれませ
ん。ディフォルトは 6 です。

@node Group Score
@section グループのスコア
@cindex group score
@cindex group rank
@cindex rank

普通は重要なグループは高レベルにしておくでしょうけれども、この方法では少々
制限がきついですよね。ひょっとしたら、グループをどれくらい頻繁に読むかに
よってグループバッファーを並べ替えたいなあ、なんて思いませんか? 理にかなっ
てるでしょ?

「グループスコア」(@dfn{group score}) はそのためのものです。Gnus に以下
で説明されている機構で、それぞれのグループに対してスコアを指定することが
できます。そしてグループバッファーをこのスコアを基に並べ替えることができ
ます。あるいは、スコア順で並べ替えてその後レベルで並べ替えることもできま
す。(レベルとスコアをひとまとめにして、グループの「ランク」
(@dfn{rank}) と呼びます。レベルが 4 でスコアが 1 のグループは、レベル
が 5 でスコアが 300 のグループよりも高いランクとなります。(レベルの方が
重要度が高く、スコアの方は重要度が低くなります。))

@findex gnus-summary-bubble-group
頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えたい
ときは、@code{gnus-summary-exit-hook} フック
に @code{gnus-summary-bubble-group} 関数を追加することができます。これで
バブル並べ替えの実行結果が (並べ替えの後で) 得られるでしょう。概略モード
を終了するたびにこの活動をさせたいのであれば、同じフック
に @code{gnus-group-sort-groups-by-rank} また
は @code{gnus-group-sort-groups-by-score} を追加できますが、いくらか遅く
なるでしょう。

@node Marking Groups
@section グループへの印
@cindex marking groups

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらがグ
ループバッファーに連続してある場合には、通常通り命令に対して数値接頭引数
を与えるだけです。そうすればほとんどのグループ命令は、これらのグループに
対してあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグルー
プに対して命令を実行することができます。単に始めにプロセス印でグループに
印を付けておき、そして命令を実行するだけです。

@table @kbd
@item #
@kindex # @r{(グループ)}
@itemx M m
@kindex M m @r{(グループ)}
@findex gnus-group-mark-group
現在のグループに印を付ける (@code{gnus-group-mark-group})。

@item M-#
@kindex M-# @r{(グループ)}
@itemx M u
@kindex M u @r{(グループ)}
@findex gnus-group-unmark-group
現在のグループから印を削除する (@code{gnus-group-unmark-group})。

@item M U
@kindex M U @r{(グループ)}
@findex gnus-group-unmark-all-groups
すべてのグループから印を削除する (@code{gnus-group-unmark-all-groups})。

@item M w
@kindex M w @r{(グループ)}
@findex gnus-group-mark-region
ポイントとマークの間のすべてのグループに印を付け
る (@code{gnus-group-mark-region})。

@item M b
@kindex M b @r{(グループ)}
@findex gnus-group-mark-buffer
バッファー内のすべてのグループに印を付ける (@code{gnus-group-mark-buffer})。

@item M r
@kindex M r @r{(グループ)}
@findex gnus-group-mark-regexp
ある正規表現に合致するすべてのグループに印を付け
る (@code{gnus-group-mark-regexp})。
@end table

@ref{Process/Prefix} も参照してください。

@findex gnus-group-universal-argument
プロセス印が付けられているすべてのグループに対して何かの命令を実行したい
ときは、@kbd{M-&} (@code{gnus-group-universal-argument}) 命令を使うこと
ができます。プロンプトから実行したい命令を入力します。

@node Foreign Groups
@section 外部グループ
@cindex foreign groups

どうやってサーバーを講読するか (@pxref{Finding the News}) を考えるとき、
最初に思い付くの
は @code{gnus-secondary-select-methods} およ
び @code{gnus-select-method} に Emacs Lisp で定義を書くことでしょう。別
のやり方は外部のサーバーとグループを使うことです。ここ
で「外部 (Foreign)」は、選択方法 (select methods) によるものではないこと
を意味します。すべての外部サーバーに関する設定と何を講読するか
は @file{~/.newsrc.eld} ファイルだけに格納されます。

以下では、一般的な外部グループの作成、変更を行なうグループモードの命令を
いくつか、および特別な目的のグループを簡単に作成する命令を紹介します。こ
れらの命令はすべて、新規に作成したグループをポイント位置に挿入しま
す---@code{gnus-subscribe-newsgroup-method} は参照されません。

これらグループを編集するコマンド群で行なった変更は @file{~/.newsrc.eld}
(@code{gnus-startup-file}) に格納されます。代わりの手段として、変
数 @code{gnus-parameters} も用意されています (@pxref{Group Parameters})。

@table @kbd
@item G m
@kindex G m @r{(グループ)}
@findex gnus-group-make-group
@cindex making groups
新しいグループを作成します (@code{gnus-group-make-group})。Gnus はプロン
プトを表示して、名前と方法と、場合によっては @dfn{address} の入力を求め
てきます。より簡単に @acronym{NNTP} グループを購読する方法については、
@ref{Browse Foreign Server} を参照してください。

@item G M
@kindex G M @r{(グループ)}
@findex gnus-group-read-ephemeral-group
一時ニュースグループを作成しま
す (@code{gnus-group-read-ephemeral-group})。 Gnus はプロンプトを表示し
て、名前、方法および @dfn{address} の入力を求めます。

@item G r
@kindex G r @r{(グループ)}
@findex gnus-group-rename-group
@cindex renaming groups
現在のグループの名前を、何か別のものに変更しま
す (@code{gnus-group-rename-group})。これはある種のグループ---主にメール
グループに対してのみ有効です。このコマンドはバックエンドによっては非常に
遅いことも有り得ます。

@item G c
@kindex G c @r{(グループ)}
@cindex customizing
@findex gnus-group-customize
グループパラメーターをカスタマイズする (@code{gnus-group-customize})。

@item G e
@kindex G e @r{(グループ)}
@findex gnus-group-edit-group-method
@cindex renaming groups
現在のグループの選択方法を修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group-method})。

@item G p
@kindex G p @r{(グループ)}
@findex gnus-group-edit-group-parameters
グループパラメーターを修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group-parameters})。

@item G E
@kindex G E @r{(グループ)}
@findex gnus-group-edit-group
グループ情報を修正するためのバッファーに移動しま
す (@code{gnus-group-edit-group})。

@item G d
@kindex G d @r{(グループ)}
@findex gnus-group-make-directory-group
@cindex nndir
ディレクトリーグループを作成します (@pxref{Directory Groups})。ディレク
トリー名をプロンプトで入力しま
す (@code{gnus-group-make-directory-group})。

@item G h
@kindex G h @r{(グループ)}
@cindex help group
@findex gnus-group-make-help-group

Gnus ヘルプグループを作成します (@code{gnus-group-make-help-group})。

@item G D
@kindex G D @r{(グループ)}
@findex gnus-group-enter-directory
@cindex nneething
任意のディレクトリーを @code{nneething} バックエンドニュースグループであ
るかのように読み込みます (@code{gnus-group-enter-directory})。
@xref{Anything Groups}.

@item G f
@kindex G f @r{(グループ)}
@findex gnus-group-make-doc-group
@cindex ClariNet Briefs
@cindex nndoc
何らかのファイルをもとにグループを作成しま
す (@code{gnus-group-make-doc-group})。このコマンドに接頭引数を与えた場
合、ファイル名とファイルタイプをプロンプトで入力します。現在サポートされ
ているファイルタイプは @code{mbox}, @code{babyl}, @code{digest},
@code{news}, @code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx} および @code{mailman} です。接頭引数なしでこのコマンドを実
行すると、Gnus はファイルタイプを推測します。@xref{Document Groups}.

@item G u
@kindex G u @r{(グループ)}
@vindex gnus-useful-groups
@findex gnus-group-make-useful-group
@code{gnus-useful-groups} にあるグループの一つを作りま
す (@code{gnus-group-make-useful-group})。

@item G w
@kindex G w @r{(グループ)}
@findex gnus-group-make-web-group
@cindex Google
@cindex nnweb
@cindex gmane
ウェブ検索結果をもとに一時的なグループを作成しま
す (@code{gnus-group-make-web-group})。このコマンドに接頭引数を与えると、
一時的ではなく固定したグループを作成します。プロンプトで検索エンジンの種
類 (search engine type) と検索文字列を入力します。有効な検索エンジンの種
類には @code{google}, @code{dejanews}, @code{gmane} があります。
@xref{Web Searches}.

もし、@code{google} 検索エンジンを用いる場合には、
@samp{shaving group:alt.sysadmin.recovery} のような合致する文字列を用い
ることによって、検索対象を特定のグループに限定することが可能です。

@item G R
@kindex G R @r{(グループ)}
@findex gnus-group-make-rss-group
@acronym{RSS} feed に基づくグループを作りま
す (@code{gnus-group-make-rss-group})。URL の入力を促されます。
@xref{RSS}.

@item G @key{DEL}
@kindex G DEL @r{(グループ)}
@findex gnus-group-delete-group
この関数は現在のグループを削除します (@code{gnus-group-delete-group})。
接頭引数が与えられると、この関数はそのグループ内の全記事を本当に削除し、
グループ自身をこの世から強制的に抹殺してしまいます。接頭引数は、あなたが
何をやろうとしているか、本当に自信があるときにのみ使ってください。まあ、
このコマンドは (@code{nntp} グループのような) 読み出し専用グループには使
えませんけれど。

@item G V
@kindex G V @r{(グループ)}
@findex gnus-group-make-empty-virtual
新しい、新鮮な、空の @code{nnvirtual} グループを作成しま
す (@code{gnus-group-make-empty-virtual})。@xref{Virtual Groups}.

@item G v
@kindex G v @r{(グループ)}
@findex gnus-group-add-to-virtual
現在のグループを @code{nnvirtual} グループに追加しま
す (@code{gnus-group-add-to-virtual})。これはプロセス印/接頭引数の習慣に
従います。
@end table

さまざまな選択方法に関するさらなる情報は @ref{Select Methods} を参照して
ください。

@vindex gnus-activate-foreign-newsgroups
もし @code{gnus-activate-foreign-newsgroups} が正の数であれば、Gnus は起
動時に、この数かそれよりも小さいレベルの外部グループをすべてチェックしま
す。これは特に違った @acronym{NNTP} サーバーからたくさんのグループを購読
している場合には、しばらく時間がかかるかもしれません。
@ref{Group Levels} も参照してください。@code{gnus-activate-level} も外部
ニュースグループの活性化に影響を及ぼします。

以下のコマンドは一時的なグループを作ります。それらは Group バッファーか
らだけではなく、どの Gnus バッファーからも呼ぶことができます。

@table @code
@item gnus-read-ephemeral-gmane-group
@findex gnus-read-ephemeral-gmane-group
@vindex gnus-gmane-group-download-format
Gmane.org で一時的なグループを講読するためのコマンドです。記事
は @code{gnus-gmane-group-download-format} によって指定され
た @acronym{URL} を使って HTTP でダウンロードされます。Gnus はグループ名
と最初の記事番号および記事数の範囲を尋ねます。

@item gnus-read-ephemeral-gmane-group-url
@findex gnus-read-ephemeral-gmane-group-url
このコマンドは @code{gnus-read-ephemeral-gmane-group} に似ていますが、グ
ループ名と最初の記事番号および記事数の範囲は、与えられ
た @acronym{URL} を元に決定されます。サポートされている @acronym{URL} の
形式は、次のとおりです:
@indicateurl{http://thread.gmane.org/gmane.foo.bar/12300/focus=12399},
@indicateurl{http://thread.gmane.org/gmane.foo.bar/12345/},
@indicateurl{http://article.gmane.org/gmane.foo.bar/12345/},
@indicateurl{http://permalink.gmane.org/gmane.foo.bar/12345/}, およ
び @indicateurl{http://news.gmane.org/group/gmane.foo.bar/thread=12345}。

@item gnus-read-ephemeral-emacs-bug-group
@findex gnus-read-ephemeral-emacs-bug-group
一時的なグループで Emacs のバグリポートを講読します。Gnus はバグの番
号 (複数可) を尋ねます。ディフォルトは現在位置の番号です。
@acronym{URL} の雛形は @code{gnus-bug-group-download-format-alist} で指
定します。

@item gnus-read-ephemeral-debian-bug-group
@findex gnus-read-ephemeral-debian-bug-group
一時的なグループで Debian のバグリポートを講読します。
@code{gnus-read-ephemeral-emacs-bug-group} に似ています。
@end table

これらのコマンドのいくつかは、記事のボタンとしても便利です。
@xref{Article Buttons}.

例:
@lisp
(require 'gnus-art)
(add-to-list
 'gnus-button-alist
 '("#\\([0-9]+\\)\\>" 1
   (string-match "\\<emacs\\>" (or gnus-newsgroup-name ""))
   gnus-read-ephemeral-emacs-bug-group 1))
@end lisp

@node Group Parameters
@section グループパラメーター
@cindex group parameters

グループパラメーターは、ある特定のグループに固有な情報を保持します。

グループパラメーターの修正には @kbd{G p} か @kbd{G c} 命令を使ってくださ
い (@kbd{G p} は Lisp ベースの、@kbd{G c} は Custom ふうのインターフェー
スを提供します)。トピックパラメーターについて読んでみることも面白いでしょ
う (@pxref{Topic Parameters})。加えて、@code{gnus-parameters} 変数を介し
てグループパラメーターを設定することもできます。下記参照してください。

以下はグループパラメーターリストの例です:

@example
((to-address . "ding@@gnus.org")
 (auto-expire . t))
@end example

それぞれの要素は『点対』(dotted pair)---つまり点 (dot) の前に鍵、点の後
ろに値があるもの、で構成されます。すべてのパラメーターはこの形式を取りま
すが、@emph{例外} としてローカル変数の指定は点対ではなく通常のリス
ト (訳注: 後述の @code{(@var{variable} @var{form})} の項を参照) になりま
す。

いくつかのパラメーターは対応するカスタマイズ可能な変数を持っています。そ
れらは正規表現と値の連想リストです。

以下は利用可能なグループパラメーターです:

@table @code
@item to-address
@cindex to-address
フォローアップとニュースへの投稿をするときに使用されるアドレス。

@example
(to-address . "some@@where.com")
@end example

これは主に、閉じたメーリングリストを表わすメールグループにおいて便利なも
のです---すなわちメーリングリストに投稿する人はすべてそれを購読している
はず、というメーリングリストのことです。このパラメーターを使用すると、メー
ルはそのメーリングリストにしか投稿されないことが保証されるので、参加者は
あなたのフォローアップ記事を二通受け取ることはありません。

@code{to-address} を指定すると、そのグループが外部グループであるかどうか
に関わらず有効になります。例えば @samp{fa.4ad-l} というグループがサーバー
上にあったとしましょう。これは本当のニュースグループですが、サーバーはメー
ルニュースゲートウェイを通して記事を受け付けます。つまりこのグループに対
して直接投稿することは不可能で、代わりにそのメーリングリストにメールを送
信しなければなりません。

@code{gnus-parameter-to-address-alist} も参照してください。

@item to-list
@cindex to-list
そのグループで @kbd{a} を押したときに使用されるアドレス。

@example
(to-list . "some@@where.com")
@end example

これはフォローアップをしたときは完全に無視されます---例外はそれがニュー
スグループを表わしているときは、@kbd{f} を押したときにメールグループのルー
ルが適用されるということです。

もし @kbd{a} コマンドをメールグループで実行したときに、@code{to-list} グ
ループパラメーターも @code{to-address} もグループパラメーターも無ければ、
@code{to-list} グループパラメーターは、
@code{gnus-add-to-list} が @code{t} に設定されていればメッセージ送信時に
自動的に付加されます。
@vindex gnus-add-to-list

@findex gnus-mailing-list-mode
@cindex mail list groups
もしこのグループパラメーターが設定されていると、概略バッファーに入ったと
きに @code{gnus-mailing-list-mode} が有効になります。

@code{gnus-parameter-to-list-alist} も参照してください。

@anchor{subscribed}
@item subscribed
@cindex subscribed
@cindex Mail-Followup-To
@findex gnus-find-subscribed-addresses
もしこのパラメーターが @code{t} に設定されていると、Gnus はあなたがこの
グループを to-address と to-list パラメーターのアドレスで購読しているメー
リングリストであると解釈します。この情報を Gnus に与えることは、あなたが
それらのメーリングリストに投稿するときに正しい Mail-Followup-To ヘッダー
を生成するための (ほんの) 第一歩です。二歩目は @file{.gnus.el} に以下を
入れることです。

@lisp
(setq message-subscribed-address-functions
      '(gnus-find-subscribed-addresses))
@end lisp

利用できる MFT 対応機能を完全に扱うには、ここ (@pxref{Mailing Lists,
,メーリングリスト, message-ja, The Message Manual}) を見てください。

@item visible
@cindex visible
グループパラメーターのリスト中に @code{(visible . t)} という要素があれば、
そのグループはグループバッファーにおいて、未読記事があるかどうかに関わら
ず、常に表示されます。

このパラメーターを @code{gnus-parameters} を介して設定することはできませ
んが、代わりに @code{gnus-permanently-visible-groups} を使えば良いでしょ
う。

@item broken-reply-to
@cindex broken-reply-to
@code{(broken-reply-to . t)} という要素があれば、そのグループで
は @code{Reply-To} は無視され、
@code{reply-to} が @code{gnus-boring-article-headers} の部分であれば、ヘッ
ダーが隠されるという意味です。これはある listserv によるメーリングリスト
を購読していて、それが @code{Reply-To} 欄を listserv 自身に返すように付
けられている場合に有効でしょう。これはおかしな振る舞いです。だからこれが
要るんです!

@item to-group
@cindex to-group
@code{(to-group . "some.group.name")} という要素は、そのグループへの投稿
はすべて @code{some.group.name} に送られる、という意味です。

@item newsgroup
@cindex newsgroup
グループパラメーターリストに @code{(newsgroup . t)} があれば、Gnus はす
べての応答をニュース記事に対する応答であるかのように扱います。これは実際
にはニュースグループのミラーであるメールグループに対して有効です。

@item gcc-self
@cindex gcc-self
グループパラメーターリストにもし @code{(gcc-self . t)} があると、新しく
作成するメッセージは現在のグループに @code{gcc} されます。も
し @code{(gcc-self . none)} があれば、@code{Gcc:} 欄は生成されません。も
し @code{(gcc-self . "group")} があると、この文字列はそのま
ま @code{Gcc:} ヘッダーとして挿入されます。それはグループ名でなければな
りません。

@code{gcc-self} の値は文字列と @code{t} のリストにすることも可能です。例
えば @code{(gcc-self "group1" "group2" t)} は、新しく作成するメッセージ
を @code{"group1"}、@code{"group2"}、および現在のグループ
に @code{gcc} するということです。

@code{gcc-self} パラメーターは後に説明するどんなディフォルト
の @code{Gcc} の規則よりも (再送するメッセージのための例外を除いて) 優先
されます (@pxref{Archived Messages})。

@strong{警告}: @code{nntp} (またはその種の) グループのパラメーターリスト
に @code{(gcc-self . t)} を加えることに効力はありません。@code{nntp} サー
バーは記事を受け入れません。

@item auto-expire
@cindex auto-expire
@cindex expiring mail
グループパラメーターに @code{(auto-expire . t)} のような要素があれば、す
べての既読記事は期限切れ消去されるように印を付けられます。他の方法は、
@xref{Expiring Mail}.

@code{gnus-auto-expirable-newsgroups} も参照してください。

@item total-expire
@cindex total-expire
@cindex expiring mail
グループパラメーターに @code{(total-expire . t)} のような要素があれば、
既読記事は、期限切れ消去の印が付いていなくてもすべて期限切れ消去処理を施
されます。注意して使用してください。未読記事、印付き記事、保留記事は期限
切れ消去されません。

@code{gnus-total-expirable-newsgroups} も参照してください。

@item expiry-wait
@cindex expiry-wait
@vindex nnmail-expiry-wait-function
グループパラメーターに @code{(expiry-wait . 10)} のような要素があれば、
この値は記事を期限切れ消去するとき
に @code{nnmail-expiry-wait} や @code{nnmail-expiry-wait-function} の設
定 (@pxref{Expiring Mail}) よりも優先されます。この値は期限切れ消去の日
数 (整数である必要はない) かもしくは @code{never} か @code{immediate} の
シンボルを指定できます。

@item expiry-target
@cindex expiry-target
期限切れ消去されるメッセージの果てる場所。このパラメーター
は @code{nnmail-expiry-target} よりも優先されます。

@item score-file
@cindex score file group parameter
@code{(score-file . "file")} のような要素は、@file{file} を現在のグルー
プに適用されるスコアファイルにします。すべての適用されるスコア・エントリー
はこのファイルに入ります。

@item adapt-file
@cindex adapt file group parameter
@code{(adapt-file . "file")} のような要素は、@file{file} を現在のグルー
プの適応ファイルにします。すべての適応スコア・エントリーはこのファイルに
入ります。

@item admin-address
@cindex admin-address
メーリングリストから脱会するときは、脱会通知メールをそのメーリングリスト
自身に送信してはいけません。代わりに管理用アドレスにメッセージを送信しま
す。このパラメーターにはどこか都合の良いな管理用アドレスを書いておくこと
ができます。

@item display
@cindex display
@code{(display . MODE)} のような要素は、グループに入るときにどの記事を表
示するかを指定します。有効な値は、

@table @code
@item all
未読、既読記事の両方をすべて表示します。

@item an integer
そのグループの最後の @var{integer} 個の記事を表示します。これ
は @kbd{C-u @var{integer}} でそのグループに入るのと同じです。

@item default
ディフォルトの記事を表示します。これは通常は未読記事と可視記事です。

@item 配列
述語を満足するように記事を表示します。

いくつか例を挙げます:

@table @code
@item [unread]
未読の記事だけを表示します。

@item [not expire]
期限切れ消去可能な記事以外のすべてを表示します。

@item [and (not reply) (not expire)]
期限切れ消去可能とすでに返信した記事以外のすべてを表示します。
@end table

利用できる演算子は @code{not}, @code{and} および @code{or} です。述語
は @code{tick}, @code{unsend}, @code{undownload}, @code{unread},
@code{dormant}, @code{expire}, @code{reply}, @code{killed},
@code{bookmark}, @code{score}, @code{save}, @code{cache},
@code{forward} および @code{unseen} を含みます。
@end table

@code{display} パラメーターは、概略バッファーを指定した一部の組だけに制
限するように働きます。制限を外すのは @kbd{/ w} コマンドでできま
す (@pxref{Limiting})。

@item comment
@cindex comment
@code{(comment . "This is a comment")} のような要素は、そのグループに対
する任意のコメントです。グループ行に表示することができま
す (@pxref{Group Line Specification})。

@item charset
@cindex charset
@code{(charset . iso-8859-1)} のような要素は、@code{iso-8859-1} をディフォ
ルトの文字セットにします。すなわち、文字セットを指定しないすべての記事に、
その文字セットが使われます。

@code{gnus-group-charset-alist} も見てください。

@item ignored-charsets
@cindex ignored-charsets
@code{(ignored-charsets x-unknown iso-8859-1)} のような要素は、
@code{iso-8859-1} と @code{x-unknown} を無視します。すなわち、記事のデコー
ドにディフォルトの文字セットが使われます。

@code{gnus-group-ignored-charsets-alist} も見てください。

@item posting-style
@cindex posting-style
このグループの追加の投稿様式をここに保存することができま
す (@pxref{Posting Styles})。書式は @code{gnus-posting-styles} 連想リス
トと同じですが、ここにはグループ名に合致する正規表現はありません (当然で
す)。このグループの様式の要素は @code{gnus-posting-styles} で見つかった
ものよりも優先されます。

例えば、このグループのみ、かっこいい名前と署名にしたいなら、
@code{gnus-posting-styles} をいじらずに、このようなものをグループパラメー
ターに入れることができます:

@example
(posting-style
  (name "Funky Name")
  ("X-Message-SMTP-Method" "smtp smtp.example.org 587")
  ("X-My-Header" "Funky Value")
  (signature "Funky Signature"))
@end example

グループバッファーを整理するためにトピック (@pxref{Group Topics}) を使っ
ている場合は、トピックパラメーターでも投稿様式を設定することができます。
トピックパラメーターにある投稿様式は、そのトピックのすべてのグループに適
用されます。もっと正確に言うと、あるグループのための投稿様式の設定は、そ
のグループおよびそれが属するすべてのトピックのパラメーターにあるすべての
投稿様式の設定を、階層的に合併することによって生成されます。

@item post-method
@cindex post-method
もしこれが設定されていると、メッセージを送信するための選択方法とし
て @code{gnus-post-method} の代わりに使われます。

@item mail-source
@cindex mail-source
これが設定されていて、かつ @code{mail-sources} の設定が @code{group} グ
ループ・メールソース (@pxref{Mail Sources}) を含んでいるならば、その値が
このグループのメールソースになります。

@item banner
@cindex banner
@code{(banner . @var{regex})} のような項目は、記事のすべての場所で正規表
現 @var{regex} に合致するものを削除します。@var{regex} の代わりにシンボ
ル @code{signature} (最後の署名を削除) や連想リス
ト @code{gnus-article-banner-alist} の各要素を使うこともできます。

@item sieve
@cindex sieve
このパラメーターは、入ってきたメールがこのグループに置くに値するかどうか
を調べる Sieve (ふるい) テストを持ちます。このグループパラメーターを元
に @samp{fileinto "group.name";} というテスト条件を本体に持つ、
Sieve の @samp{IF} 制御構造体が作られます。

例えば、もし @samp{INBOX.list.sieve} グループが @code{(sieve address
"sender" "sieve-admin@@extundo.com")} というグループパラメーターを持って
いたならば、グループパラメーターを Sieve スクリプトに変換す
る (@pxref{Sieve Commands}) ときに、以下の Sieve コードが作られます:

@example
if address "sender" "sieve-admin@@extundo.com" @{
        fileinto "INBOX.list.sieve";
@}
@end example

さらに次のような要領で正規表現の拡張も使うことができます:

@example
(sieve header :regex "list-id" "<c++std-\\1.accu.org>")
@end example

複数の電子メールアドレスのためのテストを生成するには、@code{(sieve
address "sender" ("name@@one.org" else@@two.org"))} のようなグループパラ
メーターを使ってください。Sieve スクリプト (@pxref{Sieve Commands}) を生
成すると、以下のような Sieve コードが作られます:

@example
if address "sender" ["name@@one.org", "else@@two.org"] @{
        fileinto "INBOX.list.sieve";
@}
@end example

Sieve パラメーターに関連する重要なコマンドと変数については、@ref{Sieve
Commands} を参照してください。

Sieve 言語は RFC 3028 で述べられていま
す (@pxref{Top, Emacs Sieve, Top, sieve-ja, Emacs Sieve})。

@item match-list
@cindex match-list
もしこのパラメーターが @code{t} に設定され、か
つ @code{nnmail-split-method} が @code{gnus-group-split} に設定されてい
たら、Gnus は @code{list} 分割の省略形と対比し
て @code{to-address}、@code{to-list}、@code{extra-aliases} およ
び @code{split-regexp} が一致するかどうかを調べます。
RFC2919 の @code{List-ID} に準拠するため、分割の正規表現はメールアドレス
中の @code{@@} またはドット @code{.} に合致するように変更されます。

メーリングリストのヘッダーに合致する正規表現について
は @code{nnmail-split-abbrev-alist} を参照してください。

グループパラメーターに基づいて自動的に行なわれる分割について
は @ref{Group Mail Splitting} を参照してください。

@item (agent parameters)
エージェントを使うようにしてあると、個々のグループでエージェントの振る舞
いを制御するどのパラメーターも設定することができます。エージェントパラメー
ターについては @ref{Category Syntax} を参照してください。たいていの利用
者は、設定に要する苦労を最小限にするために、エージェントカテゴリーかグルー
プトピックのどちらかでエージェントパラメーターを設定することを選ぶでしょ
う。

@item (@var{variable} @var{form})
グループに入るときに、そのグループローカルの変数を設定するグループパラメー
ターを使用することができます。@samp{news.answers} においてスレッド表示を
行ないたくないときは、そのグループにグループパラメーター
に @code{(gnus-show-threads nil)} と書けます。
@code{gnus-show-threads} は、その概略バッファーの中のローカル変数になり、
form の @code{nil} はそこで @code{eval} (評価) されます。

この機能は @var{variable} が変数として存在する場合に限って、それを概略バッ
ファーでローカルに設定することに注意してください。さもなければ form の評
価だけが行なわれるでしょう。したがって、もし form を評価した結果を変数に
設定する必要があるのならば、@code{defvar} などを使って、前もってその変数
を定義しておかなければなりません。

でも、いくつかの変数は記事バッファーか (返信、フォロー、あるいは新規に作
られたメッセージの) メッセージバッファーで評価されます。代わりに、問題の
変数を @code{gnus-newsgroup-variables} に加えることが助けになるかもしれ
ません。したがって、グループパラメーターを介し
て @code{message-from-style} を設定したいならば、@file{~/.gnus.el} ファ
イルのどこか他のところに、次の述語が必要になるかもしれません:

@lisp
(add-to-list 'gnus-newsgroup-variables 'message-from-style)
@end lisp

@vindex gnus-list-identifiers
この機能の用途の一つは、記事の表題欄からメーリングリストの標識タグをはぎ
取ることです。もしニュースグループ

@example
nntp+news.gnus.org:gmane.text.docbook.apps
@end example

が、すべての記事の表題に @samp{DOC-BOOK-APPS:} というタグを持っているな
らば、そのグループのグループパラメーターに @code{(gnus-list-identifiers
"DOCBOOK-APPS:")} を入れることによって、そのグループの概略バッファーに表
示される記事の表題からタグをはぎ取ることができます。

これはもし必要であれば、グループ毎のフック関数としても使用できます。もし
あるグループに入ったときにビープ音を鳴らしたければ、そのグループのパラメー
ターに @code{(dummy-variable (ding))} みたいなものを書いておくこともでき
ます。もし @code{dummy-variable} という変数が存在していれば (上記参照)、
それに (無意味な) @code{(ding)} の評価結果が設定されます。

あるいは、@var{variable} はそのグループに対してローカルになるので、この
様式は一時的にフックを変更するために使うことができます。例えば、以下のも
のがグループパラメーターに追加されると、

@lisp
(gnus-summary-prepared-hook
  (lambda nil (local-set-key "d" (local-key-binding "n"))))
@end lisp

そのグループに入ったときに @kbd{d} キーは記事に期限切れ消去の印を付けな
いようになります。
@end table

@vindex gnus-parameters
グループパラメーターは @code{gnus-parameters} 変数を介在して設定すること
もできます。でもいくつかのパラメーター、例えば @code{visible} は効力を発
揮しません (その場合、代替とし
て @code{gnus-permanently-visible-groups} を使うことができます)。例です:

@lisp
(setq gnus-parameters
      '(("mail\\..*"
         (gnus-show-threads nil)
         (gnus-use-scoring nil)
         (gnus-summary-line-format
          "%U%R%z%I%(%[%d:%ub%-23,23f%]%) %s\n")
         (gcc-self . t)
         (display . all))

        ("^nnimap:\\(foo.bar\\)$"
         (to-group . "\\1"))

        ("mail\\.me"
         (gnus-use-scoring  t))

        ("list\\..*"
         (total-expire . t)
         (broken-reply-to . t))))
@end lisp

グループ名が合致するすべての項が使われますが、最後の設定が「勝ち」ます。
そういうわけですから、もしそのグループ名に合致する二つの項があって、例え
ばどちらも @code{display} を設定していると、最後の設定が最初の設定を覆し
ます。

グループ名が合致する最初の項が使われます。

文字列のパラメーターは @code{to-group} の例が示すように正規表現による置
き換えを受けることがあります。

@vindex gnus-parameters-case-fold-search
グループ名と @code{gnus-parameters} で指定されたこれらの正規表現の一つを
比較するときに大文字と小文字を区別するかどうかは、ディフォルトではその比
較を行なう時点での @code{case-fold-search} の値に依存します。一般的
に @code{case-fold-search} の値は @code{t} で、それは例え
ば @code{("INBOX\\.FOO" (total-expire . t))} という要素
が、@samp{INBOX.FOO} グループと @samp{INBOX.foo} グループの両方に適用さ
れることを意味します。これらの正規表現が常に大文字と小文字を区別するよう
にしたい場合は、@code{gnus-parameters-case-fold-search} 変数の値
を @code{nil} に設定してください。あるいは、それらが常に大文字と小文字を
区別しないようにしたいなら、それを @code{t} に設定してください。

@code{gnus-parameters} を介することによって、グループによって異なる並べ
替えを定義することができます。これは、@acronym{NNTP} グループでは最新の
ニュースが先頭になるように日付で、@acronym{RSS} グループでは表題で、それ
ぞれ並べ替えを行なう例です。この例の最初のグループは、news.gmane.org か
ら取得する Debian のデイリーニュースです。@acronym{RSS} グループ
は RSS フィードで配信されている Debian のウィークリーニュー
ス @url{http://packages.debian.org/unstable/newpkg_main.en.rdf} に対応し
ます。@xref{RSS}.

@lisp
(setq
 gnus-parameters
 '(("nntp.*gmane\\.debian\\.user\\.news"
    (gnus-show-threads nil)
    (gnus-article-sort-functions '((not gnus-article-sort-by-date)))
    (gnus-use-adaptive-scoring nil)
    (gnus-use-scoring nil))
   ("nnrss.*debian"
    (gnus-show-threads nil)
    (gnus-article-sort-functions 'gnus-article-sort-by-subject)
    (gnus-use-adaptive-scoring nil)
    (gnus-use-scoring t)
    (gnus-score-find-score-files-function 'gnus-score-find-single)
    (gnus-summary-line-format "%U%R%z%d %I%(%[ %s %]%)\n"))))
@end lisp

@node Listing Groups
@section グループの一覧表示
@cindex group listing

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

@table @kbd
@item l
@itemx A s
@kindex A s @r{(グループ)}
@kindex l @r{(グループ)}
@findex gnus-group-list-groups
未読記事を持つすべてのグループを表示しま
す (@code{gnus-group-list-groups})。数値接頭引数を使うと、このコマンドは
引数の数かそれよりも小さいレベルのグループのみを表示します。ディフォルト
では、これはレベル 5 (つまり @code{gnus-group-default-list-level}) かそ
れより小さいレベル (すなわち購読しているグループのみ) を表示します。

@item L
@itemx A u
@kindex A u @r{(グループ)}
@kindex L @r{(グループ)}
@findex gnus-group-list-all-groups
未読記事のあるなしに関わらず、すべてのグループを表示しま
す (@code{gnus-group-list-all-groups})。数値接頭引数を使用すると、このコ
マンドは引数の数かそれよりも小さいレベルのグループのみを表示します。ディ
フォルトでは 7 かそれよりも小さいレベルのグループ (すなわち購読、非購読
のグループのみ) が表示されます。

@item A l
@kindex A l @r{(グループ)}
@findex gnus-group-list-level
未読記事があるグループのうち、指定したレベルのものだけを表示しま
す (@code{gnus-group-list-level})。接頭引数を与えると、未読記事の無いグ
ループも含めて表示します。

@item A k
@kindex A k @r{(グループ)}
@findex gnus-group-list-killed
kill されたグループをすべて表示します (@code{gnus-group-list-killed})。
接頭引数を与えると、購読または非購読のどちらにもなっていないすべての利用
可能なグループを表示します。これはサーバーからアクティブファイルを読むこ
とになるでしょう。

@item A z
@kindex A z @r{(グループ)}
@findex gnus-group-list-zombies
すべてのゾンビグループを表示します (@code{gnus-group-list-zombies})。

@item A m
@kindex A m @r{(グループ)}
@findex gnus-group-list-matching
正規表現に合致する名前を持つグループで、未読記事のある購読グループをすべ
て表示します (@code{gnus-group-list-matching})。

@item A M
@kindex A M @r{(グループ)}
@findex gnus-group-list-all-matching
正規表現に合致するグループを表示しま
す (@code{gnus-group-list-all-matching})。

@item A A
@kindex A A @r{(グループ)}
@findex gnus-group-list-active
今接続しているサーバーのアクティブファイルにあるグループを、本当に全部表
示します (@code{gnus-group-list-active})。これはしばらく時間がかかること
も有り得ます。たぶん @kbd{A M} を実行して、合致させたい部分
を @samp{.} としてすべての合致するリストを表示させた方が良いでしょう。ま
た、このコマンドは (まだ) 存在しないグループも表示するかもしれませ
ん---これは kill されたグループであるかのように表示されます。出力は多少
割り引いて受け取ってね。

@item A a
@kindex A a @r{(グループ)}
@findex gnus-group-apropos
正規表現に合致する名前を持つグループをすべて表示しま
す (@code{gnus-group-apropos})。

@item A d
@kindex A d @r{(グループ)}
@findex gnus-group-description-apropos
正規表現に合致する名前か説明文を持つグループをすべて表示しま
す (@code{gnus-group-description-apropos})。

@item A c
@kindex A c @r{(グループ)}
@findex gnus-group-list-cached
キャッシュ記事を持つグループをすべて表示しま
す (@code{gnus-group-list-cached})。

@item A ?
@kindex A ? @r{(グループ)}
@findex gnus-group-list-dormant
保留記事を持つグループをすべて表示しま
す (@code{gnus-group-list-dormant})。

@item A !
@kindex A ! @r{(グループ)}
@findex gnus-group-list-ticked
可視記事 (ticked articles) があるグループをすべて表示しま
す (@code{gnus-group-list-ticked})。

@item A /
@kindex A / @r{(グループ)}
@findex gnus-group-list-limit
さらに現在の選択された範囲に限定したグループを表示しま
す (@code{gnus-group-list-limit})。最初に @kbd{A ?} で保留記事があるグルー
プに制限してあるなら、@kbd{A / c} でさらにキャッシュされた記事があるグルー
プ、つまり保留記事があって、かつキャッシュされた記事もあるグループに制限
することができます。

@item A f
@kindex A f @r{(グループ)}
@findex gnus-group-list-flush
現在の選択されたグループを書き出します (@code{gnus-group-list-flush})。

@item A p
@kindex A p @r{(グループ)}
@findex gnus-group-list-plus
現在の選択されたグループを加えたグループを表示しま
す (@code{gnus-group-list-plus})。
@end table

@vindex gnus-permanently-visible-groups
@cindex visible group parameter
@code{gnus-permanently-visible-groups} 正規表現に合致するグループは、未
読記事があるかないかに関わらず常に表示されます。あるいはグループパラメー
ターにおいて @code{visible} 要素を追加することでも同様の効果を得ることが
できます。

@vindex gnus-list-groups-with-ticked-articles
印付きの記事のみを持つグループは通常グループバッファーに表示されます。も
し @code{gnus-list-groups-with-ticked-articles} が @code{nil} であれば、
そのグループは完全に空のグループであるかのように扱われます。ディフォルト
は @code{t} です。

@node Sorting Groups
@section グループの並べ替え
@cindex sorting groups

@kindex C-c C-s @r{(グループ)}
@findex gnus-group-sort-groups
@vindex gnus-group-sort-function
@kbd{C-c C-s} (@code{gnus-group-sort-groups}) 命令は、グループバッファー
を @code{gnus-group-sort-function} 変数で与えられる関数に従って並べ替え
ます。利用可能な並べ替え関数 (sorting function) には以下のものがありま
す:

@table @code
@item gnus-group-sort-by-alphabet
@findex gnus-group-sort-by-alphabet
グループ名でアルファベット順に並べ替えます。これがディフォルトです。

@item gnus-group-sort-by-real-name
@findex gnus-group-sort-by-real-name
グループを本当の (前に何も付いていない) グループ名でアルファベット順に並
べ変えます。

@item gnus-group-sort-by-level
@findex gnus-group-sort-by-level
グループレベルで並べ替えます。

@item gnus-group-sort-by-score
@findex gnus-group-sort-by-score
グループのスコアで並べ替えます。@xref{Group Score}.

@item gnus-group-sort-by-rank
@findex gnus-group-sort-by-rank
グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベルとス
コアは、ひとまとめにして「ランク」と呼ばれます。@xref{Group Score}.

@item gnus-group-sort-by-unread
@findex gnus-group-sort-by-unread
未読記事の数で並べ替えます。

@item gnus-group-sort-by-method
@findex gnus-group-sort-by-method
選択方法のアルファベット順で並べ替えます。

@item gnus-group-sort-by-server
@findex gnus-group-sort-by-server
サーバー名のアルファベット順で並べ替えます。
@end table

@code{gnus-group-sort-function} は並べ替え関数のリストであっても構いませ
ん。この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりま
せん。

ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

@table @kbd
@item G S a
@kindex G S a @r{(グループ)}
@findex gnus-group-sort-groups-by-alphabet
グループバッファーをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-groups-by-alphabet})。

@item G S u
@kindex G S u @r{(グループ)}
@findex gnus-group-sort-groups-by-unread
グループバッファーを未読記事の数で並べ替えま
す (@code{gnus-group-sort-groups-by-unread})。

@item G S l
@kindex G S l @r{(グループ)}
@findex gnus-group-sort-groups-by-level
グループバッファーをグループレベルで並べ替えま
す (@code{gnus-group-sort-groups-by-level})。

@item G S v
@kindex G S v @r{(グループ)}
@findex gnus-group-sort-groups-by-score
グループバッファーをグループのスコアで並べ替えま
す (@code{gnus-group-sort-groups-by-score})。@xref{Group Score}.

@item G S r
@kindex G S r @r{(グループ)}
@findex gnus-group-sort-groups-by-rank
グループバッファーをグループのランクで並べ替えま
す (@code{gnus-group-sort-groups-by-rank})。@xref{Group Score}.

@item G S m
@kindex G S m @r{(グループ)}
@findex gnus-group-sort-groups-by-method
グループバッファーをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-groups-by-method})。

@item G S n
@kindex G S n @r{(グループ)}
@findex gnus-group-sort-groups-by-real-name
グループバッファーを本当の (前に何も付いていない) グループ名でアルファベッ
ト順に並べ替えます (@code{gnus-group-sort-groups-by-real-name})。
@end table

以下のすべての命令はプロセス/接頭引数の習慣に従いま
す (@pxref{Process/Prefix})。

シンボル接頭引数 (@pxref{Symbolic Prefixes}) が与えられたときは、これら
すべての命令は逆順で並び換えます。

また、グループの一部を並べ替えることもできます。

@table @kbd
@item G P a
@kindex G P a @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-alphabet
グループをグループ名のアルファベット順で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-alphabet})。

@item G P u
@kindex G P u @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-unread
グループを未読記事の数で並べ替えま
す (@code{gnus-group-sort-selected-groups-by-unread})。

@item G P l
@kindex G P l @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-level
グループをグループレベルで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-level})。

@item G P v
@kindex G P v @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-score
グループをグループのスコアで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-score})。
@xref{Group Score}.

@item G P r
@kindex G P r @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-rank
グループをグループのランクで並べ替えま
す (@code{gnus-group-sort-selected-groups-by-rank})。@xref{Group Score}.

@item G P m
@kindex G P m @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-method
グループをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-group-sort-selected-groups-by-method})。

@item G P n
@kindex G P n @r{(グループ)}
@findex gnus-group-sort-selected-groups-by-real-name
グループを本当の (前に何も付いていない) グループ名でアルファベット順に並
べ替えます (@code{gnus-group-sort-selected-groups-by-real-name})。

@item G P s
@kindex G P s @r{(グループ)}
@findex gnus-group-sort-selected-groups
グループを @code{gnus-group-sort-function} に従って並べ替えます。
@end table

最後に、@kbd{C-k} と @kbd{C-y} を使って、手動でグループをあちこちに移動
できることもお忘れなく。

@node Group Maintenance
@section グループの管理
@cindex bogus groups

@table @kbd
@item b
@kindex b @r{(グループ)}
@findex gnus-group-check-bogus-groups
不正なグループを見つけて、削除しま
す (@code{gnus-group-check-bogus-groups})。

@item F
@kindex F @r{(グループ)}
@findex gnus-group-find-new-groups
新しいグループを見つけて、それらを処理しま
す (@code{gnus-group-find-new-groups})。一回の @kbd{C-u} の後で押される
と、サーバーに新しいグループを尋ねるために @code{ask-server} の方法を使
います。二回の @kbd{C-u} の後で押されると、サーバーに新しいグループを尋
ねるために最も完全であると思われる方法を用い、新しいグループをゾンビとし
て購読します。

@item C-c C-x
@kindex C-c C-x @r{(グループ)}
@findex gnus-group-expire-articles
@cindex expiring mail
現在のグループの期限切れ消去可能な記事に対して (もしあれば) すべて期限切
れ消去の処理を行ないます (@code{gnus-group-expire-articles})。これは、そ
のグループにしばらく存在していた期限切れ消去可能なすべての記事を消去する
ということです。(@pxref{Expiring Mail})。

@item C-c C-M-x
@kindex C-c C-M-x @r{(グループ)}
@findex gnus-group-expire-all-groups
@cindex expiring mail
すべてのグループのすべての期限切れ消去可能な記事に対して、期限切れ消去の
処理を行ないます。(@code{gnus-group-expire-all-groups})。
@end table

@node Browse Foreign Server
@section 外部サーバーの閲覧
@cindex foreign servers
@cindex browsing servers

@table @kbd
@item B
@kindex B @r{(グループ)}
@findex gnus-group-browse-foreign-server
選択方法とサーバー名を聞かれます。Gnus はこのサーバーに接続し、そこにあ
るグループを閲覧しようとします (@code{gnus-group-browse-foreign-server})。
@end table

@findex gnus-browse-mode
利用可能なグループのリストを持った新しいバッファーが現れます。このバッファー
は @code{gnus-browse-mode} を使用します。このバッファーは通常のグループ
バッファーにちょっと (というか、とっても) 似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです:

@table @kbd
@item n
@kindex n @r{(閲覧)}
@findex gnus-group-next-group
次のグループに移動します (@code{gnus-group-next-group})。

@item p
@kindex p @r{(閲覧)}
@findex gnus-group-prev-group
一つ前のグループに移動します (@code{gnus-group-prev-group})。

@item @key{SPC}
@kindex SPC @r{(閲覧)}
@findex gnus-browse-read-group
現在のグループに入り、最初の記事を表示しま
す (@code{gnus-browse-read-group})。

@item @key{RET}
@kindex RET @r{(閲覧)}
@findex gnus-browse-select-group
現在のグループに入ります (@code{gnus-browse-select-group})。

@item u
@kindex u @r{(閲覧)}
@findex gnus-browse-unsubscribe-current-group
@vindex gnus-browse-subscribe-newsgroup-method
現在のグループを非購読にします。と言うよりは (訳注: このコマンドはトグル
なので)、この場合は購読することになるのでしょうけれ
ど (@code{gnus-browse-unsubscribe-current-group})。新しいグループをグルー
プバッファーに編入する方法を、変
数 @code{gnus-browse-subscribe-newsgroup-method} を使って制御することが
できます。利用できるオプションについては: @xref{Subscription Methods}.

@item l
@itemx q
@kindex q @r{(閲覧)}
@kindex l @r{(閲覧)}
@findex gnus-browse-exit
閲覧モード (browse mode) を終了します (@code{gnus-browse-exit})。

@item d
@kindex d @r{(閲覧)}
@findex gnus-browse-describe-group
現在のグループを購読にします (@code{gnus-browse-describe-group})。

@item ?
@kindex ? @r{(閲覧)}
@findex gnus-browse-describe-briefly
閲覧モード (browse mode) を簡単に説明します (まあ、大して説明することも
ないんですけれどね) (@code{gnus-browse-describe-briefly})。
@end table

@node Exiting Gnus
@section Gnus の終了
@cindex exiting Gnus

そう、Gnus は最後 (サイコー) です (訳注: く、苦しい。原文は“Yes, Gnus
is ex(c)iting.”)。

@table @kbd
@item z
@kindex z @r{(グループ)}
@findex gnus-group-suspend
Gnus を中断します (@code{gnus-group-suspend})。これは Gnus を実際には終
了させず、グループバッファー以外のすべてのバッファーを消すだけです。僕は
これのうれしさがよくわかんないんだけど、誰か分かる人います?

@item q
@kindex q @r{(グループ)}
@findex gnus-group-exit
@c @icon{gnus-group-exit}
Gnus を終了します (@code{gnus-group-exit})。

@item Q
@kindex Q @r{(グループ)}
@findex gnus-group-quit
@file{.newsrc} ファイルを保存せずに Gnus を終了しま
す (@code{gnus-group-quit})。ドリブルファイルは保存されますけれ
ど (@pxref{Auto Save})。
@end table

@vindex gnus-exit-gnus-hook
@vindex gnus-suspend-gnus-hook
@vindex gnus-after-exiting-gnus-hook
Gnus を中断するときは @code{gnus-suspend-gnus-hook} が呼び出されます。
Gnus を終了するときは @code{gnus-exit-gnus-hook} が呼び出され、さら
に Gnus を終了するときの最後とし
て @code{gnus-after-exiting-gnus-hook} が呼び出されます。

Note:

@quotation
ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女のプラスティッ
クの椅子の背越しに、鉛筆で繰り返し線を描くのにつられて、足がしびれて重く
なり、意識が朦朧としてきました。
@end quotation

@node Group Topics
@section トピック
@cindex topics

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピッ
ク毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セックス
のグループをあっちへ、で、残りを (え? グループが二つくらいしかない
の?) 邪魔にならないようにその他のセクションに入れましょう。あるい
は Emacs セックスのグループを Emacs グループ、セックスグループのどちらか
の副トピックとすることさえもできます---あるいは両方に! すんごいでしょう!

@iftex
@iflatex
\gnusfigure{Group Topics}{400}{
\put(75,50){\epsfig{figure=ps/group-topic,height=9cm}}
}
@end iflatex
@end iftex
これが例です:

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

@findex gnus-topic-mode
@kindex t @r{(グループ)}
この @emph{素晴らしい} 機能を使うには、@code{gnus-topic} マイナーモード
を (何と!) 単にスイッチオンするだけ---グループバッファーで、@kbd{t} を押
してください (これはトグルコマンドです)。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待っ
てるからさ。ララ、タララン@dots{}、いい曲だね、これ@dots{}ラ、ラ、
ラ@dots{}え? 戻ってきた? よし、じゃ次は @kbd{l} を押してみて。ほら。これ
ですべてのグループが @samp{misc} の下に表示されました。興奮してクラクラ
してこない? アツくって、いまいましいくらいでしょ?

これをずっと有効にしたければ、グループモードのフックにこのマイナーモード
を追加してください。以下の行を @file{~/.gnus.el} ファイルに入れて、ね。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@menu
* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター
@end menu

@node Topic Commands
@subsection トピック命令
@cindex topic commands

トピックマイナーモードが有効であるときは、@kbd{T} サブマップが新しく利用
できるようになります。さらに標準キーの中でも、定義がちょっと変わるものが
少しあります。

だいたいにおいて、次のようなトピックの操作が可能です。まず第一に、あなた
はトピックを作ることを望むでしょう。第二に、あなたはグループをトピックに
入れて、それらをあなたの好みの順序になるまで、あちこちに移動することを望
むでしょう。第三に行なう操作は、それらの一切合切を表示したり隠すことでしょ
う。他のグループの概要を見やすくするために、あなたは副トピックやグループ
によっては、トピックが隠れるようにする必要があるかもしれませんね。

ここには、あなたの好むやり方でトピックを設定するために必要になりそうな、
基本的なキーのリストがあります。

@table @kbd
@item T n
@kindex T n @r{(トピック)}
@findex gnus-topic-create-topic
新しいトピック名の入力を促し、それを作成しま
す (@code{gnus-topic-create-topic})。

@item T @key{TAB}
@itemx @key{TAB}
@kindex T TAB @r{(トピック)}
@kindex TAB @r{(トピック)}
@findex gnus-topic-indent
現在のトピックの「字下げ」を行ない、その前のトピックの副トピックにしま
す (@code{gnus-topic-indent})。接頭引数を与えると、反対にそのトピックの
字下げを回復 (un-indent) します。

@item M-@key{TAB}
@kindex M-TAB @r{(トピック)}
@findex gnus-topic-unindent
現在のトピックの「字下げ回復」(un-indent) を行ない、それが現在の親の親の
副トピックになるようにします (@code{gnus-topic-unindent})。
@end table

以下の二つのキーは、グループとトピックをあちこち移動するために使われます。
それらは、よく知られているカット＆ペーストのように動作します。
@kbd{C-k} はカット、@kbd{C-y} はペーストです。もちろん、Emacs ではカット
＆ペーストではなくて kill & yank という用語を使いますが。

@table @kbd
@item C-k
@kindex C-k @r{(トピック)}
@findex gnus-topic-kill-group
グループあるいはトピックを kill します (@code{gnus-topic-kill-group})。
トピック内にあったグループもすべて、トピックと一緒に削除されます。

@item C-y
@kindex C-y @r{(トピック)}
@findex gnus-topic-yank-group
直前の kill されたグループあるいはトピックを yank しま
す (@code{gnus-topic-yank-group})。すべてのトピックは、すべてのグループ
の前に yank されることに気を付けてください。

ですから、あるトピックをトピックのリストの先頭に移動するには、単にそこ
で @kbd{C-k} を叩きます。これはカット＆ペーストのカットに相当します。そ
うしたらカーソルをバッファーの先頭 (“Gnus”トピックの真下) に移動して、
@kbd{C-y} を叩いてください。これはカット＆ペーストのペーストに相当します。
なあんだ、簡単じゃん。

@kbd{C-k} と @kbd{C-y} はトピックと同様にグループにも使えます。すなわち、
あなたはグループと同じようにトピックの移動もできるのです。
@end table

あなたの望みのままにトピックを使えるようにした後で、あなたはトピックを隠
したり再び見えるようにしようと思うでしょう。そのために以下のキーを用意し
ています。

@table @kbd
@item @key{RET}
@kindex RET @r{(トピック)}
@findex gnus-topic-select-group
@itemx @key{SPC}
グループを選択するか、あるいはトピックを折りたたみま
す (@code{gnus-topic-select-group})。グループの上でこのコマンドを実行す
ると、通常通りそのグループに入ります。トピック行の上で行なうと、そのトピッ
クは (すでに表示されているときは) 折りたたまれるか、(すでに折りたたまれ
ているときは) 展開されます。つまりトピックに対してはこれはトグルコマンド
です。さらに、数値の接頭引数を与えると、そのレベル (とそれよりも小さいレ
ベル) のグループが表示されます。
@end table

さてお次は、他のコマンドのリストです。順序には特に意味はありません。

@table @kbd
@item T m
@kindex T m @r{(トピック)}
@findex gnus-topic-move-group
現在のグループを、どこか他のトピックに移動させま
す (@code{gnus-topic-move-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T j
@kindex T j @r{(トピック)}
@findex gnus-topic-jump-to-topic
トピックにジャンプします (@code{gnus-topic-jump-to-topic})。

@item T c
@kindex T c @r{(トピック)}
@findex gnus-topic-copy-group
現在のグループを、どこか他のトピックにコピーしま
す (@code{gnus-topic-copy-group})。このコマンドはプロセス印/接頭引数の習
慣に従います (@pxref{Process/Prefix})。

@item T h
@kindex T h @r{(トピック)}
@findex gnus-topic-hide-topic
現在のトピックを隠します。接頭引数が与えらると、そのトピックを永久に隠し
ます。

@item T s
@kindex T s @r{(トピック)}
@findex gnus-topic-show-topic
現在のトピックを表示します。接頭引数が与えられると、そのトピックを永久に
表示します。

@item T D
@kindex T D @r{(トピック)}
@findex gnus-topic-remove-group
グループを現在のトピックから削除します (@code{gnus-topic-remove-group})。
この命令は主にいくつかのトピックに同じグループがあって、それをトピックの
一つから取り除きたいときに役立ちます。あなたはグループをすべてのトピック
から取り除くかもしれませんが、その場合は、Gnus はあなたが次回に Gnus を
起動したときにそれをルートトピックに付け加えます。実際のところ、すべての
新しいグループ (もちろん、それはどのトピックにも属していません) はルート
トピックに現われます。

この命令はプロセス印/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item T M
@kindex T M @r{(トピック)}
@findex gnus-topic-move-matching
正規表現に合致するすべてのグループを、あるトピックに移動させま
す (@code{gnus-topic-move-matching})。

@item T C
@kindex T C @r{(トピック)}
@findex gnus-topic-copy-matching
正規表現に合致するすべてのグループを、あるトピックにコピーしま
す (@code{gnus-topic-copy-matching})。

@item T H
@kindex T H @r{(トピック)}
@findex gnus-topic-toggle-display-empty-topics
空のトピックの表示・非表示を切り替えま
す (@code{gnus-topic-toggle-display-empty-topics})。

@item T #
@kindex T # @r{(トピック)}
@findex gnus-topic-mark-topic
現在のトピックにあるグループすべてにプロセス印を付けま
す (@code{gnus-topic-mark-topic})。接頭引数が与えられない場合、このコマ
ンドは副トピックに対して再帰的に働きます。

@item T M-#
@kindex T M-# @r{(トピック)}
@findex gnus-topic-unmark-topic
現在のトピックにあるすべてのグループからプロセス印を消しま
す (@code{gnus-topic-unmark-topic})。接頭引数が与えられない場合、このコ
マンドは副トピックに対して再帰的に働きます。

@item C-c C-x
@kindex C-c C-x @r{(トピック)}
@findex gnus-topic-expire-articles
@cindex expiring mail
(もしあれば) 現在のグループかトピックかのすべての期限切れ消去可能記事を
期限切れ消去します (@code{gnus-topic-expire-articles})。(@pxref{Expiring
Mail})。

@item T r
@kindex T r @r{(トピック)}
@findex gnus-topic-rename
トピックの名前を変更します (@code{gnus-topic-rename})。

@item T @key{DEL}
@kindex T DEL @r{(トピック)}
@findex gnus-topic-delete
空のトピックを削除します (@code{gnus-topic-delete})。

@item A T
@kindex A T @r{(トピック)}
@findex gnus-topic-list-active
Gnus が知っているトピック化されたグループをすべて表示しま
す (@code{gnus-topic-list-active})。

@item T M-n
@kindex T M-n @r{(トピック)}
@findex gnus-topic-goto-next-topic
次のトピックに移動します (@code{gnus-topic-goto-next-topic})。

@item T M-p
@kindex T M-p @r{(トピック)}
@findex gnus-topic-goto-previous-topic
前のトピックに移動します (@code{gnus-topic-goto-previous-topic})。

@item G p
@kindex G p @r{(トピック)}
@findex gnus-topic-edit-parameters
@cindex group parameters
@cindex topic parameters
@cindex parameters
トピックパラメーターを修正します (@code{gnus-topic-edit-parameters})。
@xref{Topic Parameters}.
@end table

@node Topic Variables
@subsection トピック変数
@cindex topic variables

前の章では、どのトピックを表示するかを Gnus に言う方法を説明しました。
この章では、それぞれのトピックの何を表示するかを Gnus に言う方法を説明し
ます。

@vindex gnus-topic-line-format
トピック行それ自体は、@code{gnus-topic-line-format} 変数の値に従って作成
されます (@pxref{Formatting Variables})。有効な要素は、

@table @samp
@item i
字下げ。
@item n
トピック名。
@item v
見えるかどうか。
@item l
レベル。
@item g
トピック中のグループの数。
@item a
トピック中の未読記事の数。
@item A
トピックとすべての副トピックの未読記事の数。
@end table

@vindex gnus-topic-indent-level
各副トピック (と副トピック内のグループ) は、トピックレベル数
の @code{gnus-topic-indent-level} 倍の空白分の字下げが行なわれます。ディ
フォルトは 2 です。

@vindex gnus-topic-mode-hook
@code{gnus-topic-mode-hook} はトピックマイナーモードバッファーで呼び出さ
れます。

@vindex gnus-topic-display-empty-topics
@code{gnus-topic-display-empty-topics} はトピックの中に未読記事が無い場
合でもそのトピックを表示するようにします。ディフォルトは @code{t} です。

@node Topic Sorting
@subsection トピックの並べ替え
@cindex topic sorting

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができます:

@table @kbd
@item T S a
@kindex T S a @r{(トピック)}
@findex gnus-topic-sort-groups-by-alphabet
現在のトピックをグループ名のアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-alphabet})。

@item T S u
@kindex T S u @r{(トピック)}
@findex gnus-topic-sort-groups-by-unread
現在のトピックを未読記事の数で並べ替えま
す (@code{gnus-topic-sort-groups-by-unread})。

@item T S l
@kindex T S l @r{(トピック)}
@findex gnus-topic-sort-groups-by-level
現在のトピックをグループのレベルで並べ替えま
す (@code{gnus-topic-sort-groups-by-level})。

@item T S v
@kindex T S v @r{(トピック)}
@findex gnus-topic-sort-groups-by-score
現在のトピックをグループのスコアで並べ替えま
す (@code{gnus-topic-sort-groups-by-score})。@xref{Group Score}.

@item T S r
@kindex T S r @r{(トピック)}
@findex gnus-topic-sort-groups-by-rank
現在のトピックをグループのランクで並べ替えま
す (@code{gnus-topic-sort-groups-by-rank})。@xref{Group Score}.

@item T S m
@kindex T S m @r{(トピック)}
@findex gnus-topic-sort-groups-by-method
現在のトピックをバックエンドの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-method})。

@item T S e
@kindex T S e @r{(トピック)}
@findex gnus-topic-sort-groups-by-server
現在のトピックをサーバーの名前でアルファベット順に並べ替えま
す (@code{gnus-topic-sort-groups-by-server})。

@item T S s
@kindex T S s @r{(トピック)}
@findex gnus-topic-sort-groups
現在のトピックを、変数 @code{gnus-group-sort-function} で与えられる関数
に従って並べ替えます (@code{gnus-topic-sort-groups})。
@end table

接頭引数が与えられると、これらすべてのコマンドは逆順の並べ替えを行ないま
す。グループの並べ替えについてのさらなる情報は @ref{Sorting Groups} を参
照してください。

@node Topic Topology
@subsection トピックの位相構造
@cindex topic topology
@cindex topology

それでは、グループバッファーの例を見ていきましょう。

@example
Gnus
  Emacs -- こいつはすげーぜ!
     3: comp.emacs
     2: alt.religion.emacs
    えっちな Emacs
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
@end example

つまり、ここでは一つのトップレベルのトピック (@samp{Gnus}) があり、その
下に二つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックが
あります (トップレベルトピックは常に一つしかありません)。この構造は、以
下のように表現できます:

@lisp
(("Gnus" visible)
 (("Emacs -- こいつはすげーぜ!" visible)
  (("えっちな Emacs" visible)))
 (("その他" visible)))
@end lisp

@vindex gnus-topic-topology
これは実に、上記の表示を行なうための、変数 @code{gnus-topic-topology} の
値そのものなのです。この変数は @file{.newsrc.eld} ファイルに保存され、手
でいじくり回してはいけません---本当にやりたいときは別ですが。この変数
は @file{.newsrc.eld} ファイルから読み込まれるので、その他のスタートアッ
プファイルの設定にはまったく影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピッ
クが表示されているかを示しています。現在は二つの設定
値---@code{visible} と @code{invisible} を使うことができます。

@node Topic Parameters
@subsection トピックパラメーター
@cindex topic parameters

トピック内のすべてのグループはグループパラメーターを、その親 (と先祖) の
トピックパラメーターから継承します。グループパラメーターとして正しいもの
はすべて、トピックパラメーターとしても正しいもので
す (@pxref{Group Parameters})。エージェントを使うようにしてあると、すべ
てのエージェントパラメー
ター (@ref{Category Syntax} の Agent Parameters を参照 (訳注: 必要な
ら Index を使って)) は有効なトピックパラメーターでもあります。

さらに、以下のパラメーターはトピックパラメーターとしてのみ有効です:

@table @code
@item subscribe
トピックで新しいグループを購読し始める場
合 (@pxref{Subscription Methods}) に、どのグループがどのトピックに行くか
を @code{subscribe} トピックパラメーターで指定します。値はそのトピックに
行くグループに合致する正規表現である必要があります。

@item subscribe-level
トピックで新しいグループを購読し始める場
合 (@code{subscribe} パラメーターを参照)、そのグループの購読度のレベル
は @code{gnus-level-default-subscribed} の代わり
に @code{subscribe-level} トピックパラメーターの値になります。
@end table

グループパラメーターは (もちろん) トピックパラメーターよりも優先され、副
トピックのトピックパラメーターは親トピックのトピックパラメーターよりも優
先されます。分かるよね。ごく普通の継承ルールで
す (ルール (@dfn{Rules}) はここでは名詞であって、動詞の「線を引く」では
ありません。このルールには反対したくなるかもしれないけど、それはご自由に)。

@example
@group
Gnus
  Emacs
     3: comp.emacs
     2: alt.religion.emacs
   452: alt.sex.emacs
    息抜き
     452: alt.sex.emacs
       0: comp.talk.emacs.recovery
  その他
     8: comp.binaries.fractals
    13: comp.sources.unix
   452: alt.sex.emacs
@end group
@end example

@samp{Emacs} トピックはトピックパラメー
ター @code{(score-file . "emacs.SCORE")} を持っています。
@samp{息抜き} トピックはトピックパラメー
ター @code{(score-file . "relief.SCORE")} を持ち、
@samp{その他} トピックはトピックパラメー
ター @code{(score-file . "emacs.SCORE")} を持っています。
さらに、@samp{alt.religion.emacs} はグループパラメー
ター @code{(score-file . "religion.SCORE")} を持っています。

さて、ここで @samp{息抜き} トピックの @samp{alt.sex.emacs} グループに入っ
たとき、@file{relief.SCORE} が基本スコアファイルとなります。も
し @samp{Emacs} トピックの同じグループに入ると、@file{emacs.SCORE} が基
本スコアファイルになるでしょう。
@samp{alt.religion.emacs} グループに入れば、@file{religion.SCORE} が基本
スコアファイルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ? まあ、その通りです。
ですが問題がある場合もあります。特に @code{total-expiry} パラメーターに
関してです。例えばあるメールグループを二つのトピックの中に、一方
は @code{total-expiry} ありで、もう一方はそれなしで持っているとしましょ
う。ここで @kbd{M-x gnus-expire-all-expirable-groups} を実行すると、何が
起こるでしょうか? Gnus は、あなたがどちらのトピックから記事を期限切れ消
去したいのかを知る方法がないため、最悪の事態が発生するかもしれません。実
際、私はこのとき何が起こるのかは「未定義 @dfn{undefined}」である、とここ
に宣言します。この手のことをやりたい場合には十分注意しなければなりません。

@node Non-ASCII Group Names
@section 英字以外の名前のグループへのアクセス
@cindex non-ascii group names

世界には、それぞれの母国語で表した名前のグループを提供するニュースサーバー
があります。例えば、あるニュースサーバーには名前が中国語で綴られたニュー
スグループがあって、そこで人々は中国語で話をしています。もちろん Gnus で
そのようなニュースグループを講読することは可能です。Gnus は現
在 @code{nntp} バックエンドだけでなく @code{nnml} バックエンド
と @code{nnrss} バックエンドで非-@acronym{ASCII} グループ名をサポートし
ています。

すべてのそのようなグループ名は、サーバー側で、ある文字セットでエンコード
されています (@acronym{NNTP} サーバーでは管理者が文字セットを決めますが、
他のバックエンドのグループではあなたがそれを決めます)。Gnus はあなたのた
めにグループバッファーと記事バッファーでデコードされたものを表示しなけれ
ばなりませんし、サーバーと通信するときはエンコードされたものを使う必要が
あります。しかし Gnus は、各々の非-@acronym{ASCII} グループ名にどんな文
字セットが使われているかを知りません。以下の二つの変数は、まさに各グルー
プでどんな文字セットを使うべきかを Gnus に伝えるためのものです:

@table @code
@item gnus-group-name-charset-method-alist
@vindex gnus-group-name-charset-method-alist
選択方法と文字セットの連想リストです。ディフォルト値は @code{nil} です。
その選択方法で指定されるサーバーにあるグループの名前は、すべてその対応す
る文字セットを使うものと仮定されます。例です:

@lisp
(setq gnus-group-name-charset-method-alist
      '(((nntp "news.com.cn") . cn-gb-2312)))
@end lisp

この変数でグループに指定された文字セットは、同じグループ
に @code{gnus-group-name-charset-group-alist} 変数で指定されたものより優
先されます (下記参照)。

選択方法は非常に長くなる場合がありますね。このように:

@lisp
(nntp "gmane"
      (nntp-address "news.gmane.org")
      (nntp-end-of-line "\n")
      (nntp-open-connection-function
       nntp-open-via-rlogin-and-telnet)
      (nntp-via-rlogin-command "ssh")
      (nntp-via-rlogin-command-switches
       ("-C" "-t" "-e" "none"))
      (nntp-via-address @dots{}))
@end lisp

そのような場合、この変数の中では @code{(nntp "gmane")} に切り詰めること
ができます。つまり、バックエンド名とサーバー名だけを含んでいれば十分です。

@item gnus-group-name-charset-group-alist
@cindex UTF-8 group names
@vindex gnus-group-name-charset-group-alist
グループ名の正規表現と、それに合致するグループのための文字セットの連想リ
ストです。UTF-8 がサポートされている場合は @code{((".*" utf-8))} がディ
フォルト値で、それ以外の場合のディフォルトは @code{nil} です。例です:

@lisp
(setq gnus-group-name-charset-group-alist
      '(("\\.com\\.cn:" . cn-gb-2312)
        (".*" . utf-8)))

@code{gnus-group-name-charset-method-alist} で合致した場合、この変数は無
視されることに注意してください。
@end lisp
@end table

これら二つの変数は @code{nntp} 以外のバックエンドにある
非-@acronym{ASCII} 名のグループをエンコードおよびデコードする文字セット
を決定するためにも使われます。つまり、それを決めるのはあなたです。何もし
なければそれらのバックエンドのグループ名で使われる文字セットは、
@code{gnus-group-name-charset-group-alist} の最後の素子のせいですべ
て @code{utf-8} になるでしょう。

さて、非-@acronym{ASCII} グループ名のための重要な変数がもう一つあります:

@table @code
@item nnmail-pathname-coding-system
@vindex nnmail-pathname-coding-system
この変数の値は coding system もしくは @code{nil} でなければなりません。
ディフォルトは @code{nil} です。

@code{nnml} バックエンド、@code{nnrss} バックエンド、エージェント、およ
びキャッシュは、それらのファイルとディレクトリーで非-@acronym{ASCII} グ
ループ名を使います。この変数は、それらのファイル名とディレクトリー名をエ
ンコードおよびデコードするときに用いられる coding system を指定す
る @code{file-name-coding-system} の値を上書きします。

@code{file-name-coding-system} の値が @code{nil} だった場合、また
は @code{nil} である @code{nnmail-pathname-coding-system} の値にそれが束
縛される場合、@code{default-file-name-coding-system} の値を使用します。

通常 @code{default-file-name-coding-system} の値は言語環境に従って初期化
されるので、その値が非-@acronym{ASCII} グループ名をエンコードおよびデコー
ドするために適切であれば、何もする必要は無いでしょう。

この変数 (または @code{default-file-name-coding-system}) の値は、必ずし
も @code{gnus-group-name-charset-method-alist} およ
び @code{gnus-group-name-charset-group-alist} によって決定される値と同じ
である必要はありません。

例えば中国語で綴られたニュースグループを講読したいのに、
@code{default-file-name-coding-system} またはこの変数がディフォルト
で @code{iso-latin-1-unix} に初期化されてしまうのならば、それ
は @code{nnmail-pathname-coding-system} をカスタマイズしなければならない
最も典型的な場合です。@code{utf-8-unix} coding system はそのための良い候
補です。あるいは @code{default-file-name-coding-system} またはこの変数が
適切な値に初期化されるように、あなたのシステムの言語環境を変更しても良い
でしょう。
@end table

記事を非-@acronym{ASCII} グループから他のグループにコピーまたは移動する
場合、グループ名をエンコードおよびデコードするための文字セットが両方のグ
ループで同じでなければならないことに注意してください。さもないと記事バッ
ファーに Newsgroups ヘッダーが正しく表示されないでしょう。

@node Misc Group Stuff
@section その他のグループ関連

@menu
* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理
@end menu

@table @kbd
@item v
@kindex v @r{(グループ)}
@cindex keys, reserved for users (Group)
@kbd{v} キーはユーザー用に予約されています。そのまま何かのコマンドに割り
当てても構いませんが、接頭キーとして使う方が良いでしょう。例です:

@lisp
(define-key gnus-group-mode-map (kbd "v j d")
  (lambda ()
    (interactive)
    (gnus-group-jump-to-group "nndraft:drafts")))
@end lisp

Emacs でユーザー用に予約されているキーとキーバインドについては、
@xref{Keymaps, Keymaps, ,emacs, The Emacs Editor}.

@item ^
@kindex ^ @r{(グループ)}
@findex gnus-group-enter-server-mode
サーバーバッファーモードに入ります (@code{gnus-group-enter-server-mode})。
@xref{Server Buffer}.

@item a
@kindex a @r{(グループ)}
@findex gnus-group-post-news
メッセージ (ディフォルトはニュース) の作成を開始しま
す (@code{gnus-group-post-news})。接頭引数が与えられると、現在位置のグルー
プに投稿します。もし接頭引数が 1 だったら、どのグループに投稿するかを尋
ねます。この関数の名前から連想されることとは裏腹に、接頭引数でメールグルー
プが指定された場合は、ニュースの代わりにメールの様式が用意されます。
@xref{Composing Messages}.

@item m
@kindex m @r{(グループ)}
@findex gnus-group-mail
メールをどこかに送ります (@code{gnus-group-mail})。接頭引数が与えられる
と、現在位置のグループの投稿様式 (posting style) を使います。もし接頭引
数が 1 だったら、どのグループの投稿様式を使うかを尋ねます。
@xref{Composing Messages}.

@item i
@kindex i @r{(グループ)}
@findex gnus-group-news
ニュースの作成を開始します (@code{gnus-group-news})。接頭引数が与えられ
ると、現在位置のグループに投稿します。もし接頭引数が 1 だったら、どのグ
ループに投稿するかを尋ねます。@xref{Composing Messages}.

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに「投稿」するのに便利です; それらは当のグループに単に直接
保存されます。対応するバックエンドが投稿のためのメソッド (request-post
method) を持っていなければなりませんが。

@item G z
@kindex G z @r{(グループ)}
@findex gnus-group-compact-group

現在位置のグループを圧縮します (@code{gnus-group-compact-group})。今のと
ころ @code{nnml} (@pxref{Mail Spool}) だけに実装されています。これは記事
番号のすきまを取り除くので、正しい全記事数を得ることができるようになりま
す。
@end table

以下はグループバッファーのための変数です:

@table @code
@item gnus-group-mode-hook
@vindex gnus-group-mode-hook
グループバッファーが作成された時に呼び出されます。

@item gnus-group-prepare-hook
@vindex gnus-group-prepare-hook
グループバッファーが生成されたあとに呼び出されます。これはバッファーを何
か変な、自然ではない方法で修正したいときに使われるかもしれません。

@item gnus-group-prepared-hook
@vindex gnus-group-prepared-hook
グループバッファーが生成された後の一番最後に呼び出されます。例えばポイン
トをどこかに移動させたいときなどに使えます。

@item gnus-permanently-visible-groups
@vindex gnus-permanently-visible-groups
この正規表現に合致するグループは、それが空であるかどうかに関わらず、常に
グループバッファーに表示されます。
@end table

@node Scanning New Messages
@subsection 新着メッセージを探す
@cindex new messages
@cindex scanning new news

@table @kbd
@item g
@kindex g @r{(グループ)}
@findex gnus-group-get-new-news
@c @icon{gnus-group-get-new-news}
サーバーの新着記事をチェックします。数値の接頭引数を使用すると、この命令
は引数 @var{arg} かそれより小さいレベルのグループのみをチェックしま
す (@code{gnus-group-get-new-news})。数値以外の接頭引数を与えると、この
命令はそのバックエンドからアクティブファイルを強制的に全部読み直します。

@item M-g
@kindex M-g @r{(グループ)}
@findex gnus-group-get-new-news-this-group
@vindex gnus-goto-next-group-when-activating
@c @icon{gnus-group-get-new-news-this-group}
現在のグループに新着記事があるかどうかをチェックしま
す (@code{gnus-group-get-new-news-this-group})。
@code{gnus-goto-next-group-when-activating} はこの命令が次のグループ位置
へ移動するかどうかを決めます。ディフォルトは @code{t} です。

@findex gnus-activate-all-groups
@cindex activating groups
@item C-c M-g
@kindex C-c M-g @r{(グループ)}
無条件にすべてのグループを起動します (@code{gnus-activate-all-groups})。

@item R
@kindex R @r{(グループ)}
@cindex restarting
@findex gnus-group-restart
Gnus を再起動します (@code{gnus-group-restart})。これ
は @file{.newsrc} ファイルをセーブし、すべてのサーバーの接続を閉じ、すべ
ての Gnus ランタイム変数をクリアした後、Gnus をもう一度最初から開始しま
す。
@end table

@vindex gnus-get-new-news-hook
@code{gnus-get-new-news-hook} は新着ニュースをチェックする直前に実行され
ます。

@vindex gnus-after-getting-new-news-hook
@code{gnus-after-getting-new-news-hook} 新着ニュースをチェックした後に実
行されます。

@node Group Information
@subsection グループ情報
@cindex group information
@cindex information on groups

@table @kbd
@item H d
@itemx C-c C-d
@c @icon{gnus-group-describe-group}
@kindex H d @r{(グループ)}
@kindex C-c C-d @r{(グループ)}
@cindex describing groups
@cindex group description
@findex gnus-group-describe-group
現在のグループの説明を表示します (@code{gnus-group-describe-group})。接
頭引数を与えると、説明文をサーバーから強制的に再読み込みします。

@item M-d
@kindex M-d @r{(グループ)}
@findex gnus-group-describe-all-groups
すべてのグループの説明を表示しま
す (@code{gnus-group-describe-all-groups})。接頭引数を与えると、説明文ファ
イルをサーバーから強制的に再読み込みします。

@item H v
@itemx V
@kindex V @r{(グループ)}
@kindex H v @r{(グループ)}
@cindex version
@findex gnus-version
現在の Gnus のバージョン番号を表示します (@code{gnus-version})。

@item ?
@kindex ? @r{(グループ)}
@findex gnus-group-describe-briefly
とても短いヘルプメッセージを与えま
す (@code{gnus-group-describe-briefly})。

@item C-c C-i
@kindex C-c C-i @r{(グループ)}
@cindex info
@cindex manual
@findex gnus-info-find-node
Gnus の info ノードに移動します (@code{gnus-info-find-node})。
@end table

@node Group Timestamp
@subsection グループの日付
@cindex timestamps
@cindex group timestamps

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利かもしれ
ません。この活動を始めさせるには、
@code{gnus-group-set-timestamp} を @code{gnus-select-group-hook} に追加
してください。

@lisp
(add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
@end lisp

これを行なった後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます---もっとも簡単なのは、グループ行
フォーマットで @samp{%d} 指定を使う方法です:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")
@end lisp

この結果として、各行は以下のように表示されます:

@example
*        0: mail.ding                                19961002T012943
         0: custom                                   19961002T012713
@end example

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。
これではちょっとあんまりなので、以下のような感じにすると日付だけ
を表示できます。

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")
@end lisp

もっと凝った日付の形式をお望みなら、利用者定義によるフォーマットの仕様を
使うことができます。以下のようなものはうまくいくでしょう:

@lisp
(setq gnus-group-line-format
      "%M\%S\%p\%P\%5y: %(%-40,40g%) %ud\n")
(defun gnus-user-format-function-d (headers)
  (let ((time (gnus-group-timestamp gnus-tmp-group)))
    (if time
        (format-time-string "%b %d  %H:%M" time)
      "")))
@end lisp

動的に束縛されている変数 (@code{gnus-tmp-group} のようなもの) に何がある
かを知るにはソースコードを眺める必要があります。変数名が複数の Gnus のバー
ジョンを通して一定していることも保証されていません。

@node File Commands
@subsection ファイル命令
@cindex file commands

@table @kbd
@item r
@kindex r @r{(グループ)}
@findex gnus-group-read-init-file
@vindex gnus-init-file
@cindex reading init file
初期化ファイルの再読み込みを行ないます (@code{gnus-init-file}、ディフォ
ルトは @file{~/.gnus.el}) (@code{gnus-group-read-init-file})。

@item s
@kindex s @r{(グループ)}
@findex gnus-group-save-newsrc
@cindex saving .newsrc
@file{.newsrc.eld} ファイル (と、もしそうしたければ @file{.newsrc} ファ
イル) をセーブします (@code{gnus-group-save-newsrc})。

@c @item Z
@c @kindex Z @r{(グループ)}
@c @findex gnus-group-clear-dribble
@c ドリブルファイルをクリアする
@c (@code{gnus-group-clear-dribble})。
@end table

@node Sieve Commands
@subsection Sieve コマンド
@cindex group sieve commands

Sieve はサーバー側で使われるメールフィルター言語です。Gnus では、各グルー
プに適用される sieve の規則を指定する、@code{sieve} グループパラメー
ター (@pxref{Group Parameters}) を使うことができます。guns はそれらすべ
てのグループパラメーターを、サーバーで使うことも可能な正しい Sieve スク
リプトに翻訳する、二つのコマンドを提供します。

@vindex gnus-sieve-file
@vindex gnus-sieve-region-start
@vindex gnus-sieve-region-end
作成された Sieve スクリプトは @code{gnus-sieve-file} (ディフォルト
は @file{~/.sieve}) に置かれます。Gnus が作るコードは二つの区切り記
号 @code{gnus-sieve-region-start} と @code{gnus-sieve-region-end} の間に
置かれるので、これらの区切り記号の外に追加の Sieve コードを書いても、次
回 Sieve スクリプトを再作成するときに消されてしまうことはありません。

@vindex gnus-sieve-crosspost
変数 @code{gnus-sieve-crosspost} は Sieve スクリプトがどのように作られる
かを制御します。もし非-@code{nil} (ディフォルト) だったら記事は規則に合
致するすべてのグループに置かれます。そうでない場合、記事は最初の規則に合
致するグループだけに置かれます。例えばグループパラメーター @samp{(sieve
address "sender" "owner-ding@@hpc.uh.edu")} は、
@code{gnus-sieve-crosspost} が @code{nil} だったら以下の Sieve コードの
断片を作ります。(@code{gnus-sieve-crosspost} が非-@code{nil} だった場合
は、行が含む @code{stop} の呼び出しが削除されること以外は同じです。)

@example
if address "sender" "owner-ding@@hpc.uh.edu" @{
        fileinto "INBOX.ding";
        stop;
@}
@end example

@xref{Top, Emacs Sieve, Top, sieve, Emacs Sieve}.

@table @kbd
@item D g
@kindex D g @r{(グループ)}
@findex gnus-sieve-generate
@vindex gnus-sieve-file
@cindex generating sieve script
@code{sieve} グループパラメーターから Sieve スクリプトを再作成して、
@code{gnus-sieve-file} に書き込みます。以前の内容は保存されません。

@item D u
@kindex D u @r{(グループ)}
@findex gnus-sieve-update
@vindex gnus-sieve-file
@cindex updating sieve script
@code{sieve} グループパラメーターを元
に @code{gnus-sieve-file} の Gnus が管理している部分を再作成してファイル
にセーブし、@code{sieveshell} プログラムを使ってサーバーにアップロードし
ます。
@end table

@node Summary Buffer
@chapter 概略バッファー
@cindex summary buffer

概略バッファー (summary buffer) ではそれぞれの記事が一行で表示されます。
その中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファーに移る一番普通の方法は、グループバッファーでグループを選択
することです (@pxref{Selecting a Group})。

好きなだけたくさんの概略バッファーを開いておくことができます。

概略モードのツールバーをカスタマイズすることができます。@kbd{M-x
customize-apropos @key{RET} gnus-summary-tool-bar} を試してみてください。

@kindex v @r{(概略)}
@cindex keys, reserved for users (Summary)
@kbd{v} キーはユーザー用に予約されています。そのまま何かのコマンドに割り
当てても構いませんが、接頭キーとして使う方が良いでしょう。例です:

@lisp
;; 副スレッドのスコアを下げる。
(define-key gnus-summary-mode-map (kbd "v -") "LrS")
@end lisp

@menu
* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Sticky Articles::             再利用しない記事バッファー
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード
@end menu

@node Summary Buffer Format
@section 概略バッファーの様式
@cindex summary buffer format

@iftex
@iflatex
\gnusfigure{The Summary Buffer}{180}{
\put(0,0){\epsfig{figure=ps/summary,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-article,width=7.5cm}}}
}
@end iflatex
@end iftex
@menu
* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする
@end menu

@findex mail-extract-address-components
@findex gnus-extract-address-components
@vindex gnus-extract-address-components
Gnus は変数 @code{gnus-extract-address-components} の値を @code{From} ヘッ
ダーの名前とアドレスの部分を抽出するための関数として使います。すでに定義
されている関数が二つ存在します: ディフォルト
は @code{gnus-extract-address-components} で、とても簡単に割り切った解決
法ですが非常に速く動作します。@code{mail-extract-address-components} は
良く動作しますが遅いです。ディフォルトの関数は 5% の割合で間違った答を返
します。もしこれに我慢ならないのであれば、代わりに他の関数を使ってくださ
い:

@lisp
(setq gnus-extract-address-components
      'mail-extract-address-components)
@end lisp

@vindex gnus-summary-same-subject
@code{gnus-summary-same-subject} は今読んでいる記事が、その前の記事と同
じ表題 (subject) であることを示す文字列です。この文字列は、それを要求す
る書法仕様で使われます。ディフォルトでは @code{""} です。

@node Summary Buffer Lines
@subsection 概略バッファーの行

@vindex gnus-summary-line-format
変数 @code{gnus-summary-line-format} の値を変えることによって、概略バッ
ファーの行の様式 (format) を変更することができます。いくつかの拡
張 (@pxref{Formatting Variables}) とともに、普通の @code{format} 文字列
と同じように動作します。

行には常にコロンかポイント位置のマーカーが存在していなければなりません。
操作した後に、カーソルはいつもコロンかポイント位置のマーカーの場所に移動
します。(もちろん、この動作を変えることができないとしたら Gnus にはある
まじきことです。関数 @code{gnus-goto-colon} を、あなたが好きなカーソルの
動きになるように、新たに書けば良いのです。) @xref{Positioning Point}.

ディフォルトの文字列は @samp{%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n} です。

以下の様式指示文字と拡張様式指示を使うことができます:

@table @samp
@item N
記事数。
@item S
表題の文字列。@code{gnus-list-identifiers} の設定によってメーリングリス
トの標識が削除されます。@xref{Article Hiding}.
@item s
スレッド (thread) の元記事であるときか直前の記事が違う表題のときはその表
題で、それ以外は @code{gnus-summary-same-subject}。
(@code{gnus-summary-same-subject} はディフォルトで @code{""}。)
@item F
完全な @code{From} 欄。
@item n
名前 (@code{From} 欄より)。
@item f
名前、@code{To} 欄の内容、または @code{Newsgroups} 欄の内容のどれかで
す (@pxref{To From Newsgroups})。
@item a
名前 (@code{From} 欄より)。これと @code{n} との違いは、これは変
数 @code{gnus-extract-address-components} で指定されている関数を使って名
前を取得することです。この方が遅いですが、おそらくより完全に近いでしょう。
@item A
名前 (@code{From} 欄より)。これは @code{a} と同じように動作します。
@item L
記事の行数。
@item c
記事の文字数。この名前指定子は (nnfolder のような) いくつかの選択方法を
サポートしません。
@item k
整形された記事の文字数; 例えば @samp{1.2k} や @samp{0.4M}。
@item I
スレッドのレベルによる字下げ (@pxref{Customizing Threading})。
@item B
複雑な trn 様式のスレッド木 (tree)。どのような応答が行なわれたかの記録を
表示します。スレッドはこのように描かれるでしょう:

@example
>
+->
| +->
| | \->
| |   \->
| \->
+->
\->
@end example

以下のオプションで見栄えをカスタマイズすることができます。ディフォルト
の @acronym{ASCII} 文字を線描画用の図案で置き換えることによって、スレッ
ド表示を実に巧妙に見せることができることに気付いてください。

@table @code
@item gnus-sum-thread-tree-root
@vindex gnus-sum-thread-tree-root
スレッドの根 (root) に使われます。@code{nil} だったら、代わりに表題を使
います。ディフォルトは @samp{> } です。

@item gnus-sum-thread-tree-false-root
@vindex gnus-sum-thread-tree-false-root
スレッドのにせの根に使われます (@pxref{Loose Threads})。@code{nil} だっ
たら、代わりに表題を使います。ディフォルトは @samp{> } です。

@item gnus-sum-thread-tree-single-indent
@vindex gnus-sum-thread-tree-single-indent
単一のメッセージのスレッドに使われます。@code{nil} だったら、代わりに表
題を使います。ディフォルトは @samp{} です。

@item gnus-sum-thread-tree-vertical
@vindex gnus-sum-thread-tree-vertical
縦線の描画に使われます。ディフォルトは @samp{| } です。

@item gnus-sum-thread-tree-indent
@vindex gnus-sum-thread-tree-indent
行下げ (indenting) に使われます。ディフォルトは @samp{  } です。

@item gnus-sum-thread-tree-leaf-with-other
@vindex gnus-sum-thread-tree-leaf-with-other
兄弟がいる葉っぱに使われます。ディフォルトは @samp{+-> } です。

@item gnus-sum-thread-tree-single-leaf
@vindex gnus-sum-thread-tree-single-leaf
兄弟がいない葉っぱに使われます。ディフォルトは @samp{\-> } です。
@end table

@item T
記事が元記事であれば何も表示せず、そうでない場合はたくさんの空白です (そ
れより後のものをすべて画面の外に追い出してしまいます)。
@item [
開き括弧。普通は @samp{[} ですが、養子記事には @samp{<} にすることができ
ます (@pxref{Customizing Threading})。
@item ]
閉じ括弧。普通は @samp{]} ですが、養子記事には @samp{>} にすることができ
ます。
@item >
それぞれのスレッドのレベルに対して一つの空白。
@item <
(20 - スレッドレベル) 個の空白。
@item U
未読。@xref{Read Articles}.

@item R
この紛らわしい名前指定子は「第二の印」(the secondary mark) です。この印
は記事がすでに返答済みのものか、キャッシュされたものか、あるいは保存され
たものかを表します。@xref{Other Marks}.

@item i
数値としてのスコア (@pxref{Scoring})。
@item z
@vindex gnus-summary-zcore-fuzz
これは、zcore でディフォルトのレベルよりも上であれば @samp{+} で、ディフォ
ルトのレベルよりも下であれば @samp{-} です。
@code{gnus-summary-default-score} との差
が @code{gnus-summary-zcore-fuzz} よりも小さいと、この仕様は使われません。
@item V
スレッド全体のスコア。
@item x
@code{Xref}.
@item D
@code{Date}.
@item d
@code{DD-MM} 様式による @code{Date}。
@item o
@var{YYYYMMDD}@code{T}@var{HHMMSS} 様式による @code{Date}。
@item M
@code{Message-ID}.
@item r
@code{References}.
@item t
現在の副スレッドの記事の数。この仕様を使うと概略バッファーの生成が幾分遅
くなります。
@item e
記事に子記事があると、@samp{=} (@code{gnus-not-empty-thread-mark}) が表
示されます。
@item P
行数。
@item O
ダウンロードの印。
@item *
カーソルを (最初のコロンの後ろの代わりに) 置く場所。
@item &user-date;
経過時間の様式。いろいろな様式
が @code{gnus-user-date-format-alist} で定義されています。
@item u
利用者定義指定子。フォーマット文字列の中の次の文字は英字でなければなりま
せん。これにより Gnus は関数 @code{gnus-user-format-function-}@var{x} を
呼び出しますが、ここで @var{x} は @samp{%u} の次の文字です。関数には現在
の記事のヘッダーが引数として渡されます。関数は文字列を返さなければなりま
せん。それは他の概略指定と同様に概略に挿入されます。
@end table

@samp{%(} と @samp{%)} の間にあるテキストは、そこにマウスがあるとき
に @code{gnus-mouse-face} でハイライトされます。そういう領域は一つだけで
す。

@samp{%U} (状態), @samp{%R} (返答済み), @samp{%z} (zcore) の扱いには気を
付ける必要があります。効率のために、Gnus はこれらの文字がどの桁に現れる
かを計算し、『ハード・コード』します。これは、可変長の仕様の後では、これ
らは意味を持たないということです。まぁ、さすがに逮捕はされないでしょうが、
概略バッファーは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。(でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。)

この制限は将来の版では無くなるかもしれません。

@node To From Newsgroups
@subsection To From Newsgroups
@cindex To
@cindex Newsgroups

いくつかのグループ (特にアーカイブグループ) では @code{From} ヘッダーは
あまり興味を引きません。そこのすべての記事はあなたによって書かれたもので
すから。代わりに、@code{To} や @code{Newsgroups} ヘッダーの情報を表示す
るためには、三つのことを決める必要があります: どの情報を集めるか, どこに
表示するか, いつ表示するか。

@enumerate
@item
@vindex gnus-extra-headers
追加のヘッダーの情報は @code{gnus-extra-headers} により制御されます。こ
れはヘッダーのシンボルのリストです。例えば:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups X-Newsreader))
@end lisp

これによって Gnus はこれらの三つのヘッダーを取得しようとし、後の容易な取
得のためにヘッダー構造に保存します。

@item
@findex gnus-extra-header
これらの追加のヘッダーの値は @code{gnus-extra-function} 関数を通じて取得
することができます。これは @code{X-Newsreader} ヘッダーを使う書式行の仕
様です:

@example
"%~(form (gnus-extra-header 'X-Newsreader))@@"
@end example

@item
@vindex gnus-ignored-from-addresses
@code{gnus-ignored-from-addresses} 変数はいつ @samp{%f} 概略行仕様
が @code{To}, @code{Newsreader} や @code{From} ヘッダーを返せば良いかを
決めます。この変数は正規表現、または判断するための関数です。もしこれ
が @code{From} ヘッダーの内容に合致すると、
@code{To} や @code{Newsreader} ヘッダーの値が代わりに使われます。

それらの @code{From} フィールドが入れ替わっている記事と、普通の記事を区
別するために、概略行の @code{To} または @code{Newsgroups} ヘッダーに、あ
る文字列が前置されます。その文字列はディフォルトで、@code{To} に
は @samp{-> } が、@code{Newsgroups} には @samp{=> } が使われますが、
@code{gnus-summary-to-prefix} と @code{gnus-summary-newsgroup-prefix} に
よって、それらの文字列をカスタマイズすることができます。
@end enumerate

@vindex nnmail-extra-headers
関連する変数は @code{nnmail-extra-headers} で、
overview (@acronym{NOV}) ファイルを作る際にいつ追加のヘッダーを含めるか
を制御します。古い overview ファイルがある場合は、この変数を変更した後に
サーバーバッファーに @kbd{^} で入って適切なメールサーバー (例え
ば nnml) で @kbd{g} を押し、再生成する必要があります。

@vindex gnus-summary-line-format
さらに @code{gnus-summary-line-format} 変数の @code{%n} 仕様
を @code{%f} 仕様に変更することによってデータを表示するように、Gnus に指
示する必要があります。

要約すると、普通は以下のようなものを @file{~/.gnus.el} に置くことになり
ます:

@lisp
(setq gnus-extra-headers
      '(To Newsgroups))
(setq nnmail-extra-headers gnus-extra-headers)
(setq gnus-summary-line-format
      "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n")
(setq gnus-ignored-from-addresses
      "Your Name Here")
@end lisp

(上記の値は Gnus のディフォルト値です。あなたの役に立つように変えてくだ
さい。)

ニュース管理人、またはニュース管理人を説得してサポートの追加をしてもらお
うと思っている利用者のみなさんへのご注意:

@acronym{NOV} ファイルの生成を制御できるメールグループでは、上記のことは
たいていの場合役立ちます。しかし、管理人を説得して (特に INN の普通の実
装において) 以下のものを @file{overview.fmt} ファイルの最後に追加しても
うらうことができれば、メールグループでの追加ヘッダーのようにそれを使うこ
とができます。

@example
Newsgroups:full
@end example

@node Summary Buffer Mode Line
@subsection 概略バッファーのモード行

@vindex gnus-summary-mode-line-format
概略のモード行の様式も変更することができます (@pxref{Mode Line
Formatting})。@code{gnus-summary-mode-line-format} を何でも好きなものに
設定してください。ディフォルトは @samp{Gnus: %%b [%A] %Z} です。

以下はあなたが遊ぶことのできる要素たちです:

@table @samp
@item G
グループ名。
@item p
接頭語を取り除いた名前。
@item A
現在の記事番号。
@item z
現在の記事スコア。
@item V
Gnus バージョン。
@item U
そのグループでの未読記事の数。
@item e
概略バッファーに表示されていない未読記事の数。
@item Z
未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記事があ
る場合の @samp{<%U(+%e) more>}、および未読記事のみの場合
の @samp{<%U more>} のどちらかです。
@item g
短縮グループ名。例えば、@samp{rec.arts.anime} は @samp{r.a.anime} に短縮
されます。
@item S
現在の記事の表題。
@item u
利用者定義の仕様 (@pxref{User-Defined Specs})。
@item s
現在のスコアファイルの名前 (@pxref{Scoring})。
@item d
保留記事の数 (@pxref{Unread Articles})。
@item t
可視印付き記事の数 (@pxref{Unread Articles})。
@item r
その概略バッファーで記事を読んだ結果、既読の印が付いた記事の数。
@item E
スコアファイルによって抹消された記事の数。
@end table

@node Summary Highlighting
@subsection 概略のハイライト

@table @code
@item gnus-visual-mark-article-hook
@vindex gnus-visual-mark-article-hook
このフックは記事を選択した後に実行されます。これは何らかの方法で記事をハ
イライトするように意図されています。@code{gnus-visual} が @code{nil} だっ
たら実行されません。

@item gnus-summary-update-hook
@vindex gnus-summary-update-hook
このフックは概略行が変化したときに呼ばれます。
@code{gnus-visual} が @code{nil} だったら実行されません。

@item gnus-summary-selected-face
@vindex gnus-summary-selected-face
これは概略バッファーでの現在の記事をハイライトするために使われるフェー
ス (もしくは、ある人たちが「フォント」と呼ぶようなもの) です。

@item gnus-summary-highlight
@vindex gnus-summary-highlight
概略行はこの変数にしたがってハイライトされます。この変数は要素
が @code{(@var{form} . @var{face})} の形式のリストです。例えば、印付きの
記事を斜体、高いスコアの記事を太字にしたければ、この変数を次のように設定
することができます。

@lisp
(((eq mark gnus-ticked-mark) . italic)
 ((> score default) . bold))
@end lisp

ご想像のとおり、@var{form} が @code{nil} でない値を返すと、@var{face} が
その行に適用されます。
@end table

@node Summary Maneuvering
@section 概略間の移動
@cindex summary movement

すべての直接移動命令は数値接頭引数を受け付け、かなり期待どおりに動作する
でしょう。

これらの命令はどれも記事を選択しません。

@table @kbd
@item G M-n
@item M-n
@kindex M-n @r{(概略)}
@kindex G M-n @r{(概略)}
@findex gnus-summary-next-unread-subject
概略行の次の未読記事に移ります (@code{gnus-summary-next-unread-subject})。

@item G M-p
@itemx M-p
@kindex M-p @r{(概略)}
@kindex G M-p @r{(概略)}
@findex gnus-summary-prev-unread-subject
概略行の前の未読記事に移ります (@code{gnus-summary-prev-unread-subject})。

@item G g
@kindex G g @r{(概略)}
@findex gnus-summary-goto-subject
記事番号を尋ね、その記事を表示せずに、その概略行に行きま
す (@code{gnus-summary-goto-subject})。
@end table

Gnus が次のグループ移動することを確認するためにキー入力を求めた場合、
@kbd{C-n} キーと @kbd{C-p} キーを使うことによって、実際にグループバッファー
に戻らなくても、次に読むグループを探すことができます。

概略の移動に関連した変数:

@table @code
@vindex gnus-auto-select-next
@item gnus-auto-select-next
移動命令の一つ (@kbd{n} のような) を発したときに現在の記事の後に未読記事
が無いと、Gnus は次のグループに移動することをうながします。この変数
が @code{t} で次のグループが空っぽだったら、Gnus は概略モードを抜けてグ
ループバッファーに戻ります。この変数が @code{t} でも @code{nil} でもなけ
れば、Gnus はさらに次の未読記事があるグループを選択します。特別な場合と
して、この変数が @code{quietly} だったら、Gnus は確認をせずに次のグルー
プを選択します。この変数が @code{almost-quietly} だった場合は、グループ
の一番最後の記事を読んでいたときに限って同じことが起こります。最後に、も
しこの変数が @code{slightly-quietly} だったら、@kbd{Z n} 命令は確認をせ
ずに次のグループに移ります。@ref{Group Levels} も参照してください。

@item gnus-auto-select-same
@vindex gnus-auto-select-same
@code{nil} でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
しようとします。(「同じ」はここでは「大体同じ」という意味かもしれません。
詳細は @code{gnus-summary-gather-subject-limit} を見てくださ
い (@pxref{Customizing Threading})。) 同じ表題の記事が無いときは、最初の
未読記事に移動します。

この変数は、スレッド表示を行なっているときはあまり役に立たないでしょう。

@item gnus-summary-check-current
@vindex gnus-summary-check-current
これが @code{nil} ではない場合、すべての『未読』移動命令は、現在の記事が
未読だったら次 (もしくは前) の記事に移動しません。代わりに、それらは現在
の記事を選びます。

@item gnus-auto-center-summary
@vindex gnus-auto-center-summary
@code{nil} でないと、Gnus は概略バッファーでのポイントを常に真中に保ちま
す。これをすると、とてもこぎれいになりますが、遅いネットワークに接続して
いたり、この Emacs らしくない流儀が好きになれないのであれば、この変数
を @code{nil} にすることによって、普通の Emacs のスクロールにすることが
できます。これは概略バッファーの水平方向でポイントが真ん中になるようにす
る操作 (horizontal re-centering) も禁止してしまうので、非常に長いスレッ
ドを読むときは不便かもしれません。

この変数は数値でも構いません。その場合は、ウィンドウの先頭からその数の行
だけ下がった位置に常にポイントがあるように制御されます。

@item gnus-summary-stop-at-end-of-message
@vindex gnus-summary-stop-at-end-of-message
もし @code{nil} でなければ、@kbd{@key{SPC}} を叩いても次の記事に行かずに、
その記事の最後にとどまります。
@end table

@node Choosing Articles
@section 記事の選択
@cindex selecting articles

@menu
* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数
@end menu

@node Choosing Commands
@subsection 選択命令

以下の移動コマンドはどれも数値接頭引数を受け付けません。それらはすべて、
記事を選択して表示します。

新しい記事を取り込んだり、グループを再表示したいときは @ref{Exiting the
Summary Buffer} を参照してください。

@table @kbd
@item @key{SPC}
@kindex SPC @r{(概略)}
@findex gnus-summary-next-page
現在の記事、またはそれが既読だった場合は次の未読記事を選択しま
す (@code{gnus-summary-next-page})。

すでに記事ウィンドウを開いているときに再び @kbd{@key{SPC}} を押すと、そ
の記事はスクロールされます。これによって、ニュースグループ全体
を @kbd{@key{SPC}} だけで便利に通読することができます。
@xref{Paging the Article}.

@item G n
@itemx n
@kindex n @r{(概略)}
@kindex G n @r{(概略)}
@findex gnus-summary-next-unread-article
@c @icon{gnus-summary-next-unread}
次の未読記事に移動します (@code{gnus-summary-next-unread-article})。

@item G p
@itemx p
@kindex p @r{(概略)}
@findex gnus-summary-prev-unread-article
@c @icon{gnus-summary-prev-unread}
前の未読記事に移動します (@code{gnus-summary-prev-unread-article})。

@item G N
@itemx N
@kindex N @r{(概略)}
@kindex G N @r{(概略)}
@findex gnus-summary-next-article
次の記事に移動します (@code{gnus-summary-next-article})。

@item G P
@itemx P
@kindex P @r{(概略)}
@kindex G P @r{(概略)}
@findex gnus-summary-prev-article
前の記事に移動します (@code{gnus-summary-prev-article})。

@item G C-n
@kindex G C-n @r{(概略)}
@findex gnus-summary-next-same-subject
同じ表題の次の記事に移動します (@code{gnus-summary-next-same-subject})。

@item G C-p
@kindex G C-p @r{(概略)}
@findex gnus-summary-prev-same-subject
同じ表題の前の記事に移動します (@code{gnus-summary-prev-same-subject})。

@item G f
@itemx .
@kindex G f @r{(概略)}
@kindex . @r{(概略)}
@findex gnus-summary-first-unread-article
最初の未読記事に移動します (@code{gnus-summary-first-unread-article})。

@item G b
@item ,
@kindex G b @r{(概略)}
@kindex , @r{(概略)}
@findex gnus-summary-best-unread-article
最高スコアの未読記事に移動しま
す (@code{gnus-summary-best-unread-article})。接頭引数が与えられると、ディ
フォルトのスコアより大きいスコアを持つ最初の未読記事に移動します。

@item G l
@itemx l
@kindex l @r{(概略)}
@kindex G l @r{(概略)}
@findex gnus-summary-goto-last-article
直前に読んだ記事に移動します (@code{gnus-summary-goto-last-article})。

@item G o
@kindex G o @r{(概略)}
@findex gnus-summary-pop-article
@cindex history
@cindex article history
概略の履歴 (history) から最後の記事を一つ取り出して選択しま
す (@code{gnus-summary-pop-article})。この命令が上の命令と違うのは、
@kbd{l} が最後の二つの記事の間を移動するだけなのに対して、これは好きなだ
け前の記事を履歴から選び出すことができる点です。これに多少関係することに
ついて、@ref{Article Backlog} を参照してください (これらの命令をたくさん
使うのであれば)。

@item G j
@item j
@kindex j @r{(概略)}
@kindex G j @r{(概略)}
@findex gnus-summary-goto-article
記事番号か @code{Message-ID} を尋ね、それからその記事に行きま
す (@code{gnus-summary-goto-article})。
@end table

@node Choosing Variables
@subsection 選ぶための変数

記事の移動と選択に関連するいくつかの変数:

@table @code
@item gnus-auto-extend-newsgroup
@vindex gnus-auto-extend-newsgroup
この変数が @code{nil} でないと、すべての移動命令は、記事が概略バッファー
に表示されていない場合でも、前 (もしくは次) の記事に移動しようとします。
その際 Gnus はサーバーから記事を取得して、記事バッファーに表示します。

@item gnus-select-article-hook
@vindex gnus-select-article-hook
このフックは記事が選択されたときに常に呼ばれます。ディフォルト
は @code{nil} です。講読するそれぞれの記事をエージェントに保存させたい場
合は、このフックに @code{gnus-agent-fetch-selected-article} を追加すれば
良いでしょう。

@item gnus-mark-article-hook
@vindex gnus-mark-article-hook
@findex gnus-summary-mark-unread-as-read
@findex gnus-summary-mark-read-and-unread-as-read
@findex gnus-unread-mark
このフックは記事が選択されたときに常に呼ばれます。これは記事に既読の印を
付けるために使われることを意図しています。ディフォルト値
は @code{gnus-summary-mark-read-and-unread-as-read} で、ほとんどすべての
読んだ記事の印を @code{gnus-read-mark} に変更します。この関数に影響され
ない記事は、可視、保留、期限切れ消去可能記事だけです。未読記事に既読の印
を付けたいだけであれば、代わり
に @code{gnus-summary-mark-unread-as-read} を使うことができます。
@code{gnus-low-score-mark} や @code{gnus-del-mark} (など) の印はそのまま
残します。
@end table

@node Paging the Article
@section 記事のスクロール
@cindex article scrolling

@table @kbd
@item @key{SPC}
@kindex SPC @r{(概略)}
@findex gnus-summary-next-page
@kbd{@key{SPC}} を押すと、現在の記事を一ページ先にスクロールします。記事
の最後に行き着いた場合は次の記事を選択しま
す (@code{gnus-summary-next-page})。

@vindex gnus-article-boring-faces
@vindex gnus-article-skip-boring
@code{gnus-article-skip-boring} が非-@code{nil} で、かつ記事の残りに引用
と署名しか無い場合、それはスキップされ、代わりに次の記事が表示されます。
@code{gnus-article-boring-faces} で、つまらないと思うものをカスタマイズ
することができます。どんなにうんざりするものでも、@kbd{C-M-v} を使うこと
によって、手動で記事のページを見ることはできます。

@item @key{DEL}
@kindex DEL @r{(概略)}
@findex gnus-summary-prev-page
現在の記事を一ページ前にスクロールします (@code{gnus-summary-prev-page})。

@item @key{RET}
@kindex RET @r{(概略)}
@findex gnus-summary-scroll-up
現在の記事を一行先にスクロールします (@code{gnus-summary-scroll-up})。

@item M-@key{RET}
@kindex M-RET @r{(概略)}
@findex gnus-summary-scroll-down
現在の記事を一行後ろへスクロールします (@code{gnus-summary-scroll-down})。

@item A g
@itemx g
@kindex A g @r{(概略)}
@kindex g @r{(概略)}
@findex gnus-summary-show-article
@vindex gnus-summary-show-article-charset-alist
現在の記事を (再) 取得します (@code{gnus-summary-show-article})。もし接
頭引数が一つ与えられると、サーバーから来たままの完全な『生の』記事を表示
します。もし接頭引数が 2回与えられると (つまり @kbd{C-u C-u g'})、現在の
記事を取得しますが、記事をトリートメントする関数は実行しません。

@cindex charset, view article with different charset
接頭引数を与えると、手動で文字セットの操作を行なうことができます。
@kbd{C-u 0 g cn-gb-2312 @key{RET}} により、メッセージはあたか
も @code{cn-gb-2312} 文字セットでエンコードされたかのようにデコードされ
ます。以下のような設定を用意しておくと、@kbd{C-u 1 g} で同じ効果を得るこ
とができます。

@lisp
(setq gnus-summary-show-article-charset-alist
      '((1 . cn-gb-2312)
        (2 . big5)))
@end lisp

@item A <
@itemx <
@kindex < @r{(概略)}
@kindex A < @r{(概略)}
@findex gnus-summary-beginning-of-article
記事の最初までスクロールします。
(@code{gnus-summary-beginning-of-article})。

@item A >
@itemx >
@kindex > @r{(概略)}
@kindex A > @r{(概略)}
@findex gnus-summary-end-of-article
記事の最後までスクロールします (@code{gnus-summary-end-of-article})。

@item A s
@itemx s
@kindex A s @r{(概略)}
@kindex s @r{(概略)}
@findex gnus-summary-isearch-article
記事バッファーでインクリメンタルサーチ (isearch) を行ないま
す (@code{gnus-summary-isearch-article})。

@item h
@kindex h @r{(概略)}
@findex gnus-summary-select-article-buffer
記事バッファーを選択します (@code{gnus-summary-select-article-buffer})。
@end table

@node Reply Followup and Post
@section 返答、フォローアップ、投稿

@menu
* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::
@end menu

@node Summary Mail Commands
@subsection 概略でのメールの命令
@cindex mail
@cindex composing mail

メールメッセージを作成するための命令:

@table @kbd
@item S r
@item r
@kindex S r @r{(概略)}
@kindex r @r{(概略)}
@findex gnus-summary-reply
@c @icon{gnus-summary-mail-reply}
@c @icon{gnus-summary-reply}
現在の記事を書いた人に返答のメールを送ります (@code{gnus-summary-reply})。

@item S R
@itemx R
@kindex R @r{(概略)}
@kindex S R @r{(概略)}
@findex gnus-summary-reply-with-original
@c @icon{gnus-summary-reply-with-original}
現在の記事を書いた人に、元記事を含んだ返答のメールを出しま
す (@code{gnus-summary-reply-with-original})。この命令はプロセス/接頭引
数の習慣を使います。

@item S w
@kindex S w @r{(概略)}
@findex gnus-summary-wide-reply
現在の記事を書いた人に対して、広い返答 (wide reply) をしま
す (@code{gnus-summary-wide-reply})。「広い返答」とはヘッダー
の @code{To}, @code{From}, (もしくは @code{Reply-To}) と @code{Cc}) のす
べての人に返答をすることです。@code{Mail-Followup-To} があれば、代わりに
それが使われます。

@item S W
@kindex S W @r{(概略)}
@findex gnus-summary-wide-reply-with-original
現在の記事に元記事を含んだ広い返答のメールを送りま
す (@code{gnus-summary-wide-reply-with-original})。この命令はプロセス/接
頭引数の習慣を使います。ただし、受取人の決定には最初の記事のヘッダーだけ
を使います。

@item S L
@kindex S L @r{(概略)}
@findex gnus-summary-reply-to-list-with-original
メーリングリストで配信されたメッセージに返事をするとき、元のメッセージの
引用付きでそのメーリングリストに返信しま
す (@code{gnus-summary-reply-to-list-with-original})。

@item S v
@kindex S v @r{(概略)}
@findex gnus-summary-very-wide-reply
現在の記事を書いた人に対して、非常に広い返答 (very wide reply) をしま
す (@code{gnus-summary-very-wide-reply})。「非常に広い返答」とは、プロセ
ス/接頭引数で指定されたすべての記事のヘッダーの @code{To}, @code{From},
(もしくは @code{Reply-To}) と @code{Cc}) のすべての人に返答をすることで
す。この命令はプロセス/接頭引数の習慣を使います。

@item S V
@kindex S V @r{(概略)}
@findex gnus-summary-very-wide-reply-with-original
現在の記事に元記事を含んだ非常に広い返答のメールを送りま
す (@code{gnus-summary-very-wide-reply-with-original})。この命令はプロセ
ス/接頭引数の習慣を使います。

@item S B r
@kindex S B r @r{(概略)}
@findex gnus-summary-reply-broken-reply-to
現在の記事を書いた人に対して返答をしますが @code{Reply-To} フィールドは
無視します (@code{gnus-summary-reply-broken-reply-to})。メーリングリスト
がそのリストを指す @code{Reply-To} を過って設定するためにこれが必要なの
であれば、おそらくあなたは代わりに @code{broken-reply-to} グループパラメー
ターを設定する必要があります。そうすれば、ものごとは正しく働くようになる
でしょう。@xref{Group Parameters}.

@item S B R
@kindex S B R @r{(概略)}
@findex gnus-summary-reply-broken-reply-to-with-original
現在の記事を書いた人に対して元記事を含んだ返答をします
が @code{Reply-To} フィールドは無視しま
す (@code{gnus-summary-reply-broken-reply-to-with-original})。

@item S o m
@itemx C-c C-f
@kindex S o m @r{(概略)}
@kindex C-c C-f @r{(概略)}
@findex gnus-summary-mail-forward
@c @icon{gnus-summary-mail-forward}
誰か他の人に現在の記事を転送します (@code{gnus-summary-mail-forward})。
接頭引数が与えられない場合、メッセージ
は @code{message-forward-as-mime} およ
び @code{message-forward-show-mml} の値に従ったやり方で転送されます。接
頭引数が 1 だったら、デコードされたメッセージが直接埋め込まれた転送用の
バッファーが作られます。2 だったら rfc822 形式の @acronym{MIME} パートが
挿入されます。この場合、元のメッセージはデコードされません。3 ではデコー
ドされた rfc822 形式の @acronym{MIME} パートが挿入されます (実際に送信す
る際に再びエンコードされます)。接頭引数 4 では、1 の場合と同じ動作になり
ます。接頭引数がこれら以外の場合には、@code{message-forward-as-mime} の
値を一時的に反転して、接頭引数が与えられなかった場合と同じ動作を行ないま
す。ディフォルトでは、転送するメッセージをそのメールに埋め込み (インライ
ン) します。

@item S m
@itemx m
@kindex m @r{(概略)}
@kindex S m @r{(概略)}
@findex gnus-summary-mail-other-window
@c @icon{gnus-summary-mail-originate}
メールを作成します (@code{gnus-summary-mail-other-window})。ディフォルト
では現在のグループの投稿様式 (posting style) を使います。接頭引数が与え
られると、それは使いません。もし接頭引数が 1 だったら、どのグループの投
稿様式を使うかを尋ねます。

@item S i
@kindex S i @r{(概略)}
@findex gnus-summary-news-other-window
ニュースを作成します (@code{gnus-summary-news-other-window})。ディフォル
トでは現在のグループに投稿します。接頭引数が与えられると、現在のグループ
名は使われません。もし接頭引数が 1 だったら、どのグループに投稿するかを
尋ねます。

この関数は、たとえメールグループで使われたとしても、実際にはニュースの様
式を用意します。これは、メッセージを実際にはネットワーク経由で送らずに、
メールグループに「投稿」するのに便利です; それらは当のグループに単に直接
セーブされます。対応するバックエンドが投稿のためのメソッド (request-post
method) を持っていなければなりませんが。

@item S D b
@kindex S D b @r{(概略)}
@findex gnus-summary-resend-bounced-mail
@cindex bouncing mail
メールを送ったのに、何らかの理由 (アドレスの間違い、転送の不調) で戻って
きたときに、この命令を使って戻ってきたメールをもう一回送ることができま
す (@code{gnus-summary-resend-bonced-mail})。メールバッファーにそのメー
ルが現れて、そこでもう一度メールを送る前にヘッダーを編集することができま
す。この命令に接頭引数を与えると、戻ってきたメールが何か他のメールへの返
答であった場合に、Gnus はそのメールを取得して、それのヘッダーの精密調査
ができるように画面に表示しようとします。ま、これはとてもよく失敗しますけ
ど。

@item S D r
@kindex S D r @r{(概略)}
@findex gnus-summary-resend-message
上の命令と混同しないでください。@code{gnus-summary-resend-message} は現
在のメッセージを送る宛先のアドレスの入力を促して、その場所にメールを送り
ます。メッセージのヘッダーは変更されません---しかし @code{Resent-To},
@code{Resent-From} などの、たくさんのヘッダーが付け加えます。これは、(お
そらく) あなた自身を @code{To} 欄に書いた本人にもメールを送ってしまうと
いうことです。これは混乱を招くでしょう。ですから当然、あなたが本当に邪悪
な人でなければ、これは使わないでしょう。

この命令は主に、あなたがいくつかのメールアカウントを持っていて、自分自身
の違ったアカウントにメールを転送したいときに用いられます。(もしあなた
が @code{root} であり、@code{postmaster} でもあり、@code{root} 宛て
に @code{postmaster} へのメールを受け取った場合は、それ
を @code{postmaster} にも再送する必要があるかもしれません。秩序がなけれ
ばなりません! (Ordnung muss sein!))

この命令はプロセス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S D e
@kindex S D e @r{(概略)}
@findex gnus-summary-resend-message-edit
一つ前のコマンドに似ていますが、再送する前にあたかも新しいメッセージのよ
うに編集することができます。

@item S O m
@kindex S O m @r{(概略)}
@findex gnus-uu-digest-mail-forward
現在の一連の記事 (@pxref{Decoding Articles}) の要約を作り、メールでその
結果を送ります (@code{gnus-uu-digest-mail-forward})。この命令はプロセ
ス/接頭引数の習慣に従います (@pxref{Process/Prefix})。

@item S M-c
@kindex S M-c @r{(概略)}
@findex gnus-summary-mail-crosspost-complaint
@cindex crossposting
@cindex excessive crossposting
現在の記事の書き手に、過剰なクロスポストへの苦情のメールを送りま
す (@code{gnus-summary-mail-crosspost-complaint})。

@findex gnus-crosspost-complaint
この命令は、現在 Usenet に横行しているクロスポストの世界的流行に対して反
撃を行なう手段として提供されています。これは変
数 @code{gnus-crosspost-complaint} を序文にして返答を作成します。この命
令はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) に従い、それぞれの
メールを送る前に送信するかどうかの確認をします。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@node Summary Post Commands
@subsection 概略の投稿命令
@cindex post
@cindex composing news

ニュースの記事を投稿するための命令:

@table @kbd
@item S p
@itemx a
@kindex a @r{(概略)}
@kindex S p @r{(概略)}
@findex gnus-summary-post-news
@c @icon{gnus-summary-post-news}
投稿するための記事を作成します (@code{gnus-summary-post-news})。ディフォ
ルトでは現在のグループに投稿します。接頭引数が与えられると、現在のグルー
プ名は使われません。もし接頭引数が 1 だったら、代わりに別のどのグループ
に投稿するかを尋ねます。

@item S f
@itemx f
@kindex f @r{(概略)}
@kindex S f @r{(概略)}
@findex gnus-summary-followup
@c @icon{gnus-summary-followup}
現在の記事のフォローアップを投稿します (@code{gnus-summary-followup})。

@item S F
@itemx F
@kindex S F @r{(概略)}
@kindex F @r{(概略)}
@c @icon{gnus-summary-followup-with-original}
@findex gnus-summary-followup-with-original
元記事を取り込んで、現在の記事にフォローアップをしま
す (@code{gnus-summary-followup-with-original})。この命令はプロセス/接頭
引数の習慣を用います。

@item S n
@kindex S n @r{(概略)}
@findex gnus-summary-followup-to-mail
メールのメッセージを受け取っていたとしても、現在の記事のフォローアップを
ニュースに投稿しま
す (@code{gnus-summary-followup-to-mail})。この命令はプロセス/接頭引数の
習慣を用います。

@item S N
@kindex S N @r{(概略)}
@findex gnus-summary-followup-to-mail-with-original
メールのメッセージを受け取っていたとしても、元記事を引用して、現在の記事
のフォローアップをニュースに投稿しま
す (@code{gnus-summary-followup-to-mail-with-original}). この命令はプロ
セス/接頭引数の習慣を用います。

@item S o p
@kindex S o p @r{(概略)}
@findex gnus-summary-post-forward
現在の記事をニュースグループに転送しま
す (@code{gnus-summary-post-forward})。接頭引数が与えられない場合、メッ
セージは @code{message-forward-as-mime} およ
び @code{message-forward-show-mml} の値に従ったやり方で転送されます。接
頭引数が 1 だったら、デコードされたメッセージが直接埋め込まれた転送用の
バッファーが作られます。2 だったら rfc822 形式の @acronym{MIME} パートが
挿入されます。この場合、元のメッセージはデコードされません。3 ではデコー
ドされた rfc822 形式の @acronym{MIME} パートが挿入されます (実際に送信す
る際に再びエンコードされます)。接頭引数 4 では、1 の場合と同じ動作になり
ます。接頭引数がこれら以外の場合には、@code{message-forward-as-mime} の
値を一時的に反転して、接頭引数が与えられなかった場合と同じ動作を行ないま
す。ディフォルトでは、デコードされたメッセージが rfc822 形式
の @acronym{MIME} パートとして生成されます。

@item S O p
@kindex S O p @r{(概略)}
@findex gnus-uu-digest-post-forward
@cindex digests
@cindex making digests
現在の一連の記事を要約して、その結果をニュースグループに送りま
す (@code{gnus-uu-digest-post-forward})。この命令はプロセス/接頭引数の習
慣を用います。

@item S u
@kindex S u @r{(概略)}
@findex gnus-uu-post-news
@c @icon{gnus-uu-post-news}
ファイルを uuencode して分割し、それらを連続して投稿しま
す (@code{gnus-uu-post-news})。(@pxref{Uuencoding and Posting})。
@end table

また @xref{Header Commands, ,ヘッダー命令, message-ja, The Message
Manual}, にさらなる情報があります。

@node Summary Message Commands
@subsection 概略メッセージ命令

@table @kbd
@item S y
@kindex S y @r{(概略)}
@findex gnus-summary-yank-message
現在の記事を、すでに存在するメッセージ作成バッファーに貼り付けま
す (@code{gnus-summaryyank-message})。この命令は貼り付けたいメッセージバッ
ファーの入力を促し、プロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。

@item S A
@kindex S A @r{(概略)}
@findex gnus-summary-attach-article
現在の記事を、すでに存在するメッセージ作成バッファーに添付しま
す (@code{gnus-summary-attach-message})。もしそのようなバッファーが無い
ときは新しいものを作成します。このコマンドは、どのメッセージバッファーに
添付したいかを尋ねます。また、プロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。


+Attach the current article into an already existing Message
+composition buffer (@code{gnus-summary-attach-message}).  If no such
+buffer exists, a new one is created.  This command prompts for what
+message buffer you want to yank into, and understands the
+process/prefix convention (@pxref{Process/Prefix}).
@end table

@node Canceling and Superseding
@subsection 記事を取り消す
@cindex canceling articles
@cindex superseding articles

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなければ
なぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消す
ことができます。

@findex gnus-summary-cancel-article
@kindex C @r{(概略)}
@c @icon{gnus-summary-cancel-article}
取り消したい記事を見つけてください (取り消すことができるのは自分の記事だ
けです。変なことは試さないでください)。そして @kbd{C} か @kbd{S c} を押
してください (@code{gnus-summary-cancel-article})。あなたの記事が取り消
されます---世界中の機械があなたの記事を取り消します。この命令はプロセ
ス/接頭引数の習慣を用います (@pxref{Process/Prefix})。

しかし注意して欲しいのは、すべてのサイトが取り消しを扱っているわけではな
いことです。ですから、たいていのサイトが問題の記事を取り消しても、あちこ
ちであなたの記事は生き残るかもしれません。

Gnus は取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 @samp{a} を使ってくださ
い (@pxref{Symbolic Prefixes})。

Gnus は @code{Cancel-Lock} ヘッダー (@pxref{Canceling News,
,ニュースを取り消す, message-ja, The Message Manual}) を使って、あなただ
けがあなたのメッセージをキャンセルできるようにします。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、「代替」
(@dfn{superseding}) 記事を投稿して元記事を置き換えることができます。

@findex gnus-summary-supersede-article
@kindex S @r{(概略)}
元記事のところへ移動して、@kbd{S s} を押してくださ
い (@code{gnus-summary-supersede-article})。それを普通に送信する前に、記
事を好きなように編集することができます。

代替に関しても、取り消しと同じことが当てはまります。こちらの方がもっとよ
く当てはまるかもしれません: いくつかのサイトは代替を受け付けません。これ
らのサイトでは、ほとんど同じ記事を二回投稿したようになってしまいます。

もしさっき記事を投稿したばかりですぐに変更したくなった場合、記事が最初に
あなたのサイトに現れる前に取り消し/代替をするための巧妙な手段があります。
まず、投稿バッファー (@file{*sent ...*} のようになっています) に戻って
ください。そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーが
そのままあります。@code{Message-ID} ヘッダーを @code{Cancel} もしく
は @code{Supersedes} に変更してください。そして、いつもやっているように
単に @kbd{C-c C-c} を押して記事を送信してください。前の記事は取り消され
るか置き換えられるでしょう。

ちょっと覚えておいてください: 'supersede' (代替) という語の中に 'c' は無
いということを。

@node Delayed Articles
@section 遅延記事
@cindex delayed sending
@cindex send delayed

ときとして、あなたはメッセージの送信を先延ばしにしたいと思うことはありま
せんか。例えば、あなたが大切なだれかの誕生日を思い出すために、ちょうどそ
の日に届くメッセージを用意したいと思ったとしましょう。
@code{gnus-delay} パッケージはこれにうってつけです。設定は簡単です:

@lisp
(gnus-delay-initialize)
@end lisp

@findex gnus-delay-article
普段はメッセージを送信するのに Message モードで @kbd{C-c C-c} コマンドを
使いますよね。先延ばしにするには、代わりに @kbd{C-c C-j}
(@code{gnus-delay-article}) を使ってください。そうすると、どのくらい遅ら
せるかを尋ねてきます。可能な返事は次の通りです:

@itemize @bullet
@item
期間。整数と一つの文字で指定します。例えば @code{42d} は 42 日遅らせるこ
とを意味します。使うことができる文字は @code{m} (分)、@code{h} (時)、
@code{d} (日), @code{w} (週), @code{M} (月) および @code{Y} (年) です。

@item
日付。@code{YYYY-MM-DD} のような形式で指定します。メッセージの送信はその
日の特定の時刻 (ディフォルトは 8 時) まで遅らせられます。
@code{gnus-delay-default-hour} も参照してください。

@item
時刻。am/pm を含まない 24 時間制の、@code{hh:mm} の形式で与えます。送信
されるのは今日のその時刻ですが、すでにその時刻を過ぎてしまっていた場合は
翌日のその時刻になります。ですから、朝の 10 時に @code{11:15} を指定した
場合は 1時間15分後に送信されることになります。しかし @code{9:20} を指定
した場合は翌日の時刻を意味します。
@end itemize

@code{gnus-delay-article} の動作は、以下の数個の変数に影響されます:

@table @code
@item gnus-delay-default-hour
@vindex gnus-delay-default-hour
特定の日付を指定した場合に、メッセージがその日の何時に送信されるかを与え
ます。可能な値は 0 から 23 までの整数です。

@item gnus-delay-default-delay
@vindex gnus-delay-default-delay
ディフォルトの遅延を与える文字列です。前述のどんな形式でも可能です。

@item gnus-delay-group
@vindex gnus-delay-group
遅延記事は、ドラフトサーバーのこのグループに期限が来るまで保管されます。
たぶんあなたはこれを変更する必要は無いでしょう。ディフォルトの値
は @code{"delayed"} です。

@item gnus-delay-header
@vindex gnus-delay-header
それぞれの記事が送信される日時はヘッダーに記録されます。この変数はヘッダー
名の文字列です。たぶんあなたはこれを変更する必要は無いでしょう。ディフォ
ルトの値は @code{"X-Gnus-Delayed"} です。
@end table

送信の先延ばしはこんなふうに行なわれます: @code{gnus-delay-article} コマ
ンドで、あなたはどのくらい遅らせるかを指定します。Gnus はメッセージを送
信する日時を計算して @code{X-Gnus-Delayed} ヘッダーに記録し、そのメッセー
ジを @code{nndraft:delayed} グループに納めます。

@findex gnus-delay-send-queue
そして、あなたが新着ニュースを取得しようとするときはいつも、Gnus は送信
する期限に達した記事をそのグループで探して、それらを送信します。これには
関数 @code{gnus-delay-send-queue} が使われます。ディフォルトではこの関数
は @code{gnus-get-new-news-hook} に追加されますが、もちろんあなたはこれ
を変更することができます。おそらくあなたは、ドラフトの送信にデーモンを使
いたいと思うのではないでしょうか? それには、デーモンに関
数 @code{gnus-delay-send-queue} を実行せよ、と言うだけで良いのです。

@table @code
@item gnus-delay-initialize
@findex gnus-delay-initialize
ディフォルトではこの関数
は @code{gnus-delay-send-queue} の @code{gnus-get-new-news-hook} への追
加を行ないます。ですが、これは第二オプション引数 @code{no-check} を受け
付けます。もしそれが非-@code{nil} だった
ら @code{gnus-get-new-news-hook} は変更されません。第一オプション引数は
無視されます。

例えば @code{(gnus-delay-initialize nil t)} は何もしないことを意味します。
あなたは遅延記事の送信にデーモンを使いたいのでしょうね。でも、それを設定
することを忘れないでくださいね。:-)
@end table

@kbd{C-c C-j} で記事を遅延させると Message モードは自動的に現在時刻
で @code{"Date"} ヘッダーを付加します。おそらく多くの場合、代わりにその
メッセージを送信した時刻を @code{"Date"} ヘッダーに反映させたいでしょう。
そのためには @code{message-draft-headers} から @code{Date} を削除してく
ださい。

@node Marking Articles
@section 記事に印を付ける
@cindex article marking
@cindex article ticking
@cindex marks

記事に付けられる印はいくつかあります。

記事の「購読度」(うひょーっ、何てすらばやしい造語だ!) を決定する印があり
ます。英字でない文字が一般に「未読」を意味するのに対して、英字の印は一般
に「既読」を意味します。

加えて、購読度に影響しない印もあります。

@ifinfo
これらの印を操作する過剰なくらいの命令があります:
@end ifinfo

@menu
* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方
@end menu

@node Unread Articles
@subsection 未読記事

以下の印は何らかの方法で記事に未読の (ような) 印を付けます。

@table @samp
@item !
@vindex gnus-ticked-mark
可視記事 (ticked) として印を付けます (@code{gnus-ticked-mark})。

「可視記事」とは常に可視状態である記事のことです。おもしろいと思う記事が
あった場合や、読むのを先に延ばしたいときや、後で返答をしたいときに、普通
は可視印を付けます。しかし、記事は期限切れ消去されることもあります (ニュー
スサーバー上の記事を消去するのはニュースサーバーのソフトウェアで、
Gnus 自体は可視記事を期限切れ消去しません) ので、永遠に記事を保存してお
きたい場合は、その記事を永続にする必要があります (@pxref{Persistent
Articles})。

@item ?
@vindex gnus-dormant-mark
保留として印を付けます (@code{gnus-dormant-mark})。

「保留記事」はフォローアップがあったときにだけ概略バッファーに現れます。
フォローアップが無いときも表示させたいときは、@kbd{/ D} 命令を使ってくだ
さい (@pxref{Limiting})。それ以外は (見えるかどうかは別にして)、可視記
事 (ticked) と似たようなものです。

@item @key{SPC}
@vindex gnus-unread-mark
未読として印を付けます (@code{gnus-unread-mark})。

「未読記事」は今までまったく読まれていない記事のことです。
@end table

@node Read Articles
@subsection 既読記事
@cindex expirable mark

以下のすべての印は記事に既読の印を付けます。

@table @samp
@item r
@vindex gnus-del-mark
利用者が手動で @kbd{d} 命令もしくはそれに類する手段を使って、既読の印を
付けた記事です (@code{gnus-del-mark})。

@item R
@vindex gnus-read-mark
実際に読まれた記事 (@code{gnus-read-mark})。

@item O
@vindex gnus-ancient-mark
前回のセッションで既読の印を付けて、今は「古く」なってしまった記事。

@item K
@vindex gnus-killed-mark
削除された印 (@code{gnus-killed-mark})。

@item X
@vindex gnus-kill-file-mark
削除ファイルによって削除の印が付いた記
事 (@code{gnus-kill-file-mark})。

@item Y
@vindex gnus-low-score-mark
低すぎるスコアのために既読の印が付いた記
事 (@code{gnus-low-score-mark})。

@item C
@vindex gnus-catchup-mark
キャッチアップによって既読の印が付いた記
事 (@code{gnus-catchup-mark})。

@item G
@vindex gnus-canceled-mark
取り消された記事 (@code{gnus-canceled-mark})。

@item Q
@vindex gnus-sparse-mark
まばらに参照された記事 (@code{gnus-sparse-mark})。
@xref{Customizing Threading}.

@item M
@vindex gnus-duplicate-mark
重複抑制により既読の印の付いた記事 (@code{gnus-duplicate-mark})。
@xref{Duplicate Suppression}.
@end table

これらのすべての印は、本当にただ記事が既読として印が付いていることを意味
するだけです。適応スコアリングをしたときには違ったように解釈されますけれ
ど。

もう一つ、特別な印があります:

@table @samp
@item E
@vindex gnus-expirable-mark
期限切れ消去可能として印の付いた記事 (@code{gnus-expirable-mark})。

記事を「期限切れ消去可能」として印を付ける (もしくは、自動的にそのように
印を付ける) ことは、普通のグループではあまり意味がありません---利用者は
ニュース記事の期限による削除を制御していません。しかし、例えばメールグルー
プでは、「期限切れ消去可能」として印の付いた記事は、いつでも Gnus によっ
て削除されることがあります。
@end table

@node Other Marks
@subsection 他の印
@cindex process mark
@cindex bookmarks

記事が読まれたかどうかには関係しない印がいくつかあります。

@itemize @bullet
@item
現在の記事にしおりを挟むことができます。あなたは猫のおしっこの習慣に関す
る長い論文を読んでいて、それを読み終わる前に晩ご飯を食べに家に帰らなけれ
ばならなかったとしましょう。そんなとき、記事にしおりを挟むことができます。
次にその記事に出くわすと、Gnus はそのしおりのところへ移動するでしょう。
@xref{Setting Marks}.

@item
@vindex gnus-replied-mark
返信したかフォローアップした (つまり、答えた) すべての記事には、二桁目
に @samp{A} の印が付きます (@code{gnus-replied-mark})。

@item
@vindex gnus-forwarded-mark
転送したすべての記事には、二桁目に @samp{F} の印が付きま
す (@code{gnus-forwarded-mark})。

@item
@vindex gnus-cached-mark
記事キャッシュに貯められている記事は、二桁目に @samp{*} の印が付きま
す (@code{gnus-replied-mark})。@xref{Article Caching}.

@item
@vindex gnus-saved-mark
(何らかの方法によって; 必ずしも宗教的というわけではなく) 『救済された』
(原文は saved==保存された) 記事は、二桁目に @samp{S} の印が付きま
す (@code{gnus-saved-mark})。

@item
@vindex gnus-unseen-mark
まだ Gnus で読まれたことがない記事は、二桁目に @samp{.} の印が付きま
す (@code{gnus-unseen-mark})。

@item
@vindex gnus-downloaded-mark
Gnus エージェント (@pxref{Agent Basics}) を使っているとき、記事
は unplugged (ネットワークから切り離されている状態) で見るためにダウンロー
ドされるかもしれません。@samp{%O} の仕様を使っていると、それらの記事には
その仕様に @samp{+} の印が付きます。(変数 @code{gnus-downloaded-mark} で
どの文字を使うかを制御します。)

@item
@vindex gnus-undownloaded-mark
Gnus エージェント (@pxref{Agent Basics}) を使っているとき、いくつかの記
事はダウンロードされていないかもしれません。Unplugged (ネットワークから
切り離されている状態) ではそのような記事を見ることができません。
@samp{%O} の仕様を使っていると、それらの記事にはその仕様に @samp{-} の印
が付きます。(変数 @code{gnus-undownloaded-mark} でどの文字を使うかを制御
します。)

@item
@vindex gnus-downloadable-mark
Gnus エージェント (@pxref{Agent Basics}) はいくつかの記事を自動的にダウ
ンロードしますが、自動的にダウンロードされない記事にもダウンロードのため
の明示的な印を付けることは可能です。そのような明示的に印が付けられた記事
には、最初の桁に @samp{%} の印が付きます。(変
数 @code{gnus-downloadable-mark} でどの文字を使うかを制御します。)

@item
@vindex gnus-not-empty-thread-mark
@vindex gnus-empty-thread-mark
@samp{%e} の仕様が使われると、スレッドがあるかどうかの印
が @code{gnus-not-empty-thread-mark} また
は @code{gnus-empty-thread-mark} によって、三桁目に付きます。

@item
@vindex gnus-process-mark
最後に「プロセス印」があります (@code{gnus-process-mark})。いろいろな種
類の命令が、プロセス印があるとそれに対して実行されます。例え
ば @kbd{X u} (@code{gnus-uu-decode-uu}) は、プロセス印の付いたすべての記
事を uudecode して表示します。プロセス印の付いた記事は二桁目
に @samp{#} があります。
@end itemize

たいていのこれら『購読度と関係無い』印は、ディフォルトでは二桁目に現れる
ことに気付いたでしょう。では、キャッシュされていて、保存されていて、返答
した記事にプロセス印を付けた場合は、どうなるのでしょう?

たいしたことはありません。優先順位は次のようになっています: プロセ
ス → キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入っ
ていて返答されていた場合、キャッシュ印が見えるだけで、返答済み印は見えま
せん。

@node Setting Marks
@subsection 印を付ける
@cindex setting marks

すべての印を付けるための命令は、数値接頭引数を受け付けます。

@table @kbd
@item M c
@itemx M-u
@kindex M c @r{(概略)}
@kindex M-u @r{(概略)}
@findex gnus-summary-clear-mark-forward
@cindex mark as unread
現在の記事から、すべての購読度に関する印を消去しま
す (@code{gnus-summary-clear-mark-forward})。要するに、記事に未読の印を
付けます。

@item M t
@itemx !
@kindex ! @r{(概略)}
@kindex M t @r{(概略)}
@findex gnus-summary-tick-article-forward
現在の記事に可視記事の印を付けま
す (@code{gnus-summary-tick-article-forward})。@xref{Article Caching}.

@item M ?
@itemx ?
@kindex ? @r{(概略)}
@kindex M ? @r{(概略)}
@findex gnus-summary-mark-as-dormant
現在の記事に保留記事の印を付けま
す (@code{gnus-summary-mark-as-read-forward})。@xref{Article Caching}.

@item M d
@itemx d
@kindex M d @r{(概略)}
@kindex d @r{(概略)}
@findex gnus-summary-mark-as-read-forward
現在の記事に既読の印を付けま
す (@code{gnus-summary-mark-as-read-forward})。

@item D
@kindex D @r{(概略)}
@findex gnus-summary-mark-as-read-backward
現在の記事に既読の印を付け、前の行にポイントを移動しま
す (@code{gnus-summary-mark-as-read-backward})。

@item M k
@itemx k
@kindex k @r{(概略)}
@kindex M k @r{(概略)}
@findex gnus-summary-kill-same-subject-and-select
現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未読記事
を選択します (@code{gnus-summary-kill-same-subject-and-select})。

@item M K
@itemx C-k
@kindex M K @r{(概略)}
@kindex C-k @r{(概略)}
@findex gnus-summary-kill-same-subject
現在の記事と同じ表題を持つすべての記事を既読として印を付けま
す (@code{gnus-summary-kill-same-subject})。

@item M C
@kindex M C @r{(概略)}
@findex gnus-summary-catchup
@c @icon{gnus-summary-catchup}
すべての未読記事に既読の印を付けます (@code{gnus-summary-catchup})。

@item M C-c
@kindex M C-c @r{(概略)}
@findex gnus-summary-catchup-all
グループのすべての記事に---可視記事や保留記事でさえも、既読の印を付けま
す (@code{gnus-summary-catchup-all})。

@item M H
@kindex M H @r{(概略)}
@findex gnus-summary-catchup-to-here
現在のグループの、現在位置とそれ以前の記事を既読として印を付けま
す (@code{gnus-summary-catchup-to-here})。

@item M h
@kindex M h @r{(概略)}
@findex gnus-summary-catchup-from-here
現在のグループの、現在位置とそれ以降の記事を既読として印を付けま
す (@code{gnus-summary-catchup-from-here})。

@item C-w
@kindex C-w @r{(概略)}
@findex gnus-summary-mark-region-as-read
ポイントとマークの間の記事に既読の印を付けま
す (@code{gnus-summary-mark-region-as-read})。

@item M V k
@kindex M V k @r{(概略)}
@findex gnus-summary-kill-below
ディフォルトのスコア (もしくは数値接頭引数) よりも低いスコアの記事を削除
します。

@item M e
@itemx E
@kindex M e @r{(概略)}
@kindex E @r{(概略)}
@findex gnus-summary-mark-as-expirable
現在の記事を期限切れ消去可能として印を付けま
す (@code{gnus-summary-mark-as-expirable})。

@item M b
@kindex M b @r{(概略)}
@findex gnus-summary-set-bookmark
現在の記事にしおりを設定します (@code{gnus-summary-set-bookmark})。

@item M B
@kindex M B @r{(概略)}
@findex gnus-summary-remove-bookmark
現在の記事のしおりを削除します (@code{gnus-summary-remobe-bookmark})。

@item M V c
@kindex M V c @r{(概略)}
@findex gnus-summary-clear-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つ記事
のすべての印を消去します (@code{gnus-summary-clar-above})。

@item M V u
@kindex M V u @r{(概略)}
@findex gnus-summary-tick-above
ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持つすべ
ての記事に可視印を付けます (@code{gnus-summary-tick-above})。

@item M V m
@kindex M V m @r{(概略)}
@findex gnus-summary-mark-above
印の入力を促し、ディフォルトのスコア (もしくは数値接頭引数) よりも大きな
スコアを持つすべての記事にその印を付けま
す (@code{gnus-summary-mark-above})。
@end table

@vindex gnus-summary-goto-unread
変数 @code{gnus-summary-goto-unread} は印が付けられた後にどのような動作
がなされるかを決定します。もし @code{nil} でないと、ポイントは次/前の未
読記事に移動します。もし @code{nil} であると、ポイントは一行上か下に行く
だけです。特別な場合として、この変数が @code{never} であると、すべての印
を付ける命令と (@kbd{@key{SPC}} のような) 他の命令は次の記事が未読であろ
うが無かろうが次の記事に移動します。ディフォルトは @code{t} です。

@node Generic Marking Commands
@subsection 一般的な印を付けるコマンド

記事に可視の印を付けるコマンド (@kbd{!}) が、(印を付けた後で) 次の記事に
移動することを望む人がいます。次の未読記事に移動してもらいたい人もいます。
さらに、現在の記事に留まっていてもらいたい人もいるでしょう。そして、前の
(未読の) 記事に行って欲しい人がいるとはまだ聞いたことはありませんが、そ
うしたいと思う人も間違いなくいると思います。

この五つの動作を五つの違った印付け命令と掛け算すると、どの命令が何をすべ
きかの非常に複雑な変数の組を持つことになります。

この窮地を脱するために、Gnus はこれらすべての違ったことをする命令を提供
します。これらは概略バッファーの @kbd{M M} マップにあります。すべてを見
るためには @kbd{M M C-h} を入力してください---このマニュアルで一覧を出す
には多過ぎます。

これらの命令を直接使うことはできますが、ほとんどの利用者は概略モードのキー
マップを交換する方を好むでしょう。例えば、@kbd{!} 命令に次の未読記事の代
わりに次の記事に移動して欲しいとすると、このようなことができます:

@lisp
(add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
(defun my-alter-summary-map ()
  (local-set-key "!" 'gnus-summary-put-mark-as-ticked-next))
@end lisp

@noindent
もしくは、

@lisp
(defun my-alter-summary-map ()
  (local-set-key "!" "MM!n"))
@end lisp

@node Setting Process Marks
@subsection プロセス印を付ける
@cindex setting process marks

プロセス印は概略バッファーに @code{#} として表示され、他のコマンドで処理
させる記事に印を付けるために使われます。例えば、四つの記事に印を付けてか
ら @kbd{*} コマンドを使うと、Gnus はそれら四つの記事をキャッシュに入れま
す。詳しくは @ref{Process/Prefix} をどうぞ。

@table @kbd
@item M P p
@itemx #
@kindex # @r{(概略)}
@kindex M P p @r{(概略)}
@findex gnus-summary-mark-as-processable
現在の記事にプロセス印を付けま
す (@code{gnus-summary-mark-as-processable})。

@item M P u
@itemx M-#
@kindex M P u @r{(概略)}
@kindex M-# @r{(概略)}
@findex gnus-summary-unmark-as-processable
もし現在の記事にプロセス印があれば取り除きま
す (@code{gnus-summary-unmark-as-processable})。

@item M P U
@kindex M P U @r{(概略)}
@findex gnus-summary-unmark-all-processable
すべての記事からプロセス印を取り除きま
す (@code{gnus-summary-unmark-all-processable})。

@item M P i
@kindex M P i @r{(概略)}
@findex gnus-uu-invert-processable
プロセス印の付いている記事とそうでない記事を逆にしま
す (@code{gnus-uu-mark-by-regexp})。

@item M P R
@kindex M P R @r{(概略)}
@findex gnus-uu-mark-by-regexp
正規表現に合致する @code{Subject} ヘッダーを持つ記事に印を付けま
す (@code{gnus-uu-mark-by-regexp})。

@item M P G
@kindex M P G @r{(概略)}
@findex gnus-uu-unmark-by-regexp
正規表現に合致する @code{Subject} ヘッダーを持つ記事から印を削除しま
す (@code{gnus-uu-unmark-by-regexp})。

@item M P r
@kindex M P r @r{(概略)}
@findex gnus-uu-mark-region
領域にある記事に印を付けます (@code{gnus-uu-mark-region})。

@item M P g
@kindex M P g @r{(概略)}
@findex gnus-uu-unmark-region
領域にある記事から印を削除します (@code{gnus-uu-unmark-region})。

@item M P t
@kindex M P t @r{(概略)}
@findex gnus-uu-mark-thread
現在のスレッド (または副スレッド) のすべての記事に印を付けま
す (@code{gnus-uu-mark-thread})。

@item M P T
@kindex M P T @r{(概略)}
@findex gnus-uu-unmark-thread
現在のスレッド (または副スレッド) のすべての記事から印を取り除きま
す (@code{gnus-uu-unamrk-thread})。

@item M P v
@kindex M P v @r{(概略)}
@findex gnus-uu-mark-over
接頭引数よりも大きなスコアを持つすべての記事に印を付けま
す (@code{gnus-uu-mark-over})。

@item M P s
@kindex M P s @r{(概略)}
@findex gnus-uu-mark-series
現在の一連の記事に印を付けます (@code{gnus-uu-mark-series})。

@item M P S
@kindex M P S @r{(概略)}
@findex gnus-uu-mark-sparse
すでにいくつか印の付いた記事を持つ一連の記事群すべてに印を付けま
す (@code{gnus-uu-mark-sparse})。

@item M P a
@kindex M P a @r{(概略)}
@findex gnus-uu-mark-all
一連の記事が出てくる順番にそれに属するすべての記事に印を付けま
す (@code{gnus-uu-mark-all})。

@item M P b
@kindex M P b @r{(概略)}
@findex gnus-uu-mark-buffer
バッファーのすべての記事を現れている順番に印を付けま
す (@code{gnus-uu-mark-buffer})。

@item M P k
@kindex M P k @r{(概略)}
@findex gnus-summary-kill-process-mark
現在のプロセス印をスタックに積んで、すべての記事を無印にしま
す (@code{gnus-summary-kill-process-mark})。

@item M P y
@kindex M P y @r{(概略)}
@findex gnus-summary-yank-process-mark
スタックから前回のプロセス印を取り出して、それを復元しま
す (@code{gnus-summary-yank-process-mark})。

@item M P w
@kindex M P w @r{(概略)}
@findex gnus-summary-save-process-mark
現在のプロセス印をスタックに積みま
す (@code{gnus-summary-save-process-mark})。
@end table

そして、記事の本文の内容に基づいてプロセス印を付けるやり方については、
@ref{Searching for Articles} の @kbd{&} 命令を参照してください。

@node Limiting
@section 制限をする
@cindex limiting

現在グループにある記事の一部だけを表示するように概略バッファーを制限でき
れば便利なことがあります。多くの制限命令が持つ効果は、概略バッファーから
少し (もしくは多く) の記事を削除することです。

制限命令はサーバーからすでに取得された記事の一部分に作用します。これらの
命令はサーバーに追加の記事を要求しません。

@table @kbd
@item / /
@itemx / s
@kindex / / @r{(概略)}
@findex gnus-summary-limit-to-subject
概略バッファーをいくつかの表題と合致するものだけに制限しま
す (@code{gnus-summary-limit-to-subject})。接頭引数が与えられると、合致
する記事を除外します。

@item / a
@kindex / a @r{(概略)}
@findex gnus-summary-limit-to-author
概略バッファーを何人かの著者に合致するものだけに制限しま
す (@code{gnus-summary-limit-to-author})。接頭引数が与えられると、合致す
る記事を除外します。

@item / R
@kindex / R @r{(概略)}
@findex gnus-summary-limit-to-recipient
概略バッファーをいくつかの受信者に合致する記事だけに制限しま
す (@code{gnus-summary-limit-to-recipient})。接頭引数が与えられると、合
致する記事を除外します。

@item / A
@kindex / A @r{(概略)}
@findex gnus-summary-limit-to-address
概略バッファーを、その From、To または Cc ヘッダーの内容が与えられたアド
レスと合致する記事に制限します (@code{gnus-summary-limit-to-address})。
接頭引数が与えられると、合致する記事を除外します。

@item / S
@kindex / S @r{(概略)}
@findex gnus-summary-limit-to-singletons
概略バッファーを表示されているスレッドに属さない記事だけに制限しま
す (@code{gnus-summary-limit-to-singletons})。接頭引数が与えられると、表
示されているスレッドに属する記事だけに制限します。

@item / x
@kindex / x @r{(概略)}
@findex gnus-summary-limit-to-extra
「追加」のヘッダーの一つに合致する記事に概略バッファーを制限しま
す (@pxref{To From Newsgroups}) (@code{gnus-summary-limit-to-extra})。接
頭引数が与えられると、合致する記事を除外します。

@item / u
@itemx x
@kindex / u @r{(概略)}
@kindex x @r{(概略)}
@findex gnus-summary-limit-to-unread
概略バッファーを既読の印が付いていない記事に制限しま
す (@code{gnus-summary-limit-to-unread})。接頭引数が与えられると、バッ
ファーを完全に未読記事のみに制限します。これは、可視と保留の記事は含まれ
ないということです。

@item / m
@kindex / m @r{(概略)}
@findex gnus-summary-limit-to-marks
印を尋ねて、その印が付いている記事に制限しま
す (@code{gnus-summary-limit-to-marks})。

@item / t
@kindex / t @r{(概略)}
@findex gnus-summary-limit-to-age
数値を尋ねて、概略バッファーをその日数より古い (もしくは同じ) 記事に制限
します (@code{gnus-summary-limit-to-age})。接頭引数が与えられると、その
数値の日よりも新しい記事に制限します。

@item / n
@kindex / n @r{(概略)}
@findex gnus-summary-limit-to-articles
概略バッファーを、接頭引数 @samp{n} で指定された次の @samp{n} 個の記事に
制限します。接頭引数が与えられないと、代わりにプロセス印が付いている記事
に制限します。(@code{gnus-summary-limit-to-articles})。

@item / w
@kindex / w @r{(概略)}
@findex gnus-summary-pop-limit
前の制限をスタックから取り出して、復元しま
す (@code{gnus-summary-pop-limit})。接頭引数を与えられると、すべての制限
をスタックから取り出します。

@item / .
@kindex / . @r{(概略)}
@findex gnus-summary-limit-to-unseen
概略バッファーをまだ読まれたことが無い記事に制限しま
す (@code{gnus-summary-limit-to-unseen})。

@item / v
@kindex / v @r{(概略)}
@findex gnus-summary-limit-to-score
@c 原文が変; see the function definition of `gnus-summary-limit-to-score'.
概略バッファーを、与えたスコアと同じか、それより大きなスコアを持つ記事に
制限します (@code{gnus-summary-limit-to-score})。

@item / p
@kindex / p @r{(概略)}
@findex gnus-summary-limit-to-display-predicate
概略バッファーを @code{display} グループパラメーターの述語を満足させるよ
うに制限します (@code{gnus-summary-limit-to-display-predicate})。この述
語に関する詳細は @ref{Group Parameters} を参照してください。

@item / r
@kindex / r @r{(概略)}
@findex gnus-summary-limit-to-replied
概略バッファーを返信した記事だけに制限しま
す (@code{gnus-summary-limit-to-replied})。接頭引数が与えられると、返信
した記事以外の記事に制限します。

@item / E
@itemx M S
@kindex M S @r{(概略)}
@kindex / E @r{(概略)}
@findex gnus-summary-limit-include-expunged
すべての消去された記事を制限に含めま
す (@code{gnus-summary-limit-include-expunged})。

@item / D
@kindex / D @r{(概略)}
@findex gnus-summary-limit-include-dormant
すべての保留記事を制限に含めま
す (@code{gnus-summary-limit-include-dormant})。

@item / *
@kindex / * @r{(概略)}
@findex gnus-summary-limit-include-cached
すべてのキャッシュに入っている記事を制限に含めま
す (@code{gnus-summary-limit-include-cached})。

@item / d
@kindex / d @r{(概略)}
@findex gnus-summary-limit-exclude-dormant
すべての保留記事を制限から除外しま
す (@code{gnus-summary-limit-exclude-dormant})。

@item / M
@kindex / M @r{(概略)}
@findex gnus-summary-limit-exclude-marks
すべての印付き記事を除外します (@code{gnus-summary-limit-exclude-marks})。

@item / T
@kindex / T @r{(概略)}
@findex gnus-summary-limit-include-thread
現在のスレッドのすべての記事を制限に含めま
す (@code{gnus-summary-limit-include-thread})。

@item / c
@kindex / c @r{(概略)}
@findex gnus-summary-limit-exclude-childless-dormant
子記事の無いすべての保留記事を制限から除外しま
す (@code{gnus-summary-limit-exclude-childless-dormant})。

@item / C
@kindex / C @r{(概略)}
@findex gnus-summary-limit-mark-excluded-as-read
すべての除外された未読の記事に既読の印を付けま
す (@code{gnus-summary-limit-mark-excluded-as-read})。接頭引数が与えられ
ると、可視と保留のみの印の記事も既読として印を付けます。

@item / b
@kindex / b @r{(概略)}
@findex gnus-summary-limit-to-bodies
概略バッファーを、ある正規表現に本文が合致する記事だけに制限しま
す (@code{gnus-summary-limit-to-bodies})。接頭引数が与えられると、制限を
逆にします (訳注: 合致しない記事だけに制限します)。合致するものを探すた
めにそれぞれの記事を取り込まなければならないので、このコマンドはとても遅
いです。

@item / h
@kindex / h @r{(概略)}
@findex gnus-summary-limit-to-headers
この前のコマンドに似ていますが、代わりにこれは、ある正規表現にヘッダーが
合致する記事だけに制限します (@code{gnus-summary-limit-to-headers})。
@end table

以下は制限命令ではありませんが、同様に接頭キー @kbd{/} を使います。

@table @kbd
@item / N
@kindex / N @r{(概略)}
@findex gnus-summary-insert-new-articles
すべての新しい記事を概略バッファーに挿入します。
@var{back-end}@code{-get-new-mail} が非-@code{nil} だったら、新しいメー
ルの到来を調べるということです。

@item / o
@kindex / o @r{(概略)}
@findex gnus-summary-insert-old-articles
すべての古い記事を概略バッファーに挿入します。数値の接頭引数が与えられる
と、その個数の記事を取り込みます。
@end table

@node Threading
@section スレッド
@cindex threading
@cindex article threading

Gnus はディフォルトで記事をスレッド表示します。「スレッドにする」とは、
ある記事への応答を応答した記事の直後に置く---階層的流儀で、ということで
す。

スレッドは記事の @code{References} 欄を調べることによって行なわれます。
理想的な世界では、これだけで木を完成させるのに十分なのですが、不運なこと
に @code{References} 欄はしばしば壊れているか、時には単に無いことがあり
ます。怪しげなニュースの伝搬は問題を悪化させるので、満足な結果を得るため
には他の検出法を採用しなければなりません。過剰な対策法は存在していて、そ
の恐るべき詳細は @ref{Customizing Threading} に詳しく書いてあります。

まず、概念の概観です:

@table @dfn
@item 根本 (root)
スレッドで一番頂点にある記事です；スレッドの最初の記事です。

@item スレッド (thread)
木のような記事の構成です。

@item 副スレッド (sub-thread)
木のような構造の (より) 小さな部分です。

@item 無束縛スレッド (loose threads)
記事の期限切れ消去や、根本がすでに前回のセッションで読まれたことにより概
略バッファーに表示されない、等の理由により、スレッドはしばしば根本を失い
ます。そのようなときには、普通は多くの副スレッドがあって、本当は一つのス
レッドに属しているのですが、根本にはつながっていない、ということになりま
す。こういうスレッドが無束縛スレッドと呼ばれています。

@item スレッド集め (thread gathering)
副スレッドを大きなスレッドに集めようとする試みです。

@item まばらスレッド (sparse threads)
そこではたぶんいくつかの記事が失われてしまったのだろうと『推測された』ス
レッドのことで、概略バッファーでは空行で表示されます。
@end table

@menu
* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令
@end menu

@node Customizing Threading
@subsection スレッドをカスタマイズする
@cindex customizing threading

@menu
* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう@dots{} でもあなたは間違っていた!
@end menu

@node Loose Threads
@subsubsection 無束縛スレッド
@cindex <
@cindex >
@cindex loose threads

@table @code
@item gnus-summary-make-false-root
@vindex gnus-summary-make-false-root
もし @code{nil} でないと、Gnus はすべてのつながっていない部分木を一つの
大きな木にして、頂上にみせかけの根本を作ります。(ちょっと待ってください。
頂上に根元 (root) ですって? ええ、そうなのです。) つながっていない部分木
は本当の根本が期限切れ消去されたか、前回のセッションで根本を読んだり削除
したときにできます。

本当のスレッドが無いときは、Gnus は何かでっち上げをする必要があります。
この変数は Gnus が使うべきごまかしの方法を示しています。値としてとること
ができる四つの候補があります。
@iftex
@iflatex
\gnusfigure{The Summary Buffer}{390}{
\put(0,0){\epsfig{figure=ps/summary-adopt,width=7.5cm}}
\put(445,0){\makebox(0,0)[br]{\epsfig{figure=ps/summary-empty,width=7.5cm}}}
\put(0,400){\makebox(0,0)[tl]{\epsfig{figure=ps/summary-none,width=7.5cm}}}
\put(445,400){\makebox(0,0)[tr]{\epsfig{figure=ps/summary-dummy,width=7.5cm}}}
}
@end iflatex
@end iftex

@cindex adopting articles
@table @code
@item 養子 (adopt)
Gnus は孤児になった記事群の最初のものを親にします。この親はすべての他の
記事を養子にします。それらの養子記事は、標準の角括弧 (@samp{[]}) の代わ
りに、先の尖った括弧 (@samp{<>}) で印が付けられます。これがディフォルト
の手段です。

@item みせかけ (dummy)
@vindex gnus-summary-dummy-line-format
@vindex gnus-summary-make-false-root-always
Gnus は親のふりをするみせかけの概略行を作ります。このみせか
けの行はどの本当の記事にも対応しないので、それを選択することは、
みせかけの記事の後の最初の本当の記事を選択をするだけになります。
みせかけの根本の様式を指定するために、
@code{gnus-summary-dummy-line-format} が使われます。これはたっ
た一つだけのフォーマットの仕様を受け付けます: それは @samp{S} で、
記事の表題です (@pxref{Formatting Variables})。たとえ集めるもの
が無くても、すべてのスレッドにみせかけの根本を持たせたい場合は、
@code{gnus-summary-make-false-root-always} を @code{t} に設定し
てください。

@item 空 (empty)
Gnus は実際にはどの記事も親にはせず、最初の孤児を除いてすべての孤児の表
題欄を単に空のままにします。(実際は @code{gnus-summary-same-subject} を
表題として使います (@pxref{Summary Buffer Format})。)

@item none
まったくどの記事も親にしません。スレッドを集めて、単に順繰りに表示するだ
けです。

@item nil
無束縛スレッドを集めません。
@end table

@item gnus-summary-gather-subject-limit
@vindex gnus-summary-gather-subject-limit
無束縛スレッドは記事の表題を比較することによって集められます。もしこの変
数が @code{nil} であると、Gnus は無束縛スレッドを一つの大きな超スレッド
に集める前に、無束縛スレッドの表題が完全に一致することを要求します。これ
は、長い表題の行を切り落としてしまう間抜けなニュースリーダーが存在する現
状では、あまりに厳しい要求かもしれません。そう思うのなら、この変数を例え
ば 20 に設定して、表題の最初の 20 文字だけが一致することを要求するように
してください。この変数を本当に低い数値に設定すると、目についたもののすべ
てを Gnus が一つのスレッドに集めるのを見ることになるでしょう。それはあま
り有用ではありません。

@cindex fuzzy article gathering
この変数を特別な値 @code{fuzzy} に設定すると、Gnus は表題の文字列を大雑
把に比較するアルゴリズムを使います (@pxref{Fuzzy Matching})。

@item gnus-simplify-subject-fuzzy-regexp
@vindex gnus-simplify-subject-fuzzy-regexp
正規表現または正規表現のリストのどちらかです。表題の大雑把な比較を行なう
ときに、それらに合致する文字列を表題から取り除きます。

@item gnus-simplify-ignored-prefixes
@vindex gnus-simplify-ignored-prefixes
もし @code{gnus-summary-gather-subject-limit} を 10 くらいに低く設定した
ならば、この変数を何か意味のあるものに設定することを考えるでしょう:

@c Written by Michael Ernst <mernst@cs.rice.edu>
@lisp
(setq gnus-simplify-ignored-prefixes
      (concat
       "\\`\\[?\\("
       (mapconcat
        'identity
        '("looking"
          "wanted" "followup" "summary\\( of\\)?"
          "help" "query" "problem" "question"
          "answer" "reference" "announce"
          "How can I" "How to" "Comparison of"
          ;; ...
          )
        "\\|")
       "\\)\\s *\\("
       (mapconcat 'identity
                  '("for" "for reference" "with" "about")
                  "\\|")
       "\\)?\\]?:?[ \t]*"))
@end lisp

この正規表現に合致するすべての語は、二つの表題を比較する前に取り除かれま
す。

@item gnus-simplify-subject-functions
@vindex gnus-simplify-subject-functions
@code{nil} でないと、この変数
は @code{gnus-summary-gather-subject-limit} よりも優先されます。この変数
は @code{Subject} の文字列に反復して作用させて簡単にするための、関数のリ
ストである必要があります。

このリストに入れて役に立つような関数は次のようなものです:

@table @code
@item gnus-simplify-subject-re
@findex gnus-simplify-subject-re
前の方にある @samp{Re:} を取り除きます。

@item gnus-simplify-subject-fuzzy
@findex gnus-simplify-subject-fuzzy
大雑把な比較ができるように簡単にします。

@item gnus-simplify-whitespace
@findex gnus-simplify-whitespace
余分な空白 (whitespace) を取り除きます。

@item gnus-simplify-all-whitespace
@findex gnus-simplify-all-whitespace
すべての空白 (whitespace) を取り除きます。
@end table

もちろん、あなた自身の関数を書くこともできます。

@item gnus-summary-gather-exclude-subject
@vindex gnus-summary-gather-exclude-subject
無束縛スレッド集めは表題だけで行なわれるので、特
に @samp{} や @samp{(none)} のような良くある表題のときは、多くの間違いを
起こす可能性があります。この状況を少し良くするために、正規表
現 @code{gnus-summary-gather-exclude-subject} を使うことによって、集める
過程においてどんな表題を除外するかを指示することができます。ディフォルト
は @samp{^ *$\\|^(none)$} です。

@item gnus-summary-thread-gathering-function
@vindex gnus-summary-thread-gathering-function
Gnus は @code{Subject} 欄を調べることによってスレッドを集めます。これは、
結果的にまったく関係の無い記事が同じ『スレッド』に含まれるかもしれないこ
とを意味し、混乱の元です。代替手段は、合致するものを見つけるため
に @code{References} 欄にある @code{Message-ID} をすべて調べることです。
これは集められたスレッドが関係の無い記事をまったく含まないことを保証しま
すが、いかれたニュースリーダーで投稿した記事は適切に集められないというこ
とでもあります。ペストかコレラかの選択権はあなたにあります。

@table @code
@item gnus-gather-threads-by-subject
@findex gnus-gather-threads-by-subject
この関数はディフォルトの収集関数で、排他的に @code{Subject} を調べます。

@item gnus-gather-threads-by-references
@findex gnus-gather-threads-by-references
この関数は排他的に @code{References} 欄を調べます。
@end table

@code{References} によって集めることを試してみたいのであれば、次のように
することができます:

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp
@end table

@node Filling In Threads
@subsubsection スレッドを埋める

@table @code
@item gnus-fetch-old-headers
@vindex gnus-fetch-old-headers
もし @code{nil} でないと、Gnus は古いスレッドをもっと古いヘッダー、すな
わち既読の印が付いている記事のヘッダー、を取得することで構築しようとしま
す。できるだけ少ない概略行を表示したいけれど、できるだけたくさんの無束縛
スレッドをつなげておきたいときは、この変数を @code{some} か数値に設定し
てください。もし数値に設定したときは、それより多い追加のヘッダーは取得さ
れません。どちらの場合でも、古いヘッダーの取得は、使っているバックエンド
が overview ファイルを使っている場合だけ動作します。それらのバックエンド
は、普通は @code{nntp}, @code{nnspool}, @code{nnml} およ
び @code{nnmaildir} です。スレッドの根本がサーバーによって期限切れ消去さ
れてしまったら、Gnus はどうしようもないことも覚えておいてください。

この変数は @code{invisible} に設定することもできます。これは視覚的な効果
は何もありませんが、@kbd{A T} 命令をよく使うのであれば役に立つでしょ
う (@pxref{Finding the Parent})。

サーバーは、このいずれをも機能させるために @acronym{NOV} をサポートしな
ければなりません。

@cindex Gmane, gnus-fetch-old-headers
この機能は性能に深刻な影響を与え得ます。すべてのローカルにキャッシュされ
たヘッダーを無視するからです。記事を期限切れ消去しないサー
バー (例えば news.gmane.org) の、あるグループのためにそれを @code{t} に
設定すると、概略の生成がとても遅くなってしまいます。

@item gnus-fetch-old-ephemeral-headers
@vindex gnus-fetch-old-ephemeral-headers
@code{gnus-fetch-old-headers} と同じですが、一時ニュースグループのために
だけ使われます。

@item gnus-build-sparse-threads
@vindex gnus-build-sparse-threads
古いヘッダーを取得すると遅くなることがあります。この変数
を @code{some} に設定することによって、同じような低賃金の効果を得ること
ができます。そうすると、Gnus はすべての記事の完全な @code{References} 欄
を見て、同じスレッドに属する記事をつなごうとします。これは、記事がそのス
レッドから失われていると Gnus が推測したスレッド表示に「ずれ」を残すでしょ
う。(これらのずれは普通の概略行のように見えます。もしずれを選択すると、
Gnus はその当の記事を取得しようとします。) この変数が @code{t} であると、
Gnus はスレッドを補完するのに役立つかどうかを考慮せずに、すべての「ずれ」
を表示します。最後に、この変数が @code{more} であると、Gnus はどこにもつ
ながっていない枝葉のまばらな節を切り落としません。この変数はディフォルト
では @code{nil} です。

@item gnus-read-all-available-headers
@vindex gnus-read-all-available-headers
これはあまり役に立たない、いささかはっきりしない変数です。ニュースではな
いグループにおいて、概略バッファーを作るためにバックエンドが極めて多くの
ものを取り込まなければならず、しかも親記事を辿ることができない場合に使う
ことを想定しています。それは主にウェブに基づいたグループでの場合です。

そんなグループを使わない場合はディフォルトの @code{nil} のままにしておく
のが無難です。使いたい場合はグループ名に合致する正規表現か、すべてのグルー
プが対象になる @code{t} にしてください。
@end table

@node More Threading
@subsubsection もっとスレッドを

@table @code
@item gnus-show-threads
@vindex gnus-show-threads
この変数が @code{nil} であると、スレッドは作られず、ここにある残りのすべ
ての変数はまったく効果が無くなります。スレッド作りを止めるとグループの選
択が少し速くなりますが、記事を読むのがもっと遅く、不便になることは確実で
す。

@item gnus-thread-hide-subtree
@vindex gnus-thread-hide-subtree
これが @code{nil} でないと、すべてのスレッドは概略バッファーが生成された
ときに隠れます。

これは述語指示子であることもできます (@pxref{Predicate Specifiers})。利
用できる述語
は @code{gnus-article-unread-p} と @code{gnus-article-unseen-p} です。

これは例です:

@lisp
(setq gnus-thread-hide-subtree
      '(or gnus-article-unread-p
           gnus-article-unseen-p))
@end lisp

(これはかなりばかげた例です。なぜならすべてのまだ読まれたことが無い記事
は未読でもあるからなのですが、趣旨は汲み取ってください。)

@item gnus-thread-expunge-below
@vindex gnus-thread-expunge-below
この数値より少ない総スコア (@code{gnus-thread-score-function} で定義され
た関数を使って算出されます) を持つすべてのスレッドは消去されます。この変
数はディフォルトでは @code{nil} で、これはどのスレッドも消去されないとい
うことです。

@item gnus-thread-hide-killed
@vindex gnus-thread-hide-killed
スレッドを削除すると、この変数が @code{nil} でない場合、部分木は隠されま
す。

@item gnus-thread-ignore-subject
@vindex gnus-thread-ignore-subject
ときどき誰かがスレッドの途中で表題を変更することがあります。この変数
が @code{nil} でないと (これがディフォルトですが)、表題の変更は無視され
ます。もし @code{nil} だと、表題の変更をすると別のスレッドになります。

@item gnus-thread-indent-level
@vindex gnus-thread-indent-level
これは、それぞれの副スレッドがどれくらい字下げ (indent) されるべきかを決
める数値です。ディフォルトは 4 です。

@item gnus-sort-gathered-threads-function
@vindex gnus-sort-gathered-threads-function
とりわけメーリングリストでは、ときとして手元にメールが到着する順番は必ず
しもメーリングリストに到着した順番と同じでは無いことがあります。その結果、
副スレッドをディフォルトの @code{gnus-thread-sort-by-number} で並べ換え
ると、応答の方がそれの元記事より先に現れてしまうことがあります。グルー
プパラメーターや適切なフッ
ク (例えば @code{gnus-summary-generate-hook}) でこの変数を代わりの値 (例
えば @code{gnus-thread-sort-by-date}) に設定することによって、そのような
場合に、より論理的な副スレッドの順番を生成することができます。
@end table

@node Low-Level Threading
@subsubsection 低レベルにおけるスレッド作成

@table @code
@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
すべてのヘッダーを解析する前に実行されるフックです。

@item gnus-alter-header-function
@vindex gnus-alter-header-function
この変数の値が @code{nil} ではなくて関数であると、ヘッダー構造 (訳注: 記
事の主要なヘッダーの内容を効率良く保持するための Lisp オブジェクト) を変
更するために呼ばれます。関数は記事ヘッダーのベクトル (訳注: すなわちヘッ
ダー構造) とともに呼ばれ、それが何らかの方法で変更されます。例え
ば @code{Message-ID} を体系的な方法で (接頭語などを付け加えることによっ
て) 変更してしまうメールからニュースへのゲートウェイがある場合、この変数
を設定することによって、その @code{Message-ID} を元の意味のあるものに戻
すことができます。これは一つの例です:

@lisp
(setq gnus-alter-header-function 'my-alter-message-id)

(defun my-alter-message-id (header)
  (let ((id (mail-header-id header)))
    (when (string-match
           "\\(<[^<>@@]*\\)\\.?cygnus\\..*@@\\([^<>@@]*>\\)" id)
      (mail-header-set-id
       (concat (match-string 1 id) "@@" (match-string 2 id))
       header))))
@end lisp

@quotation
訳注: 取得した記事の @code{Message-ID} 欄から、@samp{@@} の前に付加され
た @samp{cygnus.} で始まる文字列を取り除きます。
@end quotation
@end table

@node Thread Commands
@subsection スレッドの命令
@cindex thread commands

@table @kbd
@item T k
@itemx C-M-k
@kindex T k @r{(概略)}
@kindex C-M-k @r{(概略)}
@findex gnus-summary-kill-thread
現在のスレッド (または副スレッド) のすべての記事に既読の印を付けま
す (@code{gnus-summary-kill-thread})。もし接頭引数が正であると、代わりに
すべての印を取り除きます。接頭引数が負であると、代わりに記事を可視にしま
す。

@item T l
@itemx C-M-l
@kindex T l @r{(概略)}
@kindex C-M-l @r{(概略)}
@findex gnus-summary-lower-thread
現在のスレッド (または副スレッド) のスコアを下げま
す (@code{gnus-summary-lower-thread})。

@item T i
@kindex T i @r{(概略)}
@findex gnus-summary-raise-thread
現在のスレッド (または副スレッド) のスコアを上げま
す (@code{gnus-summary-raise-thread})。

@item T #
@kindex T # @r{(概略)}
@findex gnus-uu-mark-thread
プロセス印を現在のスレッド (または副スレッド) に付けま
す (@code{gnus-uu-mark-thread})。

@item T M-#
@kindex T M-# @r{(概略)}
@findex gnus-uu-unmark-thread
現在のスレッド (または副スレッド) からプロセス印を取り除きま
す (@code{gnus-uu-unmark-thread})。

@item T T
@kindex T T @r{(概略)}
@findex gnus-summary-toggle-threads
スレッド表示を切り替えます (@code{gnus-summary-toggle-threads})。

@item T s
@kindex T s @r{(概略)}
@findex gnus-summary-show-thread
もしあれば、現在の記事の下に隠れているスレッドを表示しま
す (@code{gnus-summary-show-thread})。

@item T h
@kindex T h @r{(概略)}
@findex gnus-summary-hide-thread
現在のスレッド (または副スレッド) を隠しま
す (@code{gnus-summary-hide-thread})。

@item T S
@kindex T S @r{(概略)}
@findex gnus-summary-show-all-threads
すべての隠されているスレッドを表示しま
す (@code{gnus-summary-show-all-threads})。

@item T H
@kindex T H @r{(概略)}
@findex gnus-summary-hide-all-threads
すべてのスレッドを隠します (@code{gnus-summary-hide-all-threads})。

@item T t
@kindex T t @r{(概略)}
@findex gnus-summary-rethread-current
現在の記事のスレッドをもう一度作り直しま
す (@code{gnus-summary-rethread-current})。これは概略バッファーがスレッ
ド表示されていないときでも動作します。

@item T ^
@kindex T ^ @r{(概略)}
@findex gnus-summary-reparent-thread
現在の記事を印付きの (もしくは前の) 記事の子記事にしま
す (@code{gnus-summary-reparent-thread})。

@item T M-^
@kindex T M-^ @r{(概略)}
@findex gnus-summary-reparent-children
現在の記事を印付きの記事の親記事にしま
す (@code{gnus-summary-reparent-children})。
@end table

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付けま
す。

@table @kbd
@item T n
@kindex T n @r{(概略)}
@itemx C-M-f
@kindex C-M-f @r{(概略)}
@itemx M-down
@kindex M-down @r{(概略)}
@findex gnus-summary-next-thread
次のスレッドに移動します (@code{gnus-summary-next-thread})。

@item T p
@kindex T p @r{(概略)}
@itemx C-M-b
@kindex C-M-b @r{(概略)}
@itemx M-up
@kindex M-up @r{(概略)}
@findex gnus-summary-prev-thread
前のスレッドに移動します (@code{gnus-summary-prev-thread})。

@item T d
@kindex T d @r{(概略)}
@findex gnus-summary-down-thread
スレッドを下ります (@code{gnus-summary-down-thread})。

@item T u
@kindex T u @r{(概略)}
@findex gnus-summary-up-thread
スレッドを登ります (@code{gnus-summary-up-thread})。

@item T o
@kindex T o @r{(概略)}
@findex gnus-summary-top-thread
スレッドの頂上に移動します (@code{gnus-summary-top-thread})。
@end table

@vindex gnus-thread-operation-ignore-subject
スレッドを作成するときに表題を無視すると、当然ながらいくつかの違った表題
があるスレッドが出来上がります。そし
て @kbd{T k} (@code{gnus-summary-kill-thread}) のような命令を発するとき
に、全体のスレッドを削除するのではなく、現在の記事と同じ表題を持つ部分だ
けを削除したいときがあるかもしれません。もしこの発想が良いと思うのであれ
ば、@code{gnus-thread-operation-ignore-subject} をいじってみてください。
これが @code{nil} でないと (それがディフォルトですが)、スレッドの命令を
実行しているときに表題は無視されます。これが @code{nil} だったら、同じス
レッドにある異なる表題を持つ記事は、そのとき行なう操作の対象に含まれませ
ん。この変数が @code{fuzzy} であると、大雑把な比較によって等しいと判定さ
れる表題を持つ記事だけが対象に含まれます (@pxref{Fuzzy Matching})。

@node Sorting the Summary Buffer
@section 並べ替え

@findex gnus-thread-sort-by-total-score
@findex gnus-thread-sort-by-date
@findex gnus-thread-sort-by-score
@findex gnus-thread-sort-by-subject
@findex gnus-thread-sort-by-author
@findex gnus-thread-sort-by-recipient
@findex gnus-thread-sort-by-number
@findex gnus-thread-sort-by-random
@vindex gnus-thread-sort-functions
@findex gnus-thread-sort-by-most-recent-number
@findex gnus-thread-sort-by-most-recent-date
概略でスレッドの表示を使っているのであれば、
@code{gnus-thread-sort-functions} を設定することによってスレッドを並べ替
えることができます。この変数の値は単独の関数、関数のリスト、または関数
と @code{(関数でないもの)} の要素を含むリストであることができます。

ディフォルトでは並べ替えは記事番号に基づいて行なわれます。すでに用意され
ている並べ替え述語関数は @code{gnus-thread-sort-by-number},
@code{gnus-thread-sort-by-author}, @code{gnus-thread-sort-by-recipient},
@code{gnus-thread-sort-by-subject},
@code{gnus-thread-sort-by-date},
@code{gnus-thread-sort-by-score},
@code{gnus-thread-sort-by-most-recent-number},
@code{gnus-thread-sort-by-most-recent-date},
@code{gnus-thread-sort-by-random} およ
び @code{gnus-thread-sort-by-total-score} です。

それぞれの関数は二つのスレッドをとり、最初のスレッドがもう一方より先に並
べ替えられるべきであれば @code{nil} でない値を返します。実際の並べ替えは、
普通それぞれのスレッドの根本だけを調べることによって行なわれることに気を
付けてください。ただし @code{gnus-thread-sort-by-most-recent-number} お
よび @code{gnus-thread-sort-by-most-recent-date} は、この規則に従いませ
ん。

二つ以上の関数を使う場合、並べ替えの第一の鍵はリストの最後の関数でなけれ
ばなりません。並べ替え関数のリストのなるべく先頭に、おそらく常
に @code{gnus-thread-sort-by-number} を含めておくべきでしょう。これは、
他の並べ替えの基準が等しいスレッドが、記事番号の登り順に表示されることを
保証します。

スコアの逆順、表題、そして最後に番号、の順に並べ替えたいのであれば、次の
ようにできます:

@lisp
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-number
        gnus-thread-sort-by-subject
        (not gnus-thread-sort-by-total-score)))
@end lisp

最大のスコアを持つスレッドが、最初に概略バッファーに表示されます。スレッ
ドが同じスコアの場合は、英字順に並び替えられます。同じスコアと表題を持つ
スレッドは番号で並べ替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並べ替えたいのであれば、次のようにできます:

@lisp
(setq gnus-thread-sort-functions
      '((not gnus-thread-sort-by-number)
        gnus-thread-sort-by-score))
@end lisp

ディフォルトでは、スレッドはそのサブスレッドととも
に @code{gnus-thread-sort-functions} の値にしたがってソートされますが、
@code{gnus-subthread-sort-functions} をカスタマイズすることによって、サ
ブスレッドをソートする順序を独自に定義することができます。例えば概略バッ
ファー上で、親スレッドはスコアの高い順から低い順にソート、しかしサブスレッ
ドはスコアとは無関係に古いものから新しいものへの順で時系列にソートされた
ままにしておく、というようなことができます。

@vindex gnus-thread-score-function
変数 @code{gnus-thread-score-function} (ディフォルトは @code{+}) に設定
されている関数は、スレッドの総スコアを計算するために用いられます。役立つ
関数は @code{max}, @code{min}, もしくは二乗、もしくはあなたの好奇心をく
すぐるような何かでしょう。

@findex gnus-article-sort-functions
@findex gnus-article-sort-by-date
@findex gnus-article-sort-by-most-recent-date
@findex gnus-article-sort-by-score
@findex gnus-article-sort-by-subject
@findex gnus-article-sort-by-author
@findex gnus-article-sort-by-random
@findex gnus-article-sort-by-number
@findex gnus-article-sort-by-most-recent-number
何か変な理由でスレッド表示を使っていないのなら、変
数 @code{gnus-article-sort-functions} をいじくる必要があります。これ
は @code{gnus-thread-sort-functions} と非常に似ていますが、記事の比較に
は少々違った関数を使います。使用可能な並べ替え述語関数
は @code{gnus-article-sort-by-number},
@code{gnus-article-sort-by-author},
@code{gnus-article-sort-by-subject}, @code{gnus-article-sort-by-date},
@code{gnus-article-sort-by-random} およ
び @code{gnus-article-sort-by-score} です。

スレッドを使っていない概略の表示を表題で並べ替えたいのであれば、次のよう
なことをすることができます:

@lisp
(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-article-sort-by-subject))
@end lisp

@code{gnus-parameters} を介することによって、グループによって異なる並べ
替えを定義することができます。@xref{Group Parameters}.

@node Asynchronous Fetching
@section 非同期記事取得
@cindex asynchronous article fetching
@cindex article pre-fetch
@cindex pre-fetch

遠くにある @acronym{NNTP} サーバーからニュースを取得していると、ネットワー
クの遅延が記事を読むことを嫌な仕事にしてしまうかもしれません。@kbd{n} を
押してから次の記事が現れるまで、しばらく待たなければなりませんものね。ど
うして前の記事を読んでいる間に Gnus が先行して記事を取得してくれないので
しょうか? なぜできないんでしょう、本当に。

まず警告しておきましょう。非同期で記事を取得、特に Gnus がそれを行なう場
合には、いくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くて、あなたは
それを読むことには興味が無いとしましょう。Gnus はこのことはわからないの
で、先行して記事 2 を取得します。あなたは記事 3 を読むことにしますが、
Gnus は記事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、Gnus はサーバーに二つ (二まで数えてください) の
接続を張ります。これはあまり良いことではないと考える人もいるでしょうが、
私には実際の代替手段が見つからないのです。余分な接続を立ち上げるためには
いくばくかの時間がかかるので、Gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先行取得を使わないときよりも、あなたのマシンと @acronym{NNTP} サー
バー間の接続にもっと負荷をかけることになるでしょう。サーバー自身にももっ
と負荷がかかるようになります---余分な記事の要求と、余分な接続によって。

はい、本当はこのようなことをすべきで無いことがこれで分かったでしょ
う@dots{} 本当にそうしたいと思わない限りは。

@vindex gnus-asynchronous
やり方です: @code{gnus-asynchronous} を @code{t} に設定してください。そ
れ以外の諸々のことは自動的に行なわれます。

@vindex gnus-use-article-prefetch
@code{gnus-use-article-prefetch} を設定することによって、どれくらいの記
事を先に取得するべきかを操作することができます。これはディフォルトで
は 30 で、グループの記事を読んでいるときに、バックエンドが次の 30 通の記
事を先行取得するということです。この変数が @code{t} であると、バックエン
ドは取得できるすべての記事を際限なく先行取得しようとします。これ
が @code{nil} であると、先行取得は行なわれません。

@vindex gnus-async-prefetch-article-p
@findex gnus-async-unread-p
おそらく先行取得をしたくない記事がいくつかあるでしょう---例えば既読記事
です。変数 @code{gnus-async-prefetch-article-p} は記事が先に取得されるか
どうかを制御します。この変数に設定される関数は、問題の記事を先行取得する
のであれば @code{nil} でない値を返さなければなりません。ディフォルトの関
数は @code{gnus-async-unread-p} で、これは既読記事には @code{nil} を返し
ます。この関数は記事のデータ構造を唯一の引数として呼ばれます。

例えば、100 行よりも短い未読記事だけを先に取得したいのであれば、次のよう
にできます:

@lisp
(defun my-async-short-unread-p (data)
  "Return non-nil for short, unread articles."
  (and (gnus-data-unread-p data)
       (< (mail-header-lines (gnus-data-header data))
          100)))

(setq gnus-async-prefetch-article-p 'my-async-short-unread-p)
@end lisp

これらの関数は何度も何度も呼ばれるので、Gnus を遅くしすぎないように、短
く簡潔であるのが好ましいです。このようなものをバイトコンパイルするのは、
おそらく良い着想でしょう。

@vindex gnus-async-post-fetch-function
@findex gnus-html-prefetch-images
記事を先行取得した後に、この @code{gnus-async-post-fetch-function} が呼
ばれます。そのときバッファーは取り込んだ記事の領域に狭められています。有
用な値は @code{gnus-html-prefetch-images} で、これはその記事が参照する画
像を先行取得および保存して、その記事を読むときにそれらの取得を待たなくて
も良いようにします。@acronym{HTML} メッセージが外部参照の画像を持ってい
るときに便利です。

@vindex gnus-prefetched-article-deletion-strategy
記事は非同期バッファーから遅かれ早かれ削除されなければなりません。
@code{gnus-prefetched-article-deletion-strategy} はいつ記事を削除するか
を指定します。これは以下の要素を含むリストです:

@table @code
@item read
記事が読まれたときに削除します。

@item exit
グループを抜けたときに記事を削除します。
@end table

ディフォルトの値は @code{(read exit)} です。
@c
@c @vindex gnus-use-header-prefetch
@c @code{gnus-use-header-prefetch} が @code{nil} でないと、次のグループ
@c から記事を先に取得します。

@node Article Caching
@section 記事のキャッシュ
@cindex article caching
@cindex caching

@emph{非常に} 遅い @acronym{NNTP} 接続を使っているのならば、記事をキャッ
シュすることを考えても良いでしょう。それをすると、それぞれの記事はあなた
のホームディレクトリーの下にローカルに溜められます。もう感付いたかもしれ
ませんが、これは i ノードを非常に速く食いつぶすだけでなく、
@emph{巨大な} ディスクスペースを食う可能性があります。それはあなたにウォッ
カの中で泳ぐようなめまいを起こさせるでしょう。

でも注意深く使われれば、それは記事を保存する、より楽な方法になり得ます。

@vindex gnus-use-long-file-name
@vindex gnus-cache-directory
@vindex gnus-use-cache
キャッシュを実行させるには @code{gnus-use-cache} を @code{t} に設定して
ください。ディフォルトでは、すべての可視または保留として印の付いている記
事はローカルのキャッシュ (@code{gnus-cache-directory}) に複写されます。
このキャッシュが平らな構造か階層的であるかは、通常通り、変
数 @code{gnus-use-long-file-name} で制御されます。

可視記事か保留記事を再選択した場合は、サーバーの代わりにキャッシュから取
得されます。キャッシュにある記事は期限切れ消去されないので、記事をそれら
が属するところに居続けさせている間、それらを保存する方法としてこれは役立
つかもしれません。保存したいすべての記事に保留の印を付けるだけで、後は心
配無用です。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょうか。

@vindex gnus-cache-remove-articles
@vindex gnus-cache-enter-articles
記事をキャッシュに入れたりキャッシュから削除することは、変
数 @code{gnus-cache-enter-articles} およ
び @code{gnus-cache-remove-articles} によって制御されます。これらは両方
ともシンボルのリストです。前者はディフォルトで
は @code{(ticked dormant)} で、可視記事と保留記事はキャッシュに入れられ
ます。後者はディフォルトでは @code{(read)} で、既読の印が付いた記事はキャッ
シュから削除されます。おそらくこれら二つのリストに含まれるシンボル
は @code{ticked}, @code{dormant}, @code{unread} および @code{read} でしょ
う。

@findex gnus-jog-cache
それでは、大規模な記事の取得と格納は、どこで関係してくるのでしょうか。
@code{gnus-jog-cache} 命令は、すべての購読グループに対して、すべての未読
記事を要求し、スコアを付け、キャッシュに保存します。この命令をいつもいつ
もいつもいつも使うのは、1) @acronym{NNTP} サーバーとの接続が本当に本当に
本当に遅くて、2) 本当に本当に本当に巨大なディスクを持っているときだけに
するべきです。これは真面目に言っています。ダウンロードされる記事の数を控
える一つの方法は、欲しくない記事のスコアを低くして、それらに既読の印を付
けることです。そうすれば、それらはこの命令ではダウンロードされません。

@vindex gnus-uncacheable-groups
@vindex gnus-cacheable-groups
すべてのグループではキャッシュをしたくないというのは良くあることです。例
えば @code{nnml} のメールがホームディレクトリーにあるのなら、それをホー
ムディレクトリーの別の場所にキャッシュするのは意味がありません。二倍の容
量を使う方が良いと思うのでなければ。

キャッシュを制限するには、@code{gnus-cacheable-groups} を例え
ば @samp{^nntp} のようなキャッシュするグループの正規表現に設定するか、ま
たは正規表現 @code{gnus-uncacheable-groups} を例えば @samp{^nnml} に設定
してください。両方の変数ともにディフォルトは @code{nil} です。もしグルー
プが両方の変数に合致すると、そのグループはキャッシュされません。

@findex gnus-cache-generate-nov-databases
@findex gnus-cache-generate-active
@vindex gnus-cache-active-file
キャッシュは、それがどの記事を含んでいるかの情報を、そのアクティブファイ
ル (@code{gnus-cache-active-file}) に格納します。このファイル (もしくは
キャッシュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、
Gnus はものごとを正しくするための二つのコマンドを提供します。
@kbd{M-x gnus-cache-generate-nov-databases} はすべての @acronym{NOV} ファ
イルを (再) 作成し、@kbd{M-x gnus-cache-generate-active} はアクティブファ
イルを (再) 作成します。

@findex gnus-cache-move-cache
@code{gnus-cache-move-cache} コマンドは、すべて
の @code{gnus-cache-directory} をどこか別の場所に移動します。あなたはど
こに移動させるかを尋ねられます。それってかっこいいでしょ?

@node Persistent Articles
@section 永続記事
@cindex persistent articles

記事のキャッシュと近い関係にあるものに「永続記事」があります。実際それは
キャッシュを見るための別の方法で、私に言わせればはるかに役に立ちます。

例えば、ニュースグループを読んでいて、永久に秘蔵しておく価値のある宝石に
出会ったとしましょう。普通はそれをファイルに保存します (多くの保存命令の
一つを使って)。問題は、単にあの、嫌なだけです。理想的には、記事はグルー
プで見つけた場所に永遠に残っていることが好ましいでしょう。ニュースサーバー
における期限切れ消去には影響されないで。

これが「永続記事」です---記事は削除されません。それは普通のキャッシュ命
令を使って実装されていますが、永続記事の管理をするために二つの明示的な命
令を使います:

@table @kbd
@item *
@kindex * @r{(概略)}
@findex gnus-cache-enter-article
現在の記事を永続にします (@code{gnus-cache-enter-article})。

@item M-*
@kindex M-* @r{(概略)}
@findex gnus-cache-remove-article
現在の記事を永続記事から取り除きます (@code{gnus-cache-remove-articles})。
これは普通は記事を削除します。
@end table

これらの命令は両方ともプロセス/接頭引数の習慣を理解します。

永続記事にだけ興味があるのなら、可視記事 (やその他のもの) がキャッシュに
入るのを避けるために、@code{gnus-use-cache} を @code{passive} に設定する
のが良いでしょう:

@lisp
(setq gnus-use-cache 'passive)
@end lisp

@node Sticky Articles
@section 粘着記事
@cindex sticky articles

記事を選択するとき、変数 @code{gnus-single-article-buffer} の値によって
は現在の記事バッファーが再利用されます。それが @code{nil} 以外の値だと、
すべての記事が同じ記事バッファーを再利用しますが、@code{nil} だった場合
はグループ毎に独自の記事バッファーを持ちます。

このことは、あるグループで同時に一つより多い記事バッファーを持つことはで
きないことを意味します。でも、時には今度のクリスマス・パーティーの段取り
のために、お母さん、お父さん、叔母さん、叔父さん、さらに 17 人のいとこか
ら最近届いたすべての電子メールを表示したいこともあるでしょう。

こんなときに粘着記事が役に立ちます。粘着記事バッファーは原理的には普通の
記事バッファーなのですが、他の記事を選択しても再利用されません。記事を粘
着質にするには、このコマンドを使ってください:

@table @kbd
@item A S
@kindex A S @r{(概略)}
@findex gnus-sticky-article
現在の記事を粘着質にします。接頭引数付きで呼ぶと、この粘着記事バッファー
の名前を尋ねます。
@end table

粘着記事バッファーを閉じるには、次のコマンドを使ってください:

@table @kbd
@item q
@kindex q @r{(記事)}
@findex bury-buffer
この粘着記事バッファーを、すべてのバッファーのリストの最後尾に置きます。

@item k
@kindex k @r{(記事)}
@findex gnus-kill-sticky-article-buffer
この粘着記事バッファーを削除します。
@end table

すべての粘着記事バッファーを削除するには、このコマンドを使えば良いでしょ
う:

@defun gnus-kill-sticky-article-buffers ARG
すべての粘着記事バッファーを削除します。接頭引数を与えると、確認を求めま
す。
@end defun

@node Article Backlog
@section 記事のバックログ
@cindex backlog
@cindex article backlog

回線が遅いために、キャッシュを使うという発想があまり魅力的ではないと
き (実際そうなのですが)、「バックログ」に切り替えることによって状況を何
とかすることができます。これはすでに読んだ記事を再取得しなくても良いよう
に、すでに読んだ記事を Gnus が一時保存しておくところです。これはもちろん、
あなたに最近読んだ記事を再び選択する癖があるときだけ役立ちます。絶対にそ
れをしない人にとっては、バックログを on にすることは Gnus を少し遅くし、
メモリーの使用量をいくらか増やすだけのことです。

@vindex gnus-keep-backlog
@code{gnus-keep-backlog} を数値 @var{n} に設定すると、Gnus は最大
で @var{n} 個の古い記事を後の再取得のためにバッファーに溜めておきます。
この変数が @code{nil} ではなく、数値でもない場合、
Gnus は @emph{すべて} の既読記事を蓄えます。それは Emacs が爆発するまで
際限なく膨れ上がって、マシンがあなたもろとも落ちてしまうということです。
私はみなさんがいつも注意を怠らないようにするために、ここに書き加えました。

ディフォルト値は 20 です。

@node Saving Articles
@section 記事の保存
@cindex saving articles

Gnus はたくさんの方法で記事を保存することができます。以下のものは非常に
率直な方法 (すなわち記事が保存する前にほとんど何もなされない) で記事を保
存するための説明です。異なる手続き (uudecode, unshar) のために
は @code{gnus-uu} を使うのが良いでしょう (@pxref{Decoding Articles})。

ここに列挙されているコマンドは対象がファイルです。ディレクトリー
名 (@samp{/} で終わるもの) を指定すると、その下にあるファイルが対象にな
ります。グループに保存したい場合
は @kbd{B c} (@code{gnus-summary-copy-article}) コマンドを参照してくださ
い (@pxref{Mail Group Commands})。

@vindex gnus-save-all-headers
@code{gnus-save-all-headers} が @code{nil} でないと、Gnus は記事を保存す
る前に不要なヘッダーを消去しません。

@vindex gnus-saved-headers
もし上記の変数が @code{nil} であると、正規表
現 @code{gnus-saved-headers} に合致するすべてのヘッダーが残される一方、
残りのものは保存する前に削除されます。

@table @kbd
@item O o
@itemx o
@kindex O o @r{(概略)}
@kindex o @r{(概略)}
@findex gnus-summary-save-article
@c @icon{gnus-summary-save-article}
ディフォルトの記事を保存する手段を用いて現在の記事を保存しま
す (@code{gnus-summary-save-article})。

@item O m
@kindex O m @r{(概略)}
@findex gnus-summary-save-article-mail
現在の記事を Unix メール (mbox) ファイルに保存しま
す (@code{gnus-summary-save-article-mail})。

@item O r
@kindex O r @r{(概略)}
@findex gnus-summary-save-article-rmail
現在の記事を Rmail の様式で保存しま
す (@code{gnus-summary-save-article-rmail})。これは Emacs 23 から mbox
になります。旧バージョンでは Babyl でした。

@item O f
@kindex O f @r{(概略)}
@findex gnus-summary-save-article-file
@c @icon{gnus-summary-save-article-file}
現在の記事を普通のファイル (plain file) 様式で保存しま
す (@code{gnus-summary-save-article-file})。

@item O F
@kindex O F @r{(概略)}
@findex gnus-summary-write-article-file
現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書きしま
す (@code{gnus-summary-write-article-file})。

@item O b
@kindex O b @r{(概略)}
@findex gnus-summary-save-article-body-file
現在の記事の本文を普通のファイル様式で保存しま
す (@code{gnus-summary-save-article-body-file})。

@item O h
@kindex O h @r{(概略)}
@findex gnus-summary-save-article-folder
現在の記事を mh のフォルダーの様式で保存しま
す (@code{gnus-summary-save-article-folder})。

@item O v
@kindex O v @r{(概略)}
@findex gnus-summary-save-article-vm
現在の記事を VM フォルダーに保存しま
す (@code{gnus-summary-save-article-vm})。

@item O p
@itemx |
@kindex O p @r{(概略)}
@kindex | @r{(概略)}
@findex gnus-summary-pipe-output
@vindex gnus-summary-pipe-output-default-command
現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとしているこ
とは---現在の記事をプロセスにパイプするということで
す (@code{gnus-summary-pipe-output})。シンボル接頭引数 (@pxref{Symbolic
Prefixes}) が与えられると、パイプへの出力に完全なヘッダーを含めます。シ
ンボル接頭引数 @code{r} は特別で、それはすべてのヘッダーを含む生の (デコー
ドされていない) 記事をパイプに送ります。
@code{gnus-summary-pipe-output-default-command} 変数をディフォルトのコマ
ンドと引数を含む文字列に設定することができます (ディフォルト
は @code{nil})。

@item O P
@kindex O P @r{(概略)}
@findex gnus-summary-muttprint
@vindex gnus-summary-muttprint-program
現在の記事を muttprint に保存します。つまり、外部プログラ
ム @uref{http://muttprint.sourceforge.net/, Muttprint} を使って記事を印
刷するということです。プログラム名と使用するオプションは、変
数 @code{gnus-summary-muttprint-program} で指定されます。
(@code{gnus-summary-muttprint})。
@end table

@vindex gnus-prompt-before-saving
すべてのこれらの命令はプロセス/接頭引数の習慣を使いま
す (@pxref{Process/Prefix})。もしこれらの関数を使ってたくさんの記事を保
存した場合、それぞれのすべての記事に対してファイル名の入力を要求されるこ
とに飽き飽きするでしょう。入力を求める動作は変
数 @code{gnus-prompt-before-saving} によって制御されます。これはディフォ
ルトでは @code{always} で、あなたが嫌な思いを味わっている、過剰な入力要
求をします。代わりにこの変数を @code{t} に設定すると、保存するそれぞれの
一連の記事に対して一回だけ入力を要求します。本当に Gnus にすべての判断を
任せてしまいたいのであれば、この変数を @code{nil} にすることさえできます。
そうすれば、記事を保存するためのファイルを促されることはありません。
Gnus は単純にすべての記事をディフォルトのファイルに保存します。

@vindex gnus-default-article-saver
Gnus を思い通りに動作させるために、変
数 @code{gnus-default-article-saver} をカスタマイズすることができます。
下の八つの既製の関数を使うことができ、また自分自身の関数を作ることもでき
ます。

@table @code
@item gnus-summary-save-in-rmail
@findex gnus-summary-save-in-rmail
@vindex gnus-rmail-save-name
@findex gnus-plain-save-name
これがディフォルトで、Rmail パッケージで使われているものです。Emacs
23 から Rmail は標準の mbox 様式を使うようになりました。それ以前に
は @dfn{Babyl} 様式というものが使われていました。そのため、既存
の Babyl ファイルに追加するのでなければ、Emacs 23 からこのコマンド
は mbox 様式で書きます。古いバージョンの Emacs では、常に Babyl 様式を使
います。変数 @code{gnus-ramil-save-name} に設定されている関数を、記事を
保存するファイルの名前を取得するために使います。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-mail
@findex gnus-summary-save-in-mail
@vindex gnus-mail-save-name
Unix メール (mbox) ファイルに保存します。変
数 @code{gnus-mail-save-name} に設定されている関数を、記事を保存するファ
イルの名前を取得するために使います。ディフォルト
は @code{gnus-plain-save-name} です。

@item gnus-summary-save-in-file
@findex gnus-summary-save-in-file
@vindex gnus-file-save-name
@findex gnus-numeric-save-name
記事を通常のファイルの後に追加します。変数 @code{gnus-file-save-name} に
設定されている関数を、記事を保存するファイルの名前を取得するために使いま
す。ディフォルトは @code{gnus-numeric-save-name} です。

@item gnus-summary-write-to-file
@findex gnus-summary-write-to-file
記事をストレートに通常のファイルに保存します。そのファイルが存在していた
ら上書きされます。変数 @code{gnus-file-save-name} に設定されている関数を、
記事を保存するファイルの名前を取得するために使います。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-save-body-in-file
@findex gnus-summary-save-body-in-file
記事の本文を通常のファイルの後に追加します。変
数 @code{gnus-file-save-name} に設定されている関数を、記事を保存するファ
イルの名前を取得するために使います。ディフォルト
は @code{gnus-numeric-save-name} です。

@item gnus-summary-write-body-to-file
@findex gnus-summary-write-body-to-file
記事の本文をストレートに通常のファイルに保存します。そのファイルが存在し
ていたら上書きされます。変数 @code{gnus-file-save-name} に設定されている
関数を、記事を保存するファイルの名前を取得するために使います。ディフォル
トは @code{gnus-numeric-save-name} です。

@item gnus-summary-save-in-folder
@findex gnus-summary-save-in-folder
@findex gnus-folder-save-name
@findex gnus-Folder-save-name
@vindex gnus-folder-save-name
@cindex rcvstore
@cindex MH folders
MH ライブラリーの @code{rcvstore} を使って、記事を MH フォルダーに保存し
ます。変数 @code{gnus-folder-save-name} に設定されている関数を、記事を保
存するファイルの名前を取得するために使います。ディフォルト
は @code{gnus-folder-save-name} ですが、@code{gnus-Folder-save-name} も
使うことができて、こちらは先頭が大文字、残りが小文字になった名前を作りま
す。

@item gnus-summary-save-in-vm
@findex gnus-summary-save-in-vm
記事を VM フォルダーに保存します。この設定を使うためには VM メールリーダー
が必要です。

@item gnus-summary-save-in-pipe
@findex gnus-summary-save-in-pipe
記事をシェルコマンドにパイプします。この関数は二つの引数 COMMAND およ
び RAW を受け付けます (無くても構いません)。有効な COMMAND の値は次の通
りです:

@itemize @bullet
@item 文字列@*
実行可能なコマンド名と、もしあれば引数です。
@item @code{nil}@*
ミニバッファーでコマンドを入力します。
@item シンボル @code{default}@*
@code{gnus-summary-pipe-output-default-command} 変数が持っている値、また
は最後に保存のために使われたコマンドで置き換えられます。
@end itemize

RAW に @code{nil} 以外の値を与えると @code{:decode} およ
び @code{:headers} 属性 (後述) が無視され、すべてのヘッダーを含む生
の (デコードされていない) 記事がパイプに渡されます。
@end table

それぞれの関数シンボルは以下の属性 (property) を持つことができます:

@table @code
@item :decode
@code{nil} ではない値が設定されているとデコードした記事を保存します。
@code{gnus-summary-save-in-file}、@code{gnus-summary-save-body-in-file}、
@code{gnus-summary-write-to-file}、
@code{gnus-summary-write-body-to-file} およ
び @code{gnus-summary-save-in-pipe} でだけ、これを設定する意義があります。

@item :function
記事をファイルに上書するのではなく、追加するための代わりの関数を指定しま
す。これを設定すると、複数の記事を一度に保存するとき
に @code{gnus-prompt-before-saving} が @code{t} に束縛され、すべての記事
が単一のファイルに保存されます。@code{gnus-summary-write-to-file} およ
び @code{gnus-summary-write-body-to-file} でだけ、これを設定する意義があ
ります。

@item :headers
保存されるヘッダーを指定する変数のシンボルをこれで設定します。省略された
場合は @code{gnus-save-all-headers} と @code{gnus-saved-headers} が、ど
のヘッダーを保存するかを制御します。
@end table

@vindex gnus-article-save-directory
これらのすべての関数は最後の一つを除いて、環境変数 @env{SAVEDIR} によっ
て初期化される @code{gnus-article-save-directory} に記事を保存します。こ
れはディフォルトでは @file{~/News/} です。

上で述べたように、記事を保存するためのファイルの適切な名前を見つけるため
に、それらは違った関数を用います。以下は名前を生成するために使うことがで
きる関数のリストです:

@table @code
@item gnus-Numeric-save-name
@findex gnus-Numeric-save-name
@file{~/News/Alt.andera-dworkin/45} のようなファイル名。

@item gnus-numeric-save-name
@findex gnus-numeric-save-name
@file{~/News/alt.andera-dworkin/45} のようなファイル名。

@item gnus-Plain-save-name
@findex gnus-Plain-save-name
@file{~/News/Alt.andera-dworkin} のようなファイル名。

@item gnus-plain-save-name
@findex gnus-plain-save-name
@file{~/News/alt.andera-dworkin} のようなファイル名。

@item gnus-sender-save-name
@findex gnus-sender-save-name
@file{~/News/larsi} のようなファイル名。
@end table

@vindex gnus-split-methods
連想リスト @code{gnus-split-methods} に正規表現を放り込むことによって、
Gnus に記事を保存する場所をほのめかすことができます。例えば Gnus に関連
する記事を @file{gnus-stuff} ファイルに、VM に関連する記事
を @file{vm-stuff} ファイルに保存したければ、この変数を以下のようにすれ
ば良いでしょう:

@lisp
(("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
 ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
 (my-choosing-function "../other-dir/my-stuff")
 ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))
@end lisp

これはそれぞれの要素が、二つの要素---「合致」と「ファイル」を持つリスト
であるリストであるということがわかります。合致は文字列 (この場合は記事の
ヘッダーに合致する正規表現として使われます)、シンボル (グループ名を引数
として、関数として呼ばれます) およびリスト (これは評価 (@code{eval}) さ
れます) のどれかであることができます。これらの動作の一つで
も @code{nil} でない結果を返すと、入力を求めるときのディフォルトとして
「ファイル」が使われます。加えて、呼ばれた関数か式が文字列か文字列のリス
トを返したときは、演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリス
トを手に入れることになります。(すべての『合致』が使われます。) そして、
実際に名前として使いたいものの入力を促されますが、その際、この変数を適用
して得られた結果が、ファイル名を補完するときの候補になります。

この変数はディフォルトでは @code{((gnus-article-archive-name))} で、これ
は Gnus が保存する記事の @code{Archive-name} 行を調べて、それをファイル
名の候補として使います。

これはファイル名を多少きれいにする関数の例です。
@samp{nnml:mail.whatever} のようなメールグループがたくさんあるとすると、
保存するためのファイル名を作る前にそれらのグループ名の最初の方を切り落と
す必要があるかもしれません。次の物はまさにそれをします:

@lisp
(defun my-save-name (group)
  (when (string-match "^nnml:mail." group)
    (substring group (match-end 0))))

(setq gnus-split-methods
      '((gnus-article-archive-name)
        (my-save-name)))
@end lisp

@vindex gnus-use-long-file-name
最後に、@code{gnus-use-long-file-name} という変数があります。これ
が @code{nil} であると、すべての上記の関数はグループ名のすべてのピリオ
ド (@samp{.}) をスラッシュ (@samp{/}) で置き換えます---つまり、すべての
ファイルを一番上のディレクトリーに置くのではなく、それらの関数が階層的な
ディレクトリーを生成するということで
す (@file{~/News/alt.andrea-dworkin} ではな
く @file{~/News/alt/andrea-dworkin} のように)。たいていのシステムにおい
て、この変数のディフォルトは @code{t} です。しかし、歴史的な理由によっ
て Xenix と usg-unix-v マシンでは @code{nil} がディフォルトになります。

この関数は削除とスコアのファイル名にも影響します。この変数がリストで、そ
のリストが @code{not-score} という要素を含んでいると、長いファイル名はス
コアファイルには使われません。そのリストが @code{not-save} という要素を
含んでいると、保存するときに長いファイル名は使われません。また、そのリス
トが @code{not-kill} という要素を含んでいると、長いファイル名は削除ファ
イルには使われません。

記事をスプールのような階層に保存したい場合は、次のようにしてください。

@lisp
(setq gnus-use-long-file-name '(not-save)) ; @r{階層にする}
(setq gnus-default-article-saver
      'gnus-summary-save-in-file) ; @r{エンコードしない}
@end lisp

そうしたならば、@kbd{o} で記事を保存するだけです。すると、階層
を @code{nneething} 一時グループによって読むことができます---グループバッ
ファーで @kbd{G D} をタイプして、一番上のディレクト
リー (@file{~/News/}) を引数として渡してください。

@node Decoding Articles
@section 記事のデコード
@cindex decoding articles

ときどき利用者は何らかの方法でエンコードされた記事 (もしくは一連の記事群)
を投稿します。Gnus はそれらをデコードすることができます。

@quotation
訳注: この章では、複数に分割して送信された一つの巨大な記事を、再び一つに
まとめ上げてデコードする処理について説明しています。現在では、そのような
分割送信をメールサーバーが受け付けない等の理由によって、ほとんど目にする
ことはありません。分割して送信しないことを確実にするには、以下の設定を行
なってくださ
い (@pxref{Mail Variables, ,メール変数, message-ja, The Message Manual}):

@lisp
(setq message-send-mail-partially-limit nil)
@end lisp
@end quotation

@menu
* Uuencoded Articles::          記事を uudecode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?
@end menu

@cindex series
@cindex article series
これらすべての関数はプロセス/接頭引数の習慣 (@pxref{Process/Prefix}) を、
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をするか
を見つけるために使います。Gnus は自分自身でどの記事がその群に属している
かを判断し、すべての記事をデコードして、その結果のファイルを展開/表示/保
存することができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します: 表
題は行の最後の二つの数字を除いて (ほとんど) 同じである必要があります。
(空白は大体無視されますが。)

例えば: @samp{cat.gif (2/3)} というような表題を選ぶと、Gnus は正規表
現 @samp{^cat.gif ([0-9]+/[0-9]+).*$} に合致するすべての記事を見つけよう
とします。

@samp{cat.gif (2/3) Part 6 of a series} のような標準でない表題はどの自動
表示命令によっても適切に認識されないため、手で記事に @kbd{#} の印を付け
なければなりません。

@node Uuencoded Articles
@subsection uuencode された記事
@cindex uudecode
@cindex uuencoded articles

@table @kbd
@item X u
@kindex X u @r{(概略)}
@findex gnus-uu-decode-uu
@c @icon{gnus-uu-decode-uu}
現在の群を uudecode します (@code{gnus-uu-decode-uu})。

@item X U
@kindex X U @r{(概略)}
@findex gnus-uu-decode-uu-and-save
現在の群を uudecode して保存します (@code{gnus-uu-decode-uu-and-save})。

@item X v u
@kindex X v u @r{(概略)}
@findex gnus-uu-decode-uu-view
現在の群を uudecode して、表示します (@code{gnus-uu-decode-uu-view})。

@item X v U
@kindex X v U @r{(概略)}
@findex gnus-uu-decode-uu-and-save-view
現在の記事を uudecode して、表示して保存しま
す (@code{gnus-uu-decode-uu-and-save-view})。
@end table

これらはすべて、プロセス印が付けられた記事に対して反応するということを覚
えておいてください。例えばニュースグループ全体をデコードして保存したいの
であれば、例によって @kbd{M P a} (@code{gnus-uu-mark-all}) に続い
て @kbd{X U} (@code{gnus-uu-decode-uu-and-save}) を実行してください。

このすべては、白日の下にいちいちキーを打っていた @sc{gnus 4.1} のとき
の @code{gnus-uu} の動作とはまったく違っています。一般にこの版
の @code{gnus-uu} は、何かの方法 (@pxref{Setting Process Marks}) で
記事に印を付け、それから @kbd{X u} を押すことを前提としています。

@vindex gnus-uu-notify-files
注意: 定数 @code{gnus-uu-notify-files} (値
が @samp{[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)} にハードコードされ
ています) に合致する名前を持つ記事をデコードしようとすると、あなたが問題
の記事を今まさに見たことをバラすために、@code{gnus-uu} は自動的
に @samp{comp.unix.wizards} に記事を投稿します。この機能を使わないように
することはできません (訳注: そんな Cindy Crawford 嬢の写真がニュースで大
量に流れていた、まだ WWW がロクに普及していなかった時代の産物です)。

@node Shell Archives
@subsection シェルアーカイブ
@cindex unshar
@cindex shell archives
@cindex shared articles

シェルアーカイブ (『shar ファイル』) はソースを配布するための人気のある
方法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うため
の命令があります:

@table @kbd
@item X s
@kindex X s @r{(概略)}
@findex gnus-uu-decode-unshar
現在の群を解凍します (@code{gnus-uu-decode-unshar})。

@item X S
@kindex X S @r{(概略)}
@findex gnus-uu-decode-unshar-and-save
現在の群を解凍して保存します (@code{gnus-uu-decode-unshar-and-save})。

@item X v s
@kindex X v s @r{(概略)}
@findex gnus-uu-decode-unshar-view
現在の群を解凍して表示します (@code{gnus-uu-decode-unshar-view})。

@item X v S
@kindex X v S @r{(概略)}
@findex gnus-uu-decode-unshar-and-save-view
現在の群を解凍し、表示して保存しま
す (@code{gnus-uu-decode-unshar-and-save-view})。
@end table

@node PostScript Files
@subsection ポストスクリプトファイル
@cindex PostScript

@table @kbd
@item X p
@kindex X p @r{(概略)}
@findex gnus-uu-decode-postscript
現在のポストスクリプト群を展開します (@code{gnus-uu-decode-postscript})。

@item X P
@kindex X P @r{(概略)}
@findex gnus-uu-decode-postscript-and-save
現在のポストスクリプト群を展開して保存しま
す (@code{gnus-uu-decode-postscript-and-save})。

@item X v p
@kindex X v p @r{(概略)}
@findex gnus-uu-decode-postscript-view
現在のポストスクリプト群を表示しま
す (@code{gnus-uu-decode-postscript-view})。

@item X v P
@kindex X v P @r{(概略)}
@findex gnus-uu-decode-postscript-and-save-view
現在のポストスクリプト群を表示して保存しま
す (@code{gnus-uu-decode-postscript-and-save-view})。
@end table

@node Other Files
@subsection 他のファイル

@table @kbd
@item X o
@kindex X o @r{(概略)}
@findex gnus-uu-decode-save
現在の記事群を保存します (@code{gnus-uu-decode-save})。

@item X b
@kindex X b @r{(概略)}
@findex gnus-uu-decode-binhex
現在の記事群を binhex で解凍します (@code{gnus-uu-decode-binhex})。これ
はまだ実際には動作しません。

@item X Y
@kindex X Y @r{(概略)}
@findex gnus-uu-decode-yenc
現在の記事群を yEnc でデコードして保存しま
す (@code{gnus-uu-decode-yenc})。
@end table

@node Decoding Variables
@subsection デコードのための変数

形容詞です。動詞ではありません。

@menu
* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数
@end menu

@node Rule Variables
@subsubsection 規則変数
@cindex rule variables

Gnus はファイルをどうやって表示するかを決めるために「規則変数」を使いま
す。これらの変数はすべて以下のような様式です。

@lisp
      (list '(regexp1 command2)
            '(regexp2 command2)
            ...)
@end lisp

@table @code
@item gnus-uu-user-view-rules
@vindex gnus-uu-user-view-rules
@cindex sox
この変数はファイルを表示するときに最初に調べられます。例えば、も
し @file{.au} 音響ファイルを変換するために @code{sox} を使いたいときは、
次のように設定することができます:

@lisp
(setq gnus-uu-user-view-rules
      (list '("\\\\.au$\" "sox %s -t .aiff > /dev/audio")))
@end lisp

@item gnus-uu-user-view-rules-end
@vindex gnus-uu-user-view-rules-end
この変数は Gnus が利用者とディフォルトの表示規則から合致するものを見つけ
ることができなかったときに調べられます。

@item gnus-uu-user-archive-rules
@vindex gnus-uu-user-archive-rules
この変数はアーカイブを展開するときにどの命令が使われるべきかを決めるため
に使うことができます。
@end table

@node Other Decode Variables
@subsubsection 他のデコードのための変数

@table @code
@vindex gnus-uu-grabbed-file-functions

@item gnus-uu-grabbed-file-functions
これは関数のリストです。すぐにファイルを移動したり表示することを可能にし、
何かができるようになる前にすべてのファイルがデコードされるのを待つ必要が
無いように、それぞれのファイルのデコードに成功した直後にそれらの関数が呼
ばれます。このリストに入れることができる既製の関数は以下の通りです:

@table @code
@item gnus-uu-grab-view
@findex gnus-uu-grab-view
ファイルを表示します。

@item gnus-uu-grab-move
@findex gnus-uu-grab-move
ファイルを移動します (もし保存関数を使っているのであれば)。
@end table

@item gnus-uu-be-dangerous
@vindex gnus-uu-be-dangerous
デコードの最中に異常な状況が起こったときに何をするかを指定します。も
し @code{nil} であると、できるだけ保守的になります。もし @code{t} である
と、動作しないものは無視して、現存するファイルを上書きします。その他の場
合は、それぞれのときに尋ねます。

@item gnus-uu-ignore-files-by-name
@vindex gnus-uu-ignore-files-by-name
この正規表現に合致する名前のファイルは表示されません。

@item gnus-uu-ignore-files-by-type
@vindex gnus-uu-ignore-files-by-type
この変数に合致する @acronym{MIME} の型を持つファイルは表示されません。
Gnus はファイル名に基づいて型を推測していることに注意してください。
@code{gnus-uu} は (まだ) @acronym{MIME} パッケージではないので、これは少々
お行儀が悪いものです。

@item gnus-uu-tmp-dir
@vindex gnus-uu-tmp-dir
@code{gnus-uu} がその仕事をする場所です。

@item gnus-uu-do-not-unpack-archives
@vindex gnus-uu-do-not-unpack-archives
@code{nil} でないと、@code{gnus-uu} は表示するためのファイルを探すために
アーカイブの中身までは見ません。

@item gnus-uu-view-and-save
@vindex gnus-uu-view-and-save
@code{nil} でないと、利用者はファイルを表示した後で常に保存するかどうか
を尋ねられます。

@item gnus-uu-ignore-default-view-rules
@vindex gnus-uu-ignore-default-view-rules
@code{nil} でないと、@code{gnus-uu} はディフォルトの表示規則を無視します。

@item gnus-uu-ignore-default-archive-rules
@vindex gnus-uu-ignore-default-archive-rules
@code{nil} でないと、@code{gnus-uu} はディフォルトのアーカイブ展開命令を
無視します。

@item gnus-uu-kill-carriage-return
@vindex gnus-uu-kill-carriage-return
@code{nil} でないと、@code{gnus-uu} は記事からすべてのキャリッジリターン
を取り去ります。

@item gnus-uu-unmark-articles-not-decoded
@vindex gnus-uu-unmark-articles-not-decoded
@code{nil} でないと、@code{gnus-uu} はデコードに失敗した記事に未読の印を
付けます。

@item gnus-uu-correct-stripped-uucode
@vindex gnus-uu-correct-stripped-uucode
@code{nil} でないと、@code{gnus-uu} は後続の空白が削除されてしまってい
る uuencode されたファイルを修復しようと @emph{試み} ます。

@item gnus-uu-pre-uudecode-hook
@vindex gnus-uu-pre-uudecode-hook
メッセージを @code{uudecode} に送る前に実行されるフックです。

@item gnus-uu-view-with-metamail
@vindex gnus-uu-view-with-metamail
@cindex metamail
@code{nil} でないと、@code{gnus-uu} は規則変数で定義された表示命令を無視
して、ファイル名に基づいた @acronym{MIME} Content-Type をでっちあげます。
その結果は表示のために @code{metamail} にかけられます。

@item gnus-uu-save-in-digest
@vindex gnus-uu-save-in-digest
@code{nil} でないと、デコードせずに保存することを指示されたときに、
@code{gnus-uu} は要約 (digest) を保存します。この変数が @code{nil} であ
ると、@code{gnus-uu} は何も加工を施さずにすべてを一つのファイルに保存し
ます。要約の作成は概ね RFC1153 に準拠していますが、意味のある目次を付け
る簡単な方法が見つからなかったので、私はそれらを単に落としました。
@end table

@node Uuencoding and Posting
@subsubsection uuencode と投稿

@table @code
@item gnus-uu-post-include-before-composing
@vindex gnus-uu-post-include-before-composing
@code{nil} でないと、@code{gnus-uu} は記事を作成する前にエンコードするファ
イルを尋ねます。この変数が @code{t} であると、@kbd{C-c C-i} によってエン
コードされたファイルを取り込むか、記事を投稿するときに取り込むかのどちら
かをすることができます。

@item gnus-uu-post-length
@vindex gnus-uu-post-length
記事の最大の長さです。エンコードされたファイルは全体のファイルを投稿する
のに必要な量のファイルに分割されます。

@item gnus-uu-post-threaded
@vindex gnus-uu-post-threaded
@code{nil} でないと、@code{gnus-uu} はエンコードされたファイルをスレッド
で投稿します。これはあまり賢い方法ではないかもしれません。というのは、今
まで私が見た中で uuencode された記事を集めるのに、スレッドを追っていくこ
とのできる他のデコーダーが存在しないからです。(えーと、私はそれをする一
つのパッケージを見たことがあります---@code{gnus-uu} です。しかしどうも、
それが数のうちに入るとは思えないのです@dots{}) ディフォルト
は @code{nil} です。

@item gnus-uu-post-separate-description
@vindex gnus-uu-post-separate-description
@code{nil} でないと、説明文は別の記事で投稿されます。最初の記事は普
通 (0/x) のように番号が付けられます。もしこの変数が @code{nil} であると、
利用者の書いた説明分は最初のファイルの始めに取り込まれ、(1/x) の番号が付
けられます。ディフォルトは @code{t} です。
@end table

@node Viewing Files
@subsection ファイルの表示
@cindex viewing files
@cindex pseudo-articles

デコードした後でファイルが何らかのアーカイブである場合、Gnus はアーカイ
ブを展開しようと試み、アーカイブの中に表示できるファイルがあるかどうかを
調べます。例えば、gzip された tar ファイル @file{pics.tar.gz} があって、
ファイル @file{pic1.jpg} と @file{pic2.gif} を含んでいる場合、Gnus は主
ファイルを解凍して tar を展開し、それから二つの絵を表示します。この展開
の過程は再帰的なので、アーカイブにアーカイブのアーカイブがあると、それは
すべて展開されます。

最後に、Gnus は普通はそれぞれの抽出された記事ごとに「疑似記事」を概略バッ
ファーに挿入します。これらの『記事』に移動した場合は、実行する命令 (普通
は Gnus が提案をします) を入力するように促され、それからその命令が実行さ
れます。

@vindex gnus-view-pseudo-asynchronously
@code{gnus-view-pseudo-asynchronously} が @code{nil} であると、Emacs は
先へ進む前に表示の終了を待ちます。

@vindex gnus-view-pseudos
@code{gnus-view-pseudos} が @code{automatic} であると、Gnus は概略バッファー
に疑似記事を挿入せず、それらをすぐに表示します。この変数
が @code{not-confirm} であると、利用者は表示が済む前に確認さえも求められ
ません。

@vindex gnus-view-pseudos-separately
@code{gnus-view-pseudos-separately} が @code{nil} でないと、表示されるそ
れぞれのファイルにつき一つの疑似記事が作成されます。@code{nil} であると、
同じ表示命令を使うすべての命令がその命令の引数のリストとして渡されます。

@vindex gnus-insert-pseudo-articles
@code{gnus-insert-pseudo-articles} が @code{nil} でないと、デコードのと
きに疑似記事を挿入します。ディフォルトでは @code{t} です。

さて、あなたはそんなふうに @emph{仮想サーバー} の @emph{仮想グループ} に
ある @emph{疑似記事} を読むことになるわけです。どうしてすべてが現実では
なくなってしまったんでしょうか?  どうしてこんなところに来てしまったんで
しょうか?

@node Article Treatment
@section 記事のトリートメント

この巨大な説明文書を読んできて、人々の著作を読むことがニュースリーダーの
本当の目的だったことを、すっかり忘れてしまったかもしれません。記事を読む
ことです。残念ながら人々は書くことがとても苦手ですが、記事を読みやすくす
るための関数と変数は山のようにあります。

@menu
* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             いろんなものを表示する:
                                X-Face, Picons, Smileys, Gravatars
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの
@end menu

@node Article Highlighting
@subsection 記事のハイライト
@cindex highlighting

記事バッファーをフルーツサラダのように、いや総天然色のフルーツサラダのよ
うにしたくありませんか。

@table @kbd
@item W H a
@kindex W H a @r{(概略)}
@findex gnus-article-highlight
@findex gnus-article-maybe-highlight
現在の記事をもっとハイライトします。この関数は、ヘッダー、引用文、署名を
ハイライトし、本文とヘッダーにボタンを加えます。

@item W H h
@kindex W H h @r{(概略)}
@findex gnus-article-highlight-headers
@vindex gnus-header-face-alist
ヘッダーをハイライトします (@code{gnus-article-highlight-headers})。ハイ
ライトは変数 @code{gnus-header-face-alist} に従って行なわれ、それはそれ
ぞれの要素が @code{(@var{正規表現} @var{名前} @var{内容})} という様式の
リストです。@var{正規表現} はヘッダーに合致する正規表現、@var{名前} はヘッ
ダーの名前をハイライトするのに使われるフェース (@pxref{Faces and Fonts})、
@var{内容} はヘッダーの値をハイライトするフェースです。最初に合致したも
のが使われます。@var{正規表現} の先頭に @samp{^} を付けてはいけないこと
に注意してください---Gnus がそれを付け加えます。

@item W H c
@kindex W H c @r{(概略)}
@findex gnus-article-highlight-citation
引用された文をハイライトします (@code{gnus-article-highlight-citation})。

引用文のハイライトをカスタマイズする変数は次の通りです:

@table @code
@vindex gnus-cite-parse-max-size
@item gnus-cite-parse-max-size
記事の大きさがこの変数 (ディフォルトでは 25000) のバイト数より大きい記事
は、引用文のハイライトが行なわれません。

@item gnus-cite-max-prefix
@vindex gnus-cite-max-prefix
引用符の最大の長さです (ディフォルトでは 20 です)。

@item gnus-cite-face-list
@vindex gnus-cite-face-list
引用文をハイライトするために使われるフェースのリストです (@pxref{Faces
and Fonts})。同じメッセージの中に複数の記事からの引用があると、Gnus はそ
れぞれの記事からの引用をそれ用のフェースで表示しようとします。これにより、
誰が何を書いたかが分かりやすくなるでしょう。

@item gnus-supercite-regexp
@vindex gnus-supercite-regexp
普通の Supercite 著者行に合致する正規表現です。

@item gnus-supercite-secondary-regexp
@vindex gnus-supercite-secondary-regexp
引き裂かれた Supercite 著者行に合致する正規表現です。

@item gnus-cite-minimum-match-count
@vindex gnus-cite-minimum-match-count
それが引用文であると判定する前に調べなければならない引用符の最小の数です。

@item gnus-cite-attribution-prefix
@vindex gnus-cite-attribution-prefix
著者行の始まりに合致する正規表現です。

@item gnus-cite-attribution-suffix
@vindex gnus-cite-attribution-suffix
著者行の終りに合致する正規表現です。

@item gnus-cite-attribution-face
@vindex gnus-cite-attribution-face
著者行に使われるフェースです。その著者が書いた文の引用のためのフェースと
融合されます。

@item gnus-cite-ignore-quoted-from
@vindex gnus-cite-ignore-quoted-from
非-@code{nil} だったら、@samp{>From } で始まる行で引用文のハイライトは行
なわれません。それらの行は、エンベロープ From 行と混同しないように、
MTA がクオートした可能性があります。ディフォルト値は @code{t} です。
@end table

@item W H s
@kindex W H s @r{(概略)}
@vindex gnus-signature-separator
@vindex gnus-signature-face
@findex gnus-article-highlight-signature
署名 (signature) をハイライトしま
す (@code{gnus-article-highlight-signature})。
@code{gnus-signature-separator} (@pxref{Article Signature}) の後のすべて
のものは署名であると解釈され、@code{gnus-signature-face} でハイライトさ
れます。それはディフォルトでは @code{italic} です。
@end table

記事を自動的にハイライトする方法については @ref{Customizing Articles} を
参照してください。

@node Article Fontisizing
@subsection 記事中の文の強調表示
@cindex emphasis
@cindex article emphasis

(訳注: Fontisize == Fontify + Emphasize)

@findex gnus-article-emphasize
@kindex W e @r{(概略)}
人々はよくニュースの記事で @samp{_これ_} や @samp{*これ*} また
は @samp{/これ/} のようなものを使って単語を強調します。Gnus は記事
を @kbd{W e} 命令 (@code{gnus-article-emphasize}) にかけることによって素
敵に見えるようにできます。

@vindex gnus-emphasis-alist
強調がどのように処理されるかは変数 @code{gnus-emphasis-alist} によって制
御されます。これは連想リストで、最初の要素は合致するべき正規表現です。二
番目の要素は、正規表現の中のどのグループが強調語全体を見つけるために使わ
れるかを示す数値です。三番目は正規表現のどのグループが表示されハイライト
されるかを決める数値です。(この二つのグループの間にあるテキストは隠され
ます。) 四番目はハイライトさせるためののフェースです。

@lisp
(setq gnus-emphasis-alist
      '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
        ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))
@end lisp

(訳注: 上記の変数の値は、ディフォルトのままにしておくのが無難です。)

@cindex slash
@cindex asterisk
@cindex underline
@cindex /
@cindex *

@vindex gnus-emphasis-underline
@vindex gnus-emphasis-bold
@vindex gnus-emphasis-italic
@vindex gnus-emphasis-underline-bold
@vindex gnus-emphasis-underline-italic
@vindex gnus-emphasis-bold-italic
@vindex gnus-emphasis-underline-bold-italic
ディフォルトでは七つの規則があり、それらは以下のフェースを用います:@*
@code{gnus-emphasis-bold}, @code{gnus-emphasis-italic},
@code{gnus-emphasis-underline}, @code{gnus-emphasis-bold-italic},
@code{gnus-emphasis-underline-italic},
@code{gnus-emphasis-underline-bold},
@code{gnus-emphasis-underline-bold-italic}。

これらのフェースを変更したいのであれば、
@kbd{M-x customize} か @code{copy-face} を使うことができます。例え
ば @code{gnus-emphasis-italic} が代わりに赤のフェースを使うようにしたい
のならば、次のようにすれば良いでしょう:

@lisp
(copy-face 'red 'gnus-emphasis-italic)
@end lisp

@vindex gnus-group-highlight-words-alist
任意の語を強調表示させたいときは、
@code{gnus-group-highlight-words-alist} 変数を使うことができます。これ
は @code{gnus-emphasis-alist} と同じ構文を使います。
@code{highlight-words} グループパラメー
ター (@pxref{Group Parameters}) を使うこともできます。

記事を自動的に強調表示させるやり方について
は @ref{Customizing Articles} を参照してください。

@node Article Hiding
@subsection 記事を隠す
@cindex article hiding

と言うよりはむしろ、記事の中にある特定のものを隠すことです。たいていの記
事には、普通はありすぎるくらいのごみがあります。

@table @kbd
@item W W a
@kindex W W a @r{(概略)}
@findex gnus-article-hide
記事バッファーでたくさんのものを隠します (@kbd{gnus-article-hide})。特に
この関数はヘッダー、@acronym{PGP}、引用文、それに署名を隠します。

@item W W h
@kindex W W h @r{(概略)}
@findex gnus-article-hide-headers
ヘッダーを隠します (@code{gnus-article-hide-headers})。
@xref{Hiding Headers}.

@item W W b
@kindex W W b @r{(概略)}
@findex gnus-article-hide-boring-headers
あまり興味の持てないヘッダーを隠しま
す (@code{gnus-article-hide-boring-headers})。@xref{Hiding Headers}.

@item W W s
@kindex W W s @r{(概略)}
@findex gnus-article-hide-signature
署名を隠します (@code{gnus-article-hide-signature})。
@xref{Article Signature}.

@item W W l
@kindex W W l @r{(概略)}
@findex gnus-article-hide-list-identifiers
@vindex gnus-list-identifiers
@code{gnus-list-identifiers} で指定されているメーリングリストの標識を削
除します。これらはいくつかのメーリングリストのサーバーがすべて
の @code{Subject} ヘッダーの最初に付ける文字列、例え
ば @samp{[zebra 4711]} のようなものです。文字列の初めにあ
る @samp{Re: } は、削除を行なう前に跳び越されます。
@code{gnus-list-identifiers} に @code{\\(..\\)} を含めてはいけません。

@table @code
@item gnus-list-identifiers
@vindex gnus-list-identifiers
表題から削除されるべきメーリングリストの標識に合致する正規表現です。これ
は正規表現のリストであることもできます。
@end table

@item W W P
@kindex W W P @r{(概略)}
@findex gnus-article-hide-pem
不要な @acronym{PEM} (privacy enhanced messages (プライバシー拡張メッセー
ジ)) の部分を隠します (@code{gnus-article-hide-pem})。

@item W W B
@kindex W W B @r{(概略)}
@findex gnus-article-strip-banner
@vindex gnus-article-banner-alist
@vindex gnus-article-address-banner-alist
@cindex banner
@cindex OneList
@cindex stripping advertisements
@cindex advertisements
@code{banner} グループパラメーターで指定されたバナーを取り除きま
す (@code{gnus-article-strip-banner})。これは主に、いくつかのメーリング
リストや司会者付きのグループがすべての記事に追加する、欝陶しいバナーと/
もしくは署名を隠すために使用されます。この関数を使う方法
は @code{banner} グループパラメーター (@pxref{Group Parameters}) をバナー
を取り除きたいグループに追加することです。パラメーターは、消去されるテキ
ストに合致する正規表現として解釈される文字列か、(最後の) 署名を消去する
ためのシンボル @code{signature}、また
は @code{gnus-article-banner-alist} の正規表現に対応した他のシンボルのい
ずれかであることができます。

例えば:

@lisp
(setq gnus-article-banner-alist
      ((googleGroups .
       "^\n*--~--~---------\\(.+\n\\)+")))
@end lisp

グループにかかわらず、記事の送信者
が @code{gnus-article-address-banner-alist} で設定されている特定のメール
アドレスを持っているときだけ、広告のようなものを隠すことができます。

@table @code
@item gnus-article-address-banner-alist
@vindex gnus-article-address-banner-alist
メールアドレスとバナーの連想リストです。それぞれの要素
は @code{(@var{address} . @var{banner})} の形式を持ち、ここ
で @var{address} は From ヘッダーにあるメールアドレスに合致する正規表現
です。また、@var{banner} はシンボル @code{signature}、
@code{gnus-article-banner-alist} の要素、正規表現または @code{nil} のう
ちの一つです。@var{address} が著者のメールアドレスに合致すると、広告のよ
うなものを消します。例えば、送信者が @samp{hail@@yoo-hoo.co.jp} というメー
ルアドレスを持っていて、彼が送信するすべての記事に @samp{Do You
Yoo-hoo!?} のようなものがある場合、以下の要素でそれらを消すことができま
す。

@lisp
("@@yoo-hoo\\.co\\.jp\\'" . "\n_+\nDo You Yoo-hoo!\\?\n.*\n.*\n")
@end lisp
@end table

@item W W c
@kindex W W c @r{(概略)}
@findex gnus-article-hide-citation
引用文を隠します (@code{gnus-article-hide-citation})。隠蔽をカスタマイズ
するいくつかの変数は:

@table @code
@item gnus-cited-opened-text-button-line-format
@itemx gnus-cited-closed-text-button-line-format
@vindex gnus-cited-closed-text-button-line-format
@vindex gnus-cited-opened-text-button-line-format
Gnus はどこの引用文が隠されているかを示すためにボタンを付け加え、文章の
隠蔽を切り替えられるようにします。この変数の様式は、以下のフォーマットの
ような変数によって指定されます (@pxref{Formatting Variables})。次の指定
が有効です:

@table @samp
@item b
隠された文の最初のポイントです。
@item e
隠された文の最後のポイントです。
@item l
隠されたリージョンの文字の数です。
@item n
隠された文の行の数です。
@end table

@item gnus-cited-lines-visible
@vindex gnus-cited-lines-visible
隠さずに表示しておく、引用文の先頭からの行数です。これは、隠さずに表示す
る先頭からの行と、隠さずに表示する末尾からの行の、それぞれの数の cons セ
ルであることもできます。
@end table

@item W W C-c
@kindex W W C-c @r{(概略)}
@findex gnus-article-hide-citation-maybe
以下の二つの変数に依存して、引用文を隠しま
す (@code{gnus-article-hide-citation-maybe}):

@table @code
@item gnus-cite-hide-percentage
@vindex gnus-cite-hide-percentage
引用文の割合のパーセンテージが、この変数 (ディフォルトは 50) より大きかっ
たら、引用文を隠します。

@item gnus-cite-hide-absolute
@vindex gnus-cite-hide-absolute
隠される前に、引用文は少なくともこの長さ (ディフォルトは 10) でなければ
なりません。
@end table

@item W W C
@kindex W W C @r{(概略)}
@findex gnus-article-hide-citation-in-followups
根本でない記事の引用文を隠しま
す (@code{gnus-article-hide-citation-in-followups})。これは対話的命令と
してはあまり役に立たないかもしれませんが、自動的に実行させるには手軽な関
数でしょう (@pxref{Customizing Articles})。
@end table

これらのすべての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接頭
引数を与えると、それらは前に隠されていたものを表示します。正の接頭引数を
与えれば、それらは常に隠します。

引用文をカスタマイズするためのさらなる変数について、
@ref{Article Highlighting} も参照してください。

自動的に記事の要素を隠すための方法は @ref{Customizing Articles} を参照
してください。

@node Article Washing
@subsection 記事の洗濯
@cindex washing
@cindex article washing

私たちはこれをもっともな理由の下で『記事の洗濯』(article washing) と呼ん
でいます。@kbd{A} キーは使われていたので、代わりに @kbd{W} キーを使う必
要がありました。

「洗濯」は『何かの何かを何か別のものに変換する』と定義されますが、普通は
もっと良く見える何かに落ち着きます。もっときれいになります、たぶん。

Gnus が記事を表示するディフォルトのやり方を変えたいとき
は @ref{Customizing Articles} を参照してください。

@table @kbd
@item C-u g
これは洗濯ではなくて、その逆です。これをタイプすると、ディスクやサーバー
にあるがままの記事が見えます。

@item g
現在の記事の再表示を強制します (@code{gnus-summary-show-article})。これ
もまた本当の洗濯ではありません。これをタイプすると、以前に適用された対話
的な洗濯機能はご破算にされ、すべてのディフォルトのトリートメントを施され
た記事が表示されます (@pxref{Customizing Articles})。

@item W l
@kindex W l @r{(概略)}
@findex gnus-summary-stop-page-breaking
ページの区切りを現在の記事から取り除きま
す (@code{gnus-summary-stop-page-breaking})。ページの区切りに付いて
は @ref{Misc Article} を参照してください。

@item W r
@kindex W r @r{(概略)}
@findex gnus-summary-caesar-message
@c @icon{gnus-summary-caesar-message}
記事バッファーでカエサル変換 (Caesar rotate, rot13) を行ないま
す (@code{gnus-summary-caesar-message})。カエサル変換か rot13 を用いて読
むことを指定する、判読不可能な記事です (典型的には攻撃的な冗談などです。)

普通は“rot13”と呼ばれています。それはアルファベットの位置が 13 個回転
するからです。例えば、@samp{B} (2 番目の文字) → @samp{O} (15 番目の文字)。
これは時々『カエサル変換』と呼ばれることもあります。というのは、カエサル
がこの形式の、えーと、いささか貧弱な暗号化を採用したという噂があるからで
す。

@item W m
@kindex W m @r{(概略)}
@findex gnus-summary-morse-message
記事バッファーをモールスでデコードしま
す (@code{gnus-summary-morse-message})。

@item W i
@kindex W i @r{(概略)}
@findex gnus-summary-idna-message
現在の記事にある IDNA エンコードされたドメイン名をデコードします。
IDNA エンコードされたドメイン名は @samp{xn--bar} のように見えます。これ
を実行した後で文字列がデコードされないままだったら、おそらくそれは不正
な IDNA 文字列でしょう (@samp{xn--bar} は不正です)。このコマンドを動かす
ためには、GNU Libidn (@url{https://www.gnu.org/software/libidn/}) をイン
ストールしていなければなりません。

@item W t
@item t
@kindex W t @r{(概略)}
@kindex t @r{(概略)}
@findex gnus-summary-toggle-header
記事バッファーにすべてのヘッダーを表示するかどうかを切り替えま
す (@code{gnus-summary-toggle-header})。

@item W v
@kindex W v @r{(概略)}
@findex gnus-summary-verbose-headers
記事バッファーにすべてのヘッダーを永続的に表示するかどうかを切り替えま
す (@code{gnus-summary-verbose-headers})。

@item W o
@kindex W o @r{(概略)}
@findex gnus-article-treat-overstrike
オーバーストライクを処理します (@code{gnus-article-treat-overstrike})。

訳注: 以下のような重ね打ちを指示する文字列を bold や underline で表示し
ます。

@samp{B^HBo^Hol^Hld^Hd}, @samp{U^H_n^H_d^H_e^H_r^H_l^H_i^H_n^H_e^H_}

@item W d
@kindex W d @r{(概略)}
@findex gnus-article-treat-dumbquotes
@vindex gnus-article-dumbquotes-map
@cindex Smartquotes
@cindex M****s*** sm*rtq**t*s
@cindex Latin 1
@code{gnus-article-dumbquotes-map} に応じて、マ■■■ソ■
■ sm*rtq**t*s を処理します。この関数は文字が sm*rtq**t* かどうかを推測
するので、対話的にのみ使用されるべきであることに注意してください。

Sm*rtq**t*s はもっと多くの引用文字を提供するために、マ■■■ソ■■が勝手
に文字マップを拡張したものです。もし、アポストロフィ (') や引用記
号 (") などがあるべきところに @code{\222} や @code{\264} のようなものが
見えてしまったら、洗濯してみてください。

@item W U
@kindex W U @r{(概略)}
@findex gnus-article-treat-non-ascii
@cindex Unicode
@cindex Non-@acronym{ASCII}
多くの非-@acronym{ASCII} 文字をそれらと等価な @acronym{ASCII} 文字に変換
します (@code{gnus-article-treat-non-ascii})。これは、フォントに制限があっ
て、アクセント文字や「進んでいる」句読点などを表示しない端末では、たいて
いの場合に役立ちます。例えば @samp{≫} から @samp{>>} への変換などを行な
います。

@item W Y f
@kindex W Y f @r{(概略)}
@findex gnus-article-outlook-deuglify-article
@cindex Outlook Express
いかれた Outlook (Express) の記事を完全に醜くなくすること (訳
注: de-ugly-fy) (sm*rtq**t*s を処理、行の折り返しを解除、著者行の修復と
引用文の整頓) をします。
(@code{gnus-article-outlook-deuglify-article})。

@item W Y u
@kindex W Y u @r{(概略)}
@findex gnus-article-outlook-unwrap-lines
@vindex gnus-outlook-deuglify-unwrap-min
@vindex gnus-outlook-deuglify-unwrap-max
折り返された引用行のように見える行の折り返しを解きます。折り返しが解かれ
た行の最小および最大の長さを表
す @code{gnus-outlook-deuglify-unwrap-min} およ
び @code{gnus-outlook-deuglify-unwrap-max} を調整することによって、どん
な行の折り返しが解かれるかを制御することができます。
(@code{gnus-article-outlook-unwrap-lines})。

@item W Y a
@kindex W Y a @r{(概略)}
@findex gnus-article-outlook-repair-attribution
壊れた著者行を修復します。@*
(@code{gnus-article-outlook-repair-attribution})。

@item W Y c
@kindex W Y c @r{(概略)}
@findex gnus-article-outlook-rearrange-citation
壊れた引用文を、テキストを整理し直すことによって修復します。
(@code{gnus-article-outlook-rearrange-citation})。

@item W w
@kindex W w @r{(概略)}
@findex gnus-article-fill-cited-article
行を折り返します (@code{gnus-article-fill-cited-articles})。

折り返す幅を指定するために、命令に数値接頭引数を与えることができます。

@item W Q
@kindex W Q @r{(概略)}
@findex gnus-article-fill-long-lines
長い行を折り返します (@code{gnus-article-fill-mode-lines})。

@item W C
@kindex W C @r{(概略)}
@findex gnus-article-capitalize-sentences
それぞれの文の最初の語を大文字にしま
す (@code{gnus-article-capitalize-sentences})。

@item W c
@kindex W c @r{(概略)}
@findex gnus-article-remove-cr
CRLF の組 (すなわち、行の最後の @samp{^M}) を LF に変換します (これ
は DOS の行末の世話をします)。そうしてから残りの CR を LF に変換しま
す (これは MAC の行末の世話をします) (@code{gnus-article-remove-cr})。

@kindex W q @r{(概略)}
@findex gnus-article-de-quoted-unreadable
Quoted-printable を処理します (@code{gnus-article-de-quoted-unreadable})。
Quoted-Printable は 非-@acronym{ASCII} (すなわち 8-bit) の記事を送るとき
に使われる一般的な @acronym{MIME} エンコーディングです。それは概し
て @samp{déjà vu} のようなものを @samp{d=E9j=E0 vu} に見せるので、とても
読み辛くなります。問題の記事が、そのエンコーディングが行なわれたことを示
す @code{Content-Transfer-Encoding} ヘッダーを持っていれば、通常それ
は Gnus によって自動的に行なわれることに注意してください。接頭引数が与え
られると、文字セットが尋ねられます。

@item W 6
@kindex W 6 @r{(概略)}
@findex gnus-article-de-base64-unreadable
Base64 をデコードします (@code{gnus-article-de-base64-unreadable})。
Base64 は非-@acronym{ASCII} (すなわち 8-bit) の記事を送るときに使われる、
一般的な @acronym{MIME} エンコーディングです。問題の記事が、そのエンコー
ディングが行なわれたことを示す @code{Content-Transfer-Encoding} ヘッダー
を持っていれば、通常それは Gnus によって自動的に行なわれることに注意して
ください。接頭引数が与えられると、文字セットが尋ねられます。

@item W Z
@kindex W Z @r{(概略)}
@findex gnus-article-decode-HZ
HZ または HZP を処理します。HZ (または HZP) は中国語の記事を伝送するとき
に使われる一般的な符号です。これは @samp{~@{<:Ky2;S@{#,NpJ)l6HK!#~@}} の
ような典型的な文字列を作ります。

@item W A
@kindex W A @r{(概略)}
@findex gnus-article-treat-ansi-sequences
@cindex @acronym{ANSI} control sequences
@acronym{ANSI} SGR シーケンスを overlay または extent に変換しま
す (@code{gnus-article-treat-ansi-sequences})。@acronym{ANSI} シーケンス
は中国語のニュースグループで強調表示に使われています。

@item W u
@kindex W u @r{(概略)}
@findex gnus-article-unsplit-urls
URL に含まれる改行を削除します。いくつかのメイラーは、行を短くするために
出ていくメールに改行を挿入しますが、これは長い URL を複数の行に分割して
しまいます。改行を削除することによって、それらの URL を復旧させま
す (@code{gnus-article-unsplit-urls})。

@item W h
@kindex W h @r{(概略)}
@findex gnus-article-wash-html
@acronym{HTML} を処理します。当該メッセージが @acronym{HTML} であること
を示す @code{Content-Type} ヘッダーを持っていたならば、それは Gnus によっ
て自動的に行なわれることに注意してください。

接頭引数が与えられると、文字セットを尋ねられます。それがもし数値だったら、
@code{gnus-summary-show-article-charset-alist} (@pxref{Paging the
Article}) で定義されている文字セットが使われます。(訳注: 実質的には「文
字セット」ではなくて @code{coding-system} です。)

ディフォルトでは @acronym{HTML} の変換に @code{mm-text-html-renderer}
(@pxref{Display Customization, ,表示のカスタマイズ, emacs-mime-ja, The
Emacs MIME Manual}) で設定された関数を使います。使うことができる、あらか
じめ用意された関数は以下の通りです:

@table @code
@item shr
Gnus の簡易 html 描画器 (shr) を使います。

@item gnus-w3m
w3m を使って Gnus に描画させます。

@item w3m
@uref{http://emacs-w3m.namazu.org/, emacs-w3m} を使います。

@item w3m-standalone
@uref{http://w3m.sourceforge.net/, w3m} を使います。

@item links
@uref{http://links.sf.net/, Links} を使います。

@item lynx
@uref{http://lynx.isc.org/, Lynx} を使います。

@item html2text
html2text (シンプルな @acronym{HTML} コンバーターで、Gnus に含まれていま
す) を使います。
@end table

@item W b
@kindex W b @r{(概略)}
@findex gnus-article-add-buttons
クリックできるボタンを記事に加えます (@code{gnus-article-add-buttons})。
@xref{Article Buttons}.

@item W B
@kindex W B @r{(概略)}
@findex gnus-article-add-buttons-to-head
クリックできるボタンを記事のヘッダーに加えま
す (@code{gnus-article-add-buttons-to-head})。

@item W p
@kindex W p @r{(概略)}
@findex gnus-article-verify-x-pgp-sig
署名付きコントロールメッセージの認証を行ないま
す (@code{gnus-article-verify-x-pgp-sig})。
@code{newgroup} や @code{checkgroups} といったコントロールメッセージは、
通常そのニュースグループ階層のメインテイナーによって署名されています。認
証を行なうためには、メインテイナーの @acronym{PGP} 公開鍵をあなたのキー
リングに追加しなければなりません。@footnote{多くのニュースグループ階層の
メインテイナーの @acronym{PGP} の鍵
は @uref{https://ftp.isc.org/pub/pgpcontrol/README.html} から入手するこ
とができます。}

@item W s
@kindex W s @r{(概略)}
@findex gnus-summary-force-verify-and-decrypt
署名されたメッセージ (@acronym{PGP}, @acronym{PGP/MIME} また
は @acronym{S/MIME} によって) を検証しま
す (@code{gnus-summary-force-verify-and-decrypt})。@xref{Security}.

@item W a
@kindex W a @r{(概略)}
@findex gnus-article-strip-headers-in-body
記事の本文の先頭から @code{X-No-Archive} ヘッダーのようなヘッダーを取り
除きます (@code{gnus-article-strip-headers-in-body})。

@item W E l
@kindex W E l @r{(概略)}
@findex gnus-article-strip-leading-blank-lines
記事の先頭にあるすべての空白行を取り除きま
す (@code{gnus-article-strip-leading-blank-lines})。

@item W E m
@kindex W E m @r{(概略)}
@findex gnus-article-strip-multiple-blank-lines
すべての空白行を空行で置き換えてから、すべての複数の空行を一つの空行で置
き換えます (@code{gnus-article-strip-multiple-blank-lines})。

@item W E t
@kindex W E t @r{(概略)}
@findex gnus-article-remove-trailing-blank-lines
記事の最後にあるすべての空白行を取り除きま
す (@code{gnus-article-remove-trailing-blank-lines})。

@item W E a
@kindex W E a @r{(概略)}
@findex gnus-article-strip-blank-lines
上の三つの命令をすべて実行します (@code{gnus-article-strip-blank-lines})。

@item W E A
@kindex W E A @r{(概略)}
@findex gnus-article-strip-all-blank-lines
すべての空白行を取り除きます (@code{gnus-article-strip-all-blank-lines})。

@item W E s
@kindex W E s @r{(概略)}
@findex gnus-article-strip-leading-space
記事の本文のすべての行頭にあるすべての空白を取り除きま
す (@code{gnus-article-strip-leading-space})。

@item W E e
@kindex W E e @r{(概略)}
@findex gnus-article-strip-trailing-space
記事の本文のすべての行末にあるすべての空白を取り除きま
す (@code{gnus-article-strip-trailing-space})。
@end table

自動的に記事の洗濯を行なわせる方法は @ref{Customizing Articles} を参照し
てください (訳注: 実は多くの洗濯がディフォルトで自動的に行なわれます)。

@node Article Header
@subsection 記事ヘッダー

これらのコマンドは記事ヘッダーをいろいろに変形させます。

@table @kbd
@item W G u
@kindex W G u @r{(概略)}
@findex gnus-article-treat-unfold-headers
折り返されたヘッダー行を一行にしま
す (@code{gnus-article-treat-unfold-headers})。

@item W G n
@kindex W G n @r{(概略)}
@findex gnus-article-treat-fold-newsgroups
@code{Newsgroups} と @code{Followup-To} ヘッダーを折り返しま
す (@code{gnus-article-treat-fold-newsgroups})。

@item W G f
@kindex W G f @r{(概略)}
@findex gnus-article-treat-fold-headers
すべてのメッセージヘッダーを折り返しま
す (@code{gnus-article-treat-fold-headers})。

@item W E w
@kindex W E w @r{(概略)}
@findex gnus-article-remove-leading-whitespace
すべてのヘッダーから余分な空白を取り除きま
す (@code{gnus-article-remove-leading-whitespace})。
@end table

@node Article Buttons
@subsection 記事のボタン
@cindex buttons

人々はよく記事の中に他の資料を参照するための案内を入れることがありますが、
それらの参照への案内の上で @kbd{@key{RET}} を打つか、マウスの真中のボタ
ンを使ったときに、彼らが話題にしているのが何であれ、最小限の曖昧さ
で Gnus が取得することができれば素敵でしょう。

@vindex gnus-button-man-handler
特定の標準的な参照に、Gnus はディフォルトで「ボタン」を付けます: ちゃん
とした URL、メールアドレス、Message-ID、Info へのリンク、man ページ、そ
れに関連する Emacs または Gnus の参考文献です。これは二つの変数によって
制御されていて、その一つは記事の本文を扱い、もう一つは記事のヘッダーを扱
います。

@table @code
@item gnus-button-alist
@vindex gnus-button-alist
それぞれの要素が次のような様式を持つ連想リストです:

@lisp
(@var{regexp} @var{button-par} @var{use-p} @var{function} @var{data-par})
@end lisp

@table @var
@item regexp
この正規表現 (大文字と小文字は区別されません) に合致するすべてのテキスト
は、外部への参照であるとみなされます。これは埋め込まれた URL に合致する
典型的な正規表現です: @samp{<URL:\\([^\n\r>]*\\)>}。これはまた正規表現の
値を持つ変数であってもよく、有用な変数とし
て @code{gnus-button-url-regexp} およ
び @code{gnus-button-mid-or-mail-regexp} があります。

@item button-par
Gnus は合致したもののどの部分がハイライトされるのかを知らなければなりま
せん。これは正規表現のどの副表現がハイライトされるかを指定する番号です。
すべてをハイライトしたいのなら、ここで 0 を使ってください。

@item use-p
この式は @code{評価} され、結果が @code{nil} でなかったら、これは合致で
あるとみなされます。これは間違った合致を避けるために特別な選別をしたいと
きに役に立ちます。ここではしばしば @code{gnus-button-@var{*}-level} のよ
うな名前の変数が使われますが、@xref{Article Button Levels}, 他のどんな形
式でも使うことができます。
@c
@c @code{use-p} is @code{eval}ed only if @code{regexp} matches.

@item function
この関数が、このボタンをクリックしたときに呼ばれます。

@item data-par
@var{button-par} のように、これは部分表現の番号ですが、これは合致のどの
部分が @var{function} にデータとして送られるかを指定します。
@end table

したがって URL をボタンにする完全な要素は、こうなります。

@lisp
("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)
@end lisp

@item gnus-header-button-alist
@vindex gnus-header-button-alist
これは他の連想リストと同じようなものですが、記事のヘッダーだけに適用され
ることと、それぞれの項目がどのヘッダーにボタンを付けるかを指示するための
追加の要素を持っていることが異なります:

@lisp
(@var{header} @var{regexp} @var{button-par} @var{use-p} @var{function} @var{data-par})
@end lisp

@var{header} は正規表現です。
@end table

@subsubsection 関連する変数と関数

@table @code
@item gnus-button-@var{*}-level
@ref{Article Button Levels} を参照してください。
@c
@c Stuff related to gnus-button-browse-level

@item gnus-button-url-regexp
@vindex gnus-button-url-regexp
埋め込まれた URL に合致する正規表現です。上述の変数のディフォルトの値で
使われます。
@c
@c Stuff related to gnus-button-man-level

@item gnus-button-man-handler
@vindex gnus-button-man-handler
Man ページの表示に使う関数です。少なくとも一つの引数として Man ページの
名前の文字列を受け付けなければなりません。
@c
@c Stuff related to gnus-button-message-level

@item gnus-button-mid-or-mail-regexp
@vindex gnus-button-mid-or-mail-regexp
Message-ID かメールアドレスに合致する正規表現です。

@item gnus-button-prefer-mid-or-mail
@vindex gnus-button-prefer-mid-or-mail
この変数は @samp{foo123@@bar.invalid} のような文字列のボタンが押されたと
きに、何を行なうかを決める変数です。このような文字列は Message-ID かメー
ルアドレスのいずれかです。もし @code{mid} か @code{mail} というシンボル
のうちの一つだったら、Gnus は常にそれぞれ文字列が Message-ID またはメー
ルアドレスであると仮定します。この変数が @code{ask} というシンボルに設定
されると、Gnus はいつも利用者が何をしたいかを尋ねます。それが関数だった
場合、たった一つの文字列を引数として呼ばれます。その関数は @code{mid}、
@code{mail}、@code{invalid} または @code{ask} を返さなければなりません。
ディフォルト値は関数 @code{gnus-button-mid-or-mail-heuristic} です。

@item gnus-button-mid-or-mail-heuristic
@findex gnus-button-mid-or-mail-heuristic
その引数がメッセージの ID かメールアドレスであるかを推定する関数です。
メッセージの ID だったら @code{mid} を、メールアドレスだった
ら @code{mail} を、不確かだったら @code{ask} を、そして無効な文字列だっ
たら @code{invalid} を返します。

@item gnus-button-mid-or-mail-heuristic-alist
@vindex gnus-button-mid-or-mail-heuristic-alist
関数 @code{gnus-button-mid-or-mail-heuristic} で使われる @code{(RATE
. REGEXP)} 対の連想リストです。
@c
@c Misc stuff

@item gnus-article-button-face
@vindex gnus-article-button-face
ボタンに使われるフェースです。

@item gnus-article-mouse-face
@vindex gnus-article-mouse-face
マウスのカーソルがボタンの上にあるときに使われるフェースです。
@end table

記事に自動的にボタンを付ける方法は、@ref{Customizing Articles} を参照し
てください。

@node Article Button Levels
@subsection 記事ボタンのレベル
@cindex button levels

変数 @code{gnus-button-@var{*}-level} の値が高いほど、より多くのボタンが
現れます。レベルがゼロだったらボタンは表示されません。ディフォルト
値 (それは 5) では、とてもたくさんのボタンをすでに見ているはずです。高い
レベルではより多くのボタンを見ることになりますが、多くの要らないものも現
れるかもしれません。それらを避けるために、特定のグループに対して変
数 @code{gnus-button-@var{*}-level} を設定しても良いでしょ
う (@pxref{Group Parameters})。@code{gnus-parameters} 変数の例です:

@lisp
;; @r{いくつかのグループで @code{gnus-button-*-level} を増やす:}
(setq gnus-parameters
      '(("\\<\\(emacs\\|gnus\\)\\>" (gnus-button-emacs-level 10))
        ("\\<unix\\>"               (gnus-button-man-level 10))
        ("\\<tex\\>"                (gnus-button-tex-level 10))))
@end lisp

@table @code
@item gnus-button-browse-level
@vindex gnus-button-browse-level
Message-ID、メールアドレスおよびニュースの URL を参照する案内の表示を制
御します。関連する変数と関数には @code{gnus-button-url-regexp}、
@code{browse-url} および @code{browse-url-browser-function} があります。

@item gnus-button-emacs-level
@vindex gnus-button-emacs-level
Emacs または Gnus への参照の表示を制御します。関連する関数は、
@code{gnus-button-handle-custom},
@code{gnus-button-handle-describe-function},
@code{gnus-button-handle-describe-variable},
@code{gnus-button-handle-symbol},
@code{gnus-button-handle-describe-key},
@code{gnus-button-handle-apropos},
@code{gnus-button-handle-apropos-command},
@code{gnus-button-handle-apropos-variable},
@code{gnus-button-handle-apropos-documentation} およ
び @code{gnus-button-handle-library} です。

@item gnus-button-man-level
@vindex gnus-button-man-level
(Unix の) man ページへの参照の表示を制御します。
@code{gnus-button-man-handler} を見てください。

@item gnus-button-message-level
@vindex gnus-button-message-level
Message-ID、メールアドレスおよびニュースの URL の表示を制御します。関連
する変数と関数に
は @code{gnus-button-mid-or-mail-regexp},
@code{gnus-button-prefer-mid-or-mail},
@code{gnus-button-mid-or-mail-heuristic} およ
び @code{gnus-button-mid-or-mail-heuristic-alist} があります。
@end table

@node Article Date
@subsection 記事の日付

日付は聞いたことの無い何か辺鄙なタイムゾーンで作成されていることが良くあ
るので、記事が送られたときに何時だったかを知ることができるのはとても良い
ことです。

@table @kbd
@item W T u
@kindex W T u @r{(概略)}
@findex gnus-article-date-ut
UT (別名 GMT, ZULU) で日付を表示します (@code{gnus-article-date-ut})。

@item W T i
@kindex W T i @r{(概略)}
@findex gnus-article-date-iso8601
@cindex ISO 8601
日付を国際的な形式、ISO 8601 で表示しま
す (@code{gnus-article-date-iso8601})。

@item W T l
@kindex W T l @r{(概略)}
@findex gnus-article-date-local
日付をローカル・タイムゾーンで表示しま
す (@code{gnus-article-date-local})。

@item W T p
@kindex W T p @r{(概略)}
@findex gnus-article-date-english
日付を英語で楽に発音できる形式で表示しま
す (@code{gnus-article-date-english})。

@item W T s
@kindex W T s @r{(概略)}
@vindex gnus-article-time-format
@findex gnus-article-date-user
@findex format-time-string
日付を利用者定義の様式を使って表示します (@code{gnus-article-date-user})。
その様式は変数 @code{gnus-article-time-format} で指定される、
@code{format-time-string} に渡される文字列です。指定することができる様式
の一覧は、変数の説明文を見てください。

@item W T e
@kindex W T e @r{(概略)}
@findex gnus-article-date-lapsed
@findex gnus-start-date-timer
@findex gnus-stop-date-timer
記事が投稿されてから今までどれくらいの時間が経過したかを表示しま
す (@code{gnus-article-date-lapsed})。こんなふうに。

@example
Date: 6 weeks, 4 days, 1 hour, 3 minutes, 8 seconds ago
@end example

この行を絶えず更新させるためには、頻度を秒数
で @code{gnus-article-update-date-headers} 変数に設定してください (ディ
フォルトは @code{nil} です)。

@item W T o
@kindex W T o @r{(概略)}
@findex gnus-article-date-original
本来の日付を表示します (@code{gnus-article-date-original})。これはあなた
が普段は他の変換関数を使っていて、それが完全に間違ったことをしているので
はないかと心配になったときに役に立ちます。例えば、記事が 1854年に投稿さ
れたと主張したとしましょう。しかし、そのようなことは @emph{完全に } 不可
能です。私が信用できませんか? *くすくす*
@end table

好みの書式で自動的に日付を表示する方法は @ref{Customizing Articles} を参
照してください。

@node Article Display
@subsection 記事に表示するもの
@cindex picons
@cindex x-face
@cindex smileys
@cindex gravatars

これらのコマンドは、いろんな取るに足らないギミック (gimmicks) の表示を、
それらをサポートしている Emacs の記事バッファーに追加します。

@code{X-Face} ヘッダーは小さな白黒画像で、メッセージヘッダーから持ってき
ます (@pxref{X-Face})。

@code{Face} ヘッダーは小さなカラー画像で、メッセージヘッダーから持ってき
ます (@pxref{Face})。

スマイリーは、人々がメッセージに散らかしたがる小さな @samp{:-)} シンボル
です。

一方 Picon はあなた自身のシステムに依存し、Gnus はヘッダーに合致するあな
たの持ち物を探してみます (@pxref{Picons})。

Gravatars は @uref{http://www.gravatar.com/} からオンラインで取得しま
す (@pxref{Gravatars})。

これらすべての機能はトグルです。もしすでにそれらが存在していたならば、そ
れらは削除されます。

@table @kbd
@item W D x
@kindex W D x @r{(概略)}
@findex gnus-article-display-x-face
@code{X-Face} を @code{From} ヘッダーに表示しま
す (@code{gnus-article-display-x-face})。

@item W D d
@kindex W D d @r{(概略)}
@findex gnus-article-display-face
@code{Face} を @code{From} ヘッダーに表示しま
す (@code{gnus-article-display-face})。

@item W D s
@kindex W D s @r{(概略)}
@findex gnus-treat-smiley
スマイリーを表示します (@code{gnus-treat-smiley})。

@item W D f
@kindex W D f @r{(概略)}
@findex gnus-treat-from-picon
@code{From} ヘッダーを Picon 化します (@code{gnus-treat-from-picon})。

@item W D m
@kindex W D m @r{(概略)}
@findex gnus-treat-mail-picon
すべてのメールヘッダー (すなわち @code{Cc}、@code{To}) を Picon 化しま
す (@code{gnus-treat-mail-picon})。

@item W D n
@kindex W D n @r{(概略)}
@findex gnus-treat-newsgroups-picon
すべてのニュースヘッダー (すなわ
ち @code{Newsgroups} と @code{Followup-To}) を Picon 化しま
す (@code{gnus-treat-newsgroups-picon})。

@item W D g
@kindex W D g @r{(概略)}
@findex gnus-treat-from-gravatar
@code{From} ヘッダーをアバター化します (@code{gnus-treat-from-gravatar})。

@item W D h
@kindex W D h @r{(概略)}
@findex gnus-treat-mail-gravatar
メールヘッダーぜんぶ (つまり @code{Cc}、@code{To}) をアバター化しま
す (@code{gnus-treat-from-gravatar})。

@item W D D
@kindex W D D @r{(概略)}
@findex gnus-article-remove-images
記事バッファーからすべての画像を削除しま
す (@code{gnus-article-remove-images})。

@item W D W
@kindex W D W @r{(概略)}
@findex gnus-html-show-images
@code{gnus-article-html} で描画した @acronym{HTML} 記事を読んでいるとき
に、阻止された画像をこのコマンドでバッファーに挿入することができま
す (@code{gnus-html-show-images})。
@end table

@node Article Signature
@subsection 記事の署名
@cindex signatures
@cindex article signature

@vindex gnus-signature-separator
それぞれの記事は二つの部分に分けられます---ヘッダーと本文です。本文は署
名部分と文章部分に分けることができます。どれが署名とみなされるかを決める
変数は @code{gnus-signature-separator} です。これは普通は RFC 5536 で規
定されている標準の @samp{^-- $} です。しかし、多くの人が標準ではない署名
セパレーターを使うので、この変数は一つ一つ試される、正規表現のリストであ
ることもできます。(探索は本文の最後から始めへとなされます。) よくありそ
うな値は:

@lisp
(setq gnus-signature-separator
      '("^-- $"         ; @r{標準}
        "^-- *$"        ; @r{普通の崩し方}
        "^-------*$"    ; @r{多くの人は長ーーい横棒の}
                        ; @r{行を使います。みっともない!}
        "^ *--------*$" ; @r{二倍みっともない!}
        "^________*$"   ; @r{下線も人気があります}
        "^========*$")) ; @r{邪道!}
@end lisp

あなたが寛容であればあるほど、間違った結果を得ることになるでしょう。

@vindex gnus-signature-limit
@code{gnus-signature-limit} は記事を表示するときにどれが署名とみなされる
かへの制限を提供します。

@enumerate
@item
これが整数であれば、署名はこの整数より (文字数で) 長くなっていてはいけま
せん。
@item
これが浮動小数点数であれば、署名はその数値より (行数で) 長くなっていては
いけません。
@item
これが関数であれば、その関数は引数なしで呼ばれ、それが @code{nil} を返せ
ば、そのバッファーには署名がありません。
@item
これが文字列であれば、それは正規表現として使われます。もしそれが合致すれ
ば、当のその文字列は署名ではありません。
@end enumerate

この変数は、要素が上に列挙された型のリストであることもできます。例です:

@lisp
(setq gnus-signature-limit
      '(200.0 "^---*Forwarded article"))
@end lisp

これは署名セパレーターの後に 200 を超える行があるか、セパレーターの後の
テキストが正規表現 @samp{^---*Forwarded article} に合致すれば、結局それ
は署名ではないということです。

@node Article Miscellanea
@subsection 記事いろいろ

@table @kbd
@item A t
@kindex A t @r{(概略)}
@findex gnus-article-babel
記事をある言語から別のものへ変換します (@code{gnus-article-babel})。
@end table

@node MIME Commands
@section MIME コマンド
@cindex MIME decoding
@cindex attachments
@cindex viewing attachments

以下のコマンドはすべて数値接頭引数を理解します。例えば @kbd{3 K v} は
「三番目の @acronym{MIME} パートを表示する」という意味です。

@table @kbd
@item b
@itemx K v
@kindex b @r{(概略)}
@kindex K v @r{(概略)}
@acronym{MIME} パートを表示します。

@item K o
@kindex K o @r{(概略)}
@acronym{MIME} パートを保存します。

@item K O
@kindex K O @r{(概略)}
ファイル名の入力を求めてから @acronym{MIME} パートを保存し、それを記事か
ら取り除きます。取り除かれた @acronym{MIME} オブジェクト
は message/external-body 型の @acronym{MIME} 形式として参照されるように
なります。

@item K r
@kindex K r @r{(概略)}
@acronym{MIME} パートを外部にある本体で置き換えます。

@item K d
@kindex K d @r{(概略)}
@acronym{MIME} パートを削除して、削除したことの案内を追加します。

@item K c
@kindex K c @r{(概略)}
@acronym{MIME} パートをコピーします。

@item K e
@kindex K e @r{(概略)}
@acronym{MIME} パートを外部コマンドで表示します。

@item K i
@kindex K i @r{(概略)}
@acronym{MIME} パートをバッファー内に表示します。

@item K |
@kindex K | @r{(概略)}
@acronym{MIME} パートを外部コマンドにパイプします。
@end table

以降の @acronym{MIME} コマンドの残りは、数値接頭引数を同じやり方では使い
ません:

@table @kbd
@item K H
@kindex K H @r{(概略)}
@findex gnus-article-browse-html-article
現在の記事の @samp{text/html} パートを WWW ブラウザーで見ます。メッセー
ジに @code{cid} 形式で埋め込まれたインライン画像は一般に安全だと考えられ
ているので適切に処理されます。接頭引数が与えられなければ、すべて
の @acronym{HTML} パートの先頭に記事のヘッダーが加えられます。

警告: Spammers は @acronym{HTML} 記事中の画像への (@code{http} 形式
の) リンクを、あなたがその記事を読んだかどうかを確かめるために使います。
このコマンドは @acronym{HTML} 記事からその手の ``web bugs'' を取り除かな
いでブラウザーに渡すので、このコマンドは信頼できる送信者からのメールでだ
け使うべきです。

このコマンドは画像を含む @acronym{HTML} コンテンツをブラウザーに渡すため
に一時ファイルを作り、グループを抜け出るときに (もしあなたが望めば) それ
らを削除します。

@item K b
@kindex K b @r{(概略)}
すべての @acronym{MIME} パートの先頭にボタンを付加します。埋め込まれたパー
トをセーブ (または他の動作を実行) しようとするときに、たいてい便利です。

@item W M h
@kindex W M h @r{(概略)}
@findex gnus-mime-buttonize-attachments-in-header
@vindex gnus-mime-display-attachment-buttons-in-header
@acronym{MIME} パート・ボタンを記事のヘッダーの最後に表示しま
す (@code{gnus-mime-buttonize-attachments-in-header})。このコマンドは表
示をトグルで切り替えます。ヘッダーに加えられるボタンは記事のボディーでイ
ンライン表示できないものだけです。ボタンを常に表示したいな
ら @code{gnus-mime-display-attachment-buttons-in-header} を @code{nil} 以
外の値にしてください。ディフォルトは @code{t} です。ボタンの見栄えを変え
るには、@code{gnus-header-face-alist} をカスタマイズしてください。

@item K m
@kindex K m @r{(概略)}
@findex gnus-summary-repair-multipart
ときたま、ヘッダーが無かったり間違ったヘッダーを持つマルチパートのメッセー
ジが送信されてきます。このコマンドは、それらのメッセージがより快適に表示
されるように「修復」を試みます (@code{gnus-summary-repair-multipart})。

@item X m
@kindex X m @r{(概略)}
@findex gnus-summary-save-parts
@acronym{MIME} タイプに合致するすべてのパートを、ディレクトリーにセーブ
します (@code{gnus-summary-save-parts})。プロセス/接頭引数の習慣を理解し
ます (@pxref{Process/Prefix})。

@item M-t
@kindex M-t @r{(概略)}
@findex gnus-summary-toggle-display-buttonized
記事バッファーにボタンを表示するかしないかを切り替えまま
す (@code{gnus-summary-toggle-display-buttonized})。

@item W M w
@kindex W M w @r{(概略)}
@findex gnus-article-decode-mime-words
記事ヘッダーにある RFC 2047 でエンコードされた語をデコードしま
す (@code{gnus-article-decode-mime-words})。

@item W M c
@kindex W M c @r{(概略)}
@findex gnus-article-decode-charset
エンコードされた記事の本文を、文字セットでデコードしま
す (@code{gnus-article-decode-charset})。

このコマンドは、文字セットを決めるために @code{Content-Type} ヘッダーを
調べます。記事にそんなヘッダーが無い場合でも、接頭引数を与えることによっ
て、デコードするための文字セットを入力することは可能です。ある共通のエン
コーディングを使って (でも @acronym{MIME} ヘッダーは含めずに) 人々が記事
を投稿する地域的なグループでは、@code{charset} グループ/トピック・パラメー
ターに必要な文字セットを設定すれば良いでしょう (@pxref{Group
Parameters})。

@item W M v
@kindex W M v @r{(概略)}
@findex gnus-mime-view-all-parts
現在の記事にある、すべての @acronym{MIME} パートを表示しま
す (@code{gnus-mime-view-all-parts})。
@end table

関連する変数:

@table @code
@item gnus-ignored-mime-types
@vindex gnus-ignored-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプは、Gnus によって完全に無視されます。ディフォル
ト値は @code{nil} です。

すべての Vcard を無視させるには、こんなふうにしてください:

@lisp
(setq gnus-ignored-mime-types
      '("text/x-vcard"))
@end lisp

@item gnus-article-loose-mime
@vindex gnus-article-loose-mime
非-@code{nil} だったら、Gnus は記事を @acronym{MIME} メッセージとして解
読する前に、@samp{MIME-Version} があることを必要としません。これは、ある
壊れたメール・ユーザー・エージェントからのメッセージを読むときに役立ちま
す。ディフォルトは @code{t} です。

@item gnus-article-emulate-mime
@vindex gnus-article-emulate-mime
@cindex uuencode
@cindex yEnc
@acronym{MIME} ではない別のエンコーディングの手法があります。最も一般的
なのは @samp{uuencode} ですが、yEncode も普及してきています。この変数が
非-@code{nil} になっていると、Gnus はメッセージの本文にそれらのエンコー
ディングが見つかるかどうかを調べ、もしあったならば、それら
を Gnus の @acronym{MIME} 機構で処理します。ディフォルトは @code{t} です。
デコードできるのは単一の yEnc でエンコードされたパートだけです。Gnus は
エンコードについてはサポートしません。

@item gnus-unbuttonized-mime-types
@vindex gnus-unbuttonized-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプには、ボタンが付加されません。ただし、それらが表
示されないか、@code{gnus-buttonized-mime-types} 変数の方が優先される場合
を除いて、ですが。ディフォルト値は @code{(".*/.*")} です。この変数
は @code{gnus-inhibit-mime-unbuttonizing} が @code{nil} のときだけ使われ
ます。

@item gnus-buttonized-mime-types
@vindex gnus-buttonized-mime-types
これは正規表現のリストで、これに含まれている正規表現に合致す
る @acronym{MIME} タイプには、それらが表示されない場合を除いて、ボタンが
付加されます。この変数は @code{gnus-unbuttonized-mime-types} よりも優先
されます。ディフォルト値は @code{nil} です。この変数
は @code{gnus-inhibit-mime-unbuttonizing} が @code{nil} のときだけ使われ
ます。

例えば、セキュリティーのボタンだけを表示して、他のボタンを表示しないよう
にするには、この変数を @code{("multipart/signed")} に設定して、
@code{gnus-unbuttonized-mime-types} はディフォルト値のままにしておいてく
ださい。

また、このリストに @code{"multipart/alternative"} を加えることによって、
そういうメールに含まれている二つのメディア・タイプのうちの一つを選ぶこと
ができる、ラジオボタンを表示させることができます。
@code{mm-discouraged-alternatives} も参照してください (@pxref{Display
Customization, ,表示のカスタマイズ, emacs-mime-ja, The Emacs MIME
Manual})。

@item gnus-inhibit-mime-unbuttonizing
@vindex gnus-inhibit-mime-unbuttonizing
これが非-@code{nil} だと、すべての @acronym{MIME} パートにボタンを付加し
ます。ディフォルト値は @code{nil} です。

@item gnus-article-mime-part-function
@vindex gnus-article-mime-part-function
それぞれの @acronym{MIME} パートに対して、この関数が @acronym{MIME} ハン
ドル (訳注: パートのタイプや内容物を表現するために、Gnus の内部で使われ
るデータの構造体) を引数にして呼ばれます。この関数は、利用者が記事から情
報を集め (例えば Vcard の情報を bbdb のデータベースに加え) たり、パート
に基づいて何かを起動 (例えば、すべての jpeg をあるディレクトリーにセー
ブ) するために使われることが意図されています。

後者を行なう関数の例です:

@lisp
(defun my-save-all-jpeg-parts (handle)
  (when (equal (car (mm-handle-type handle)) "image/jpeg")
    (with-temp-buffer
      (insert (mm-get-part handle))
      (write-region (point-min) (point-max)
                    (read-file-name "Save jpeg to: ")))))
(setq gnus-article-mime-part-function
      'my-save-all-jpeg-parts)
@end lisp

@vindex gnus-mime-multipart-functions
@item gnus-mime-multipart-functions
@acronym{MIME} マルチパートの型と、それらを扱う関数の連想リストです。

@vindex gnus-mime-display-multipart-alternative-as-mixed
@item gnus-mime-display-multipart-alternative-as-mixed
"multipart/alternative" のパートを "multipart/mixed" であるものとして表
示します。

@vindex gnus-mime-display-multipart-related-as-mixed
@item gnus-mime-display-multipart-related-as-mixed
"multipart/related" のパートを "multipart/mixed" であるものとして表示し
ます。

もし @samp{text/html} を表示するのが気に入らないのなら、
@code{mm-discouraged-alternatives} を参照してください。ただし (それ
で "text/html" を表示しないように設定して、かつ) この変数
が @code{nil} だと、"multipart/related" パートの中にある画像や他の資料を
見逃してしまうかもしれません。@xref{Display Customization,
,表示のカスタマイズ, emacs-mime-ja, The Emacs MIME Manual}.

@vindex gnus-mime-display-multipart-as-mixed
@item gnus-mime-display-multipart-as-mixed
"multipart" のパートを "multipart/mixed" であるものとして表示します。も
し @code{t} だと、
@code{gnus-mime-display-multipart-alternative-as-mixed} およ
び @code{gnus-mime-display-multipart-related-as-mixed} が @code{nil} で
あっても、この設定の方が優先されます。

@vindex mm-file-name-rewrite-functions
@item mm-file-name-rewrite-functions
@acronym{MIME} パートのファイル名を書き換えるために使われる関数のリスト
です。それぞれの関数はファイル名を受け取って、ファイル名を返します。

出来合いの関数は@*
@code{mm-file-name-delete-whitespace},
@code{mm-file-name-trim-whitespace},
@code{mm-file-name-collapse-whitespace} およ
び @code{mm-file-name-replace-whitespace} です。最後のものはファイル名に
含まれるそれぞれの空白文字を、変
数 @code{mm-file-name-replace-whitespace} の値で置き換えます。ディフォル
ト値は @code{"_"} (単一の下線) です。
@findex mm-file-name-delete-whitespace
@findex mm-file-name-trim-whitespace
@findex mm-file-name-collapse-whitespace
@findex mm-file-name-replace-whitespace
@vindex mm-file-name-replace-whitespace

標準の関数である @code{capitalize}, @code{downcase}, @code{upcase} およ
び @code{upcase-initials} も、役に立つでしょう。

ファイル名に含まれる空白文字が害をもたらすことは、みんなが知っています。
ただし、気にかけない人たちを除いて、ですが。そんな蒙昧の人たちから、たく
さんの添付ファイルを受け取るのであれば、こんなもの
を @file{~/.gnus.el} ファイルに追加することによって、安寧な生活を送るこ
とができるでしょう。

@lisp
(setq mm-file-name-rewrite-functions
      '(mm-file-name-trim-whitespace
        mm-file-name-collapse-whitespace
        mm-file-name-replace-whitespace))
@end lisp
@end table

@node Charsets
@section 文字セット
@cindex charsets

人々はいろいろな文字セットを使いますが、私たちは彼らが何の文字セットを使っ
ているかを教えてくれる @acronym{MIME} を持っています。あるいはもっと正確
に言えば、持っていたらいいなあと思います。多くの人たち
が @acronym{MIME} を利用しないか理解しないニュースリーダーとメイラーを使っ
て、何の文字セットを使うかを言わずに、単にメッセージを送出するのですが、
これを少しばかり救済するために、いくつかの地域的なニュース階層には、何の
文字セットがディフォルトであるかを宣言する取り決めがあります。例え
ば @samp{fj} 階層では @code{iso-2022-jp} を使っています。

@vindex gnus-group-charset-alist
この知識は @code{gnus-group-charset-alist} 変数にエンコードされています。
これは正規表現 (グループのフルネームに合致した最初の項目を使います) と、
それらのグループを講読するときに使われるディフォルトの文字セットの、連想
リストです。

@vindex gnus-newsgroup-ignored-charsets
加えて、人々のいくらかは @acronym{MIME} を意識していると自
称 (soi-disant) しているくせに、実はそうではないエージェントを使っていま
す。それらは、実際にはメッセージが @code{koi-8} なの
に @code{iso-8859-1} だと、陽気にメッセージに刻印するのです。ここでは救
済のために @code{gnus-newsgroup-ignored-charsets} 変数を使うことができま
す。そのリストに連ねられた文字セットは無視されます。この変数は、グループ
パラメーター (@pxref{Group Parameters}) を使って、グループ毎に設定するこ
とができます。ディフォルト値は @code{(unknown-8bit x-unknown)} で、それ
はいくつかのエージェントが内蔵し、主張する値を含んでいます。

@vindex gnus-group-posting-charset-alist
投稿する場合に、@acronym{MIME} でエンコードしてはいけない文字セットを判
定するために、@code{gnus-group-posting-charset-alist} が使われます。例え
ばいくつかの階層では、quoted-printable でヘッダーをエンコードすることは
嫌われます。

この変数は正規表現と、投稿に際してエンコードしなくても良いことを許され
た (またはエンコードすることが嫌われる) 文字セットの連想リストです。それ
ぞれの要素は @code{(}@var{test header body-list}@code{)} の形式であり、
それらは次の意味を持ちます。

@table @var
@item test
Newsgroups ヘッダーに合致する正規表現、または変数シンボルのどちらかです。
後者の場合は、その値を調べた結果が非-@code{nil} だったら、その要素が採用
されることになります。
@item header
ヘッダーをエンコードしなくても良い文字セットです (@code{nil} は、すべて
の文字セットをエンコードすることを意味します)。
@item body-list
“Content-Transfer-Encoding: 8bit”でもって本文をエンコードしても良
い (または quoted-printable や base64 でエンコードすることが嫌われる) 文
字セットのリスト、または特別な値の一つである @code{nil} (常
に quoted-printable でエンコードする)、または @code{t} (常に
“Content-Transfer-Encoding: 8bit”を使う) です。
@end table

@cindex Russian
@cindex koi8-r
@cindex koi8-u
@cindex iso-8859-5
@cindex coding system aliases
@cindex preferred charset
メッセージを送信するときに何の文字セットが使われるかを制御する付加的な変
数については、@xref{Encoding Customization,
,エンコーディングのカスタマイズ, emacs-mime-ja, The Emacs MIME
Manual}, を参照してください (訳注: 特に日本語のメッセージの文字セットに
ついては、例えば変数 @code{mm-coding-system-priorities} を参照してくださ
い)。

Gnus 固有ではないけれど、役に立つかもしれない文字セットに関する他の秘訣:

もし、同一の Emacs の文字セットをエンコードする @acronym{MIME} の文字セッ
トが複数あるのならば、以下の宣言を使うことによって、使う文字セットを選択
することができます:

@lisp
(put-charset-property 'cyrillic-iso8859-5
                      'preferred-coding-system 'koi8-r)
@end lisp

これは、ロシア語がディフォルトの @code{iso-8859-5} @acronym{MIME} 文字セッ
トの代わりに、@code{koi8-r} でエンコードされることを意味します。

メッセージを @code{koi8-u} で読みたいのであれば、以下のように騙すことが
できます。

@lisp
(define-coding-system-alias 'koi8-u 'koi8-r)
@end lisp

これは、ほとんど正しいことをするでしょう。

そして最後に、@code{windows-1251} のような文字セットを読むには、次のよう
に宣言すれば良いでしょう (訳注: Emacs の版によっては、
@code{windows-1251} が最初から実装されています)。

@lisp
(codepage-setup 1251)
(define-coding-system-alias 'windows-1251 'cp1251)
@end lisp

@node Article Commands
@section 記事命令

@table @kbd
@item A P
@cindex PostScript
@cindex printing
@kindex A P @r{(概略)}
@vindex gnus-ps-print-hook
@findex gnus-summary-print-article
記事バッファーのポストスクリプト (PostScript) イメージを作成して印刷しま
す (@code{gnus-summary-print-article})。@code{gnus-ps-print-hook} がバッ
ファーを印刷する直前に実行されます。他に Muttprint を使って印刷すること
もできます (@pxref{Saving Articles})。

@item A C
@vindex gnus-fetch-partial-articles
@findex gnus-summary-show-complete-article
もし @code{<backend>-fetch-partial-articles} が @code{nil} 以外の値だっ
たら、バックエンドがサポートしていれば Gnus は記事の部分を取り込みます。
今のところ @code{nnimap} だけが行ないます。もし記事の部分を見ているとき
に、そうではなく完全な記事を見る必要があるならば、@kbd{A C} コマン
ド (@code{gnus-summary-show-complete-article}) がそうします。

@item w
@itemx A w
@kindex w @r{(概略)}
@kindex A w @r{(概略)}
@cindex web
@cindex url
@findex gnus-summary-browse-url
記事バッファーを走査して @code{browse-url} で閲覧できるリンクを提示しま
す。接頭引数を与えると代わり
に @code{browse-url-secondary-browser-function} で閲覧します。
@end table

@node Summary Sorting
@section 概略の並べ替え
@cindex summary sorting

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなたは
たくさんの方法で概略バッファーを並べ替えることができます。

@table @kbd
@item C-c C-s C-n
@kindex C-c C-s C-n @r{(概略)}
@findex gnus-summary-sort-by-number
記事番号によって並べ替えます (@code{gnus-summary-sort-by-number})。

@item C-c C-s C-m C-n
@kindex C-c C-s C-n @r{(概略)}
@findex gnus-summary-sort-by-most-recent-number
最新の記事番号によって並べ替えま
す (@code{gnus-summary-sort-by-most-recent-number})。

@item C-c C-s C-a
@kindex C-c C-s C-a @r{(概略)}
@findex gnus-summary-sort-by-author
著者によって並べ替えます (@code{gnus-summary-sort-by-author})。

@item C-c C-s C-t
@kindex C-c C-s C-t @r{(概略)}
@findex gnus-summary-sort-by-recipient
受信者によって並べ替えます (@code{gnus-summary-sort-by-recipient})。

@item C-c C-s C-s
@kindex C-c C-s C-s @r{(概略)}
@findex gnus-summary-sort-by-subject
表題によって並べ替えます (@code{gnus-summary-sort-by-subject})。

@item C-c C-s C-d
@kindex C-c C-s C-d @r{(概略)}
@findex gnus-summary-sort-by-date
日付によって並べ替えます (@code{gnus-summary-sort-by-date})。

@item C-c C-s C-m C-d
@kindex C-c C-s C-m C-d @r{(概略)}
@findex gnus-summary-sort-by-most-recent-date
最新の日付によって並べ替えま
す (@code{gnus-summary-sort-by-most-recent-date})。

@item C-c C-s C-l
@kindex C-c C-s C-l @r{(概略)}
@findex gnus-summary-sort-by-lines
行数によって並べ替えます (@code{gnus-summary-sort-by-lines})。

@item C-c C-s C-c
@kindex C-c C-s C-c @r{(概略)}
@findex gnus-summary-sort-by-chars
記事の長さ (文字数) で並べ替えます (@code{gnus-summary-sort-by-chars})。

@item C-c C-s C-m C-m
@kindex C-c C-s C-m C-m @r{(概略)}
@findex gnus-summary-sort-by-marks
記事の講読度の印 (readedness marks) で並べ替えま
す (@code{gnus-summary-sort-by-marks})。

@item C-c C-s C-i
@kindex C-c C-s C-i @r{(概略)}
@findex gnus-summary-sort-by-score
スコアによって並べ替えます (@code{gnus-summary-sort-by-score})。

@item C-c C-s C-r
@kindex C-c C-s C-r @r{(概略)}
@findex gnus-summary-sort-by-random
ランダムに並べ替えます (@code{gnus-summary-sort-by-random})。

@item C-c C-s C-o
@kindex C-c C-s C-o @r{(概略)}
@findex gnus-summary-sort-by-original
ディフォルトの方法で並べ替えます (@code{gnus-summary-sort-by-original})。
@end table

これらの関数はスレッドを使っているときと使っていないときの両方で動作しま
す。後者では、すべての概略行が一行一行並べ替えられます。前者では根本だけ
に基づいて並べ替えられ、それはあなたが求めていることとは異なっているかも
しれません。スレッドを使うかどうかを切り替えるには @kbd{T T} を打ってく
ださい (@pxref{Thread Commands})。

接頭引数を与えると並べ替えの順序が逆になります。

@node Finding the Parent
@section 親記事を探す
@cindex parent articles
@cindex referring articles

@table @kbd
@item ^
@kindex ^ @r{(概略)}
@findex gnus-summary-refer-parent-article
現在の記事の親記事を読みたいのに、それが概略バッファーに表示されていなく
ても、おそらくそれは可能でしょう。というのは、現在のグループ
が @acronym{NNTP} で取得されていて、親がまだ期限切れ消去されていない上、
現在の記事の @code{References} がぶち壊されていなければ、た
だ @kbd{^} か @kbd{A r} を押せば良いだけで
すから (@code{gnus-summary-refer-parent-article})。すべてがうまくいけば、
親記事を取得できるでしょう。もし親記事がすでに概略バッファーに表示されて
いるのであれば、ポイントがその記事に移動するでしょう。

正の数値接頭引数を与えられると、その数の祖先たちを遡って取得します。負の
数値接頭引数が与えられた場合は、その数の世代だけ前の祖先の記事のみを取得
します。ですから @kbd{3 ^} とすれば、Gnus は現在の記事の親と祖父母と曾祖
父母を取得します。@kbd{-3 ^} とすれば、Gnus は現在の記事の曾祖父母だけを
取得します。

@item A R @r{(概略)}
@findex gnus-summary-refer-references
@kindex A R @r{(概略)}
記事の @code{References} 欄にあるすべての記事を取得しま
す (@code{gnus-summary-refer-references})。

@item A T @r{(概略)}
@findex gnus-summary-refer-thread
@kindex A T @r{(概略)}
現在の記事があるスレッドの、全部の記事を表示しま
す (@code{gnus-summary-refer-thread})。この命令は動作するために現在のグ
ループのすべてのヘッダーを取得しなければならないので、普通は少し時間がか
かります。これをしばしば行なうのであれば、
@code{gnus-fetch-old-headers} を @code{invisible} に設定することを考えた
ほうが良いでしょう (@pxref{Filling In Threads})。これは普通は視覚的な効
果はありませんが、この命令の動作をかなり速くします。もちろんグループに入
るのはいくらか遅くなりますが。

@vindex gnus-refer-thread-limit
変数 @code{gnus-refer-thread-limit} はこの命令を実行するときにどのくらい
古い (すなわち、現在のグループで最初に表示されたものよりも前の記事の) ヘッ
ダーを取得するかを指定します。ディフォルトは 200 です。もし @code{t} で
あれば、取得可能なすべてのヘッダーを取得します。@code{A T} 命令に数値接
頭引数を与えると、代わりにそれが使われます。

@item M-^ @r{(概略)}
@findex gnus-summary-refer-article
@kindex M-^ @r{(概略)}
@cindex Message-ID
@cindex fetching by Message-ID
どのグループに属しているかに関わらず、任意の記事を Gnus に要求することが
できます。
@kbd{M-^} (@code{gnus-summary-refer-article}) は @code{Message-ID}、つま
りあの長くてなかなか読むことのできな
い @samp{<38o6up$6f2@@hymir.ifi.uio.no>} のようなものをあなたに尋ねます。
あなたはすべてを正確に打ち込まなければなりません。残念ながら、あいまいな
検索はできないのです。

Gnus はすでに取得してあるヘッダーたちの中で @code{Message-ID} を探します
が、見つからなかったら @code{gnus-refer-article-method} に設定されている
すべての選択方法を試してもみます。
@end table

@vindex gnus-refer-article-method
もしあなたの読んでいるグループが @code{Message-ID} での取得があまり良く
できないようなバックエンド (@code{nnspool} など) であるのなら、
@code{gnus-refer-article-method} を @acronym{NNTP} の選択方法に設定すれ
ば良いでしょう。おそらく、あなたが問い合わせる @acronym{NNTP} サーバーが
あなたの読んでいるスプールを更新していると最も良いでしょう。しかし、それ
はどうしても必要なわけではありません。

それは選択方法のリストのみならず、現在の選択方法を意味する特別なシンボ
ル @code{current} であることもできます。Gnus は合うものを発見するまでそ
れらすべての方法を試します。

これは現在の選択方法を試して、それが失敗した場合には Google に訊く設定の
例です:

@lisp
(setq gnus-refer-article-method
      '(current
        (nnweb "google" (nnweb-type google))))
@end lisp

ほとんどのメールバックエンドは @code{Message-ID} での取得が可能ですが、
あまり優雅な方法でやっているわけではありません。@code{nnmbox},
@code{nnbabyl}, @code{nnmaildir} および @code{nnml} がどのグループからで
も記事を捜索できるのに対して、@code{nnfolder} と @code{nnimap} は現在の
グループに投稿された記事しか探すことができません。@code{nnmh} ではまった
く不可能です。

幸いにも特別なバックエンドである @code{nnregistry} は、どんなグループに
ある記事でもバックエンドに関係無く見つけ出すことができます。
@xref{Registry Article Refer Method, @code{Message-ID} に基づいてレジス
トリーで記事を取得する}.

@node Alternative Approaches
@section 代替手段

ニュースを読む方法の好みは人それぞれです。これは Gnus なのですから、概略
バッファーのためのマイナーモードに少しばかり選択肢を設けます。

@menu
* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする
@end menu

@node Pick and Read
@subsection 選んで読む
@cindex pick and read

いくつかのニュースリーダー (@code{nn} や、ええ
と VM/CMS の @code{Netnews} など) は二段階の講読インターフェースを使いま
す。利用者はまず概略バッファーで読みたい記事に印を付けます。それから、記
事バッファーだけを表示して記事を読みます。

@findex gnus-pick-mode
Gnus はこれをするための概略バッファーマイナーモードを提供しま
す---@code{gnus-pick-mode} です。これは、基本的には簡単に印を付けられる
ように少数のプロセス印命令を一個のキーだけで済む命令にして、概略バッファー
へ切り替えるための追加の命令を一つ提供します。

@quotation
訳注: Pick マイナーモードを有効にするには、以下のフックを使ってください:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

そうせずに、概略バッファーに入ってから @kbd{M-x gnus-pick-mode} を実行し
ても、うまくいかないようです。
@end quotation

これらが pick mode で使うことができるキーです:

@table @kbd
@item .
@kindex . @r{(選択)}
@findex gnus-pick-article-or-thread
現在の行の記事かスレッドを選択しま
す (@code{gnus-pickd-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が非-@code{nil} だったら、このキーが
スレッドの最初の記事で使われるとスレッド全体を選択します。そうでなければ、
その記事だけを選択します。もし数値接頭引数を与えられると、その番号のスレッ
ドか記事に移動して、それを選択します。(普通は行番号が概略行の最初に表示
されます。)

@item @key{SPC}
@kindex SPC @r{(選択)}
@findex gnus-pick-next-page
概略バッファーを一ページ次にスクロールします (@code{gnus-pick-next-page})。
もしバッファーの最後であれば、選択した記事を読み始めます。

@item u
@kindex u @r{(選択)}
@findex gnus-pick-unmark-article-or-thread
スレッドか記事を未選択にしま
す (@code{gnus-pick-unmark-article-or-thread})。変
数 @code{gnus-thread-hide-subtree} が非-@code{nil} だったら、このキーが
スレッドの最初で使われるとそのスレッドを未選択にします。そうでなければ、
その記事だけを未選択にします。その行にあるスレッドか記事を未選択にする
ために、このキーに数値接頭引数を与えることができます。

@item @key{RET}
@kindex RET @r{(選択)}
@findex gnus-pick-start-reading
@vindex gnus-pick-display-summary
選択された記事を読み始めます (@code{gnus-pick-start-reading})。接頭引数
が与えられると、最初にすべての未選択記事に既読の印を付けます。
@code{gnus-pick-display-summary} が @code{nil} でないと、概略バッファー
は読んでいる間も表示されます。
@end table

すべての普通の概略モード命令は pick-mode でも使用可能ですが、@kbd{u} は
例外です。それでも、同じ関数 @code{gnus-summary-tick-article-forward} に
割り当てられている @kbd{!} を使うことができます。

これが良さそうだと思ったら、次のようにしてください:

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@vindex gnus-pick-mode-hook
@code{gnus-pick-minor-mode-hook} は pick マイナーモードのバッファーで実
行されます。

@vindex gnus-mark-unpicked-articles-as-read
@code{gnus-mark-unpicked-articles-as-read} が非-@code{nil} だったら、選
択されなかったすべての記事に既読の印を付けます。ディフォルト
は @code{nil} です。

@vindex gnus-summary-pick-line-format
pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。Pick モードの行の様式は変
数 @code{gnus-summary-pick-line-format} で制御されま
す (@pxref{Formatting Variables})。これ
は @code{gnus-summary-line-format} と同じ様式指定を受け付けま
す (@pxref{Summary Buffer Lines})。

@node Binary Groups
@subsection バイナリーグループ
@cindex binary groups

@findex gnus-binary-mode
多くの時間をバイナリーグループで過ごしているのなら、いつも @kbd{X u},
@kbd{n}, @kbd{@key{RET}} を叩くのが嫌になっているでしょう。
@kbd{M-x gnus-binary-mode} は、単に記事を普通の方法で表示する代わりに、
記事を選択するための普通の Gnus の関数を、一連の記事を uudecode してその
結果を表示するように変更する、概略バッファーのためのマイナーモードです。

@kindex g @r{(バイナリー)}
@findex gnus-binary-show-article
現実には、このモードにしたときに、実際に記事を見るための唯一の命令
が @kbd{g} です (@code{gnus-binary-show-article})。

@vindex gnus-binary-mode-hook
@code{gnus-binary-mode-hook} がバイナリーマイナーモードのバッファーで呼
ばれます。

@node Tree Display
@section 木表示
@cindex trees

@vindex gnus-use-trees
もし普通の Gnus の概略表示を好きでないならば、
@code{gnus-use-trees} を @code{t} に設定してみると良いかもしれません。こ
れは (ディフォルトで) 追加の「木バッファー」(tree buffer) を作成します。
木バッファーではすべての概略モード命令を実行することができます。

もちろん、木表示をカスタマイズする変数が少しあります:

@table @code
@item gnus-tree-mode-hook
@vindex gnus-tree-mode-hook
すべての木モードのバッファーで実行されるフックです。

@item gnus-tree-mode-line-format
@vindex gnus-tree-mode-line-format
木モードのバッファーにおけるモード行のためのフォーマット文字列で
す (@pxref{Mode Line Formatting})。ディフォルト
は @samp{Gnus: %%b %S %Z} です。使用可能な指定
は @ref{Summary Buffer Mode Line} を参照してください。

@item gnus-selected-tree-face
@vindex gnus-selected-tree-face
木バッファーで選択された記事をハイライトするために使われるフェースです。
ディフォルトでは @code{modeline} です。

@item gnus-tree-line-format
@vindex gnus-tree-line-format
木の節のためのフォーマット文字列です。でもこれは少し誤った名称です---そ
れは行ではなく、ただ節を定義するだけです。ディフォルトの値
は @samp{%(%[%3,3n%]%)} で、それは投稿者の名前の最初の三文字を表示します。
すべての節が同じ長さであることが重要なので、@samp{%4,4n} のような指定
を @emph{使わなければなりません}。

有効な指定は:

@table @samp
@item n
投稿者の名前。
@item f
@code{From} 欄。
@item N
記事の番号。
@item [
開き括弧。
@item ]
閉じ括弧。
@item s
表題。
@end table

@xref{Formatting Variables}.

表示に関連した変数は:

@table @code
@item gnus-tree-brackets
@vindex gnus-tree-brackets
これは『本当の』記事と『まばら』な記事に違いを付けるために使われます。様
式は

@example
((@var{本当の開} . @var{本当の閉})
 (@var{まばら開} . @var{まばら閉})
 (@var{偽の開} . @var{偽の閉}))
@end example

となっていて、ディフォルト
は @code{((?[ . ?]) (?( . ?)) (?@{ . ?@}) (?< . ?>))} です。

@item gnus-tree-parent-child-edges
@vindex gnus-tree-parent-child-edges
これは親の節を子に接続するために使われる文字を含むリストです。ディフォル
トは @code{(?- ?\\ ?|)} です。
@end table

@item gnus-tree-minimize-window
@vindex gnus-tree-minimize-window
もしこの変数が @code{nil} でないと、他の Gnus ウィンドウがもっと場所を取
れるように Gnus は木バッファーをできるだけ小さくします。もしこの変数が数
値であると、木バッファーの高さはその数値より大きくなることはありません。
ディフォルトは @code{t} です。フレームでいくつかのウィンドウが横に並んで
表示されていて、木バッファーがそのうちの一つである場合、木ウィンドウを最
小化することはその隣に表示されているすべてのウィンドウの大きさをも変更す
ることに注意してください。

以下のフックを追加して、いつでも木ウィンドウを最小化するようにしても良い
でしょう。

@lisp
(add-hook 'gnus-configure-windows-hook
          'gnus-tree-perhaps-minimize)
@end lisp

@item gnus-generate-tree-function
@vindex gnus-generate-tree-function
@findex gnus-generate-horizontal-tree
@findex gnus-generate-vertical-tree
実際にスレッドの木を作成する関数です。二つの定義済みの関
数 @code{gnus-generate-horizontal-tree} およ
び @code{gnus-generate-vertical-tree} (これがディフォルトです) が利用可
能です。
@end table

水平木バッファー (horizontal tree buffer) の例です:

@example
@{***@}-(***)-[odd]-[Gun]
     |      \[Jan]
     |      \[odd]-[Eri]
     |      \(***)-[Eri]
     |            \[odd]-[Paa]
     \[Bjo]
     \[Gun]
     \[Gun]-[Jor]
@end example

同じスレッドが垂直木バッファー (vertical tree buffer) で表示されたもので
す:

@example
@{***@}
  |--------------------------\-----\-----\
(***)                         [Bjo] [Gun] [Gun]
  |--\-----\-----\                          |
[odd] [Jan] [odd] (***)                   [Jor]
  |           |     |--\
[Gun]       [Eri] [Eri] [odd]
                          |
                        [Paa]
@end example

もし水平木を使っているのなら、概略バッファーで木を隣り合わせで表示できれ
ば嬉しいでしょう。次のようなものを @file{~/.gnus.el} ファイルに加えるこ
とができます:

@lisp
(setq gnus-use-trees t
      gnus-generate-tree-function 'gnus-generate-horizontal-tree
      gnus-tree-minimize-window nil)
(gnus-add-configuration
 '(article
   (vertical 1.0
             (horizontal 0.25
                         (summary 0.75 point)
                         (tree 1.0))
             (article 1.0))))
@end lisp

@xref{Window Layout}.

@node Mail Group Commands
@section メールグループ命令
@cindex mail group commands

いくつかの命令はメールグループでのみ意味を持ちます。これらの命令が現在の
グループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょう。

これらすべての命令は (期限切れ消去と編集命令は除く) プロセス/接頭引数の
習慣を使います (@pxref{Process/Prefix})。

@table @kbd
@item B e
@kindex B e @r{(概略)}
@findex gnus-summary-expire-articles
@cindex expiring mail
現在のグループのすべての期限切れ消去可能な記事について、期限切れ消去の処
理 (@code{gnus-summary-expire-articles}) を行ないます。これは、そのグルー
プにしばらく存在していた期限切れ消去可能なすべての記事を消去するというこ
とです。(@pxref{Expiring Mail})。

@item B C-M-e
@kindex B C-M-e @r{(概略)}
@findex gnus-summary-expire-articles-now
@cindex expiring mail
グループのすべての期限切れ消去可能な記事を削除しま
す (@code{gnus-summay-expire-articles-now})。これは、現在のグループにあ
る @strong{すべて} の期限切れ消去可能な記事が、永遠に空の大き
な @file{/dev/null} へ消え去るということです。

@item B @key{DEL}
@kindex B DEL @r{(概略)}
@cindex deleting mail
@findex gnus-summary-delete-article
@c @icon{gnus-summary-mail-delete}
メール記事を削除します。これは『あなたのディスクから永久に削除して二度と
戻らない』の意味の『削除』です。注意して使ってくださ
い (@code{gnus-summary-delete-article})。

@item B m
@kindex B m @r{(概略)}
@cindex move mail
@findex gnus-summary-move-article
@vindex gnus-preserve-marks
あるメールグループから別のメールグループへ記事を移動しま
す (@code{gnus-summary-move-article})。@code{gnus-preserve-marks} の値
が @code{nil} でなければ (それがディフォルト)、印は保存されます。

@item B c
@kindex B c @r{(概略)}
@cindex copy mail
@findex gnus-summary-copy-article
@c @icon{gnus-summary-mail-copy}
あるグループ (メールグループや他のもの) からメールグループに記事をコピー
します (@code{gnus-summary-copy-article})。@code{gnus-preserve-marks} の
値が @code{nil} でなければ (それがディフォルト)、印は保存されます。

@item B B
@kindex B B @r{(概略)}
@cindex crosspost mail
@findex gnus-summary-crosspost-article
現在の記事を他のグループにクロスポストしま
す (@code{gnus-summary-crosspost-article})。これは他のグループの記事の新
しい複製を作成し、記事の Xref 欄も適切に更新されます。

@item B i
@kindex B i @r{(概略)}
@findex gnus-summary-import-article
任意のファイルを現在のメールグループに取り込みま
す (@code{gnus-summary-import-article})。あなたはファイル名と、
@code{From} 欄と @code{Subject} 欄の入力を促されます。

@item B I
@kindex B I @r{(概略)}
@findex gnus-summary-create-article
空の記事を現在のメールグループに作りま
す (@code{gnus-summary-create-article})。@code{From} ヘッダー
と @code{Subject} ヘッダーの内容を尋ねられます。

@item B r
@kindex B r @r{(概略)}
@findex gnus-summary-respool-article
@vindex gnus-summary-respool-default-method
メール記事をスプールし直します (@code{gnus-summary-move-article})。
@code{gnus-summary-respool-default-method} が再スプールするときのディフォ
ルトの選択方法として使用されます。この変数はディフォルトで
は @code{nil} で、その場合は現在のグループの選択方法が代わりに使われます。
@code{gnus-preserve-marks} の値が @code{nil} でなければ (それがディフォ
ルト)、印は保存されます。

訳注: 「スプールし直す」というのはメールの分
割 (@ref{Splitting Mail} または @ref{Fancy Mail Splitting}) の規則に基づ
いて、メールを適切なグループに入れ直すことです。そのグループに間違って入っ
てしまったメールを、分割の規則を修正した後で、正しいグループに移動させる
場合などに使います。この章の @kbd{B q} と @kbd{B t} も見てください。

@item B w
@itemx e
@kindex B w @r{(概略)}
@kindex e @r{(概略)}
@findex gnus-summary-edit-article
@kindex C-c C-c @r{(記事)}
@findex gnus-summary-edit-article-done
現在の記事を編集します (@code{gnus-summary-edit-article})。編集を終了し
て変更を固定するに
は @kbd{C-c C-c} (@code{gnus-summary-edit-article-done}) を打ちます。も
し @kbd{C-c C-c} 命令に接頭引数を与えると、Gnus は記事を再ハイライトしま
せん。

訳注: 変更しないで編集を終るには、@kbd{C-c C-k} をタイプしてください。

@item B q
@kindex B q @r{(概略)}
@findex gnus-summary-respool-query
記事を再スプールするときは、再スプールをする前にどのグループに記事が移る
かを知りたいでしょう。この命令でそれがわかりま
す (@code{gnus-summary-respool-query})。

@item B t
@kindex B t @r{(概略)}
@findex gnus-summary-respool-trace
同様に、この命令は再スプールするときに使われるすべての特級分割方式を、も
しあれば表示します (@code{gnus-summary-respool-trace})。

@item B p
@kindex B p @r{(概略)}
@findex gnus-summary-article-posted-p
一部の人たちには、あなたが投稿した記事にフォローアップするときに「親切な」
複製を送る傾向があります。これらは普通はそこに @code{Newsgroups} ヘッダー
が付いているのですが、いつもそうであるとは限りません。この命
令 (@code{gnus-summary-article-posted-p}) は現在の記事をあなたのニュース
サーバーから (というよりは、むし
ろ @code{gnus-refer-article-method} や @code{gnus-select-method} か
ら) 取得しようとして、記事を発見できたかどうかを報告します。それが記事を
発見しなかったとしても、それはとにかく投稿されているかもしれません---メー
ルの伝達はニュースの伝達よりもずっと速いので、ニュースの複製がまだ到着し
ていないだけかもしれないのです。

訳注: その「親切な」複製が、概略バッファーで独立した記事として見えていな
いと検査することができないので、そうするために @kbd{A D} また
は @kbd{C-d} 命令 (@pxref{Really Various Summary Commands}) を使う必要が
あるかもしれません。この命令はとにかくすべての選択方法を試すので、特にそ
れらに遅いものが含まれているときは、注意して使ってください。

@item K E
@kindex K E @r{(概略)}
@findex gnus-article-encrypt-body
@vindex gnus-article-encrypt-protocol
記事の本文を暗号化します (@code{gnus-article-encrypt-body})。本文は、変
数 @code{gnus-article-encrypt-protocol} で指定されたプロトコルで暗号化さ
れます。
@end table

@vindex gnus-move-split-methods
@cindex moving articles
いつも記事をどこかに移動 (もしくは複製) することを習慣にしているのならば、
記事をどこに入れれば良いかを Gnus に提案してもらいたいと思うでしょう。
@code{gnus-move-split-methods} は @code{gnus-split-methods} と同じ構文を
使う変数です (@pxref{Saving Articles})。あなたが妥当だと思うような提案を
するようにその変数をカスタマイズすることができます。
(@code{gnus-split-methods} がファイル名を使うのに対し
て @code{gnus-move-split-methods} はグループ名を使うことに注意してくださ
い。)

@lisp
(setq gnus-move-split-methods
      '(("^From:.*Lars Magne" "nnml:junk")
        ("^Subject:.*gnus" "nnfolder:important")
        (".*" "nnml:misc")))
@end lisp

@node Various Summary Stuff
@section 概略のいろいろなもの

@menu
* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令
@end menu

@table @code
@vindex gnus-summary-display-while-building
@item gnus-summary-display-while-building
非-@code{nil} だったら、構築中の概略バッファーを更新しながら表示します。
@code{t} だった場合は、行が挿入される度に毎回バッファーを更新します。値
が整数 @var{n} であった場合は、@var{n} 行毎に表示を更新します。ディフォ
ルトは @code{nil} です。

@vindex gnus-summary-display-arrow
@item gnus-summary-display-arrow
非-@code{nil} だったら、現在の記事を指し示すためにフリンジに矢印を表示し
ます。(訳注: フリンジとは Emacs 21 以上でウィンドウの左右に現れる余白の
ことです。)

@vindex gnus-summary-mode-hook
@item gnus-summary-mode-hook
概略モードのバッファーを作成するときにこのフックが呼ばれます。

@vindex gnus-summary-generate-hook
@item gnus-summary-generate-hook
これはスレッド作成と概略バッファー作成の前に実行する最後のものとして呼ば
れます。これはニュースグループの持っているデータに基づいてスレッドの変数
をカスタマイズするのに非常に便利です。このフックはほとんどの概略バッファー
変数が設定された後に概略バッファーから呼ばれます。

@vindex gnus-summary-prepare-hook
@item gnus-summary-prepare-hook
これは概略バッファーが作成された後に呼ばれます。例えば、これを何かしら神
をも畏れぬ方法で行をハイライトしたり、バッファーの見え方を修正したりする
のに使ったりするかもしれません。

@vindex gnus-summary-prepared-hook
@item gnus-summary-prepared-hook
概略バッファーが作成された後で一番最後に呼ばれるフックです。

@vindex gnus-summary-ignore-duplicates
@item gnus-summary-ignore-duplicates
Gnus が同じ @code{Message-ID} を持つ二つの記事を発見したときは、何か思い
切ったことをしなければなりません。別の記事が同じ @code{Message-ID} を持
つことは許されていませんが、それは何らかのソースからメールを読んでいると
きに起こるかもしれません。この変数によって Gnus が何をするかをカスタマイ
ズできるようになっています。@code{nil} だったら (それがディフォルトです)、
Gnus は (表示のためだけに) @code{Message-ID} を付け替えて、その記事を他
の記事と同じように表示します。@code{t} にすると、それは記事を表示しませ
ん---最初から存在しなかったかのように。

@vindex gnus-alter-articles-to-read-function
@item gnus-alter-articles-to-read-function
この変数に設定した関数で、選択する記事のリストを変更することができます。
関数は二つの引数 (グループ名と選択する記事のリスト) を受け付けます。

例えば以下の関数は、キャッシュされた記事のリストを、あるグループのリスト
だけに追加します。

@lisp
(defun my-add-cached-articles (group articles)
  (if (string= group "some.group")
      (append gnus-newsgroup-cached articles)
    articles))
@end lisp

@vindex gnus-newsgroup-variables
@item gnus-newsgroup-variables
ニュースグループ (その概略バッファーの) のローカル変数、または変数とそれ
らの評価されるディフォルトの表現 (ディフォルト値が @code{nil} でない場
合) の cons セルのリストで、その概略バッファーが活きている間はグローバル
変数になります。(訳注: いわゆるバッファーローカル変数ではありません。)

注: ディフォルトの表現は単にローカル変数に設定されるのではなく、その前
に (@code{eval} 関数を使って) 評価されます。ディフォルトの表現
が @code{global} というシンボルだった場合は評価されず、代わりにそのロー
カル変数のグローバル値が使われます。

これらグループパラメーターの値が他のバッファーで行なわれる処理に影響する
ようになっていても、(訳注: その概略バッファーの) グループパラメーターを
設定するために使うことができます。例です:

@lisp
(setq gnus-newsgroup-variables
     '(message-use-followup-to
       (gnus-visible-headers .
         "^From:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^To:")))
@end lisp

@ref{Group Parameters} も参照してください。

訳注: もっと良い例が必要です。@code{gnus-newsgroup-variables} およ
び @code{gnus-parameters} (@pxref{Group Parameters}) の値を次のように設
定したとしましょう:

@lisp
(setq gnus-newsgroup-variables '((@var{var} . @var{foo})))
(setq gnus-parameters
      '(("^fj\\." (@var{var} . @var{bar}))
        ("^japan\\." (@var{var} . @var{baz}))))
@end lisp

こうしておくと変数 @var{var} の値が、@samp{fj} 階層のニュースグルー
プ (の概略バッファー) に入ると @var{bar} になり、@samp{japan} 階層のグルー
プに入ると @var{baz} になります。グループを抜けても変数 @var{var} の値は
変化しませんが、@samp{fj} または @samp{japan} 階層以外のグループに入ると
変数 @var{var} の値は @var{foo} になります (正確には、@var{foo},
@var{bar} または @var{baz} の値は、本編で説明されているよう
に @code{eval} した結果が使われます)。

通常のグループパラメーターは、そのグループの概略バッファーでだけ値を知る
ことができるのに対して、@code{gnus-newsgroup-variables} で設定した変数は、
同じ Emacs のどのバッファーでも、現在選択されているグループ固有の値を持
つ点が違います。異なる複数のグループの概略バッファーを使う場合には、注意
する必要があります。

特別な場合として @var{foo} が @code{nil} で良い場合は、次のように記述す
ることができます:

@lisp
(setq gnus-newsgroup-variables '(@var{var}))
(setq gnus-parameters
      '(("^fj\\." (@var{var} . @var{bar}))
        ("^japan\\." (@var{var} . @var{baz}))))
@end lisp

@code{gnus-newsgroup-variables} および @code{gnus-parameters} はどちらも
リストなので、@code{setq} よりはむし
ろ @code{add-to-list} や @code{push} などを使って、値を「追加」した方が
便利かもしれません。
@end table

@node Summary Group Information
@subsection 概略グループ情報

@table @kbd
@item H d
@kindex H d @r{(概略)}
@findex gnus-summary-describe-group
現在のグループの簡潔な説明を表示しま
す (@code{gnus-summary-describe-group})。接頭引数が与えられると、サーバー
から強制的に説明の再読み込みをします。

@item H h
@kindex H h @r{(概略)}
@findex gnus-summary-describe-briefly
最も重要な概略コマンドの、非常に簡潔な説明を表示しま
す (@code{gnus-summary-describe-briefly})。

@item H i
@kindex H i @r{(概略)}
@findex gnus-info-find-node
Gnus の info の節 (node) に移動します (@code{gnus-info-find-node})。
@end table

@node Searching for Articles
@subsection 記事を探す

@table @kbd
@item M-s
@kindex M-s @r{(概略)}
@findex gnus-summary-search-article-forward
それ以降のすべての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-forward})。

@item M-r
@kindex M-r @r{(概略)}
@findex gnus-summary-search-article-backward
それ以前のすべての (生の) 記事を正規表現で検索しま
す (@code{gnus-summary-search-article-backward})。

@item M-S
@kindex M-S @r{(概略)}
@findex gnus-summary-repeat-search-article-forward
前回の前方検索を繰り返しま
す (@code{gnus-summary-repeat-search-article-forward})。

@item M-R
@kindex M-R @r{(概略)}
@findex gnus-summary-repeat-search-article-backward
前回の後方検索を繰り返しま
す (@code{gnus-summary-repeat-search-article-backward})。

@item &
@kindex & @r{(概略)}
@findex gnus-summary-execute-command
この命令は、ヘッダー、そのヘッダーの内容に合致する正規表現、および合致し
たときに実行されるコマンドの入力を要求しま
す (@code{gnus-summary-execute-command})。ヘッダーが空文字列だったら、記
事全体で合致するものを探します。接頭引数を与えられると、代わりに後ろ向き
に探します。

例えば @kbd{& @key{RET} 何かの.*文字列 @key{RET} #} は、ヘッダーか本文
に @samp{何かの.*文字列} を持つすべての記事にプロセス印を付けます。

@item M-&
@kindex M-& @r{(概略)}
@findex gnus-summary-universal-argument
この命令に続けて入力する命令を、プロセス印が付けられているすべての記事で
実行します (@code{gnus-summary-universal-argument})。
@end table

@node Summary Generation Commands
@subsection 概略生成命令

@table @kbd
@item Y g
@kindex Y g @r{(概略)}
@findex gnus-summary-prepare
現在の概略バッファーを再作成します (@code{gnus-summary-prepare})。

@item Y c
@kindex Y c @r{(概略)}
@findex gnus-summary-insert-cached-articles
(現在のグループのために) キャッシュされたすべての記事を概略バッファーに
挿入します (@code{gnus-summary-insert-cached-articles})。

@item Y d
@kindex Y d @r{(概略)}
@findex gnus-summary-insert-dormant-articles
(現在のグループのための) すべての保留記事を概略バッファーに挿入しま
す (@code{gnus-summary-insert-dormant-articles})。

@item Y t
@kindex Y t @r{(概略)}
@findex gnus-summary-insert-ticked-articles
(現在のグループのための) すべての可視記事を概略バッファーに挿入しま
す (@code{gnus-summary-insert-ticked-articles})。
@end table

@node Really Various Summary Commands
@subsection 本当にいろいろな概略命令

@table @kbd
@item A D
@itemx C-d
@kindex C-d @r{(概略)}
@kindex A D @r{(概略)}
@findex gnus-summary-enter-digest-group
現在の記事が別の記事を寄せ集めたもの (例えばダイジェスト) であるならば、
それらの記事でできているグループに入るためにこの命令を使うことができま
す (@code{gnus-summary-enter-digest-group})。この命令に接頭引数を与えな
いと Gnus はどのような型の記事が現在表示されているかを推測しようとし、実
際にはそれが『ダイジェスト』であるものとして強引に解釈します。基本的に、
ある様式で寄せ集められた別のメッセージを見るときはいつでも、@kbd{C-d} を
使うことによって、もっと便利なやり方でそれらのメッセージを読むことができ
ます。

変数 @code{gnus-auto-select-on-ephemeral-exit} はダイジェスト・グループ
を出た後に、どの記事を選択すべきかを制御します。有効な値は次の通りです:

@table @code
@item next
次の記事を選択します。

@item next-unread
次の未読記事を選択します。

@item next-noselect
カーソルを次の記事に移動します。これがディフォルトです。

@item next-unread-noselect
カーソルを次の未読記事に移動します。
@end table

これら以外の値だったり、次の (未読の) 記事が無かったら、ダイジェスト・グ
ループに入る前に選択されていた記事が現れます。

@item C-M-d
@kindex C-M-d @r{(概略)}
@findex gnus-summary-read-document
この命令は上のものによく似ていますが、いくつかの文書を一つのおおーきなグ
ループに集めます (@code{gnus-summary-read-read-document})。それを実現す
るために、この命令はそれぞれの文書のための @code{nndoc} グループを開いて
から、それら複数の @code{nndoc} グループのてっぺんで @code{nnvirtual} グ
ループを開きます。この命令はプロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。

@item C-t
@kindex C-t @r{(概略)}
@findex gnus-summary-toggle-truncation
長い概略行を切り詰めるかどうかを切り替えま
す (@code{gnus-summary-toggle-truncation})。これはおそらく概略バッファー
で行を中央に表示する機能を混乱させるので、記事を読んでいるときに行の切り
詰めを off にするのは良い考えではないでしょう。

@item =
@kindex = @r{(概略)}
@findex gnus-summary-expand-window
概略バッファーのウィンドウを拡大しま
す (@code{gnus-summary-expand-window})。接頭引数を与えられると、記事バッ
ファーのためのウィンドウの配置の設定を強制します (訳注: ディフォルトでは
記事バッファーのためのウィンドウの配置の設定には概略バッファーを表示する
ことも含まれているので、普通に記事を読んでいるときと同じになるでしょう)。

@item C-M-e
@kindex C-M-e @r{(概略)}
@findex gnus-summary-edit-parameters
現在のグループのグループパラメーター (@pxref{Group Parameters}) を編集し
ます (@code{gnus-summary-edit-parameters})。

@item C-M-a
@kindex C-M-a @r{(概略)}
@findex gnus-summary-customize-parameters
現在のグループのグループパラメーター (@pxref{Group Parameters}) をカスタ
マイズします (@code{gnus-summary-customize-parameters})。
@end table

@node Exiting the Summary Buffer
@section 概略バッファーを抜ける
@cindex summary exit
@cindex exiting groups

概略バッファーから抜けると、普通はグループのすべての情報を更新してグルー
プバッファーに戻ります。

@table @kbd
@item Z Z
@itemx Z Q
@itemx q
@kindex Z Z @r{(概略)}
@kindex Z Q @r{(概略)}
@kindex q @r{(概略)}
@findex gnus-summary-exit
@vindex gnus-summary-exit-hook
@vindex gnus-summary-prepare-exit-hook
@vindex gnus-group-no-more-groups-hook
@c @icon{gnus-summary-exit}
現在のグループを出て、グループのすべての情報を更新しま
す (@code{gnus-summary-exit})。抜け出るための多くの処理を行なう前
に @code{gnus-summary-prepare-exit-hook} が呼ばれ、それはディフォルト
で @code{gnus-summary-expire-articles} を呼びます。抜け出るための処理を
終えた後で @code{gnus-summary-exit-hook} が呼ばれます。グループモードに
戻るときに (未読の) グループが残っていなかった
ら @code{gnus-group-no-more-groups-hook} が実行されます。

@item Z E
@itemx Q
@kindex Z E @r{(概略)}
@kindex Q @r{(概略)}
@findex gnus-summary-exit-no-update
グループのどんな情報も更新せずに現在のグループを抜け出ま
す (@code{gnus-summary-exit-no-update})。

@item Z c
@itemx c
@kindex Z c @r{(概略)}
@kindex c @r{(概略)}
@findex gnus-summary-catchup-and-exit
@c @icon{gnus-summary-catchup-and-exit}
グループのすべての可視ではない (unticked) 記事に既読の印を付けてから抜け
ます (@code{gnus-summary-catchup-and-exit})。

@item Z C
@kindex Z C @r{(概略)}
@findex gnus-summary-catchup-all-and-exit
可視記事さえも含むすべての記事に既読の印を付けてから抜けま
す (@code{gnus-summary-catchup-all-and-exit})。

@item Z n
@kindex Z n @r{(概略)}
@findex gnus-summary-catchup-and-goto-next-group
すべての記事に既読の印を付けて次のグループへ移動しま
す (@code{gnus-summary-catchup-and-goto-next-group})。

@item Z p
@kindex Z p @r{(概略)}
@findex gnus-summary-catchup-and-goto-prev-group
すべての記事に既読の印を付けて前のグループへ移動しま
す (@code{gnus-summary-catchup-and-goto-prev-group})。

@item Z R
@itemx C-x C-s
@kindex Z R @r{(概略)}
@kindex C-x C-s @r{(概略)}
@findex gnus-summary-reselect-current-group
現在のグループを出て、それから入り直しま
す (@code{gnus-summary-reselect-current-group})。接頭引数が与えられると、
既読と未読の両方のすべての記事を選択します。

@item Z G
@itemx M-g
@kindex Z G @r{(概略)}
@kindex M-g @r{(概略)}
@findex gnus-summary-rescan-group
@c @icon{gnus-summary-mail-get}
グループを抜け、そのグループの新しい記事を調べてから、再びそのグループを
選択します (@code{gnus-summary-rescan-group})。接頭引数が与えられると、
既読と未読の両方のすべての記事を選択します。

@item Z N
@kindex Z N @r{(概略)}
@findex gnus-summary-next-group
グループを抜けて、次のグループへ移動しま
す (@code{gnus-summary-next-group})。

@item Z P
@kindex Z P @r{(概略)}
@findex gnus-summary-prev-group
グループを抜けて、前のグループへ移動しま
す (@code{gnus-summary-prev-group})。

@item Z s
@kindex Z s @r{(概略)}
@findex gnus-summary-save-newsrc
現在の既読と印付き記事の数をドリブルバッファー (dribble buffer) に保存し、
それからドリブルバッファーを保存します (@code{gnus-summary-save-newsrc})。
接頭引数が与えられると @file{.newsrc} ファイル (と @file{.newsrc.eld} ファ
イル) も保存します。この命令を使うと、更新なしで抜け出ること (@kbd{Q} 命
令) は意味が無くなります。
@end table

@vindex gnus-exit-group-hook
グループのすべての情報を「更新」して現在のグループを抜けるとき
に @code{gnus-exit-group-hook} が呼ばれます。例え
ば @kbd{Q} 命令 (@code{gnus-summary-exit-no-update}) はこのフックを呼び
ません。

@findex gnus-summary-wake-up-the-dead
@findex gnus-dead-summary-mode
@vindex gnus-kill-summary-on-exit
グループを抜けた後でそれを後悔する癖があるのなら、
@code{gnus-kill-summary-on-exit} を @code{nil} に設定と良いかもしれませ
ん。そうすると Gnus は抜け出るときに概略バッファーを削除しません。(何と
いう驚き!) 代わりに、それはバッファーの名前
を @file{*Dead Summary ... *} のようなものに変更して、
@code{gnus-dead-summary-mode} というマイナーモードを導入します。今やその
バッファーに切り替えると、すべてのキーが関
数 @code{gnus-summary-wake-up-the-dead} に割り当てられていることに気付く
でしょう。死んだ概略バッファー (dead summary buffer) でどんなキーでも叩
くと、それは生きた普通の概略バッファーになります。

死んだ概略バッファーは同時に一つしか存在することはできません。

@vindex gnus-use-cross-reference
概略バッファーを抜け出ると、現在のグループのデータ (どの記事を読んで、ど
の記事に返答したか、など) は更新されます。もし変
数 @code{gnus-use-cross-reference} が @code{t} であると (それがディフォ
ルトです)、そのグループに相互参照された (cross referenced) 記事には、そ
れがクロスポストされた他の購読しているグループにあっても、既読の印が付き
ます。この変数が @code{nil} でも @code{t} でもなければ、記事には購読して
いるグループと購読していないグループの両方で既読の印が付きま
す (@pxref{Crosspost Handling})。

@node Crosspost Handling
@section クロスポストの扱い

@cindex velveeta
@cindex spamming
クロスポストされた記事に既読の印を付けることによって、同じ記事を二回以上
読まないで済むことを保証します。もちろん、だれかがそれを複数のグループに
別々に投稿しない限りは。同じ記事を複数のグループに (クロスポストではでは
なく) 投稿することは @dfn{spamming} と呼ばれ、あなたはそのような憎むべき
犯罪を行なうものに対して、法律によって不快な記事を送ることが義務づけられ
ています。

覚えておいてください: クロスポストはまあ構いませんが、同じ記事を別々に複
数のグループに投稿するのは許されません。大量のクロスポス
ト (@dfn{velveeta} として知られているもの) は何としても避けられるべきで、
過剰なクロスポストに対して不満を言うため
に @code{gnus-summary-mail-crosspost-complaint} 命令を使うことさえできま
す。

@cindex cross-posting
@cindex Xref
@cindex @acronym{NOV}
Gnus にクロスポストを正しく扱えなくさせる原因の一つは、@sc{xover} (これ
は非常に良いです、というのはそれは速度をとても速くするからです) をサポー
トしているけれども @acronym{NOV} 行に @code{Xref} 欄を含めな
い @acronym{NNTP} サーバーを使っていることです。これは害悪です。でも、
あぁ、悲しいかな、非常に良くあることなのです。Gnus はあなたが読んだすべ
ての記事に @code{Xref} 行を記録することによって The Right Thing (正しい
こと) をしようとしますが、記事を削除したり単に読まないで既読の印を付ける
と、Gnus がこれらの記事の @code{Xref} 行をのぞきまわる機会が無くなってし
まうので、相互参照 (cross reference) の機構を使えなくなってしまいます。

@cindex LIST overview.fmt
@cindex overview.fmt
あなたの @acronym{NNTP} サーバーがその概観ファイ
ル (overview file) に @code{Xref} 欄を含めるかどうかを調べるには、
@samp{telnet your.nntp.server nntp} をタイプして、@code{inn} サーバーで
は @samp{MODE READER} コマンドを与えてから、@samp{LIST overview.fmt} を
試してください。これは動作しないかもしれません。しかし、もし動作して、取
得した最後の行が @samp{Xref:full} でないならば (訳注: 最後の行ではないか
もしれません)、ニュースの管理者が概観ファイルに @code{Xref} 欄を含めるよ
うにしてくれるまで、彼女に向かって叫び、泣き付くべきでしょう。

Gnus にいつでも正しい @code{Xref} を取得するようにさせたいのであれば、
@code{nntp-nov-is-evil} を @code{t} にする必要があり、それは非常に速度を
遅くします。@ref{Slow/Expensive Connection} も参照してください。

ま、人生はそのようなものです。

代替手段に付いては @ref{Duplicate Suppression} を参照してください。

@node Duplicate Suppression
@section 重複の抑制

ディフォルトでは Gnus はクロスポスト機構を利用することによって、同じ記事
を二回以上読まないようにしようとします (@pxref{Crosspost Handling})。し
かし、その単純で効果的な方法は、いろいろな理由により、満足する結果をもた
らさないかもしれません。

@enumerate
@item
@acronym{NNTP} サーバーは @code{Xref} 欄の生成に失敗するかもしれません。
これは悪いことで、あまり起こりません。

@item
@acronym{NNTP} サーバーは @file{.overview} データベースに @code{Xref} 欄
を含めるのに失敗するかもしれません。これは悪いことで、非常に良くあること
です、あぁ悲しい。

@item
同じグループ (もしくはいくつかの関連したグループ) を違っ
た @acronym{NNTP} サーバーから読んでいるかもしれません。

@item
グループに投稿された記事と重複するメールを受け取ったかもしれません。
@end enumerate

@code{Xref} の扱いに失敗する状況は確かに他にもありますが、これら四つが最
も良くある状況です。

もし、本当にもしも @code{Xref} の扱いに失敗したら、「重複抑制」に切り替
えることを考慮する必要があるかもしれません。そうすれば、Gnus はあなたが
読んだすべての記事、あるいは既読の印を付けたすべての記事
の @code{Message-ID} を記憶し、そしてまるで魔法のように、以後それらを読
むときはいつでも既読の印が付いているようにします---@emph{すべて} のグルー
プで。この機構を使うのは何だかとても非効率になりそうですが、過度に非効率
なわけではありません。同じ記事を二回以上読むよりは、間違い無く望ましいで
す。

重複抑制はあまり精密な道具ではありません。どちらかというと大槌のようなも
のです。それは非常に単純なやり方で動作しています---あなたが記事に既読の
印を付けると、その Message-ID をキャッシュに加えます。次にそ
の Message-ID に出会うと、@samp{M} 印によって記事に既読の印を付けます。
その記事をどのグループで見たかは気にしません。

@table @code
@item gnus-suppress-duplicates
@vindex gnus-suppress-duplicates
@code{nil} でなければ、重複抑制をします。

@item gnus-save-duplicate-list
@vindex gnus-save-duplicate-list
@code{nil} でなければ、重複のリストをファイルに保存します。これは起動と
終了の時間を長くするので、ディフォルトは @code{nil} です。しかし、これ
は Gnus を一回実行したときに読まれた重複記事だけが抑制されるということで
す。

@item gnus-duplicate-list-length
@vindex gnus-duplicate-list-length
この変数はどのくらい多くの @code{Message-ID} を重複抑制リストに保ってお
くかを決定します。ディフォルトは 10000 です。

@item gnus-duplicate-file
@vindex gnus-duplicate-file
重複抑制のリストを格納しておくファイルの名前です。ディフォルト
は @file{~/News/suppression} です。
@end table

何度も Gnus を終了して起動する傾向があるのであれば、おそら
く @code{gnus-save-duplicate-list} を @code{t} にするのは良い考えでしょ
う。もし Gnus を続けて何週間も走らせておくのであれば、それ
を @code{nil} にした方が良いかもしれません。一方、リストを保存することは
起動と終了をずっと遅くするので、頻繁に Gnus を終了して起動するのであれば、
@code{gnus-save-duplicate-list} を @code{nil} に設定するべきです。うーむ。
私はあなたがどうするかに任せようと思います。

@node Security
@section セキュリティー

Gnus は署名されたメッセージを検証したり、暗号化されたメッセージをデコー
ドすることができます。@acronym{PGP}, @acronym{PGP/MIME} およ
び @acronym{S/MIME} の形式をサポートしますが、それらを動作させるためには、
いくつかの外部プログラムを必要とします:

@enumerate
@item
@acronym{PGP} と @acronym{PGP/MIME} のメッセージを扱うには、OpenPGP の実
装である GnuPG のようなものをインストールしなければなりません。Emacs に
含まれている GnuPG へのインターフェースは EasyPG というもの (@pxref{Top,
,EasyPG, epa, EasyPG Assistant user's manual}) ですが、PGG (@pxref{Top,
,PGG, pgg-ja, PGG Manual}) および Mailcrypt もサポートします。

@item
@acronym{S/MIME} のメッセージを扱うには、OpenSSL をインストールする必要
があります。OpenSSL 0.9.6 か、それより新しいものがお勧めです。
@end enumerate

以下は、メッセージを読む、または作成する場合に、セキュリティーの機能を制
御するための変数です:

@table @code
@item mm-verify-option
@vindex mm-verify-option
署名されたパートを検証するためのオプション。@code{never} は検証しない、
@code{always} はいつも検証する、@code{known} は知られたプロトコルの場合
だけ検証する、の意味です。それら以外の場合は、どうするかを利用者に尋ねま
す。

@item mm-decrypt-option
@vindex mm-decrypt-option
暗号化されたパートをデコードするためのオプション。@code{never} はデコー
ドしない、@code{always} はいつもデコードする、@code{known} は知られたプ
ロトコルの場合だけデコードする、の意味です。それら以外の場合は、どうする
かを利用者に尋ねます。

@item mm-sign-option
@vindex mm-sign-option
署名されたパートを作成するためのオプション。@code{nil} ではディフォルト
の署名のための鍵を使い、@code{guided} では署名のための鍵をメニューから選
びます。

@item mm-encrypt-option
@vindex mm-encrypt-option
暗号化されたパートを作成するためのオプション。@code{nil} で
は @samp{From:} ヘッダーを受取人として最初に合致する公開鍵を使い、
@code{guided} では受取人のキーをメニューから選びます。

@item mml1991-use
@vindex mml1991-use
@acronym{PGP} のメッセージのための、OpenPGP の実装への elisp インターフェー
スを示すシンボルです。ディフォルトは @code{epg} ですが、後方互換のため
に @code{pgg} および @code{mailcrypt} もサポートします。ディフォルトでは、
Gnus はこの順番で最初に見つかるインターフェースを使います。

@item mml2015-use
@vindex mml2015-use
@acronym{PGP/MIME} のメッセージのための、OpenPGP の実装への elisp インター
フェースを示すシンボルです。ディフォルトは @code{epg} ですが、後方互換の
ために @code{pgg}、@code{mailcrypt} および @code{gpg} もサポートします。
ディフォルトでは、Gnus はこの順番で最初に見つかるインターフェースを使い
ます。
@end table

ディフォルトではセキュリティーの情報を表示するボタンが現れません。それら
は実際にメールを読む際に邪魔になるからです。 @kbd{K b} をタイプすれば、
その情報を表示することができますが。これを恒久的に行なわせるには、
@code{gnus-buttonized-mime-types} およ
び @code{gnus-unbuttonized-mime-types} 変数を使ってください。これらの変
数の詳細と、常にセキュリティーの情報を表示させるためにカスタマイズする方
法は、@ref{MIME Commands} を参照してください。

@cindex snarfing keys
@cindex importing PGP keys
@cindex PGP key ring import
メニュー項目やコマンドから OpenPGP の鍵を取得 (snarf) する (すなわち、記
事から鍵を鍵束に輸入 (import) する) 機能は、明示的にはサポートされません。
というよりはむしろ、あなたが適切だと思うどんな動作をも通常
の @acronym{MIME} の機構を介して指定できるように、
Gnus は @samp{application/pgp-keys} として鍵を検出し、ラベルを付けます。
@acronym{MIME} ボタンをクリック (@pxref{Using MIME}) したときに、GNU
Privacy Guard を使って鍵を輸入してくれるようにするには、以下のような行
を @file{~/.mailcap} ファイル (@pxref{mailcap, ,mailcap, emacs-mime-ja,
The Emacs MIME Manual}) に記入してください。

@example
application/pgp-keys; gpg --import --interactive --verbose; needsterminal
@end example

これは、たまたま @code{mailcap-mime-data} ですでに定義されている、ディフォ
ルトの動作でもあります。

送信するメッセージに署名したり暗号化するために、どうやって設定するかにつ
いてのもっと詳しい情報が、message マニュアル (@pxref{Security,
,セキュリティー, message-ja, The Message Manual}) で見つかるでしょう。

@node Mailing List
@section メーリングリスト
@cindex mailing list
@cindex RFC 2396

@kindex A M @r{(概略)}
@findex gnus-mailing-list-insinuate
Gnus は RFC 2369 で規定された各種のメーリングリストで使われるフィールド
を理解します。これを有効にするには概略バッファー
で @kbd{A M} (@code{gnus-mailing-list-insinuate}) を使うなどして、
@code{to-list} グループパラメーター (@pxref{Group Parameters}) を追加し
てください。

これによって概略バッファーでの以下の命令が使えるようになります。

@table @kbd
@item C-c C-n h
@kindex C-c C-n h @r{(概略)}
@findex gnus-mailing-list-help
List-Help フィールドがあったら、メーリングリストのヘルプを取り寄せるため
のメッセージを送信します。

@item C-c C-n s
@kindex C-c C-n s @r{(概略)}
@findex gnus-mailing-list-subscribe
List-Subscribe フィールドがあったら、メーリングリストの講読を始めるため
のメッセージを送信します。

@item C-c C-n u
@kindex C-c C-n u @r{(概略)}
@findex gnus-mailing-list-unsubscribe
List-Unsubscribe フィールドがあったら、メーリングリストの講読をやめるた
めのメッセージを送信します。

@item C-c C-n p
@kindex C-c C-n p @r{(概略)}
@findex gnus-mailing-list-post
List-Post フィールドがあったら、メーリングリストに投稿します。

@item C-c C-n o
@kindex C-c C-n o @r{(概略)}
@findex gnus-mailing-list-owner
List-Owner フィールドがあったら、メーリングリストの管理者宛てにメッセー
ジを送信します。

@item C-c C-n a
@kindex C-c C-n a @r{(概略)}
@findex gnus-mailing-list-archive
List-Archive フィールドがあったら、メーリングリストのアーカイブを閲覧し
ます。
@end table

@node Article Buffer
@chapter 記事バッファー
@cindex article buffer

記事は一つしかない記事バッファーに表示されます。すべての概略バッファー
は (Gnus に指示しない限り) 同じ記事バッファーを共有します。

@menu
* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を @acronym{MIME} に通す
* HTML::                        @acronym{HTML} メッセージを読む
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他
@end menu

@node Hiding Headers
@section 余分なヘッダーを隠す
@cindex hiding headers
@cindex deleting headers

各記事の頭の部分はヘッダー (@dfn{head}) と呼ばれます。(残りの部分はボ
ディー (@dfn{body}) です。すでにお気づきでしょうが。)

@vindex gnus-show-all-headers
ヘッダーにはたくさんの有益な情報が含まれています。記事を書いた人の名前、
それが書かれた日付、および記事の表題です。これはとても良いのですが、ヘッ
ダーには大部分の人にとっては見たくもない情報---記事があなたのところに着
くまでにどんなシステムを経由してきたか、@code{Message-ID}、
@code{References} などなど…もううんざりするくらい---たくさん含まれてい
ます。たぶんあなたはこれらの行のいくつかは取り除いてしまいたいと思うでしょ
う。もしこれらの行をすべて記事バッファー内に残しておきたければ、
@code{gnus-show-all-headers} を @code{t} に設定してください。

Gnus はヘッダーを選り分けるために二つの変数を用意しています:

@table @code
@item gnus-visible-headers
@vindex gnus-visible-headers
この変数が @code{nil} 以外であれば、どのヘッダーを記事バッファーに残した
いかを指定する正規表現であるとみなされます。この変数に合致しないヘッダー
はすべて隠されます。

例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します:

@lisp
(setq gnus-visible-headers "^From:\\|^Subject:")
@end lisp

この変数は、表示させたいヘッダーに合致する正規表現をリストで指定すること
もできます。

@item gnus-ignored-headers
@vindex gnus-ignored-headers
この変数は @code{gnus-visible-headers} の反対です。この変数が設定されて
いれば (かつ @code{gnus-visible-headers} が @code{nil} であれば)、これは
隠したいヘッダー行すべてに合致する正規表現であるとみなされます。この変数
に合致しないすべてのヘッダー行が表示されます。

例えば、単に @code{References} 欄と @code{Xref} 欄のみを消し去りたければ、
以下のようにします:

@lisp
(setq gnus-ignored-headers "^References:\\|^Xref:")
@end lisp

この変数は消したいヘッダーに合致する正規表現のリストでも構いません。

なお、@code{gnus-visible-headers} が @code{nil} 以外の場合は、この変数に
は効果が無いことに注意してください。
@end table

@vindex gnus-sorted-header-list
Gnus はヘッダーの並べ替え (sort) も行ないます (これはディフォルトで行な
われます)。この並べ替えは @code{gnus-sorted-header-list} 変数を設定する
ことで制御することができます。これはヘッダーをどういう順序で表示するかを
指定する正規表現のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風になるで
しょう。

@lisp
(setq gnus-sorted-header-list '("^From:" "^Subject:"))
@end lisp

表示するようになっているヘッダーでこの変数に指定されていないものは、この
変数に指定されているすべてのヘッダーの後に、適当な順序で表示されるでしょ
う。

@findex gnus-article-hide-boring-headers
@vindex gnus-boring-article-headers
@code{gnus-treat-hide-boring-headers} を @code{head} に設定することによっ
て、もっとつまらないヘッダーを隠すことができます。この関数が何をするか
は @code{gnus-boring-article-headers} 変数に依存します。この変数はリスト
ですが、このリストには実際のヘッダーの名前が入るのではありません。代わり
に Gnus がチェックして視界から消し去るためのさまざまな「つまらない条件」
(@dfn{boring conditions}) のリストを指定します。

この条件には以下のようなものがあります。

@table @code
@item empty
空のヘッダーをすべて消去します。
@item followup-to
@code{Followup-To} 欄が @code{Newsgroups} 欄と同一である場合には消去しま
す。
@item reply-to
@code{Reply-To} 欄が @code{From} 欄と同じアドレスを示しているか、
@code{broken-reply-to} グループパラメーターが設定されている場合には消去
します。
@item newsgroups
@code{Newsgroups} 欄が現在のグループ名しか含んでいない場合には消去します。
@item to-address
@code{To} 欄が現在のグループの @code{to-address} パラメーターと同じもの
しか含んでいない場合には消去します。
@item to-list
@code{To} 欄が現在のグループの @code{to-list} パラメーターと同じものしか
含んでいない場合には消去します。
@item cc-list
@code{Cc} 欄が現在のグループの @code{to-list} パラメーターと同じものしか
含んでいない場合には消去します。
@item date
その記事が過去三日以内のものであれば、@code{Date} 欄を消去します。
@item long-to
@code{To} 欄および/または @code{Cc} 欄があまりにも長い場合には消去します。
@item many-to
@code{To} 欄および/または @code{Cc} 欄が一つよりも多ければ、それらをすべ
て消去します。
@end table

これらのうちの三つの要素を入れたければ、こんな風になります:

@lisp
(setq gnus-boring-article-headers
      '(empty followup-to reply-to))
@end lisp

これはこの変数のディフォルト値でもあります。

@node Using MIME
@section MIME を使う
@cindex @acronym{MIME}

パントマイム (mime) は、観客があくびをしながらぼんやりしているのにもかか
わらず、意味も無く空中で手を振るものの標準として広く知られています。

一方 @acronym{MIME} は、そのためにすべてのニュースリーダーが恐怖で死んで
しまうのにもかかわらず、意味も無く記事をエンコードする標準です。

@acronym{MIME} は記事がどんな文字セットを使うか、文字をどうエンコードす
るかを指定することができ、さらには絵やその他のみだらなものを無邪気な格好
の記事に埋め込むことさえ可能にします。

@vindex gnus-display-mime-function
@findex gnus-display-mime
Gnus は @acronym{MIME} パートを表示するために、
@code{gnus-display-mime-function} によって @acronym{MIME} 記事を処理しま
す。これはディフォルトでは @code{gnus-display-mime} で、
@acronym{MIME} オブジェクトを表示し、セーブし、かつ操作するために使うこ
とができる、ひとかたまりのクリック可能なボタンを作成します。

@acronym{MIME} ボタンの上にポイントを置いたならば、以下のコマンドが利用
できます:

@table @kbd
@findex gnus-article-press-button
@item @key{RET} @r{(記事)}
@kindex RET @r{(記事)}
@itemx BUTTON-2 @r{(記事)}
@acronym{MIME} オブジェクトの表示をトグルで切り替えま
す (@code{gnus-article-press-button})。そのオブジェクトを内蔵のビューワー
で表示できないときは、Gnus は @file{mailcap} ファイルにある外部のビュー
ワーに助けを求めます。ビューワーが @samp{copiousoutput} 仕様になっている
場合は、オブジェクトはインラインで (訳注: Emacs の表示に埋め込まれて) 表
示されます。

@findex gnus-mime-view-part
@item M-@key{RET} @r{(記事)}
@kindex M-RET @r{(記事)}
@itemx v @r{(記事)}
手段を尋ね、その手段を使って @acronym{MIME} オブジェクトを表示しま
す (@code{gnus-mime-view-part})。

@findex gnus-mime-view-part-as-type
@item t @r{(記事)}
@kindex t @r{(記事)}
@acronym{MIME} オブジェクトを、異なる @acronym{MIME} メディア・タイプで
あるかのように表示します (@code{gnus-mime-view-part-as-type})。

@findex gnus-mime-view-part-as-charset
@item C @r{(記事)}
@kindex C @r{(記事)}
文字セットを尋ね、その文字セットを使って @acronym{MIME} オブジェクトを表
示します (@code{gnus-mime-view-part-as-charset})。

@findex gnus-mime-save-part
@item o @r{(記事)}
@kindex o @r{(記事)}
ファイル名を尋ねて @acronym{MIME} オブジェクトをセーブしま
す (@code{gnus-mime-save-part})。

@findex gnus-mime-save-part-and-strip
@item C-o @r{(記事)}
@kindex C-o @r{(記事)}
ファイル名を尋ね、@acronym{MIME} オブジェクトをセーブして、それを記事か
ら取り外します (記事を編集することによって行なわれます)。取り外され
た @acronym{MIME} オブジェクトは message/external-body @acronym{MIME} タ
イプとして参照されるようになりま
す (@code{gnus-mime-save-part-and-strip})。

@findex gnus-mime-replace-part
@item r @r{(記事)}
@kindex r @r{(記事)}
ファイル名の入力を求めて、@acronym{MIME} オブジェクト
を message/external-body 型の @acronym{MIME} 形式のファイルとして参照さ
れる外部にある本体で置き換えます。(@code{gnus-mime-replace-part})。

@findex gnus-mime-delete-part
@item d @r{(記事)}
@kindex d @r{(記事)}
記事から @acronym{MIME} オブジェクトを取り外し、取り外したことを表す告知
で置き換えます (@code{gnus-mime-delete-part})。
@c
@c FIXME: gnus-auto-select-part はここで説明されるべきです。

@findex gnus-mime-copy-part
@item c @r{(記事)}
@kindex c @r{(記事)}
@acronym{MIME} オブジェクトを新たに作ったバッファーにコピーして、それを
表示します (@code{gnus-mime-copy-part})。接頭引数が与えられると、デコー
ドせずに生の内容物をコピーします。数値の接頭引数を与えると、文字セットに
よるデコードを半手動で切り替えることができま
す (@ref{Paging the Article} で述べられてい
る @code{gnus-summary-show-article-charset-alist} を参照してください)。
@code{auto-compression-mode} (@pxref{Compressed Files, ,Accessing
Compressed Files, emacs, The Emacs Editor}) が設定されていると、
@file{.gz} や @file{.bz2} のような圧縮されたファイルを自動的に解凍します。

@findex gnus-mime-print-part
@item p @r{(記事)}
@kindex p @r{(記事)}
@acronym{MIME} オブジェクトを印刷します (@code{gnus-mime-print-part})。
このコマンドは @file{.mailcap} ファイルで定義された @samp{print=} 仕様に
従います。

@findex gnus-mime-inline-part
@item i @r{(記事)}
@kindex i @r{(記事)}
@acronym{MIME} オブジェクトの内容物を、その記事バッファー
に @samp{text/plain} として挿入します (@code{gnus-mime-inline-part})。接
頭引数が与えられると、デコードせずに生の内容物を挿入します。数値の接頭引
数を与えると、文字セットによるデコードを半手動で切り替えることができま
す (@ref{Paging the Article} で述べられてい
る @code{gnus-summary-show-article-charset-alist} を参照してください)。
@code{auto-compression-mode} (@pxref{Compressed Files, ,Accessing
Compressed Files, emacs, The Emacs Editor}) の
設定とは無関係に、@file{.gz} や @file{.bz2} のような圧縮されたファイル
を @code{jka-compr} を使って自動的に解凍します。

@findex gnus-mime-view-part-internally
@item E @r{(記事)}
@kindex E @r{(記事)}
内部ビューワーで @acronym{MIME} オブジェクトを表示します。内部ビューワー
が使えないときは、外部ビューワーを使いま
す (@code{gnus-mime-view-part-internally})。

@findex gnus-mime-view-part-externally
@item e @r{(記事)}
@kindex e @r{(記事)}
外部ビューワーで @acronym{MIME} オブジェクトを表示しま
す (@code{gnus-mime-view-part-externally})。

@findex gnus-mime-pipe-part
@item | @r{(記事)}
@kindex | @r{(記事)}
@acronym{MIME} オブジェクトをプロセスに出力しま
す (@code{gnus-mime-pipe-part})。

@findex gnus-mime-action-on-part
@item . @r{(記事)}
@kindex . @r{(記事)}
@acronym{MIME} オブジェクトをどう処理するかを、対話的に決めて実行しま
す (@code{gnus-mime-action-on-part})。
@end table

Gnus はいくつかの種類の @acronym{MIME} オブジェクトを自動的に表示します。
どのパートに対してそうするかを Gnus が決めるやり方については、
Emacs @acronym{MIME} マニュアルで述べられています。

不愉快なものでびっくりさせられるのを避けるには、トグルで切り替える関数を
使うのが最も良いでしょう。 (例えば、@samp{alt.sing-a-long} グループに入
ると、あなたの気づかないうちに @acronym{MIME} は記事中のサウンドファイル
をデコードして、何やら怪しげな長い長い歌があなたのスピーカーから大音響で
流れ出し、あなたはボリュームボタンを見つけられず、というのはそんなものは
もともと付いていないからで、みんなはあなたの方を睨みはじめ、あなたはプロ
グラムを止めようとするけれどもできなくて、ボリュームを制御するプログラム
も見つけられなくて、そして部屋中の全員は突然あなたのことを軽蔑の眼差しで
見るようになってしまい、あなたはちょっと面白くない思いをする、とか)。

現実の出来事と実在の人物に類似しているかもしれませんが、これはすべてホン
トのことです。げほげほ。

@ref{MIME Commands} も見てください。

@node HTML
@section HTML
@cindex HTML

Gnus は @acronym{HTML} 記事を素敵に整形して記事バッファーに表示すること
ができます。たくさんの方法がありますが、それらのうちの 2つがディフォルト
の手段であると言えます。

もし Emacs が libxml2 を使うように作られていれば、Gnus は純粋に Elisp で
書かれていて Emacs に組み込まれている Simple HTML Renderer @code{shr} を
使います。@footnote{@code{shr} は @acronym{HTML} 記事が指定する色を表示
しますが、それらを読むことができるように調整しようとします。もっとコント
ラストを強くしたいなら @pxref{FAQ 4-16} を見てください。}
@code{shr} は Emacs のブラウザーであ
る EWW (@pxref{EWW, ,EWW, emacs, The Emacs Manual}) でも使われます。

Emacs に libxml2 のサポートが無くても @code{w3m} がインストールされてい
れば、Gnus は @acronym{HTML} メールを描画して、その結果を記事バッファー
に表示します (@code{gnus-w3m})。

完全な概要については @xref{Display Customization, ,Display Customization,
emacs-mime-ja, The Emacs MIME Manual}, を参照してください。この章はディ
フォルトの機能だけを説明します。

@table @code
@item mm-text-html-renderer
@vindex mm-text-html-renderer
もしこれが @code{gnus-article-html} に設定されていると、
Gnus は @code{w3m} を利用するその組み込み機能を使います。

@item gnus-blocked-images
@vindex gnus-blocked-images
@acronym{URL} がこの正規表現に合致する外部画像は取得も表示もされません。
例えば ``ads'' という文字列をそれらの内に持つすべての @acronym{URL} を阻
止するには、以下のようにしてください:

@lisp
(setq gnus-blocked-images "ads")
@end lisp

これは評価されるべき関数でも構いません。その場合、それはグループ名をパラ
メーターとして呼ばれます。ディフォルト値
は @code{gnus-block-private-groups} で、ニュースグループの記事ではないど
んなものに対しても @samp{"."} を返します。これはメールを読むときに外部画
像を取得しないということで、それによってあなたがメールを読んだかどうかを
追跡するために誰も web bugs (訳注: インターネットユーザを追跡するための
ツール) の類を使えないようにします。

@code{gnus-inhibit-images} も参照してください (@pxref{Misc Article})。

@item gnus-html-cache-directory
@vindex gnus-html-cache-directory
Gnus は @code{gnus-blocked-images} がどう設定されているかに応じて画像を
ダウンロードしてキャッシュしますが、それらの画像はこのディレクトリーに保
存されます。

@item gnus-html-cache-size
@vindex gnus-html-cache-size
そのディレクトリーで、@code{gnus-html-cache-size} で指定されたバイト数を
越える古いファイルは消去されます。ディフォルトは 500MB です。

@item gnus-html-frame-width
@vindex gnus-html-frame-width
HTML を描画するときの幅です。ディフォルトは 70 です。

@item gnus-max-image-proportion
@vindex gnus-max-image-proportion
表示される画像が、それらがあるウィンドウに対してどれくらい大きいかを表す
値です。0.7 という値 (ディフォルト) は、それらがウィンドウの幅と高さ
の 70% を取ることができることを意味します。画像がこれより大きくて、か
つ Emacs がそれを行なうことができるならば (訳注: ImageMagick ライブラリー
を使うように構築されているならば)、これらの基準に合うように縮小されます。

@item gnus-article-show-cursor
@vindex gnus-article-show-cursor
これが @code{nil} 以外の値だったら、記事バッファーが現在バッファーではな
いときでも、記事バッファーにカーソルを表示します。
@end table

これを使うためには @code{w3m} と @code{curl} がインストールされている必
要があります。もしあれば Gnus は自動的に @acronym{HTML} を表示するはずで
す。

@node Customizing Articles
@section 記事のカスタマイズ
@cindex article customization

記事をどのように見せるかをカスタマイズするためのたくさんの関数が存在して
います。これらの関数を対話的に呼ぶこともできる
し (@pxref{Article Washing})、記事を選択したときに自動的に選択することも
できます。

自動的に呼ばれるようにするためには、対応するトリートメント変数を設定しな
ければなりません。例えばヘッダーを隠すためには、
@code{gnus-treat-hide-headers} を設定します。以下は設定できる変数の一覧
ですが、まずこれらの変数の取り得る値について話しましょう。

注意: いくつかの値は、有効な値であってもほとんど意味を無しません。実用的
な値は下の一覧を調べてください。

@enumerate
@item
@code{nil}: このトリートメントをしません。

@item
@code{t}: このトリートメントをすべての本文のパートで行ないます。

@item
@code{head}: ヘッダーでそのトリートメントをします。

@item
@code{first}: このトリートメントを最初の本文のパートで行ないます。

@item
@code{last}: このトリートメントを最後の本文のパートで行ないます。

@item
整数: このトリートメントをこの数値より短いすべての本文のパートで行ないま
す。

@item
文字列のリスト: このリストに含まれている正規表現に合致する名前のグループ
で読まれた記事の、すべての本文のパートでこのトリートメントを行ないます。

@item
最初の要素が文字列でないリストです:

リストは再帰的に評価されます。リストの最初の要素は述語です。以下の述語が
認識されます: @code{or}, @code{and}, @code{not}, @code{typep}。例です:

@lisp
(or last
    (typep "text/x-vcard"))
@end lisp

@item
関数: 引数を受け取らない関数で、@code{nil} または non-@code{nil} を返し
ます。現在の記事は変数 @code{gnus-article-buffer} の値が示すバッファーに
あります。
@end enumerate

ここで「パート」という語が使われていることに気付いたと思います。これはメッ
セージには @acronym{MIME} マルチパート記事があり、いくつかのパートに分割
されているかもしれないという事実に関連しています。マルチパートでない記事
は一つのパートのみであるとみなされます。

@vindex gnus-article-treat-types
このトリートメントはすべてのマルチパートのパートたちに適用されるのでしょ
うか?  はい、そうしたければそうなります。ですが、ディフォルトで
は @samp{text/plain} パートだけにトリートメントが施されます。これ
は @code{gnus-article-treat-types} 変数で制御され、これはパートの型に合
致する正規表現のリストです。制御変数の値が、上で説明されているように述語
のリストであるときは、この変数は無視されます。

@ifinfo
@c 印刷されるマニュアルでは、同じセクションに冗長気味なエントリーが現れ
@c ないようにしますが、'i gnus-treat-foo-bar @key{RET}' また
@c は 'i foo-bar' を行なうことができるように、これらを info に加えます。
@vindex gnus-treat-buttonize
@vindex gnus-treat-buttonize-head
@vindex gnus-treat-capitalize-sentences
@vindex gnus-treat-overstrike
@vindex gnus-treat-strip-cr
@vindex gnus-treat-strip-headers-in-body
@vindex gnus-treat-strip-leading-blank-lines
@vindex gnus-treat-strip-multiple-blank-lines
@vindex gnus-treat-strip-pem
@vindex gnus-treat-strip-trailing-blank-lines
@vindex gnus-treat-unsplit-urls
@vindex gnus-treat-wash-html
@vindex gnus-treat-date
@vindex gnus-treat-from-picon
@vindex gnus-treat-mail-picon
@vindex gnus-treat-newsgroups-picon
@vindex gnus-treat-from-gravatar
@vindex gnus-treat-mail-gravatar
@vindex gnus-treat-display-smileys
@vindex gnus-treat-body-boundary
@vindex gnus-treat-display-x-face
@vindex gnus-treat-display-face
@vindex gnus-treat-emphasize
@vindex gnus-treat-fill-article
@vindex gnus-treat-fill-long-lines
@vindex gnus-treat-hide-boring-headers
@vindex gnus-treat-hide-citation
@vindex gnus-treat-hide-citation-maybe
@vindex gnus-treat-hide-headers
@vindex gnus-treat-hide-signature
@vindex gnus-treat-strip-banner
@vindex gnus-treat-strip-list-identifiers
@vindex gnus-treat-highlight-citation
@vindex gnus-treat-highlight-headers
@vindex gnus-treat-highlight-signature
@vindex gnus-treat-play-sounds
@vindex gnus-treat-x-pgp-sig
@vindex gnus-treat-unfold-headers
@vindex gnus-treat-fold-headers
@vindex gnus-treat-fold-newsgroups
@vindex gnus-treat-leading-whitespace
@end ifinfo

以下のトリートメントのオプションが使用可能です。これをカスタマイズするた
めの最も簡単な方法は @code{gnus-article-treat} カスタマイズグループを調
査することです。丸括弧の中の値は提案されている意味のある値です。他のもの
も可能ですが、ほとんどの人にとってはおそらくここに一覧表示されているもの
で十分でしょう。

@table @code
@item gnus-treat-buttonize (t, integer)
@item gnus-treat-buttonize-head (head)

@xref{Article Buttons}.

@item gnus-treat-capitalize-sentences (t, integer)
@item gnus-treat-overstrike (t, integer)
@item gnus-treat-strip-cr (t, integer)
@item gnus-treat-strip-headers-in-body (t, integer)
@item gnus-treat-strip-leading-blank-lines (t, first, integer)
@item gnus-treat-strip-multiple-blank-lines (t, integer)
@item gnus-treat-strip-pem (t, last, integer)
@item gnus-treat-strip-trailing-blank-lines (t, last, integer)
@item gnus-treat-unsplit-urls (t, integer)
@item gnus-treat-wash-html (t, integer)

@xref{Article Washing}.

@item gnus-treat-date (head)

日付ヘッダーを @code{gnus-article-date-headers} 変数に応じて変形/追加し
ます。これは表示する Date ヘッダーのリストです。利用可能な形式は:

@table @code
@item ut
協定世界時。GMT とか ZULU とも言います。

@item local
ユーザーのローカル時間帯。

@item english
英文として読める形式。

@item lapsed
メッセージが投稿されてからの経過時間。

@item combined-lapsed
元の Date ヘッダーと (短い形式の) 経過時間。

@item combined-local-lapsed
ユーザーのローカル時間帯と (短い形式の) 経過時間。

@item original
元の Date ヘッダー。

@item iso8601
ISO8601 形式。つまり ``2010-11-23T22:05:21'' のようなもの。

@item user-defined
@code{gnus-article-time-format} 変数に従った形式。
@end table

@xref{Article Date}.

@item gnus-treat-from-picon (head)
@item gnus-treat-mail-picon (head)
@item gnus-treat-newsgroups-picon (head)

@xref{Picons}.

@item gnus-treat-from-gravatar (head)
@item gnus-treat-mail-gravatar (head)

@xref{Gravatars}.

@item gnus-treat-display-smileys (t, integer)

@item gnus-treat-body-boundary (head)

@vindex gnus-body-boundary-delimiter
ヘッダーと本文の間に境界線を追加します。境界線に
は @code{gnus-body-boundary-delimiter} に設定された文字列が使われます。

@xref{Smileys}.

@vindex gnus-treat-display-x-face
@item gnus-treat-display-x-face (head)

@xref{X-Face}.

@vindex gnus-treat-display-face
@item gnus-treat-display-face (head)

@xref{Face}.

@vindex gnus-treat-emphasize
@item gnus-treat-emphasize (t, head, integer)
@vindex gnus-treat-fill-article
@item gnus-treat-fill-article (t, integer)
@vindex gnus-treat-fill-long-lines
@item gnus-treat-fill-long-lines (t, integer)
@vindex gnus-treat-hide-boring-headers
@item gnus-treat-hide-boring-headers (head)
@vindex gnus-treat-hide-citation
@item gnus-treat-hide-citation (t, integer)
@vindex gnus-treat-hide-citation-maybe
@item gnus-treat-hide-citation-maybe (t, integer)
@vindex gnus-treat-hide-headers
@item gnus-treat-hide-headers (head)
@vindex gnus-treat-hide-signature
@item gnus-treat-hide-signature (t, last)
@vindex gnus-treat-strip-banner
@item gnus-treat-strip-banner (t, last)
@vindex gnus-treat-strip-list-identifiers
@item gnus-treat-strip-list-identifiers (head)

@xref{Article Hiding}.

@vindex gnus-treat-highlight-citation
@item gnus-treat-highlight-citation (t, integer)
@vindex gnus-treat-highlight-headers
@item gnus-treat-highlight-headers (head)
@vindex gnus-treat-highlight-signature
@item gnus-treat-highlight-signature (t, last, integer)

@xref{Article Highlighting}.

@vindex gnus-treat-play-sounds
@item gnus-treat-play-sounds
@item gnus-treat-ansi-sequences (t)
@vindex gnus-treat-x-pgp-sig
@item gnus-treat-x-pgp-sig (head)

@vindex gnus-treat-unfold-headers
@item gnus-treat-unfold-headers (head)
@vindex gnus-treat-fold-headers
@item gnus-treat-fold-headers (head)
@vindex gnus-treat-fold-newsgroups
@item gnus-treat-fold-newsgroups (head)
@vindex gnus-treat-leading-whitespace
@item gnus-treat-leading-whitespace (head)

@xref{Article Header}.
@end table

@vindex gnus-part-display-hook
もちろん、@code{gnus-part-display-hook} から呼ばれる自分用の関数を書く
こともできます。関数はそのパートに範囲が狭められた状態で呼ばれ、ほとんど
なんでも好きなことができます。バッファーに保存しておかなければならない情
報はありません---何でも変えることができます。

@node Article Keymap
@section 記事のキーマップ

概略バッファーにおけるキー操作のほとんどは記事バッファーでも使用できます。
これらは概略バッファーでそれらを押したかのように動作するはずです。つまり
記事を読んでいる間、実際に概略バッファーを表示させておく必要がありません。
すべての操作は記事バッファーから行なうことができるのです。

@kindex v @r{(記事)}
@cindex keys, reserved for users (Article)
@kbd{v} キーはユーザー用に予約されています。そのまま何かのコマンドに割り
当てても構いませんが、接頭キーとして使う方が良いでしょう。

他にもいくつかのキーが利用できます:

@table @kbd
@item @key{SPC}
@kindex SPC @r{(記事)}
@findex gnus-article-next-page
記事を一ページ先にスクロールします。(@code{gnus-article-next-page})。
@kbd{h @key{SPC} h} とまったく同じです。

@item @key{DEL}
@kindex DEL @r{(記事)}
@findex gnus-article-prev-page
記事を一ページ前にスクロールします (@code{gnus-article-prev-page})。
@kbd{h @key{DEL} h} とまったく同じです。

@item C-c ^
@kindex C-c ^ @r{(記事)}
@findex gnus-article-refer-article
カーソルが @code{Message-ID} の近辺にあるときに @kbd{C-c ^} を押すと、
Gnus はサーバーからその記事を取ってこようとしま
す (@code{gnus-article-refer-article})。

@item C-c C-m
@kindex C-c C-m @r{(記事)}
@findex gnus-article-mail
カーソルの近くにあるアドレスに返信を送ります (@code{gnus-article-mail})。
接頭引数を与えると、そのメールを引用します。

@item s
@kindex s @r{(記事)}
@findex gnus-article-show-summary
バッファーを再配置して、概略バッファーが見えるようにしま
す (@code{gnus-article-show-summary})。

@item ?
@kindex ? @r{(記事)}
@findex gnus-article-describe-briefly
利用できるキー操作のごく簡単な説明を出しま
す (@code{gnus-article-describe-briefly})。

@item @key{TAB}
@kindex TAB @r{(記事)}
@findex gnus-article-next-button
次のボタンがあればそこに移動します (@code{gnus-article-next-button})。こ
れは記事にボタンを付ける機能をオンにしているときのみ意味を持ちます。

@item M-@key{TAB}
@kindex M-TAB @r{(記事)}
@findex gnus-article-prev-button
一つ前のボタンがあればそこに移動します (@code{gnus-article-prev-button})。

@item R
@kindex R @r{(記事)}
@findex gnus-article-reply-with-original
現在の記事に元記事を含んだ返答のメールを送りま
す (@code{gnus-article-reply-with-original})。もし領域が活性化されていた
ならば、その領域にあるテキストだけを yank します。

@item S W
@kindex S W @r{(記事)}
@findex gnus-article-wide-reply-with-original
現在の記事に元記事を含んだ広い返答のメールを送りま
す (@code{gnus-article-wide-reply-with-original})。もし領域が活性化され
ていたならば、その領域にあるテキストだけを yank します。

訳注:「広い返答」とはヘッダーの @code{To}, @code{From}, (もしく
は @code{Reply-To}) と @code{Cc}) のすべての人に返答をすることです。
@code{Mail-Followup-To} があれば、代わりにそれが使われます。

@item F
@kindex F @r{(記事)}
@findex gnus-article-followup-with-original
現在の記事に元記事を含んでフォローアップをしま
す (@code{gnus-article-followup-with-original})。もし領域が活性化されて
いたならば、その領域にあるテキストだけを yank します。
@end table

@node Misc Article
@section 記事のその他

@table @code
@item gnus-single-article-buffer
@vindex gnus-single-article-buffer
@cindex article buffers, several
@code{nil} 以外であれば、すべてのグループに対して同じ記事バッファーを使
用します (これはディフォルトです)。@code{nil} であれば、各グループ毎の固
有の記事バッファーを持つようになります。

@item gnus-widen-article-window
@cindex gnus-widen-article-window
もし @code{nil} でなかったら @kbd{h} コマンドで記事を選ぶときに記事ウィ
ンドウをフレーム全体を占めるように拡大します。

@vindex gnus-article-decode-hook
@item gnus-article-decode-hook
@cindex @acronym{MIME}
@acronym{MIME} 記事をデコードするときに使用されるフックです。ディフォル
ト値は @code{(article-decode-charset article-decode-encoded-words)} です。

@vindex gnus-article-prepare-hook
@item gnus-article-prepare-hook
このフックは記事が記事バッファーに挿入された直後に呼び出されます。これは
主に、何か記事の内容に依存する処理をする関数のために用意されています。記
事バッファーの内容を変更するような目的で使うべきではないでしょう。

@item gnus-article-mode-hook
@vindex gnus-article-mode-hook
記事モードのバッファーで呼び出されるフックです。

@item gnus-article-mode-syntax-table
@vindex gnus-article-mode-syntax-table
記事バッファーで用いられる構文テーブル (syntax table) です。これ
は @code{text-mode-syntax-table} をもとに初期化されます。

@vindex gnus-article-over-scroll
@item gnus-article-over-scroll
非-@code{nil} にすることによって、それ以上スクロールする新しいテキストが
無くても記事バッファーをスクロールできるようにします。ディフォルト
は @code{nil} です。(訳注: 記事の最下行が見えているときに、@code{nil} だ
と @kbd{@key{RET}} キーでそれ以上スクロールしませんが、非-@code{nil} に
すると記事が見えなくなるまでスクロールします。)

@vindex gnus-article-mode-line-format
@item gnus-article-mode-line-format
この変数は @code{gnus-summary-mode-line-format} と同じ仕様に沿った様式文
字列です (@pxref{Summary Buffer Mode Line})。これは、その変数と同じ様式
指定および二つの拡張を受付けます。

@table @samp
@item w
記事の「洗濯状態」(@dfn{wash status})。これは記事に対して行なわれたであ
ろう洗濯操作を、それぞれ一文字で示す短い文字列になります。文字とそれらの
意味は次の通りです:

@table @samp
@item c
記事バッファーにおいて、引用された文が隠されているかもしれない場合に表示
されます。

@item h
記事バッファーにおいて、ヘッダーが隠されている場合に表示されます。

@item p
記事が電子署名または暗号化されていて、Gnus がセキュリティーのためのヘッ
ダーを隠していると表示されます。(注: 署名が正しいか間違っているかを表す
ものではありません。)

@item s
記事バッファーにおいて、署名が隠されている場合に表示されます。

@item o
記事バッファーにおいて、Gnus が重ね打ち文字のトリートメントを行なった場
合に表示されます。

@item e
記事バッファーにおいて、Gnus が強調された文字のトリートメントを行なった
場合に表示されます。
@end table

@item m
記事の @acronym{MIME} パートの数です。
@end table

@vindex gnus-break-pages
@item gnus-break-pages
改ページ (@dfn{page breaking}) を行なうかどうかを制御します。この変数
が @code{nil} 以外であれば、記事中にページ区切り文字が現れるごとにページ
分割をします。この変数が @code{nil} であればページ分けは行なわれません。

@item gnus-page-delimiter
@vindex gnus-page-delimiter
これが上で触れた区切り文字です。ディフォルトでは @samp{^L} (フォームフィー
ド) です。

@cindex IDNA
@cindex internationalized domain names
@vindex gnus-use-idna
@item gnus-use-idna
この変数は @samp{From:}、@samp{To:} および @samp{Cc:} ヘッダーにある国際
化ドメイン名を、Gnus が IDNA デコードするかどうかを制御します。そのよう
なメッセージの作り方について
は @xref{IDNA, ,国際化ドメイン名, message-ja, The Message Manual}, を参
照してください。これに
は @uref{https://www.gnu.org/software/libidn/, GNU Libidn} が必要で、こ
の変数はそれをインストールしてある場合だけ有効になります。

@vindex gnus-inhibit-images
@item gnus-inhibit-images
もし @code{nil} でなければ、記事のボディーでの画像のインライン表示を禁止
します。これは @acronym{MIME} パートとして記事にある画像、およ
び @code{mm-text-html-renderer} (@pxref{Display Customization, ,表示のカ
スタマイズ, emacs-mime-ja, The Emacs MIME Manual}) が @code{shr} また
は @code{gnus-w3m} である場合に表示された @acronym{HTML} 記事の画像に対
して有効です。
@end table

@node Composing Messages
@chapter メッセージの作成
@cindex composing messages
@cindex messages
@cindex mail
@cindex sending mail
@cindex reply
@cindex followup
@cindex post
@cindex using gpg
@cindex using s/mime
@cindex using smime

@kindex C-c C-c @r{(投稿)}
すべての投稿とメールを送るためのコマンドは、あなたをメッセージバッファー
に導きます。そこでは @kbd{C-c C-c} を押すことによって記事を送信する前に、
記事を好きなように編集することができます。@xref{Top, ,概要, message-ja,
The Message Manual}.  メッセージはあなたの設定に基づいて投稿またはメール
として送信されます (@pxref{Posting Server})。

@menu
* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?
@end menu

投稿するべきでなかった記事を削除するための情報について @ref{Canceling
and Superseding} も参照してください。

@node Mail
@section メール

出て行くメールをカスタマイズする変数です:

@table @code
@item gnus-uu-digest-headers
@vindex gnus-uu-digest-headers
要約メッセージ (digested message) に含まれるヘッダーに合致する正規表現の
リストです。ヘッダーは合致した順に取り込まれます。@code{nil} だったら、
すべてのヘッダーを含みます。

@item gnus-add-to-list
@vindex gnus-add-to-list
@code{nil} でなければ、@kbd{a} を押したときに、@code{to-list} グループパ
ラメーターをそれの無いメールグループに付け加えます。

@item gnus-confirm-mail-reply-to-news
@vindex gnus-confirm-mail-reply-to-news
非-@code{nil} だったら、あなたがニュース記事への返答をメールでしようとす
ると Gnus は確認を求めます。@code{nil} ならば、あなたがやりたいことに何
も口出ししません。これは関数か正規表現であることもできます。関数は唯一の
パラメーターとしてグループ名を受け取り、確認する必要がある場合に
非-@code{nil} を返します。これを正規表現にすると、それに合致する名前のグ
ループで確認を求めます。

メールで返信する気は無いのに時たまぞんざいに R を押してしまう癖があるな
らば、この変数はそんなあなたのためにあります。

@item gnus-confirm-treat-mail-like-news
@vindex gnus-confirm-treat-mail-like-news
非-@code{nil} だったら、Gnus はメールに返信する時に
も @code{gnus-confirm-mail-reply-to-news} に基づいた確認を求めます。これ
はメーリングリストをニュースグループのように扱うのに便利です。
@end table

@node Posting Server
@section 投稿するサーバー

最新の (もちろん、非常に知的な) 記事を送り出すために、あの魔法のよう
な @kbd{C-c C-c} キーを押した時、それはどこにいくのでしょう?

尋ねてくれてありがとう。あなたを恨みます。

それは非常に複雑になり得ます。

@vindex gnus-post-method
ニュースを投稿するとき、通常 Message は @code{message-send-news} を呼び
出します (@pxref{News Variables, ,ニュース変数, message-ja, The Message
Manual})。普通は、Gnus は講読用と同じ選択方法を使って投稿します (このこ
とは、あなたがたくさんのグループを異なったサーバーで講読している場合に、
たぶん都合が良いのです)。しかし、あなたが講読しているそのサーバーが投稿
を許可せず、読むことのみを許可しているのならば、おそらくあなたの (非常に
知的でとんでもなく興味深い) 記事を投稿するために、他のサーバーを使いたい
と思うでしょう。そうならば @code{gnus-post-method} を他の方法に設定する
ことができます:

@lisp
(setq gnus-post-method '(nnspool ""))
@end lisp

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが落
ちていたりしたら、どうしたらよいのでしょう? この変数よりも優先させるため
に @kbd{C-c C-c} 命令にゼロでない数の接頭引数を与えることによって、投稿
に“current”(現在の) サーバーを使わせること、すなわちディフォルトの動
作 (訳注: @code{gnus-post-method} のディフォルト値は @code{current}) に
戻すことができます。

もし、ゼロを接頭引数としてその命令に与えたなら (すなわち、@kbd{C-u 0 C-c
C-c})、Gnus は投稿にどの方法を使うかをあなたに尋ねます。

@code{gnus-post-method} を選択方法のリストにすることもできます。その場合
は、Gnus は常に投稿にどの方法を使うかをあなたに尋ねます。

最後に、あなたがいつでも基本の選択方法を使って投稿したいのならば、この変
数を @code{native} にしてください。

@vindex message-send-mail-function
メールを送信するときに、Message は @code{message-send-mail-function} 変
数によって指定される関数を呼び出します。Gnus はそれを、あなたのシステム
に適合する値に設定しようとします。詳しくは: @xref{Mail Variables, ,
メール変数, message-ja, The Message Manual}.

@node POP before SMTP
@section POP before SMTP
@cindex pop before smtp
@findex message-smtpmail-send-it
@findex mail-source-touch-pop

あなたの @acronym{ISP} は @acronym{POP}-before-@acronym{SMTP} 認証を使い
ますか?  この認証手順は、電子メールを送信する前に @acronym{POP} サーバー
と通信することを要求します。それを行なうには @file{~/.gnus.el} ファイル
に以下の行を入れてください:

@lisp
(add-hook 'message-send-mail-hook 'mail-source-touch-pop)
@end lisp

@noindent
メールを送信する直前に、@code{mail-source-touch-pop} 関数はメールを取得
せずに @code{mail-sources} の値に従って @acronym{POP} 認証を行ないます。
@xref{Mail Sources}.

もし @code{mail-sources} に二つ以上の @acronym{POP} メールサーバーを設定
しているならば、それらの一つを @acronym{POP}-before-@acronym{SMTP} 認証
に使われる @acronym{POP} メールサーバーとし
て @code{mail-source-primary-source} に設定する必要があるでしょう。それ
が第一 @acronym{POP} メールサーバーならば (すなわち、主にそのサーバーか
らメールを取得しているならば)、それを以下のように恒久的に設定することが
できます:

@lisp
(setq mail-source-primary-source
      '(pop :server "pop3.mail.server"
            :password "secret"))
@end lisp

@noindent
さもなければ、@acronym{POP}-before-@acronym{SMTP} 認証を行なうときだけ、
それを以下のように動的に束縛してください:

@lisp
(add-hook 'message-send-mail-hook
          (lambda ()
            (let ((mail-source-primary-source
                   '(pop :server "pop3.mail.server"
                         :password "secret")))
              (mail-source-touch-pop))))
@end lisp

@node Mail and Post
@section メールと投稿

これはメールの送信とニュースの投稿の両方に関連する変数のリストです:

@table @code
@item gnus-mailing-list-groups
@findex gnus-mailing-list-groups
@cindex mailing lists
あなたのニュースサーバーが、本当にメーリングリストの記事
を @acronym{NNTP} サーバーに流し込むゲートウェイによって、それらがニュー
スグループの記事として見えるようにしているのであれば、それらのグループは
問題なく読めるでしょう。しかしいくらか面倒なことを克服すること無しに、そ
れらに投稿またはフォローアップすることはできません。一つの解決法は、グルー
プパラメーター (@pxref{Group Parameters}) に @code{to-address} を加える
ことです。簡単にできるのは、@code{gnus-mailing-list-groups} を、本当はメー
リングリストであるグループに合致する正規表現に設定することです。そうすれ
ば、少なくともメーリングリストへのフォローアップはたいていのときに行なう
ことができるでしょう。これらのグループに投稿すること (@kbd{a}) は、それ
でも苦痛を引き起こすでしょうけれど。

@item gnus-user-agent
@vindex gnus-user-agent
@cindex User-Agent
この変数は、どの情報が User-Agent ヘッダーに陳列されるかを制御します。シ
ンボルのリスト、または文字列です。有効なシンボルは @code{gnus} (Gnus の
バージョン) および @code{emacs} (Emacs のバージョン) です。Emacs のバー
ジョンには @code{config} (@code{system-configuration} の値) か @code{type}
(@code{system-type} の値) を加えることができます。これを文字列にするとき
は、正しいフォーマットを使ってください (RFC2616 参照)。
@end table

あなたは自分が送るメッセージで、綴りをチェックしたいかもしれません。もし
くは手で綴りのチェックをしたくないのであれば、自動綴りチェック
を @code{ispell} パッケージを使うことによって付け加えることができます:

@cindex ispell
@findex ispell-message
@lisp
(add-hook 'message-send-hook 'ispell-message)
@end lisp

@code{ispell} の辞書をグループに応じて切り替えたいならば、以下のようにす
れば良いでしょう。

@lisp
(add-hook 'gnus-select-group-hook
          (lambda ()
            (cond
             ((string-match
               "^de\\." (gnus-group-real-name gnus-newsgroup-name))
              (ispell-change-dictionary "deutsch"))
             (t
              (ispell-change-dictionary "english")))))
@end lisp

あなたの必要に応じて変更してください。

@vindex gnus-message-highlight-citation
@code{gnus-message-highlight-citation} を @code{t} に設定すれば、
message モードのバッファーでも記事バッファーと同様に、引用された文のレベ
ルの違いに応じたハイライトが行なわれます。

@node Archived Messages
@section メッセージの保管
@cindex archived messages
@cindex sent messages

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った
方法を提供します。ディフォルトの方法はメッセージを保存するため
に「アーカイブ仮想サーバー」を使うことです。これを完全に禁止したいのであ
れば、変数 @code{gnus-message-archive-group} を @code{nil} にしなければ
なりません。ディフォルトは @code{"sent.%Y-%m"} で、これは月が変わる毎に
一つのアーカイブを作ります。

グループで読んだ興味のあるメッセージの保存については、@kbd{B c}
(@code{gnus-summary-copy-article}) コマンドを参照してくださ
い (@pxref{Mail Group Commands})。

@vindex gnus-message-archive-method
@code{gnus-message-archive-method} は、送ったメッセージを保存するために
どの仮想サーバーを Gnus が使うかを指定します。ディフォルト
は @code{"arhive"} で、実際に使われるときに以下の方法に展開されます:

@lisp
(nnfolder "archive"
          (nnfolder-directory   "~/Mail/archive")
          (nnfolder-active-file "~/Mail/archive/active")
          (nnfolder-get-new-mail nil)
          (nnfolder-inhibit-expiry t))
@end lisp

@quotation
@vindex gnus-update-message-archive-method
注: このようなサーバーは、@code{"archive"} という名前のサーバーの実際の
選択方法としてその後ずっと使えるようにするために (つま
り @code{gnus-message-archive-method} が @code{"archive"} に設定された場
合のために)、最初に @file{~/.newsrc.eld} ファイルに保存されます。もしそ
れが一度保存されると、@code{gnus-message-archive-method} の値を後で変更
しても、ディフォルトではそれは更新されません。したがっ
て @code{"archive"} というサーバーが、いつでもこのよう
な @code{nnfolder} サーバーを意味するとは限りません。保存される選択方法
が常に @code{gnus-message-archive-method} の値を反映するようにしたい場合
は、@code{gnus-update-message-archive-method} 変数を @code{nil} 以外の値
に設定してください。この変数のディフォルト値は @code{nil} です。
@end quotation

@code{nnfolder} はこのようなことをするのには極めて適した選択方法なのです
が、これに限らず @code{nnml} や @code{nnmbox} などの、どのメール選択方法
でも使うことができます。ディフォルトで選択されるディレクトリーが気にいら
なければ、次のようにすることができます:

@lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
                 (nnfolder-inhibit-expiry t)
                 (nnfolder-active-file "~/News/sent-mail/active")
                 (nnfolder-directory "~/News/sent-mail/")))
@end lisp

訳注: 上記のような例は「意図した通りに動作しない」FAQ のネタになりつつあ
り、不具合の原因が特定できない事例が少なくありません。例えば、同
じ @code{"archive"} という名前の仮想サーバーを過去に使ったことがあると、
それが @file{~/.newsrc.eld} ファイルの中で @code{gnus-server-alist} 変数
に登録されているかもしれません。あるいは単に、同名の仮想サーバーを現在も
使っているかもしれません。そのような場合は、別の名前を使う必要があります。

@vindex gnus-message-archive-group
@cindex Gcc
Gnus は外へ出て行くすべてのメッセージに、
@code{gnus-message-archive-method} で指定されたアーカイブ仮想サーバーに
ある (あるいはそれ以外のサーバーにある) 一つかそれ以上のグループに保存す
ることを意図した @code{Gcc} 欄を挿入します。どのグループを使うかは変
数 @code{gnus-message-archive-group} によって決まります。

この変数 (@code{gnus-message-archive-group}) は次のようなことをするため
に使うことができます:

@table @asis
@item 文字列
メッセージはそのグループに保存されます。

グループ名に選択方法を含めることができますが、そうするとそのメッセージ
は @code{gnus-message-archive-method} で指定した選択方法ではなくて、代わ
りにグループ名の選択方法で保存されることに注意しましょう。
@code{gnus-message-archive-method} は、上に示したようなディフォルト値を
持つためものであると考えてください。ですか
ら @code{gnus-message-archive-group} を @code{"foo"} にしておけば、外へ
出て行くメッセージは @samp{nnfolder+archive:foo} に保存されますが、
@code{"nnml:foo"} という値を使うと、外へ出て行くメッセージ
は @samp{nnml:foo} に保存されるでしょう。

@item 文字列のリスト
メッセージはそれらのすべてのグループに保存されます。

@item 正規表現、関数、Lisp フォームの連想リスト
キーが『合致』すると、その結果が使われます。

訳注: 正確には以下の三種類です。
@itemize @bullet
@item
正規表現とグループ名 (または複数のグループ名リスト) の連想リスト。最初に
正規表現が合致した要素のグループ名 (またはグループ名のリスト) が使われま
す。
@item
関数のリスト。それぞれの関数には現在のグループ名が引数として与えられ、最
初に返ってきた @code{nil} 以外の値が使われます。
@item
Lisp フォームのリスト。それぞれのフォームが評価され、最初に返ってき
た @code{nil} 以外の値が使われます。
@end itemize

@item @code{nil}
メッセージの保存は行なわれません。
@end table

例をあげてみましょう:

@samp{MisK} という単一のグループに保存するだけならば:
@lisp
(setq gnus-message-archive-group "MisK")
@end lisp

二つのグループ、@samp{MisK} と @samp{safe} に保存するならば:
@lisp
(setq gnus-message-archive-group '("MisK" "safe"))
@end lisp

どのグループにいるかによって違ったグループに保存するなら:
@lisp
(setq gnus-message-archive-group
      '(("^alt" "sent-to-alt")
        ("mail" "sent-to-mail")
        (".*" "sent-to-misc")))
@end lisp

もっと複雑なもの:
@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          "misc-mail")))
@end lisp

すべてのニュースメッセージを一つのファイルに保存して、メールメッセージを
一月につき一つのファイルに保存するというのはどうでしょう:

@lisp
(setq gnus-message-archive-group
      '((if (message-news-p)
            "misc-news"
          (concat "mail." (format-time-string
                           "%Y-%m" (current-time))))))
@end lisp

さあ、メッセージを送ると適切なグループに保存されるようになりました。(も
し特定のメッセージを保存をしたくないのであれば、挿入された @code{Gcc} 欄
を取り除いてください。)  保管グループは次に Gnus を起動したときか、次に
グループバッファーで @kbd{F} を押したときにグループバッファーに現れます。
他のグループと同じように、そのグループに入って記事を読むことができます。
そのグループが本当に大きくて悩ましくなったら、なにか良いものにその名前を
変更することができます (グループバッファーで @kbd{G r} を使うことによっ
て)---@samp{misc-mail-september-1995} その他何でも。新しいメッセージは古
い (今は空になった) グループに溜められます。

@table @code
@item gnus-gcc-mark-as-read
@vindex gnus-gcc-mark-as-read
もし非-@code{nil} なら、@code{Gcc} の記事に既読の印を付けます。

@item gnus-gcc-externalize-attachments
@vindex gnus-gcc-externalize-attachments
@code{nil} だったら、ファイルを通常のパートとして Gcc で保存する記事のコ
ピーに添付します。それが正規表現で Gcc のグループ名に合致する場合は、外
部パートとしてファイルを添付します。@code{all} だったらローカルファイル
を参照する外部パートとして添付します。それが別の非-@code{nil} だった場合
の動作は @code{all} のときと同じですが、将来は変わるかもしれません。

(訳注: 送信したメッセージと同じものを Gcc で保存する代わりに、添付ファイ
ルをメッセージから切り離して、別にセーブするかどうかを制御する変数です。)

@item gnus-gcc-self-resent-messages
@vindex gnus-gcc-self-resent-messages
@code{gcc-self} グループパラメーターのようなものですが、
@code{gnus-summary-resend-message} (@pxref{Summary Mail Commands}) が再
送する変更されていないメッセージだけに適用されます。この変数
の @code{nil} 以外の値は、どんな @code{Gcc} ヘッダーよりも優先します。

これがもし @code{none} だったら @code{Gcc} コピーは行なわれません。も
し @code{t} だったら、再送するメッセージは現在のグループに @code{Gcc} コ
ピーされます。もしこれが文字列だったら、それで再送するメッセージがコピー
されるグループを指定します。@code{nil} だったら、もしあれば既存
の @code{Gcc} ヘッダーに従って @code{Gcc} が行なわれます。これがも
し @code{no-gcc-self} だったら (それがディフォルト)、再送するメッセージ
は既存の @code{Gcc} ヘッダーが指定するものから現在のグループを除いたグルー
プに @code{Gcc} コピーされます。

@item gnus-gcc-pre-body-encode-hook
@vindex gnus-gcc-pre-body-encode-hook
@itemx gnus-gcc-post-body-encode-hook
@vindex gnus-gcc-post-body-encode-hook
これらの hook は送信したメッセージを @code{Gcc} コピーする際、そのボディー
をエンコードする前後に実行されます。Hook が実行されるときのバッファーに
は、ヘッダーを含めたそのメッセージがあります。そのメッセージに対して行な
われる変更は、元のメッセージではなく @code{Gcc} コピーだけに作用します。
これらの hook はコピーを編集するため (そして続いて起こる何らかの変換に影
響を及ぼすため)、例えば MML のセキュリティー・タグ (@pxref{Signing and
encrypting}) を取り除くような用途に使うことができます。
@end table

@node Posting Styles
@section 投稿様式
@cindex posting styles
@cindex styles

それらはすべて変数で、私の頭をくらくらさせます。

投稿するグループによって違った @code{Organization} と署名を付けたいんで
すか?  そして、家のマシンと職場のマシンの両方から投稿するけれども、違っ
た @code{From} 行などを使いたいんですか?  そんなこと、どうでもいいじゃあ
りませんか。

@vindex gnus-posting-styles
そのようなことをする方法の一つは、変更する必要のある変数を変更する賢いフッ
クを書くことです。それは少し退屈なので、利用者にこれらのことを手軽な連想
リストで指定するというすばらしい着想にたどり着いた人がいました。これが変
数 @code{gnus-posting-styles} の例です:

@lisp
((".*"
   (signature "Peace and happiness")
   (organization "What me?"))
 ("^comp"
  (signature "Death to everybody"))
 ("comp.emacs.i-love-it"
  (organization "Emacs is it")))
@end lisp

この例から推測されるように、この連想リストはいくつか
の「様式」(style) からなっています。それぞれの様式は最初の要素が何らかの
形で「合致」したときに適用されます。連想リスト全体は最初から最後まで反復
して実行され、それぞれの合致が適用されます。これは、後の様式の属性が前に
合致した様式の属性よりも優先されるということです。ですか
ら @samp{comp.programming.literate} は、@samp{Death to everybody} という
署名と @samp{What me?} という @code{Organization} ヘッダーを持ちます。

それぞれの様式の最初の要素は @code{マッチ} (match) と言います。もしそれ
が文字列であれば、Gnus はそれを正規表現であるものとして、グループ名に合
致するかどうかを調べます。@code{(header @var{合致} @var{正規表現})} とい
う形式であれば、Gnus は元記事の中からその名前が @var{合致} であるヘッダー
を探し、それを @var{正規表現} と比較します。
@var{合致} と @var{正規表現} は文字列です。(元記事とは、あなたがそれに対
して返信またはフォローアップしようとしている対象の記事です。返信あるいは
フォローアップを作成していなければ、合致するものは何もありません。) も
し @code{マッチ} が関数のシンボルであれば、その関数が引数無しで呼ばれま
す。それが変数のシンボルであれば、その変数が参照されます。それがリストで
あれば、そのリストが @code{評価} されます。どの場合でも、これ
が @code{nil} でない値を返せば、様式は @code{合致した} と言います。

それぞれの様式は任意の量の「属性」を持つことができます。それぞれの属性
は @code{(@var{name} @var{value})} の対により成り立っています。加え
て @code{(@var{name} :file @var{value})} の形式
か @code{(@var{name} :value @var{value})} の形式を使うこともできます。こ
こで @code{:file} は @var{value} がファイル名を表して、その内容が属性値
として使用されるべきであることを示し、@code{:value} は @var{value} がファ
イル名を表わさないことを明示的に示します。属性名 (@var{name}) は、以下の
どれかであることができます。

@itemize @bullet
@item @code{signature}
@item @code{signature-file}
@item @code{x-face-file}
@item @code{address} (@code{user-mail-address} よりも優先されます)
@item @code{name} (@code{(user-full-name)} よりも優先されます)
@item @code{body}
@end itemize

@code{signature-file} 属性は @code{message-signature-directory} 変数を見
ることに注意してください。

属性名は文字列またはシンボルであることもできます。その場合それはヘッダー
名として使われ、その値が記事のヘッダーに挿入されます。もし属性名
が @code{nil} だったら、そのヘッダー名は削除されます。もし属性名
が @code{eval} だったらその様式が評価され、結果は捨てられます。

属性値は文字列、引数の無い関数 (返り値が使われます)、変数 (その値が使わ
れます) またはリスト (それは @code{評価} されて、返り値が使われます) で
あることができます。関数と S式 (sexp) はセットアップされつつあるメッセー
ジバッファーで呼ばれるか評価されます。現在の記事のヘッダー群は変
数 @code{message-reply-headers} から得られます。これ
は @code{mail-header-*} アクセサーを介してアクセスでき
る @code{mail-header} オブジェクトです。

属性値が文字列である場合、もし @code{match} が正規表現だったら、あるい
はそれが @code{(header @var{match} @var{regexp})} の形式だった
ら、@samp{gnus-match-substitute-replacement} はその属性値上で、位置パラ
メーター @samp{\@var{n}} (訳注: 何番目の括弧に合致するかを @var{n} で指
定するもの) を対応する合致した括弧で置き換えようとしま
す (@pxref{Replacing Match,,Replacing the Text that Matched, elisp, The
Emacs Lisp Reference Manual})。

@vindex message-reply-headers
作成しようとしているメッセージがニュース記事かメールメッセージであるかを
調べたいときは、関
数 @code{message-news-p} と @code{message-mail-p} の戻り値を調べてくださ
い。

@findex message-mail-p
@findex message-news-p
そして、これは例です:

@lisp
(setq gnus-posting-styles
      '((".*"
         (signature-file "~/.signature")
         (name "User Name")
         (x-face-file "~/.xface")
         (x-url (getenv "WWW_HOME"))
         (organization "People's Front Against MWM"))
        ("^rec.humor"
         (signature my-funny-signature-randomizer))
        ((equal (system-name) "gnarly")  ;; @r{様式}
         (signature my-quote-randomizer))
        (message-news-p        ;; @r{関数シンボル}
         (signature my-news-signature))
        (window-system         ;; @r{変数シンボル}
         ("X-Window-System" (format "%s" window-system)))
        ;; @r{Lars さんに返事をするときは}
        ;; @r{Organization ヘッダーを付けよう。}
        ((header "to" "larsi.*org")
         (Organization "Somewhere, Inc."))
        ;; @r{元のメッセージが送られてきた宛先と同じだが}
        ;; @r{そのサブのアドレスから返事をします。}
        ((header "x-original-to" "me\\(\\+.+\\)@@example.org")
         (address "me\\1@@example.org"))
        ((posting-from-work-p) ;; @r{利用者が定義した関数}
         (signature-file "~/.work-signature")
         (address "user@@bar.foo")
         (body "お前はクビだ。\n\n親愛なるボスより。")
         ("X-Message-SMTP-Method" "smtp smtp.example.org 587")
         (organization "Important Work, Inc"))
        ("nnml:.*"
         (From (with-current-buffer gnus-article-buffer
                 (message-fetch-field "to"))))
        ("^nn.+:"
         (signature-file "~/.mail-signature"))))
@end lisp

@samp{nnml:.*} の規則は、あなたが出すすべての返事の @code{To} アドレス
を @code{From} アドレスとして使うことを意味します。これは、あなたがたく
さんのメーリングリストに参加している場合に便利でしょう。代わり
に @code{message-alternative-emails} を使うこともできます。@xref{Message
Headers, ,メッセージヘッダー, message-ja, The Message Manual}.

「業務」様式の中で特に興味深いのは @samp{X-Message-SMTP-Method} ヘッダー
です。それは Eメールをどうやって送るかを指定します。例えば、会社の規則に
よっては特定の Eメールは特定の @acronym{SMTP} サーバーを通す必要があるで
しょう。@xref{Mail Variables, ,メール変数, message-ja, Message Manual}.

@node Drafts
@section 下書き
@cindex drafts

メッセージ (メールもしくはニュース) を書いているときに、オーブンにステー
キが入っている (もしくはあなたがとーってもすごい菜食主義者で、何かのペー
ストがフードプロセッサーに入っている) ことを突然思い出したなら、書いてい
るメッセージを保存する方法があれば良いと思うでしょう。いつか別の日に編集
を続けることができ、それが完成したと思ったときに送ることができるように。

えぇ、心配しないでください。メールかニュースを送信するための Gnus の命令
を使って何らかのメッセージを書き始めたときにあなたが手にするバッファーは、
自動的に特別な @dfn{draft} グループに関連付けられます。普通の方法  (例え
ば @kbd{C-x C-s}) でバッファーを保存すれば、その記事はそこに保存されます。
(自動保存 (auto-save) ファイルも下書きグループ (draft group) に行きます。)

@cindex nndraft
@vindex nndraft-directory
下書きグループは @samp{nndraft:drafts} と呼ばれる特別なグループです (あ
なたが絶対に知っていなければならないのであれば、それは @code{nndraft} グ
ループとして実装されています)。変
数 @code{nndraft-directory} は @code{nndraft} がそのファイルをどこに保管
するかを指定します。このグループを特別なものにしているのは、その中の記事
に可視や既読の印を付けることができないことです---そのグループのすべての
記事は永久に未読です。

もしグループが存在しないと、それは作成され、購読させられます。グループバッ
ファーからそれを消し去る唯一の方法は、それを購読しないようにすることです。
下書きグループの特別の特性はグループの特性 (@pxref{Group Parameters}) に
よって生じ、それが失われてしまうと他のグループのように振る舞うようになり
ます。これは (グループの特性を消してしまうことは) 以下のコマンドが使えな
いことを意味します。そのグループの特別の特性を復活させる最も簡単な方法は、
@kbd{C-k} でそのグループを削除してから Gnus を再起動することです。そのグ
ループの内容物は失われません。

@c @findex gnus-dissociate-buffer-from-draft
@c @kindex C-c M-d (Mail)
@c @kindex C-c M-d (Post)
@c @findex gnus-associate-buffer-with-draft
@c @kindex C-c C-d (Mail)
@c @kindex C-c C-d (Post)
@c If you're writing some super-secret message that you later want to
@c encode with PGP before sending, you may wish to turn the auto-saving
@c (and association with the draft group) off.  You never know who might be
@c interested in reading all your extremely valuable and terribly horrible
@c and interesting secrets.  The @kbd{C-c M-d}
@c (@code{gnus-dissociate-buffer-from-draft}) command does that for you.
@c If you change your mind and want to turn the auto-saving back on again,
@c @kbd{C-c C-d} (@code{gnus-associate-buffer-with-draft} does that.
@c
@c @vindex gnus-use-draft
@c To leave association with the draft group off by default, set
@c @code{gnus-use-draft} to @code{nil}.  It is @code{t} by default.
@c
@findex gnus-draft-edit-message
@kindex D e @r{(下書き)}
記事の編集を続けたいときは、下書きグループに入っ
て @kbd{D e} (@code{gnus-draft-edit-message}) を押すだけです。編集を中断
したときの状態のバッファーに移動します。

送信を拒否された記事も、この下書きグループに入れられま
す (@pxref{Rejected Articles})。

@findex gnus-draft-send-all-messages
@kindex D s @r{(下書き)}
@findex gnus-draft-send-message
@kindex D S @r{(下書き)}
送信を拒否されたメッセージがたくさんあって、それ以上編集せずにそれらを送
信したい場合は、@kbd{D s} 命令 (@code{gnus-draft-send-message}) を使うこ
とができます。この命令はプロセス/接頭引数の習慣を理解しま
す (@pxref{Process/Prefix})。@kbd{D S} 命
令 (@code{gnus-draft-send-all-messages}) はバッファーのすべてのメッセー
ジを送り出します。

@findex gnus-draft-toggle-sending
@kindex D t @r{(下書き)}
送りたくないメッセージがいくつかあるのであれば、@kbd{D t} 命
令 (@code{gnus-draft-toggle-sending}) を使ってメッセージに送信不可の印を
付けることができます。これは切り替え命令です。

最後に。もし下書きの記事を消したいときは、通常の @kbd{B @key{DEL}} コマ
ンドを使ってください (@pxref{Mail Group Commands})。

@node Rejected Articles
@section 拒否された記事
@cindex rejected articles

時々ニュースサーバーは記事を送信することを拒否します。おそらくサーバーは
あなたの顔を好きではないのでしょう。おそらく落ち込んでいるのでしょう。お
そらく @emph{悪魔 (demon) がいるのでしょう}。おそらく引用文を入れすぎた
のでしょう。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落
ちていたのでしょう。

もちろんこれらの状況は完全に Gnus の扱える範囲外です。(もちろん Gnus は
あなたの風貌を愛しているし、いつも機嫌が良いし、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちたり
しません。) ですから Gnus はこれらの記事を後でサーバーの機嫌が良くなる
まで保存します。

拒否された記事は自動的に特別な下書きグループ (@pxref{Drafts}) に入れられ
ます。サーバーが復旧した暁には、普通あなたはそのグループに入って、すべて
の記事を送ることになるでしょう。

@node Signing and encrypting
@section 署名と暗号化
@cindex using gpg
@cindex using s/mime
@cindex using smime

素の @acronym{PGP} 形式、@acronym{PGP/MIME} または @acronym{S/MIME} を使っ
て、Gnus はメッセージに電子署名したり暗号化することができます。そのよう
なメッセージのデコードに関しては、@code{mm-verify-option} オプションおよ
び @code{mm-decrypt-option} オプション (@pxref{Security}) を参照してくだ
さい。

@vindex gnus-message-replysign
@vindex gnus-message-replyencrypt
@vindex gnus-message-replysignencrypted
署名したメッセージを送ってきた人たちに、署名した返信を返したいことはしば
しばあります。さらに暗号化されたメッセージへの返信を暗号化したいことは、
もっとたびたびあるかもしれません。Gnus は前者のため
に @code{gnus-message-replysign} の機能を、後者のため
に @code{gnus-message-replyencrypt} の機能を提供します。さら
に @code{gnus-message-replysignencrypted} を設定することによって (ディフォ
ルトで on になっています)、暗号化したメッセージに自動的に署名もします。

@acronym{MIME} パートに対してセキュリティーの操作を行なうため
の @acronym{MML} への指示は、以下のように署名の場合は @kbd{C-c C-m s} キー
マップを使って、暗号化の場合は @kbd{C-c C-m c} キーマップを使って行ない
ます。

@table @kbd
@item C-c C-m s s
@kindex C-c C-m s s @r{(Message)}
@findex mml-secure-message-sign-smime

@acronym{S/MIME} を使って現在のメッセージに電子署名します。

@item C-c C-m s o
@kindex C-c C-m s o @r{(Message)}
@findex mml-secure-message-sign-pgp

@acronym{PGP} を使って現在のメッセージに電子署名します。

@item C-c C-m s p
@kindex C-c C-m s p @r{(Message)}
@findex mml-secure-message-sign-pgp

@acronym{PGP/MIME} を使って現在のメッセージに電子署名します。

@item C-c C-m c s
@kindex C-c C-m c s @r{(Message)}
@findex mml-secure-message-encrypt-smime

@acronym{S/MIME} を使って現在のメッセージを電子暗号化します。

@item C-c C-m c o
@kindex C-c C-m c o @r{(Message)}
@findex mml-secure-message-encrypt-pgp

@acronym{PGP} を使って現在のメッセージを電子暗号化します。

@item C-c C-m c p
@kindex C-c C-m c p @r{(Message)}
@findex mml-secure-message-encrypt-pgpmime

@acronym{PGP/MIME} を使って現在のメッセージを電子暗号化します。

@item C-c C-m C-n
@kindex C-c C-m C-n @r{(Message)}
@findex mml-unsecure-message
メッセージから、セキュリティー関連の @acronym{MML} タグを外します。
@end table

もっと詳しいことは @xref{Security, ,セキュリティー, message-ja, The
Message Manual}, を参照してください。

@node Select Methods
@chapter 選択方法
@cindex foreign groups
@cindex select methods

「外部グループ」(foreign group) とは、普通 (もしくはディフォルト) の方法
で読まれないグループのことです。例えばそれは別の @acronym{NNTP} サーバー
のグループであったり、仮想グループであったり、個人的なメールグループであっ
たりするでしょう。

外部グループ (あるいは実際にどんなグループでも) は「名前」と「選択方法」
で指定されます。先に後者を例に出すと、選択方法はリストで、最初の要素がど
のバックエンドを使うか (例えば @code{nntp}, @code{nnspool},
@code{nnml}) を、二つめの要素が「サーバー名」を表します。選択方法には、
その当のバックエンドにとって特別の意味を持つ値である追加の要素があるかも
しれません。

選択方法とは「仮想サーバー」を定義することだ、と言うことができます---で
すから私たちはまさにそれをしました (@pxref{Server Buffer})。

グループの「名前」は、バックエンドがそのグループを認識する名前です。

例えば @samp{some.where.edu} という @acronym{NNTP} サーバーにあ
る @samp{soc.motss} グループは、名前 @samp{soc.motss} と選択方
法 @code{(nntp "some.where.edu")} を持ちます。@code{nntp} バックエンドは
このグループを @samp{soc.motss} として知っているだけですが、Gnus はこの
グループを @samp{nntp+some.where.edu:soc.motss} と呼びます。

もちろん、違った方法はすべてそれ特有の要素を持っています。

@menu
* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Using IMAP::                  @acronym{IMAP} からメールを読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* Other Sources::               ディレクトリー、ファイルを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む
@end menu

@node Server Buffer
@section サーバーバッファー

伝統的に、「サーバー」は誰かがそれに接続して、それからの情報を要求するマ
シンかソフトウェアの断片です。Gnus は実際のどんなサーバーにも直接には接
続せず、何かのバックエンドを通してすべての処理を行ないます。しかしそれは
まさしく実際の媒体と Gnus の間に一つ以上の階層を置くことであって、ちょう
どそれぞれのバックエンドが疑似的なサーバーに相当すると言っても良いでしょ
う。

例えば @code{nntp} バックエンドは、複数の別々に実在す
る @acronym{NNTP} サーバー、あるいは実在する同じ @acronym{NNTP} サーバー
の異なるポートに接続するために用いられます。あなたはどのバックエンドを使
うか、そしてどんなパラメーターを設定するかを選択方
法 (@dfn{select method}) に設定して Gnus に指示します。

選択方法の指定は、ときに極めて面倒なものになります---えーと、例え
ば @samp{news.funet.fi} という @acronym{NNTP} サーバーのポート 13 を読み
たいのだけれど、@acronym{NOV} ヘッダーを取り寄せようとすると固まってしま
うし、間違った記事を選択してしまうような場合です。うおっほん。とにかくこ
のサーバーを使うそれぞれのグループについてそういうことを設定しなければな
らないとしたら、大変な作業になってしまうでしょう。そこで Gnus は、そうい
う作業をサーバーバッファーで行なうために、選択方法に名前を付ける手段を設
けているのです。

サーバーバッファーに入るためには、グループバッファー
で @kbd{^} (@code{gnus-group-enter-server-mode}) コマンドを使ってくださ
い。

@menu
* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない
@end menu

@vindex gnus-server-mode-hook
サーバーバッファーを作成するときに @code{gnus-server-mode-hook} が実行さ
れます。

@node Server Buffer Format
@subsection サーバーバッファーの表示様式
@cindex server buffer format

@vindex gnus-server-line-format
サーバーバッファーの行の外見を、変数 @code{gnus-server-line-format} 変数
を変更することによって変えることができます。これは @code{format} のよう
な変数で、少しばかり単純な拡張がなされています:

@table @samp
@item h
どのようにニュースが取得されるか---バックエンドの名前。

@item n
サーバーの名前。

@item w
どこからニュースが取得されるか---アドレス。

@item s
サーバーの接続の 開いた/閉じた/拒否された 状態。

@item a
そのサーバーがエージェント化されているかどうか。
@end table

@vindex gnus-server-mode-line-format
モード行も変数 @code{gnus-server-mode-line-format} を使うことによってカ
スタマイズすることができます (@pxref{Mode Line Formatting})。

[訳注: 現在この変数は使われていません。]

以下の仕様が理解されます:

@table @samp
@item S
サーバー名。

@item M
サーバーの選択方法。
@end table

@ref{Formatting Variables} も参照してください。

@node Server Commands
@subsection サーバー命令
@cindex server commands

サーバーバッファーでは以下のキー割り当てを使うことができます。いくつかの
コマンドは、初期設定ファイルで定義したサーバーではなく、あなたがこのイン
ターフェースを通して追加したサーバーでだけ働くことを念頭に置いてください。

@table @kbd
@item v
@kindex v @r{(サーバー)}
@cindex keys, reserved for users (Server)
@kbd{v} キーはユーザー用に予約されています。そのまま何かのコマンドに割り
当てても構いませんが、接頭キーとして使う方が良いでしょう。

@item a
@kindex a @r{(サーバー)}
@findex gnus-server-add-server
新しいサーバーを追加します (@code{gnus-server-add-server})。

@item e
@kindex e @r{(サーバー)}
@findex gnus-server-edit-server
サーバーを編集します (@code{gnus-server-edit-server})。

@item S
@kindex S @r{(サーバー)}
@findex gnus-server-show-server
サーバーの定義を表示します (@code{gnus-server-show-server})。

@item @key{SPC}
@kindex SPC @r{(サーバー)}
@findex gnus-server-read-server
現在のサーバーを眺めます (@code{gnus-server-read-server})。

訳注: 実際には @code{gnus-server-read-server-in-server-buffer} 命令を呼
びますが、@code{gnus-server-browse-in-group-buffer} の値がディフォルト
の @code{nil} であれば @code{gnus-server-read-server} と同じです。
@code{gnus-server-browse-in-group-buffer} を @code{nil} 以外の値にするこ
とはまったくお勧めできませんが、あなたが何をするのも自由です。詳細はソー
スコードを読むか、実際に試して痛い目に会ってください。;-p

@item q
@kindex q @r{(サーバー)}
@findex gnus-server-exit
グループバッファーに戻ります (@code{gnus-server-exit})。

@item k
@kindex k @r{(サーバー)}
@findex gnus-server-kill-server
現在のサーバーを切り取ります (kill します)
(@code{gnus-server-kill-server})。

@item y
@kindex y @r{(サーバー)}
@findex gnus-server-yank-server
先ほど切られた (killed) サーバーを貼り付けます (yank します)
(@code{gnus-server-yank-server})。

@item c
@kindex c @r{(サーバー)}
@findex gnus-server-copy-server
現在のサーバーを複写します (@code{gnus-server-copy-server})。

@item l
@kindex l @r{(サーバー)}
@findex gnus-server-list-servers
すべてのサーバーの一覧を表示します (@code{gnus-server-list-servers})。

@item s
@kindex s @r{(サーバー)}
@findex gnus-server-scan-server
サーバーにそのソースから新しい記事を調べるように要求しま
す (@code{gnus-server-scan-server})。主にメールサーバーが意味のある動作
をします。

@item g
@kindex g @r{(サーバー)}
@findex gnus-server-regenerate-server
サーバーにすべてのデータ構造を再作成させま
す (@code{gnus-server-regenerate-server})。これは同期が外れてしまったメー
ルバックエンドがあるときに役に立ちます。

@item z
@kindex z @r{(サーバー)}
@findex gnus-server-compact-server

現在位置のサーバーのすべてのグループを圧縮します。今のところ @code{nnml}
(@pxref{Mail Spool}) だけに実装されています。これは記事番号のすきまを取
り除くので、正しい全記事数を得ることができるようになります。
@end table

サーバーを閉じ、禁止し、および再開するための他のコマンドについて
は @ref{Unavailable Servers}。

@node Example Methods
@subsection 方法の例

ほとんどの選択方法は、説明する必要が無いくらいにかなり単純です:

@lisp
(nntp "news.funet.fi")
@end lisp

直接スプールから読むのはもっと単純です:

@lisp
(nnspool "")
@end lisp

見ての通り、選択方法の最初の要素はバックエンドの名前で、二番目は「アドレ
ス」(address)、もしくはそう呼びたいのであれば「名前」です。

これらの二つの要素の後には、任意の数
の @code{(@var{変数} @var{様式})} の対を置くことができます。

最初の例に戻りましょう---そのマシンのポート 15 から読みたいのだと思って
ください。これがその時に、そうなるはずの選択方法です:

@lisp
(nntp "news.funet.fi" (nntp-port-number 15))
@end lisp

どの変数が関連するかを見つけ出すために、それぞれのバックエンドの説明文書
を読むべきでしょうが、これは @code{nnmh} の例です。

@code{nnmh} はスプールのような構造を読むためのメールバックエンドです。例
えばアクセスしたい二つの構造があるとしましょう: 一つはあなたの私的なメー
ルスプールで、他方は公的なものです。これは私的なメールのために使うことが
できる指定です:

@lisp
(nnmh "private" (nnmh-directory "~/private/mail/"))
@end lisp

(それでこのサーバーは @samp{private} と呼ばれますが、あなたはすでに推測
していたかもしれませんね。)

これは公的なスプールのための方法です:

@lisp
(nnmh "public"
      (nnmh-directory "/usr/information/spool/")
      (nnmh-get-new-mail nil))
@end lisp

@cindex proxy
@cindex firewall
あなたが防壁 (firewall) の中にいて、防壁マシンを通して @acronym{NNTP} サー
バーに接続するしかないのであれば、防壁マシンに @code{rlogin} して、そこ
から @uref{http://netcat.sourceforge.net/, netcat} で @acronym{NNTP} サー
バーに接続するように Gnus に指示することができます。こんなことをするのは
いささかばかげているのですが、でも仮想サーバーの定義はおそらくこのような
ものになるはずです:

@lisp
(nntp "firewall"
      (nntp-open-connection-function nntp-open-via-rlogin-and-netcat)
      (nntp-via-address "the.firewall.machine")
      (nntp-address "the.real.nntp.host"))
@end lisp

あの素敵な @code{ssh} プログラムを、モデムを経由する通信を圧縮するために
使いたいのならば、上記の例に以下の設定を加えることができます。

@lisp
      (nntp-via-rlogin-command "ssh")
@end lisp

@code{nntp-via-rlogin-command-switches} も参照してください。間接的に接続
する場合の例です:

@lisp
(setq gnus-select-method
      '(nntp "indirect"
             (nntp-address "news.server.example")
             (nntp-via-user-name "intermediate_user_name")
             (nntp-via-address "intermediate.host.example")
             (nntp-via-rlogin-command "ssh")
             (nntp-via-rlogin-command-switches ("-C"))
             (nntp-open-connection-function nntp-open-via-rlogin-and-netcat)))
@end lisp

もちろん、自動認証を行なわせるためには @code{ssh-agent} を適切に設定しな
ければなりません。

防壁の中にいたとしても "runsocks" のようなラッパーコマンドを通して外の世
界に直接アクセスできるのならば、以下のように socks 化された netcat でニュー
スサーバーに接続することができるでしょう:

@lisp
(nntp "outside"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-netcat-stream)
      (nntp-address "the.news.server"))
@end lisp

@node Creating a Virtual Server
@subsection 仮想サーバーを作成する

永続記事を使ってたくさんの記事をキャッシュに保存しているのであれば、キャッ
シュを読むための仮想サーバーを作る必要があるでしょう。

最初に新しいサーバーを追加する必要があります。それをするのは @kbd{a} 命
令です。おそらくキャッシュを読むためには @code{nnml} を使うのが一番良い
でしょう。@code{nnspool} や @code{nnmh} も使えるでしょうれけど。

@kbd{a nnml @key{RET} cache @key{RET}} とタイプしてください。

今やあなたは真新しい @samp{cache} という @code{nnml} の仮想サーバーを手
に入れたはずです。次はそれを編集して、正しい定義を与えましょう。サーバー
を編集するには @kbd{e} をタイプしてください。あなたは以下のものを含むバッ
ファーに入ります:

@lisp
(nnml "cache")
@end lisp

それを次のように変更してください:

@lisp
(nnml "cache"
      (nnml-directory "~/News/cache/")
      (nnml-active-file "~/News/cache/active"))
@end lisp

サーバーバッファーに戻るには @kbd{C-c C-c} をタイプしてください。今では
この仮想サーバーで @kbd{@key{RET}} を押すと、閲覧バッファーに入って、表
示されているどのグループにでも入ることができるはずです。

@node Server Variables
@subsection サーバー変数
@cindex server variables
@cindex server parameters

変数を (バックエンドと Emacs 一般の両方で) 定義する際の一つのやっかいな
点は、いくつかの変数は、概してその変数の定義がロードされるときに他の変数
で初期化されることです。「基」になる変数がロードされた後でそれを変更して
も、「派生」した変数は変更されません。

これは一般にディレクトリーやファイルの変数に影響します。例え
ば @code{nnml-directory} はディフォルトでは @file{~/Mail/} で、また、す
べての @code{nnml} ディレクトリー変数はその変数によって初期化されるので、
@code{nnml-active-file} は @file{~/Mail/active} になります。新し
い @code{nnml} 仮想サーバーを定義する場合、@code{nnml-directory} を設定
するだけでは十分では @emph{ありません}---あなたはすべてのファイル変数を、
そうしたいと望んだ値に明示的に設定しなければなりません。それぞれのバック
エンドのための完全な変数のリストを見るには、このマニュアルの後に続くそれ
ぞれのバックエンドの部分を読んでください。でも @code{nnml} の定義の例は
ここにあります:

@lisp
(nnml "public"
      (nnml-directory "~/my-mail/")
      (nnml-active-file "~/my-mail/active")
      (nnml-newsgroups-file "~/my-mail/newsgroups"))
@end lisp

サーバー変数はしばしば「サーバーパラメーター」と呼ばれます。

@node Servers and Methods
@subsection サーバーと選択方法

普通に選択方法を使う (例えば外部サーバーから記事を読むときにグループを選
択する手段として @code{gnus-secondary-select-method} 使う) 場面ではどこ
でも、代わりに仮想サーバーの名前を使うことができます。これによって、たく
さんキーボードを叩かなくて済むかもしれません。そして、どんなときでもその
方が良いです。

@node Unavailable Servers
@subsection 使用不可能なサーバー

あるサーバーに接続することができないように見えるとき、Gnus はそのサーバー
に拒否された (@code{denied}) ことを記録します。その後でそのサーバーと接
続しようとするどんな試みも、単に無視されます。実際にそうかどうかを少しも
確かめずに、Gnus は「接続を開くことができません」と (英語で) 告げます。

それはずいぶんお行儀が悪いと思うかもしれませんが、たいていの場合は有意義
なのです。例えば @samp{nephelococcdyia.com} というサーバーで十個のグルー
プを購読しているとしましょう。サーバーはどこかとても遠いところにあって、
そのマシンはとても遅いので、今日それが接続を拒否するかどうかを調べるだけ
でも一分かかります。もし Gnus がそれを十回試すようになっていたとすると、
とても煩わしいでしょう。ですから Gnus はそれを試そうとはしません。一度で
も「接続が拒否された」(connection refused) という結果を受け取ったなら、
それはサーバーが「落ちている」(down) のだ、とみなします。

では、一時的にそのマシンの機嫌が悪いだけだったら何が起こるのでしょう? マ
シンが復活したかどうかをどうすれば調べることができるのでしょう?

それには、サーバーバッファーに移動して (@pxref{Server Buffer})、以下の命
令で突いてみてください:

@table @kbd
@item O
@kindex O @r{(サーバー)}
@findex gnus-server-open-server
現在の行のサーバーとの接続を確立しようとしま
す (@code{gnus-server-open-server})。

@item C
@kindex C @r{(サーバー)}
@findex gnus-server-close-server
サーバーとの接続 (もしあれば) を閉じま
す (@code{gnus-server-close-server})。

@item D
@kindex D @r{(サーバー)}
@findex gnus-server-deny-server
現在のサーバーに接続不可の印を付けま
す (@code{gnus-server-deny-server})。これは事実上そのサーバーを使わない
ようにします。

@item M-o
@kindex M-o @r{(サーバー)}
@findex gnus-server-open-all-servers
バッファーにあるすべてのサーバーとの接続を開きま
す (@code{gnus-server-open-all-servers})。

@item M-c
@kindex M-c @r{(サーバー)}
@findex gnus-server-close-all-servers
バッファーにあるすべてのサーバーとの接続を閉じま
す (@code{gnus-server-close-all-servers})。

@item R
@kindex R @r{(サーバー)}
@findex gnus-server-remove-denials
Gnus が接続を拒否されたすべてのサーバーの、すべての印を消去し
ます (@code{gnus-server-remove-denials})。

@item c
@kindex c @r{(サーバー)}
@findex gnus-server-copy-server
サーバーをコピーして新しい名前を付けま
す (@code{gnus-server-copy-server})。これは、複雑な接続方法の定義がすで
にあって、それと同じ定義を異なる (物理) サーバーのために使う必要がある場
合に役立つはずです。

@item L
@kindex L @r{(サーバー)}
@findex gnus-server-offline-server
サーバーの状態をオフラインにします (@code{gnus-server-offline-server})。
@end table

@node Getting News
@section ニュースの取得
@cindex reading news
@cindex news back ends

ニュースリーダーは普通はニュースを読むために使われます。Gnus は現在はニュー
スを取得するための二つの方法だけを提供しています---@acronym{NNTP} サーバー
から、またはローカルスプールから読むことができます。

@menu
* NNTP::                        @acronym{NNTP} サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む
@end menu

@node NNTP
@subsection NNTP
@cindex nntp

@acronym{NNTP} サーバーから外部グループを購読するのは比較的簡単です。単
に選択方法として @code{nntp} を指定し、@acronym{NNTP} サーバーのアドレス
を、うーん、アドレスとして指定するだけです。

@acronym{NNTP} サーバーが標準ではないポート (port) に設置されているとき
は、選択方法の三番目の要素をこのポートの番号に設定すれば、正しいポートに
接続することができるでしょう。そのためにはグループ情報を編集しなければな
りません (@pxref{Foreign Groups})。

外部グループの名前は基本グループと同じでも構いません。実際、あなたの思う
ままに同じグループを可能な限りの違ったサーバーから購読することができます。
名前の衝突は起こりません。

以下の変数は仮想 @code{nntp} サーバーを作るために使われます:

@table @code
@item nntp-server-opened-hook
@vindex nntp-server-opened-hook
@cindex @sc{mode reader}
@cindex authinfo
@cindex authentication
@cindex nntp authentication
@findex nntp-send-authinfo
@findex nntp-send-mode-reader
は接続ができた後に実行されます。それは @acronym{NNTP} サーバーに接続した
後に、それに命令を送るために使うことができます。ディフォルトで
は @code{MODE READER} 命令が、@code{nntp-send-mode-reader} 関数によって
サーバーに送られるようになっています。この関数は常にこのフックにあるべき
です。

@item nntp-authinfo-function
@vindex nntp-authinfo-function
@findex nntp-send-authinfo
@vindex nntp-authinfo-file
この関数は @acronym{NNTP} サーバーに @samp{AUTHINFO} を送るために使われ
ます。ディフォルトの関数は @code{nntp-send-authinfo} で、適切な記載事項
を探すために @file{~/.authinfo} (もしくは @code{nntp-authinfo-file} 変数
に設定した何でも) を調べます。もし一つも見つからなかったら、ログイン名と
パスワードの入力を要求します。@file{~/.authinfo} ファイルの様式
は @code{ftp} のための @file{~/.netrc} ファイルと (ほとんど) 同じです。
それは @code{ftp} のマニュアルページで定義されていますが、ここに顕著な実
例があります:

@enumerate
@item
ファイルは一つ以上の行を含み、それぞれは一つのサーバーを定義します。

@item
それぞれの行は任意の数の標章 (token) と値の対を含むことができます。

有効な標章は @samp{machine}, @samp{login}, @samp{password},
@samp{default} です。加えて、Gnus は @file{.netrc}/@code{ftp} の構文の原
型には現れない二つの新しい標章、名付けて @samp{port} と @samp{force} を
導入します。(これが @file{.authinfo} ファイルの様式が @file{.netrc} ファ
イルの様式から逸脱する唯一の方法です。) @samp{port} はサーバーのどのポー
トを認証に用いるかを示し、@samp{force} は以下で説明します。
@end enumerate

これがそのファイルの例です:

@example
machine news.uio.no login larsi password geheimnis
machine nntp.ifi.uio.no login larsi force yes
@end example

標章と値の対はどんな順番ででも現れることができます。例え
ば @samp{machine} が最初でなければならない必要はありません。

この例では、前者のサーバーにログイン名とパスワードの両方が与えられている
のに対して、後者にはログイン名だけがあり、利用者はパスワードの入力を求め
られるでしょう。後者は @samp{force} タグも持っていて、これによって接続時
に @var{nntp} サーバーに認証情報 (authinfo) が送られます。ディフォル
ト (すなわち、@samp{force} タグが無いとき) では、@var{nntp} サーバーが認
証情報を尋ねない限りそれを @var{nntp} サーバーに送りません。

@samp{machine} 行に合致しないすべてのサーバーに適用され
る @samp{default} 行を追加することもできます。

@example
default force yes
@end example

これは、それ以前に書かれていないすべてのサーバーに @samp{AUTHINFO} 命令
を強制的に送ります。

@file{~/.authinfo} ファイルを世界中が読めるような設定のままで放置しない
ように注意してください。

@item nntp-server-action-alist
@vindex nntp-server-action-alist
これはサーバーの型に合致する正規表現と、合致が起こったときに取られる動作
の連想リストです。例えば、Gnus に innd に接続したときに毎回ビープ音を鳴
らしたいのであれば、次のようにすることができます:

@lisp
(setq nntp-server-action-list
      '(("innd" (ding))))
@end lisp

まぁ、そんなことをしたいとは思わないでしょうけれどね。

ディフォルトの値は

@lisp
'(("nntpd 1\\.5\\.11t"
   (remove-hook 'nntp-server-opened-hook
                'nntp-send-mode-reader)))
@end lisp

で、これは nntpd 1.5.11t には @code{MODE READER} 命令を確実に送らないよ
うにします。なぜなら、その命令はサーバーの息の根を止めると聞いているから
です。

@item nntp-maximum-request
@vindex nntp-maximum-request
もし @acronym{NNTP} サーバーが @acronym{NOV} ヘッダーをサポートしていな
いのであれば、このバックエンドは @code{head} 命令をいくつも送って、ヘッ
ダーを集めます。この動作を速くするために、バックエンドは返答を待たずにこ
の命令をたくさん送り、それからすべての返答を読みます。これは変
数 @code{nntp-maximum-request} によって制御され、ディフォルトで 400 です。
もしネットワークの具合が良くないようなら、この変数を 1 に設定するべきで
しょう。

@item nntp-connection-timeout
@vindex nntp-connection-timeout
定期的に接続している外部 @code{nntp} グループがたくさんあると、ちゃんと
応答しなかったり常識的な時間内に返答できないくらいの負荷がかかってい
る @acronym{NNTP} サーバーの問題があるはずです。これはやっかいな問題をも
たらしますが、@code{nntp-connection-timeout} を設定することによってある
程度解消することができます。これは接続を諦める前に、@code{nntp} バックエ
ンドが何秒待つかを示す整数です。もしこれが @code{nil} であると、それがディ
フォルトですが、時間切れによる切断は行ないません。

@item nntp-nov-is-evil
@vindex nntp-nov-is-evil
@acronym{NNTP} サーバーが @acronym{NOV} をサポートしていない場合は、この
変数を @code{t} に設定すれば良いでしょう。でも @code{nntp} は普通
は @acronym{NOV} が使えるかどうかを自動的に調べます。(訳注: ですから、わ
ざわざ設定しなくても構いません。)

@item nntp-xover-commands
@vindex nntp-xover-commands
@cindex @acronym{NOV}
@cindex XOVER
サーバーから @acronym{NOV} 行を取得するための命令として使われる文字列の
リストです。この変数のディフォルトの値は @code{("XOVER" "XOVERVIEW")} で
す。(訳注: それらを順に試します。)

@item nntp-nov-gap
@vindex nntp-nov-gap
@code{nntp} は、普通はサーバーに @acronym{NOV} 行のための一つの大きな要
求を送ります。サーバーは一つの巨大な行のリストで応答します。しかし、グルー
プの 2-5000 の記事を読んだ後で 1 と 5001 を読みたいだけだとしても、
@code{nntp} は必要の無い 4999 個の @acronym{NOV} 行を取得することになり
ます。この変数は、どれくらい大きな二つの連続した記事群の間の隔た
り (gap) まで @code{XOVER} の要求を分割せずに送るかを決定します。ネット
ワークが速い場合に、この変数を本当に小さな数値に設定してしまうと、おそら
く取得が遅くなることに注意してください。この変数が @code{nil} ならば、
@code{nntp} は要求を分割しません。ディフォルトは 5 です。

@item nntp-xref-number-is-evil
@vindex nntp-xref-number-is-evil
ユーザーが指定した @code{Message-ID} を持っている記事、または現在のもの
の親記事の @code{Message-ID} を持っている記事を参照すると
き (@pxref{Finding the Parent})、Gnus はそれがどこにあるかを知るため
に @acronym{NNTP} サーバーに @code{HEAD} コマンドを送ります。そしてサー
バーは、@code{Xref} ヘッダーにグループと記事番号の対を含んでいるデータを
返します。そのデータが、その記事が現在のグループにあることを示すなら、通
常 Gnus はその記事を参照するのに記事番号を使用します、そうでなけれ
ば @code{Message-ID} を使いますが。ところが、あるニュースサーバー (例え
ば Diablo を実行するもの) は、同じ記事群を有する複数のエンジンを運転して
いて、それらの間では記事番号が同期されていません。その場
合 @code{Xref} ヘッダーに現われる記事番号は、どのエンジンが選ばれるかに
よって変化するので、例えば現在のグループにある親記事を参照することができ
ません。そのようなサーバーに接続するのであれば、この変数を @code{nil} で
はない値に設定してください。そうすれば Gnus は記事番号を使いません。例え
ば:

@lisp
(setq gnus-select-method
      '(nntp "newszilla"
             (nntp-address "newszilla.example.com")
             (nntp-xref-number-is-evil t)
             @dots{}))
@end lisp

このサーバー変数のディフォルト値は @code{nil} です。

@item nntp-prepare-server-hook
@vindex nntp-prepare-server-hook
@acronym{NNTP} サーバーに接続を試みる前に実行するフックです。

@item nntp-record-commands
@vindex nntp-record-commands
これを @code{nil} でない値にすると、@code{nntp} は @acronym{NNTP} サーバー
に送ったすべての命令を (時刻と共に) @file{*nntp-log*} バッファーに記録し
ます。これは動作していないように見える Gnus の @acronym{NNTP} 接続をデバッ
グしているときに役に立ちます。

@item nntp-open-connection-function
@vindex nntp-open-connection-function
どのように @acronym{NNTP} サーバーと接続するかをカスタマイズすることがで
きます。@code{nntp-open-connection-function} パラメーターを設定しておく
と、Gnus は接続を確立するためにその関数を使います。そのために七つの関数
があらかじめ用意されています。それらは二種類に分類することができ、直接接
続するための関数群 (四つ) と間接的に接続するためのもの (三つ) があります。

@item nntp-never-echoes-commands
@vindex nntp-never-echoes-commands
非-@code{nil} で @acronym{NNTP} サーバーがコマンドをエコーバックしないこ
とを意味します。報告によると、ある種の @acronym{NNTPS} サーバーはコマン
ドをエコーバックしないそうです。したがって、例え
ば @code{nntp-open-connection-function} を @code{nntp-open-ssl-stream} に
設定してあるそのようなサーバーのための選択方法の中で、この変数を
非-@code{nil} に設定する必要があるでしょう。ディフォルト値
は @code{nil} です。この変数の値 @code{nil} は、
@code{nntp-open-connection-functions-never-echo-commands} 変数でくつがえ
されることに注意してください。

@item nntp-open-connection-functions-never-echo-commands
@vindex nntp-open-connection-functions-never-echo-commands
コマンドをエコーバックしない関数のリストです。
@code{nntp-open-connection-function} に設定した関数がコマンドをエコーバッ
クしないならば、それをこのリストに加えてください。
@code{nntp-never-echoes-commands} 変数の @code{nil} でない値が、この変数
をくつがえすことに注意してください。ディフォルト値
は @code{(nntp-open-network-stream)} です。

@item nntp-prepare-post-hook
@vindex nntp-prepare-post-hook
記事を投稿する直前に実行されるフックです。もし記事
に @code{Message-ID} ヘッダーが無くてニュースサーバーが推奨 ID を提供し
てくれるならば、このフックが実行される前にそれが記事に加えられます。これ
は、もしあなたが Gnus が @code{Message-ID} ヘッダーを付けないようにして
いても、@code{Cancel-Lock} ヘッダーを作るために利用することができます。
それにはこうすれば良いでしょう:

@lisp
(add-hook 'nntp-prepare-post-hook 'canlock-insert-header)
@end lisp

すべてのサーバーが推奨 ID をサポートしているわけではないことに注意してく
ださい。これは例えば INN 2.3.0 以上で動作します。

@item nntp-server-list-active-group
もし @code{nil} だったら @samp{LIST ACTIVE} の代わりに常
に @samp{GROUP} を使います。これは普通遅いのですが、誤って active ファイ
ルを頻繁に更新しないように設定されているサーバーでは助けになるはずです。
@end table

@menu
* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
@end menu

@node Direct Functions
@subsubsection 直接接続するための関数
@cindex direct connection functions

これらの関数は、あなたのマシンと @acronym{NNTP} サーバーを接続するために
直接呼ばれます。また、それらの動作はそれらが共通に参照する変数に影響され
ます (@pxref{Common Variables})。

@table @code
@findex nntp-open-network-stream
@item nntp-open-network-stream
これはディフォルトで、単純に遠隔システムのポートもしくは別のものに接続し
ます。もし Emacs とサーバーの両方がサポートしていれば、その接続は自動的
に暗号化された @acronym{STARTTLS} 接続に昇格されます。

@item network-only
上記に同じ。ただし自動で @acronym{STARTTLS} への昇格は行ないません。

@findex nntp-open-tls-stream
@item nntp-open-tls-stream
「安全な」チャンネルを使ってサーバーに接続します。これを使うために
は @uref{https://www.gnu.org/software/gnutls/, GnuTLS} をインストールし
ておかなければなりません。それからサーバーを次のように定義します:

@lisp
;; @r{ポート 563 が "nntps" として @file{/etc/services} で定義済み}
;; @r{であっても、@samp{gnutls-cli -p} でその名前は使えません。}
;;
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open-tls-stream)
      (nntp-port-number 563)
      (nntp-address "snews.bar.com"))
@end lisp

@c FIXME gnutls を支持し、openssl s_client は非推奨とすべきです。
@findex nntp-open-ssl-stream
@item nntp-open-ssl-stream
「安全な」チャンネルを使ってサーバーに接続します。これを使うために
は @uref{http://www.openssl.org, OpenSSL}
@ignore
@c Defunct URL, ancient package, so don't mention it.
または @uref{ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL, SSLeay}
@end ignore
をインストールしておかなければなりません。それからサーバーを次のように定
義します:

@lisp
;; @r{ポート 563 が "snews" として @file{/etc/services} で定義済みで}
;; @r{あっても、@samp{openssl s_client -port} でその名前は使えません。}
;;
(nntp "snews.bar.com"
      (nntp-open-connection-function nntp-open-ssl-stream)
      (nntp-port-number 563)
      (nntp-address "snews.bar.com"))
@end lisp

@findex nntp-open-netcat-stream
@item nntp-open-netcat-stream
@code{netcat} コマンドを使って @acronym{NNTP} サーバーに接続します。ディ
フォルトの @code{nntp-open-network-stream} がそれをするのにもかかわらず、
なぜこの関数があるのか不思議に思うかもしれません。その理由 (の一つ) は、
もしあなたが防壁の中にいたとしても @code{runsocks} のようなコマンドラッ
パーのおかげで外の世界を直接アクセスできるならば、それをこのように使うこ
とができるのです:

@lisp
(nntp "socksified"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-netcat-stream)
      (nntp-address "the.news.server"))
@end lisp

ディフォルトのメソッドのままでそれを行なうには Emacs のセッション全体を
ラップする必要があるでしょうが、それは良い考えではありません。

@findex nntp-open-telnet-stream
@item nntp-open-telnet-stream
@code{nntp-open-netcat-stream} に似ていますが、@code{netcat} ではな
くて @code{telnet} を使います。行末コードを変更したりするの
で @code{telnet} はいささか堅実さに欠けるのですが、@code{netcat} が無い
場合もあります。前の例はこのように書き換えられるでしょう:

@lisp
(nntp "socksified"
      (nntp-pre-command "runsocks")
      (nntp-open-connection-function nntp-open-telnet-stream)
      (nntp-address "the.news.server")
      (nntp-end-of-line "\n"))
@end lisp
@end table

@node Indirect Functions
@subsubsection 間接的に接続するための関数
@cindex indirect connection functions

これらの関数は、実際に @acronym{NNTP} サーバーに接続する前に中間のホスト
に接続するために間接的に呼ばれます。すべてのこれらの関数と関連する変数は
“via”接続の仲間に属しているとも言えるので、それを明確にするためにすべ
て“via”という接頭語が付けられます。また、それらの動作はそれらが共通に
参照する変数に影響されます (@pxref{Common Variables})。

@table @code
@item nntp-open-via-rlogin-and-netcat
@findex nntp-open-via-rlogin-and-netcat
遠隔システムに @samp{rlogin} して、そこから本当の @acronym{NNTP} サーバー
に接続するために @code{netcat} を使います。これは、例えばあなたが始めに
防壁マシンに接続しなければならない場合に便利です。

@code{nntp-open-via-rlogin-and-netcat}-用の変数:

@table @code
@item nntp-via-rlogin-command
@vindex nntp-via-rlogin-command
中間のホストにログインするために使われるコマンドです。ディフォルト
は @samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-via-rlogin-command-switches
@vindex nntp-via-rlogin-command-switches
@code{nntp-via-rlogin-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @code{nil} です。も
し @samp{ssh} を @code{nntp-via-rlogin-command} の値として使うならば、す
べてのデータ接続を圧縮するために @samp{("-C")} を使うことができます。
@end table

@item nntp-open-via-rlogin-and-telnet
@findex nntp-open-via-rlogin-and-telnet
本質的には同じことなのですが、中間のホストから本当の @acronym{NNTP} サー
バーに接続するために、@samp{netcat} の代わりに @code{telnet} を使います。
行末コードを変更したりするので @code{telnet} はいささか堅実さに欠けるの
ですが、@code{netcat} が無い場合もあるでしょう。

@code{nntp-open-via-rlogin-and-telnet}-用の変数:

@table @code
@item nntp-telnet-command
@vindex nntp-telnet-command
中間のホストから本当の @acronym{NNTP} サーバーに接続するために使われるコ
マンドです。ディフォルトは @samp{telnet} です。

@item nntp-telnet-switches
@vindex nntp-telnet-switches
@code{nntp-telnet-command} のコマンドのスイッチとして使われる文字列のリ
ストです。ディフォルトは @code{("-8")} です。

@item nntp-via-rlogin-command
@vindex nntp-via-rlogin-command
中間のホストにログインするために使われるコマンドです。ディフォルト
は @samp{rsh} ですが、@samp{ssh} が人気のある代替手段です。

@item nntp-via-rlogin-command-switches
@vindex nntp-via-rlogin-command-switches
@code{nntp-via-rlogin-command} のコマンドのスイッチとして使われる文字列
のリストです。@samp{ssh} を使う場合に、もし中間のホストで telnet コマン
ドが疑似端末を必要とするならば、これを @samp{("-t" "-e" "none")} また
は @samp {("-C" "-t" "-e" "none")} にする必要があるでしょう。ディフォル
トは @code{nil} です。
@end table

@code{nntp-end-of-line} の値を @samp{\n} に変更する必要があるであろうこ
とに注意してください (@pxref{Common Variables})。

@item nntp-open-via-telnet-and-telnet
@findex nntp-open-via-telnet-and-telnet
これもまた本質的には同じことなのですが、中間のホストに接続するため
に @samp{rlogin} の代わりに @samp{telnet} を使います。

@code{nntp-open-via-telnet-and-telnet}-用の変数:

@table @code
@item nntp-via-telnet-command
@vindex nntp-via-telnet-command
中間のホストに @code{telnet} するために使われるコマンドです。ディフォル
トは @samp{telnet} です。

@item nntp-via-telnet-switches
@vindex nntp-via-telnet-switches
@code{nntp-via-telnet-command} のコマンドのスイッチとして使われる文字列
のリストです。ディフォルトは @samp{("-8")} です。

@item nntp-via-user-password
@vindex nntp-via-user-password
中間のホストにログインするときに使われるパスワードです。

@item nntp-via-envuser
@vindex nntp-via-envuser
もし非-@code{nil} なら、中間の @code{telnet} のセッション (クライアント
とサーバーの両方) で @code{ENVIRON} オプションをサポートし、ログイン名の
入力を要求しません。これは例えば Solaris の @code{telnet} で動作します。

@item nntp-via-shell-prompt
@vindex nntp-via-shell-prompt
中間のホストでのシェルのプロンプトに合致する正規表現です。ディフォルト
は @samp{bash\\|\$ *\r?$\\|> *\r?} です。
@end table

@code{nntp-end-of-line} の値を @samp{\n} に変更する必要があるであろうこ
とに注意してください (@pxref{Common Variables})。
@end table

これらは上記のすべての関数が参照する付加的な変数です:

@table @code
@item nntp-via-user-name
@vindex nntp-via-user-name
中間のホストに接続するときに使う利用者名です。

@item nntp-via-address
@vindex nntp-via-address
接続する中間のホストのアドレスです。
@end table

@node Common Variables
@subsubsection 共通の変数

以下の変数は、すべての、またはいくつかのあらかじめ用意されている関数の動
作に影響を及ぼします。設定されていなければ、すべての関数が影響されま
す (それぞれの仮想サーバーにおいて、サーバー変数として個々に値が設定され
ていない場合に、以下の値がディフォルトで使われます)。

@table @code
@item nntp-pre-command
@vindex nntp-pre-command
素の接続用の関数ではないも
の (@code{nntp-open-network-stream}、@code{nntp-open-tls-stream} また
は @code{nntp-open-ssl-stream} 以外のすべて) を通して接続するときに使う
コマンドラッパーです。例えばあなたは @samp{SOCKS} ラッパーを割り当てるで
しょう。(訳注: @code{telnet} などの外部コマンドに被せて使われます。)

@item nntp-address
@vindex nntp-address
@acronym{NNTP} サーバーのアドレスです。

@item nntp-port-number
@vindex nntp-port-number
接続する @acronym{NNTP} サーバーのポート番号です。ディフォルト
は @samp{nntp} です。@acronym{TLS}/@acronym{SSL} を介し
た @acronym{NNTP} を使うには、ポートの名前ではなくて整数 (つま
り @samp{snews} や @samp{nntps} ではなくて @samp{563}) を指定する必要が
あります。外部の @acronym{TLS}/@acronym{SSL} ツールはポートの名前では動
作しないからです。

@item nntp-end-of-line
@vindex nntp-end-of-line
@acronym{NNTP} サーバーとお話をしているときに行の終わりの印として使われ
る文字列です。これはディフォルトで @samp{\r\n} ですが、素ではない接続用
の telnet 同等の関数を使っているときは @samp{\n} であるべきです。

@item nntp-netcat-command
@vindex nntp-netcat-command
@samp{netcat} を通して @acronym{NNTP} サーバーと接続するときに使うコマン
ドです。これは中間のホストと接続するためのものでは @emph{ありません}。こ
れはまさに本当の @acronym{NNTP} サーバーと接続するためのものです。ディフォ
ルトは @samp{nc} です。

@item nntp-netcat-switches
@vindex nntp-netcat-switches
@code{nntp-netcat-command} に渡すスイッチのリストです。ディフォルト
は @samp{()} です。
@end table

@node News Spool
@subsection ニューススプール
@cindex nnspool
@cindex news spool

ローカルスプールから外部グループを購読することは極めて簡単だし便利かもし
れません。非常に大きな記事があるグループ---例え
ば @samp{alt.binaries.pictures.furniture} を読む速度が速くなります。

とにかく、@code{nnspool} を選択方法として、かつ @code{""} (もしくは何で
も) をアドレスとして指定するだけです。

もしローカルスプールにつなぐことが可能なら、おそらくそれを基本選択方法と
して使うべきでしょう (@pxref{Finding the News})。それは普通
は @code{nntp} 選択方法を使うより速いですが、そうでないかもしれません。
それは場合によります。何があなたのサイトで一番良いかを見つけるために、い
ろいろと試してみなければなりません。

@table @code
@item nnspool-inews-program
@vindex nnspool-inews-program
記事を投稿するために使われるプログラムです。

@item nnspool-inews-switches
@vindex nnspool-inews-switches
記事を投稿するときに inews プログラムに与えられるパラメーターです。

@item nnspool-spool-directory
@vindex nnspool-spool-directory
@code{nnspool} が記事を探すところです。これは普通
は @file{/usr/spool/news/} です。

@item nnspool-nov-directory
@vindex nnspool-nov-directory
@code{nnspool} が @acronym{NOV} ファイルを探すところです。これは普通
は @file{/usr/spool/news/over.view/} です。

@item nnspool-lib-dir
@vindex nnspool-lib-dir
ニュースのライブラリーが置かれているディレクトリーの場所です (ディフォル
トで @file{/usr/lib/news/} です)。

@item nnspool-active-file
@vindex nnspool-active-file
アクティブファイルの絶対パス名です。

@item nnspool-newsgroups-file
@vindex nnspool-newsgroups-file
@file{newsgroups} ファイルの絶対パス名です。

@item nnspool-history-file
@vindex nnspool-history-file
@file{history} ファイルの絶対パス名です。

@item nnspool-active-times-file
@vindex nnspool-active-times-file
@file{active.times} ファイルの絶対パス名です。

@item nnspool-nov-is-evil
@vindex nnspool-nov-is-evil
@code{nil} でないと、@code{nnspool} はそれが見つけたどん
な @acronym{NOV} ファイルも使おうとはしません。

@item nnspool-sift-nov-with-sed
@vindex nnspool-sift-nov-with-sed
@cindex sed
@code{nil} でないと、これがディフォルトですが、概観ファイ
ル (overview) から関連する部分を得るために @code{sed} を使います。も
し @code{nil} だと、@code{nnspool} はファイル全体をバッファーに読み込ん
で、そこで実行します。
@end table

@node Using IMAP
@section IMAP を使う
@cindex imap

おそらく最も人気があるメール・バックエンドは @code{nnimap} です。それ
は @acronym{IMAP} サーバーに接続します。@acronym{IMAP} サーバーはメール
をサーバーに格納するので、クライアントは何もローカルに格納しません。もし、
いろいろな場所から、またはいろいろなユーザー・エージェントでメールを読ん
でいるのであれば、それは便利な選択だと言えます。

@menu
* Connecting to an IMAP Server::     @acronym{IMAP} を始める
* Customizing the IMAP Connection::  @acronym{IMAP} 接続のための変数
* Client-Side IMAP Splitting::       正しいメールボックスにメールを置く
* Support for IMAP Extensions::      拡張とラベルをサーバーから取得する
@end menu

@node Connecting to an IMAP Server
@subsection IMAP サーバーに接続する

@acronym{IMAP} サーバーへの接続はとても簡単なはずです。グループバッファー
で @kbd{B} を叩くか、または (もしあなたの第一の関心事がメールを読むこと
であるなら) 以下のようなことをしてください:

@example
(setq gnus-select-method
      '(nnimap "imap.gmail.com"))
@end example

ユーザー名とパスワードを尋ねられます。それに飽きたなら、以下のもの
を @file{~/.authinfo} ファイルに加えてください:

@example
machine imap.gmail.com login <username> password <password> port imap
@end example

ほとんどのユーザーには、それだけで良いはずです。

@node Customizing the IMAP Connection
@subsection IMAP 接続をカスタマイズする

もっと複雑な接続方法の例:

@example
(nnimap "imap.gmail.com"
        (nnimap-inbox "INBOX")
        (nnimap-split-methods default)
        (nnimap-expunge t)
        (nnimap-stream ssl))
@end example

@table @code
@item nnimap-address
サーバーのアドレスです。@samp{imap.gmail.com} のようなもの。

@item nnimap-server-port
サーバーのポートが標準とは異なるなら、ここで設定できます。代表的なポート
は @code{"imap"} あるいは @code{"imaps"} でしょう。

@item nnimap-stream
@code{nnimap} がどうやってサーバーに接続するかを指定します。使える値は:

@table @code
@item undecided
これがディフォルトです。最初に @code{ssl} 設定を、次に @code{network} 設
定を試します。

@item ssl
標準の @acronym{TLS}/@acronym{SSL} 接続を使います。

@item network
暗号化されないので安全ではない、ストレートなソケット接続です。しかし、も
し Emacs とサーバーの両方がサポートしていれば、暗号化され
た @acronym{STARTTLS} 接続に昇格します。

@item starttls
正規の @acronym{IMAP} ポート上で暗号化された @acronym{STARTTLS} を使いま
す。

@item shell
もしサーバーに接続するために他のホストをトンネルする必要があるなら、この
オプションを使って @code{nnimap-shell-program} を必要に応じてカスタマイ
ズすることができます。

@item plain
暗号化されておらず安全ではないストレートな接続。たと
え @acronym{STARTTLS} が利用可能でも使いません。
@end table

@item nnimap-authenticator
いくつかの @acronym{IMAP} サーバーは匿名ログインを許容しています。その場
合、これを @code{anonymous} に設定する必要があります。もしこの変数を設定
しないと標準のログイン手順が使われます。特定のログイン手順を指定したいな
ら、この変数を @code{login} (伝統的な @acronym{IMAP} のログイン手順)、
@code{plain} または @code{cram-md5} のどれかを設定してください。

@item nnimap-expunge
もし @code{nil} でなければ、記事を消去した後でそれらを永久に取り除きます。
これはサーバーに UID EXPUNGE の機能があれば常に実行されますが、ディフォ
ルトではサーバーにそのコマンドが無ければ実行しません。

@item nnimap-streaming
事実上すべての @acronym{IMAP} サーバーはデータの高速ストリーミングをサポー
トしています。もしサーバーへの接続に問題があるのなら、これ
を @code{nil} に設定してみてください。

@item nnimap-fetch-partial-articles
もし @code{nil} 以外の値だったら、サーバーから記事の部分を取り込みます。
もし文字列が設定されていたら、それは正規表現であると解釈され、そのタイプ
が合致する部分が取り込まれます。例えば @samp{"text/"} 場合はすべてのテキ
スト型の部分を取り込みますが、残りはサーバーに置いたままになります。

@item nnimap-record-commands
もし @code{nil} でなければ、すべての @acronym{IMAP} コマンド
を @samp{"*imap log*"} バッファーに記録します。

@item nnimap-use-namespaces
もし @code{nil} でなければ、nnimap グループ名において IMAP 名前空間の接
頭辞を省略します。もしあなたのメールボックス
が @samp{INBOX} や @samp{INBOX.Lists.emacs} のように名付けられているとし
ても、nnimap グループ名を @samp{INBOX} や @samp{Lists.emacs} のようにし
たいのであれば、このオプションを有効にしてください。
@end table

@node Client-Side IMAP Splitting
@subsection クライアント側での IMAP 分割

多くの人々が、メールを @acronym{IMAP} サーバー上のそれぞれのメールボック
スに並び換え/分割することを好みます。そうすれば、さほど関心が無いメール
をダウンロードする必要がありません。

もしクライアント側でメール分割をする必要があるのなら、関連する変数は次の
通りです:

@table @code
@item nnimap-inbox
新着メールが調べられる @acronym{IMAP} メールボックスです。これはメールボッ
クス名のリストでもかまいません。

@item nnimap-split-methods
@code{nnmail-split-methods} と同じ構文を使います (@pxref{Splitting
Mail})。ただし @code{default} というシンボルである場合は例外で、
@code{nnmail-split-methods} の値を使います。

@item nnimap-split-fancy
@code{nnmail-split-fancy} と同じ構文を使います。

@item nnimap-unsplittable-articles
分割を行なっているときに無視すべきフラグのシンボルのリスト。すなわち、そ
れらのフラグをもっている記事は、分割を行なう対象として考慮されないという
ことです。ディフルトは @samp{(%Deleted %Seen)} です。
@end table

以下は、クライアント側で ``特級'' メール分割を行なう @code{nnimap} バッ
クエンドの完全な例です:

@example
(nnimap "imap.example.com"
        (nnimap-inbox "INBOX")
        (nnimap-split-fancy
         (| ("MailScanner-SpamCheck" "spam" "spam.detected")
            (to "foo@@bar.com" "foo")
            "undecided")))
@end example

@node Support for IMAP Extensions
@subsection IMAP 拡張のサポート

@cindex Gmail
@cindex X-GM-LABELS
@cindex IMAP labels

Google の Gmail を使っていると、メールを読んでいるときに Gmail ラベルを
見たいときがあるでしょう。Gnus はその情報を提供することができます。その
ためには変数 @code{gnus-extra-headers} の中で @samp{X-GM-LABELS} を要求
してください。例えばこんなふうに:

@example
(setq gnus-extra-headers
      '(To Newsgroups X-GM-LABELS))
@end example

これによって、後に参照できるように Gnus はメッセージヘッダーにラベルを追
加します。その内容は常に括弧で囲まれたリストになります (中身が無い場合も
あります。)。

@node Getting Mail
@section メール取得
@cindex reading mail
@cindex mail

ニュースリーダーでメールを読むなんて実に奇妙ですよね?  いや、もちろんで
きるのですが。

@menu
* Mail in a Newsreader::        ニュースリーダーでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを鬼のように分割することができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる
@end menu

@node Mail in a Newsreader
@subsection ニュースリーダーでメール

使い慣れた伝統的なメールリーダーから Gnus に乗り換えることを決断したなら
ば、かなりのカルチャーショックを経験することになるでしょう。

Gnus は伝統的なメールリーダーのようなふるまいをしません。あなたが望むな
らそのようにもできますが、それは骨折り損のくたびれ儲けです。

Gnus はふつう同じ手法ですべてのグループを扱います。あるグループを選んで
新しい、または未読のメッセージを読むと、それらには既読の印が付けられ、
(意図的に要求しなければ) 以後はそれらを目にすることはありません。これっ
てとてもニュースリーダー的でしょ。

メッセージを消すために、取り立てて何かを行なうことはありません。

このことは既読のメッセージはすべて消されてしまうことを意味するのかっ
て? そりゃあんまりですよね!

しかし、そうではありません。古いメッセージは何らかの仕組みによって期限切
れ消去 (@dfn{expire}) されるのです。ニュースのメッセージはニュースの管理
人 (が管理しているサーバー) によって期限切れ消去の処理が制御され、メール
の期限切れ消去の処理はあなたが制御します。メールの期限切れ消去については、
@ref{Expiring Mail} で徹底的に網羅されています。

多くの Gnus の利用者が、それをニュースとメールの両方でしばらく使ってみた
後で気が付くのは、その配送の機構がメッセージの扱い方に関して行なうことが、
ほんの少ししか無いことです。

多くの人たちが複数のメーリングリストを講読しています。それら
は @acronym{SMTP} で配送されるもの、すなわちメールです。それらのメッセー
ジに返答をしないまま、あるいはさらに、それらを非常に注意深くは読まないま
まに、私たちは何週間も過ごすかもしれません。でも、そういうメッセージを保
存しておく必要はありません。なぜならば、もう一度読む必要が生じたとしても、
それらはどこかに保存されているからです。

ある人たちは小人数に利用されているローカルニュースグループを講読していま
す。それらは @acronym{NNTP} で配送されるもの、すなわちニュースです。私た
ちは自分の仕事に役立てるために、それらの膨大なメッセージの断片を読んだり
返事をしなければなりません。しかもそれらがどこかに保存されているとは限ら
ないので、興味のあるメッセージを個人メールと同じように保存しなければなり
ません。

配送の仕組みの違いはどうでもよいことで、大事なのはいかに主題に興味を持っ
ているかと、もう一度読みたいときにいかに簡単に呼び出せるかなのです。

Gnus はメールをニュースグループのように「グループ」に並べ変えて、各々の
グループ (メールかニュース) を別個に扱うための豊富な機能を提供します。

ある人たちは Gnus (えっへん) のやりかたに満足できなくて、Gnus が
男 (male) になること、もとい、メールリーダーになることを欲します。
Gnus をもっとメールリーダー的なものにするために鞭打つことは可能ではある
のですが、前にも言ったように簡単ではありません。いわゆるメールリーダーが
好みならば @sc{vm} を使いましょう。これは優秀な、厳密な意味でのメールリー
ダーです。

脅かすわけではないのですが、はっきりさせておきたいのは、あなたにメッセー
ジについての新しいやり方を修得して欲しいということです。あなたが Gnus の
やり方を受け入れてくれた暁には、きっとあなたは Gnus が好きになるでしょう。
請け合いますよ。(少くとも、私が Gnus に入れた Emacs のサブリミナル脳味噌
洗濯関数を売ってくれた人はそれを保証しています。あなたも同化します。あな
たは Gnus を愛します。あなたは Gnus でのメールの方法を愛します。絶対に。)

@node Getting Started Reading Mail
@subsection メールを読むことを始める

Gnus を使って新しいメールを読むことはまったく簡単です。あなたが選んだメー
ルバックエンドを @code{gnus-secondary-select-methods} に放り込むだけで、
自動的に読むことができるようになります。

例えば @code{nnml} (これは「一メールにつき一ファイル」のバックエンドで
す) を使いたいなら、次のものを @file{~/.gnus.el} ファイルに入れれば良い
でしょう:

@lisp
(setq gnus-secondary-select-methods '((nnml "")))
@end lisp

そうすると、次に Gnus を起動したときにこのバックエンドは新しい記事を求め、
すべてのメッセージをスプールファイルからそのディレクトリー (ディフォルト
では @file{~/Mail/}) に移します。新しいグループ (@samp{mail.misc}) が作
られて、他のグループと同じように読むことができるようになります。

たぶんメールをいくつかのグループに分割したいでしょうけれど:

@lisp
(setq nnmail-split-methods
      '(("junk" "^From:.*Lars Ingebrigtsen")
        ("crazy" "^Subject:.*die\\^Organization:.*flabby")
        ("other" "")))
@end lisp

これは三つの新しい @code{nnml} メールグループ @samp{nnml:junk},
@samp{nnml:crazy} および @samp{nnml:other} を作ることになります。初めの
二つのグループにふさわしくないすべてのメールは、最後のグループに置かれま
す。

Gnus でメールを読むにはこれで十分なはずです。マニュアルのこの部分の他の
章を熟読する必要があるかもしれませんが。特に @ref{Choosing a Mail Back
End} と @ref{Expiring Mail} を。

@node Splitting Mail
@subsection メールの分割
@cindex splitting mail
@cindex mail splitting
@cindex mail filtering (splitting)

@quotation
訳注: このマニュアルの多方面で使われている「分割」という語のうち、受信し
たメールをいろいろなグループに「区分け」することを意味するもの
は“split”という語に対応します。ある一つのメールを「分解」するのではな
くて、外からやって来た複数のメールをそれぞれの格納先に一通ずつ「振り分け
る」意味で使っています。
@end quotation

@vindex nnmail-split-methods
変数 @code{nnmail-split-methods} は入ってくるメールをどのようにグループ
分けするかを指定します。

@lisp
(setq nnmail-split-methods
  '(("mail.junk" "^From:.*Lars Ingebrigtsen")
    ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
    ("mail.other" "")))
@end lisp

この変数はリストのリストで、それぞれのリストの最初の要素はメールグループ
の名前、二つめの要素はそれぞれのメールがそのグループに属するかどうかをヘッ
ダーで判定するために使う正規表現です (ところで、メールグループの名前
が @samp{mail} で始まる必要はありません)。最初の文字列は、
@code{replace-match} が合致した文章から取り出した副表現を挿入するために
使われるような、@samp{\\1} の様式を含むかもしれません。例えば:

@lisp
("list.\\1" "From:.* \\(.*\\)-list@@majordomo.com")
@end lisp

@noindent
この場合、挿入されるテキストを小文字にすべきかどうか
を @code{nnmail-split-lowercase-expanded} が制御します。@xref{Fancy Mail
Splitting}.

二番目の要素は関数でも構いません。その場合、それは規則の最初の要素 (メー
ルグループの名前) を引数として、ヘッダーだけに範囲を狭められたバッファー
で呼ばれます。メールがそのグループに属すると判断したら、その関数
は @code{nil} でない値を返す必要があります。

@cindex @samp{bogus} group
これらのグループの最後は常に総合的なものであるべきで、その正規表現は他の
正規表現に合致しなかったメールに合致するために、
@emph{いつも} @samp{""} でなければなりません。(これらの規則は連想リスト
の初めから終わりまで順番に処理されます。クロスポストを有効にしていない限
り、最初に合致した規則が「勝ち」ます。クロスポストを有効にしている場合は、
すべての合致した規則が「勝ち」ます。)  合致する規則がなかったら、メール
は最後に @samp{bogus} グループで終わります。メール分割によって新しいグルー
プが作られた場合は、それらを見るため
に @code{gnus-group-find-new-groups} を実行する必要があるでしょう。これ
は @samp{bogus} グループにも当てはまります。

あなた自身でこれをいじくりまわしたいときは、あなたの選んだ関数をこの変数
に設定することができます。この関数は入って来たメールメッセージのヘッダー
に範囲を狭められたバッファーで、引数無しで呼ばれます。この関数は、そのメー
ルメッセージをが行くべきだと判断するグループ名のリストを返さなければなり
ません。

この変数は特級メール分割であっても良いです。構文については @xref{Fancy
Mail Splitting}.

すべてのメールバックエンドは、入って来た気の毒な無実のヘッダーを乱暴に扱っ
ても良いことに注意してください。それらはすべて @code{Lines} ヘッダーを追
加します。いくつかは @code{X-Gnus-Group} ヘッダーを加えます。たいていの
ものは Unix の mbox の @code{From@key{SPC}} 行を何か別のものに変えます。

@vindex nnmail-crosspost
すべてのメールバックエンドはクロスポストをサポートします。複数の正規表現
が合致すると、メールはそれらすべてのグループに「クロスポスト」されます。
@code{nnmail-crosspost} はこの機能を使うかどうかを指定します。どの記事も
総合の (@samp{""}) グループにクロスポストされないことに注意してください。

@vindex nnmail-crosspost-link-function
@cindex crosspost
@cindex links
@code{nnmh} と @code{nnml} はクロスポストされた記事にハードリン
ク (hardlink) を作ることによってクロスポストを行ないます。しかし、すべて
のファイルシステムがハードリンクの機能を提供しているわけではありません。
もしあなたがその場合に当てはまるのであれば、
@code{nnmail-crosspost-link-function} を @code{copy-file} に設定してくだ
さい。(この変数はディフォルトで @code{add-name-to-file} です。)

@findex nnmail-split-history
以前に行なわれたメール分割がメッセージをどこに入れたかを見たい場合は、
@kbd{M-x nnmail-split-history} 命令を使ってください。これからスプールし
直そうとするメッセージがどこに入るかを見たい場合は、
@code{gnus-summary-respool-trace} および関連する命令 (@pxref{Mail Group
Commands}) を使ってください。

@vindex nnmail-split-header-length-limit
@code{nnmail-split-header-length-limit} の制限より長いヘッダー行は、分割
関数の処理対象から除外されます。

@vindex nnmail-mail-splitting-decodes
@vindex nnmail-mail-splitting-charset
ディフォルトでは分割の処理においてヘッダーを @acronym{MIME} デコードしな
いので、非-@acronym{ASCII} 文字列に合致させることができません。しかし、
生のヘッダーのデータを元に記事の合致を判定したい場合には役立つでしょう。
それを可能にするには @code{nnmail-mail-splitting-decodes} 変数
を @code{nil} ではない値に設定してください。加え
て @code{nnmail-mail-splitting-decodes} が @code{nil} ではない場合に、
@code{nnmail-mail-splitting-charset} 変数の値が @acronym{MIME} ではない
エンコードされた文字列 (訳注: @code{iso-2022-jp} でエンコードされた生の
データなど) をデコードするために使われます。ディフォルトは @code{nil} で、
@acronym{MIME} ではないエンコードされた文字列をデコードしません。あなた
にとって好都合な値はおそらく @code{undecided} か、またはあなたが興味があ
るメールで通常使われている文字セット (訳注: 実際は coding system) になる
でしょう。

@vindex nnmail-resplit-incoming
ディフォルトでは入ってくるすべてのメッセージに対して分割の処理が行なわれ
ます。しかし、もし @code{mail-sources} 変数 (@pxref{Mail Source
Specifiers}) に @code{directory} の項目を設定すると、ディフォルトでは分
割は @emph{行なわれません}。変
数 @code{nnmail-resplit-incoming} を @code{nil} ではない値に設定すれば、
この場合でも分割を起こさせることができます。(この変数は他の種類の項目に
対しては効果がありません。)

Gnus はあなた自身に災いが及ぶ可能性あっても、あなたが望むすべての機会を
提供します。例えば、あなたの上司からくるすべてのメールを入れるグループを
作ったとしましょう。その後、偶発的にそのグループの購読をやめてしまうとど
うなるでしょう。それでも Gnus は上司からのすべてのメールを未購読のグルー
プに入れるので、上司が「月曜日までにその報告書を準備しないと首だ!」とい
うメールをあなたに送っても、あなたはそれを見ることはなく、火曜日になって
本当は翌月の家賃を払うために空のボトルを集めるべきであっても、まだ有給で
雇われていると信じているかもしれません。

@node Mail Sources
@subsection メールソース

メールはたくさんの別のソース (source) から取得することができます---例え
ばメールスプールから、@acronym{POP} メールサーバーから、procmail ディレ
クトリーから、maildir から。

@menu
* Mail Source Specifiers::      メールのソースがどこかを指定する
* Mail Source Functions::
* Mail Source Customization::   ものごとに影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使う
@end menu

@node Mail Source Specifiers
@subsubsection メールソース指示子
@cindex POP
@cindex mail server
@cindex procmail
@cindex mail spool
@cindex mail source

「メールソース指示子」に @code{メールソース} (@pxref{Fetching Mail}) を
設定して、Gnus にメールを取得する方法を指示しましょう。

例です:

@lisp
(pop :server "pop3.mailserver.com" :user "myname")
@end lisp

ご覧のように、メールソース指示子はリストで、最初の要素は「メールソースの
型」、それに任意の数の「キーワード」が続きます。明示的に指定されていない
キーワードはディフォルト値になります。

@code{mail-sources} はすべてのグループに対して共通です。しかし特定のグルー
プのために、@code{mail-sources} に @code{group} メールソース指示子を持た
せて、かつ単一のメールソースを指定する @code{mail-source} グループパラメー
ター (@pxref{Group Parameters}) を設定することによって、メールソースを追
加することができます。これを使う場合の @code{mail-sources} は、一般には
単なる @code{((group))} です。そしてグループのため
の @code{mail-source} パラメーターはこのようなものになるでしょう:

@lisp
(mail-source . (file :path "home/user/spools/foo.spool"))
@end lisp

これは、そのグループは (このグループだけは) メッセージをスプールファイ
ル @samp{/user/spools/foo.spool} から取得することを意味します。

以下のメールソースの型が使用可能です:

@table @code
@item file
単一のファイルからメールを取得します。普通はメールスプールです。

キーワード:

@table @code
@item :path
ファイルの名前です。ディフォルトは @env{MAIL} 環境変数の値
か @code{rmail-spool-directory} の値 (普通
は @file{usr-mail/spool/user-name} のようなもの) です。

@item :prescript
@itemx :postscript
それぞれのメールを取得する前と後で実行するスクリプトです。
@end table

ファイルメールソースの例:

@lisp
(file :path "/usr/spool/mail/user-name")
@end lisp

もしくは、ディフォルトのファイル名を使うと:

@lisp
(file)
@end lisp

メールスプールファイルがローカルマシンに無い場合は、
@acronym{POP} や @acronym{IMAP} などでメールを取得するのが最善です。ここ
では ange-ftp のファイル名は使用できません---メールを移動しているときに
メールスプールをロックする方法がありません。

適当なサーバーを設置することが不可能なら、変わりに ssh を使うことができ
ます。

@lisp
(setq mail-sources
      '((file :prescript "ssh host bin/getmail >%t")))
@end lisp

@samp{getmail} スクリプトは以下のようなものになるでしょう:

@example
#!/bin/sh
#  getmail - move mail from spool to stdout
#  flu@@iki.fi

MOVEMAIL=/usr/lib/emacs/20.3/i386-redhat-linux/movemail
TMP=$HOME/Mail/tmp
rm -f $TMP; $MOVEMAIL $MAIL $TMP >/dev/null && cat $TMP
@end example

あなたが使いたい @samp{movemail} と一時ファイルに合わせて、スクリプトを
書き換えてください。

@item directory
@vindex nnmail-scan-directory-mail-source-once
特定のディレクトリーにある複数のファイルからメールを取得します。これは普
通は procmail に新しいメールをいくつかのファイルに分割させているときに使
われます。すなわち、そのディレクトリーにあるファイルとグループは一対一で
対応しているので、@file{foo.bar.spool} ファイルにあるメール
は @code{foo.bar} グループに置かれます (接尾語の @code{.spool} は変更可
能です)。@code{nnmail-scan-directory-mail-source-once} を @code{nil} 以
外の値にすると、Gnus に新しいメールソースを一回だけ調べさせることができ
ます。これは特に、指定したレベルのメールグループだけを調べたいときに便利
です。

@vindex nnmail-resplit-incoming
@code{nnmail-resplit-incoming} という変数もあり、これを非-@code{nil} に
すると通常の分割処理がそのディレクトリーにあるすべてのファイルに対して行
なわれます (@pxref{Splitting Mail})。

キーワード:

@table @code
@item :path
ファイルがあるディレクトリーの名前です。これにはディフォルト値はありませ
ん。

@item :suffix
この接尾語で終わる名前ファイルだけが使われます。ディフォルト
は @samp{.spool} です。

@item :predicate
この述語が @code{nil} でない値を返すファイルだけが使われます。ディフォル
トは @code{identity} です。これは追加の選別器として使用されます---正しい
接尾語で、@emph{かつ} この述語を満足するファイルだけが対象になります。

訳注: この場合の述語は関数で、正しい接尾語を持つファイルの名前が引数とし
て渡されます。

@item :prescript
@itemx :postscript
それぞれのメールを取得する前と後で実行するスクリプトです。
@end table

ディレクトリーメールソースの例です:

@lisp
(directory :path "/home/user-name/procmail-dir/"
           :suffix ".prcml")
@end lisp

@item pop
@acronym{POP} サーバーからメールを取得します。

キーワード:

@table @code
@item :server
@acronym{POP} サーバーの名前です。ディフォルトは @env{MAILHOST} 環境変数
から取得されます。

@item :port
@acronym{POP} サーバーのポート番号です。これは数値 (例え
ば @samp{:port 1234}) か文字列 (例えば @samp{:port "pop3"}) です。もし文
字列なら Unix システムにおける @file{/etc/services} に載っているサービス
名でなければなりません。ディフォルトは @samp{"pop3"} です。システムによっ
ては @samp{"pop-3"} としなければならないかもしれません。

@item :user
@acronym{POP} サーバーに与える利用者名です。ディフォルトはログイン名です。

@item :password
@acronym{POP} サーバーに与えるパスワードです。設定しないと利用者は入力を
求められます。

@item :program
@acronym{POP} サーバーからメールを取得するために使用されるプログラムです。
これは @code{format} で使うような文字列でなければなりません。例です:

@example
fetchmail %u@@%s -P %p %t
@end example

有効な書法仕様指示子は:

@table @samp
@item t
メールがそこに移動させられるファイルの名前です。これは常にこの文字列に含
まれていなければなりません。

@item s
サーバーの名前です。

@item P
サーバーのポート番号です。

@item u
使用する利用者名です。

@item p
使用するパスワードです。
@end table

これらの仕様で使われる値は、対応するキーワードに与えた値から取られます。

@item :prescript
メールを取得する前に実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

これの良く知られている使い道は、@acronym{POP} サーバーに接続するため
の SSH トンネルをお膳立てすることです、ここに例があります:

@lisp
(pop :server "127.0.0.1"
     :port 1234
     :user "foo"
     :password "secret"
     :prescript
     "nohup ssh -f -L 1234:pop.server:110 remote.host sleep 3600 &")
@end lisp

(訳注: 原典
は @url{http://article.gmane.org/gmane.emacs.gnus.general/81249}。)

@item :postscript
メールを取得した後で実行されるスクリプトです。構文は @code{:program} キー
ワードと同じです。これは実行される関数であることもできます。

@item :function
@acronym{POP} サーバーからメールを取得するために使う関数です。その関数は
一つのパラメーター (メールがそこへ移動されるべきファイルの名前) とともに
呼ばれます

@item :authentication
これは @code{password} かシンボル @code{apop} のどちらかで、何の認証方式
を使うかを指示します。ディフォルトは @code{password} です。

@item :leave
メールを取得後もサーバーに残すには @code{nil} 以外の値にします。組み込み
関数 @code{pop3-movemail} (ディフォルト) だけがこのキーワードをサポート
します。

もしこれが数値だったら、最初に新着メールをチェックしたときからその日数だ
けメールをサーバーに残します。その場合は @acronym{UIDL} で制御されるので、
一度取得したメールを再び取り込むことはありません。@code{nil} の場合 (そ
れがディフォルト)、サーバーにあるメールは取得後すぐに削除されます。これ
が @code{nil} でも数値でもない場合はすべてのメールをサーバーに残すので、
あなたは同じメールを何度も受け取る羽目になるでしょう。

@vindex pop3-uidl-file
@code{pop3-uidl-file} 変数で @acronym{UIDL} データをローカルに格納するファ
イルを指定します。ディフォルト値は @file{~/.pop3-uidl} です。

@acronym{POP} サーバーはセッションとセッションの間の状態の情報を維持しな
いので、クライアントがそこにあると思っているものと実際にあるものが一致し
ないかもしれないことに注意してください。それらが一致しないと、メールをダ
ブって受け取るか、またはすべてが崩壊して、あなたは壊れたメールボックスと
ともに置き去りにされる可能性があります。
@end table

@findex pop3-movemail
@vindex pop3-leave-mail-on-server
@code{:program} と @code{:function} キーワードが指定されていない場合
は @code{pop3-movemail} が使われます。

メールを @acronym{POP} サーバーから取得するための、いくつかの例を挙げま
す。

ディフォルトの利用者名を使って、ディフォルトの @acronym{POP} サーバーか
ら取得し、ディフォルトの取得方法を使用します:

@lisp
(pop)
@end lisp

指名したサーバーから、指名した利用者とパスワードで取得します:

@lisp
(pop :server "my.pop.server"
     :user "user-name" :password "secret")
@end lisp

サーバーに 14 日間メールを残します:

@lisp
(pop :server "my.pop.server"
     :user "user-name" :password "secret"
     :leave 14)
@end lisp

メールの移動に @samp{movemail} を使います:

@lisp
(pop :program "movemail po:%u %t %p")
@end lisp

@item maildir
Maildir からメールを取得します。これは少なくとも qmail と postfix によっ
てサポートされているメールボックスの形式で、特別のディレクトリーにあるそ
れぞれのファイルは、厳密に一通のメールを含んでいます。

キーワード:

@table @code
@item :path
メールが保存されるディレクトリーの名前です。ディフォルトは環境変
数 @env{MAILDIR} から取得した値か、または @file{~/Maildir/} です。
@item :subdirs
Maildir のサブディレクトリーです。ディフォルトは @samp{("new" "cur")} で
す。
@c Gnus で取得する前に、ときどき pop3 デーモンでメールを探すなら、以下の
@c 最初の例のように、maildir の中の @code{cur} ディレクトリーからもメー
@c ルを取得する必要があるかもしれません。

リモートマシンからメールを取り寄せることも出来ます。(というのも、
maildir はロックの問題を気にせずに済むからです。)
@end table

Maildir メールソースの例をふたつ:

@lisp
(maildir :path "/home/user-name/Maildir/"
         :subdirs ("cur" "new"))
@end lisp

@lisp
(maildir :path "/user@@remotehost.org:~/Maildir/"
         :subdirs ("new"))
@end lisp

@item imap
@acronym{IMAP} サーバーからメールを取得します。何らかの理由で、
@acronym{IMAP} をそれが意図されたようなネットワーク上でメールを読むプロ
トコルとしては (すなわち @code{nnimap} で) 使いたくないときは、Gnus で
は @acronym{POP} サーバーと同様に扱って、指定された @acronym{IMAP} メー
ルボックスから記事を取得することができます。詳しく
は @ref{Using IMAP} を参照してください。

キーワード:

@table @code
@item :server
@acronym{IMAP} サーバーの名前。ディフォルトは環境変数 @env{MAILHOST} か
ら得ます。

@item :port
@acronym{IMAP} サーバーのポート番号。普通はディフォルトは @samp{143} で、
@acronym{TLS}/@acronym{SSL} 接続には @samp{993} です。

@item :user
@acronym{IMAP} サーバーに渡す利用者名です。ディフォルトはログイン名です。

@item :password
@acronym{IMAP} サーバーに渡すパスワードです。指定されていないときは、利
用者は入力することを促されます。

@item :stream
サーバーに接続するときに使うストリーム。@code{imap-stream-alist} にある
シンボルの中のひとつを設定します。現状では @samp{gssapi},
@samp{kerberos4}, @samp{starttls}, @samp{tls}, @samp{ssl},
@samp{shell} またはディフォルトの @samp{network} になります。

@item :authentication
サーバーでの認証にどの認証法を使うか。これに
は @code{imap-authenticator-alist} で定義されているシンボルの一つを設定
します。現状では @samp{gssapi}, @samp{kerberos4}, @samp{digest-md5},
@samp{cram-md5}, @samp{anonymous} またはディフォルトの @samp{login} にな
ります。

@item :program
:stream に @samp{shell} が設定されているときは、この値が変
数 @code{imap-shell-program} に割り当てられます。これは @code{format} ふ
うの文字列 (または文字列のリスト) でなければなりません。例を示しましょう:

@example
ssh %s imapd
@end example

何物もそのプログラムの出力を邪魔しないようにしてください。例えばエラー出
力は void に振り分けましょう。有効な書法仕様指示子は以下の通りです。

@table @samp
@item s
サーバーの名前。

@item l
@code{imap-default-user} で設定された利用者名。

@item p
サーバーのポート番号。
@end table

これらの指定に使われる値は、対応するキーワードに与えた値から取ってきます。

@item :mailbox
メールを取得するメールボックスの名前。ディフォルトは @samp{INBOX} で、こ
れは普通は入ってくるメールを受け取るメールボックスです。単一のメールボッ
クスの代わりに、メールを取得する複数のメールボックスのリストでもよいです。

@item :predicate
取得する記事を見つけるために使われる述語。ディフォルトの、@samp{UNSEEN
UNDELETED} はおそらくたいていの人には最良の選択でしょうが、ときど
き @acronym{IMAP} クライアントでメールボックスを覗いて、いくつかの記事に
既読 (または SEEN) の印を付けるなら、これを @samp{1:*} に設定する必要が
あるかもしれません。そうすれば、メールボックスのすべての記事は印の如何に
関わらず取得されます。述語の完全な一覧は、RFC2060 の 6.4.4 節を読んでく
ださい。

@item :fetchflag
サーバーで、取得した記事にフラグを付ける方法。ディフォルト
の @samp{\Deleted} はそれらに消去のフラグを付けますが、単に既読のフラグ
を付けるための @samp{\Seen} が代案になるでしょう。これらは最もありそうな
二つの選択ですが、他のフラグも RFC2060 の 2.3.2 節で定義されています。

@item :dontexpunge
@code{nil} でなかったら、記事を取得した後で、それらに消去の印が付いてい
ても削除しません。
@end table

@acronym{IMAP} メールソースの例:

@lisp
(imap :server "mail.mycorp.com"
      :stream kerberos4
      :fetchflag "\\Seen")
@end lisp

@item group
実際のメールソースとして @code{mail-source} グループパラメーターで設定さ
れているものを使います。@xref{Group Parameters}.

@end table

@table @dfn
@item Common Keywords
共通キーワードはどんな型のメールソースにも使うことができます。

キーワード:

@table @code
@item :plugged
@code{nil} でなかったら、Gnus が unplugged (ネットワークから切り離されて
いる状態) であってもメールを取得します。ディレクトリーをメールソースに使っ
ているのならば、この例のように指定することができます:

@lisp
(setq mail-sources
      '((directory :path "/home/pavel/.Spool/"
                   :suffix ""
                   :plugged t)))
@end lisp

こうしておくことによって unplugged であっても Gnus はメールを取得します。
これはローカルのメールとニュースを使う場合に便利です。
@end table
@end table

@node Mail Source Functions
@subsubsection 関数インターフェース

上記のいくつかのキーワードは、実行するための Lisp 関数を指定します。関数
が実行されている間だけ、それぞれのキーワード @code{:foo} に対し
て Lisp 変数 @code{foo} が、そのキーワードの値に束縛されます。例えば、以
下のメールソースの設定例について考えてみてください。

@lisp
(setq mail-sources '((pop :user "jrl"
                          :server "pophost" :function fetchfunc)))
@end lisp

関数 @code{fetchfunc} が実行されているとき、@code{user} というシンボルの
値は @code{"jrl"} に束縛され、@code{server} というシンボルの値
は @code{"pophost"} に束縛されます。@code{port}, @code{password},
@code{program}, @code{prescript}, @code{postscript}, @code{function} お
よび @code{authentication} の値もまた (それらのディフォルト値に) 束縛さ
れます。

それぞれの型のメールソースのためのキーワードのリストについては、前述の説
明を参照してください。

@node Mail Source Customization
@subsubsection メールソースのカスタマイズ

以下はメールの取得方法に影響する変数の一覧です。普通はこれらのどれも設定
または変更する必要は無いでしょう。

@table @code
@item mail-source-crash-box
@vindex mail-source-crash-box
メールが、それを処理している期間中に格納されている場所です。ディフォルト
は @file{~/.emacs-mail-crash-box} です。

@cindex Incoming*
@item mail-source-delete-incoming
@vindex mail-source-delete-incoming
@code{nil} でなければ、入って来たメールを一時的に格納したファイルを、そ
れを処理した後で消去します。@code{t} ではファイルをただちに消去し、
@code{nil} ではいかなるファイルも消しません。正の数だった場合は、その日
数以上に古いファイルを消去します (消去は新着メールを受け取るときだけ行な
われます)。@code{mail-source-delete-incoming} を @code{nil} にしておいて、
@code{mail-source-delete-old-incoming} をフックで呼ぶか、または対話的に
呼ぶこともできます。@code{mail-source-delete-incoming} のディフォルト値
は、アルファ版の Gnus では @code{10}、リリースされた版の Gnus で
は @code{2} です。@xref{Gnus Development}.

@item mail-source-delete-old-incoming-confirm
@vindex mail-source-delete-old-incoming-confirm
非-@code{nil} だったら、古い incoming (メールの到着時に使われた) ファイ
ルを消去するときに確認を求めます。この変数
は @code{mail-source-delete-incoming} が正の数である場合だけ使われます。

@item mail-source-ignore-errors
@vindex mail-source-ignore-errors
非-@code{nil} だったら、メールソースからメールを読むときのエラーを無視し
ます。

@item mail-source-directory
@vindex mail-source-directory
入ってきたメールソースのファイルが (もしあれば) 格納されるディレクトリー
です。ディフォルトは @file{~/Mail/} です。現時点でこれが使われる唯一のも
のは、変数 @code{mail-source-delete-incoming} が @code{nil} または数値で
あった場合に、入ってきたメールを格納するファイルの置き場所の指定です。

@item mail-source-incoming-file-prefix
@vindex mail-source-incoming-file-prefix
入ってきたメールを一時的に格納するファイルの名前の接頭語です。ディフォル
トは @file{Incoming} で、この場合ファイル
は @file{Incoming30630D_} や @file{Incoming298602ZD} のようになります。
これが本当に関係するの
は @code{mail-source-delete-incoming} が @code{nil} または数値の場合だけ
ですが。

@item mail-source-default-file-modes
@vindex mail-source-default-file-modes
すべての新しいメールファイルはこのファイルモードになります。ディフォルト
は @code{#o600} です。

@item mail-source-movemail-program
@vindex mail-source-movemail-program
@code{nil} でなかったら、新着メールを取り込むためのプログラムの名前であ
ると解釈されます。@code{nil} だったら @code{exec-directory} にあ
る @code{movemail} が使われます。
@end table

@node Fetching Mail
@subsubsection メールの取得

@vindex mail-sources
新しいメールをどこから取得するかを実際に Gnus に指示する手段は、
@code{mail-sources} をメールソース指示子のリストに設定することで
す (@pxref{Mail Source Specifiers})。

この変数が @code{nil} であれば、メールバックエンドは決して自分自身ではメー
ルを取得しようとしません。

ローカルのスプールと @acronym{POP} メールサーバーの両方からメールを取得
したいなら、このようにすることができます:

@lisp
(setq mail-sources
      '((file)
        (pop :server "pop3.mail.server"
             :password "secret")))
@end lisp

あるいは、これらのキーワードのどんなディフォルトも使いたくなければ、この
ようにしてください:

@lisp
(setq mail-sources
      '((file :path "/var/spool/mail/user-name")
        (pop :server "pop3.mail.server"
             :user "user-name"
             :port "pop3"
             :password "secret")))
@end lisp

あなたがメールバックエンドを使うとき、Gnus はすべてのメールを inbox から
吸い上げてホームディレクトリーに放り込みます。あなたがメールバックエンド
を使っていないときは、Gnus は一通もメールを移動しません---そういう場合に
は、最初にたくさんの魔法を唱えなければなりません。まず五芳星を描き、蝋燭
を灯し、山羊を生け贄として捧げ終えた後には、Gnus があなたのメールを移動
したとしても、あなたは実際にはあまり驚かないはずです。

@node Mail Back End Variables
@subsection メールバックエンド変数

これらの変数 (のほとんど) は、すべてのさまざまなメールバックエンドに関連
します。

@table @code
@vindex nnmail-read-incoming-hook
@item nnmail-read-incoming-hook
すべてのメールバックエンドは、新しいメールを読み込んだ後にこのフックを呼
びます。そうしたければ、何かのメール監視プログラムに知らせるためにこのフッ
クを使うことができます。

@vindex nnmail-split-hook
@item nnmail-split-hook
@findex gnus-article-decode-encoded-words
@cindex RFC 1522 decoding
@cindex RFC 2047 decoding
それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前に、それが
格納されているバッファーで実行されるフックです。このフックは、それがふさ
わしいと考えられるようにするために、どんなやり方ででも自由にバッファーの
内容を編集することができます---バッファーは分割が終わった後で捨てられ、
バッファーで行なわれた変更はどのファイルにも現れません。
@code{gnus-article-decode-rfc1522} は、このフックに加えられることがあり
そうな関数の一つです。

@vindex nnmail-pre-get-new-mail-hook
@vindex nnmail-post-get-new-mail-hook
@item nnmail-pre-get-new-mail-hook
@itemx nnmail-post-get-new-mail-hook
これらは、入ってくるメールを処理するときに実行される、有用な二つのフック
です---@code{nnmail-pre-get-new-mail-hook} は新しいメールを処理する直前
に呼ばれ、@code{nnmail-post-get-new-mail-hook} はメールの扱う処理が終わっ
たときに呼ばれます。以下はこれらの二つのフックを使って、新しいメールのファ
イルのファイルモードを変更する例です:

@lisp
(add-hook 'nnmail-pre-get-new-mail-hook
          (lambda () (set-default-file-modes #o700)))

(add-hook 'nnmail-post-get-new-mail-hook
          (lambda () (set-default-file-modes #o775)))
@end lisp

@item nnmail-use-long-file-names
@vindex nnmail-use-long-file-names
@code{nil} でないなら、メールバックエンドは長いファイル名とディレクトリー
名を使います。@samp{mail.misc} のようなグループは @file{mail.misc} とい
う長い名前のディレクトリーかファイルに収められます (@code{nnml} バックエ
ンドの場合はディレクトリー、@code{nnfolder} バックエンドの場合はファイル
です)。@code{nil} だったら、同じグループは @file{mail/misc} に収められま
す。

@item nnmail-delete-file-function
@vindex nnmail-delete-file-function
@findex delete-file
ファイルを消去するために呼ばれる関数です。ディフォルト
は @code{delete-file} です。

@item nnmail-cache-accepted-message-ids
@vindex nnmail-cache-accepted-message-ids
@code{nil} でないと、バックエンドに (例えば @code{Gcc} によって) 入って
来た記事の @code{Message-ID} を、メールの重複を発見するためのキャッシュ
に入れます。ディフォルトは @code{nil} です。

@item nnmail-cache-ignore-groups
@vindex nnmail-cache-ignore-groups
正規表現か正規表現のリストです。名前がどれかの正規表現に合致するグループ
の記事は、@code{Message-ID} キャッシュに記録されません。

例えば特級分割 (@pxref{Fancy Mail Splitting}) を関
数 @code{nnmail-split-fancy-with-parent} とともに使っている場合に役立つ
でしょう。
@end table

@node Fancy Mail Splitting
@subsection 特級メール分割
@cindex mail splitting
@cindex fancy mail splitting

@quotation
訳注: @dfn{Fancy} という単語は、創造的、空想的、気まぐれな、好きな、派手
な、上等な、極上の、変わり種の、等々のさまざまな意味で使われますが、ここ
では助動詞無しで使える利便を考えて「特級」という訳語を割り当てました。
@end quotation

@vindex nnmail-split-fancy
@findex nnmail-split-fancy
比較的単純な、標準のメール分割指定の方法では思い通りにならないならば、
@code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定すると良
いでしょう。そうすると、変数 @code{nnmail-split-fancy} で遊ぶことができ
るようになります。

まずこの変数の値の例を見てみましょう:

@lisp
;; @r{メイラーデーモンから送られたメッセージが、普通のグループにクロス}
;; @r{ポストされないようにします。警告は本当のエラーとは違ったグループ}
;; @r{に入れます。}
(| ("from" mail (| ("subject" "warn.*" "mail.warning")
                   "mail.misc"))
   ;; @r{エラーでないメッセージはすべての関連するグループにクロスポスト}
   ;; @r{しますが、(ding) メーリングリストと他の (ding) 関連のメールの}
   ;; @r{ためのグループにはクロスポストしません。}
   (& (| (any "ding@@ifi\\.uio\\.no" "ding.list")
         ("subject" "ding" "ding.misc"))
      ;; @r{他のメーリングリスト@dots{}}
      (any "procmail@@informatik\\.rwth-aachen\\.de" "procmail.list")
      (any "SmartList@@informatik\\.rwth-aachen\\.de" "SmartList.list")
      ;; @r{以下のどちらのメーリングリストも同じ接尾語なので、bugs- だ}
      ;; @r{けに投稿されたものが mypkg.list にクロスポストされないよう}
      ;; @r{にしています。しかし本当にクロスポストされた記事をクロスポ}
      ;; @r{ストすることはできるようになっています。}
      (any "bugs-mypackage@@somewhere" "mypkg.bugs")
      (any "mypackage@@somewhere" - "bugs-mypackage" "mypkg.list")
      ;; @r{人々@dots{}}
      (any "larsi@@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
   ;; @r{合致しなかったメールはすべてを捕まえるグループへ行きます。}
   "misc.misc")
@end lisp

この変数は「分割」の様式になっています。分割は (ことによると) それぞれの
分割が他の分割を含む再帰的構造です。以下は使うことができる分割の構文です:

@table @code
@item group
分割が文字列だったら、それはグループ名であるとみなされます。通常の正規表
現の展開が行なわれます。後述の例 (訳注: @samp{\\&},
@samp{\\1}〜@samp{\\9}) を見てください。

@c この行を折り返さないでください。
@item (@var{field} @var{value} [- @var{restrict} [@dots{}] ] @var{split} [@var{invert-partial}])
この分割は少なくとも三つの要素を含んでいる必要があります。最初の要
素 @var{field} (正規表現) に合致するヘッダーが @var{value} (これも正規表
現) に合致する文字列を含んでいたならば、@var{split} で指定されたグループ
にメッセージを格納します。

@var{field} の後にあって、しかも合致した @var{value} の最後尾より前にあ
る何かの文字列に @var{restrict} (これもまた正規表現) が合致したら、
@var{split} は無視されます。いくつかの @var{restrict} のどれもが合致しな
ければ @var{split} が実行されます。

最後の要素 @var{invert-partial} は任意です。これが省略されていなくて、し
かも値が @code{nil} でなければ、語 (word) の境界をまたいで正規表現の合致
を行なうかどうかの振る舞
い (@code{nnmail-split-fancy-match-partial-words} 変数によって制御されま
す; 下記参照) が反転します。(Gnus 5.10.7 の新機能)

@item (| @var{split} @dots{})
分割がリストで、最初の要素が @code{|} (垂直棒) だったら、それぞれ
の @var{split} をそのうちの一つが合致するまで実行します。ここで言う「合
致」とは、ある @var{split} がメッセージを一つ以上のグループに格納しよう
とすることです。

@item (& @var{split} @dots{})
分割がリストで、最初の要素が @code{&} だったら、そのリストにあるすべて
の @var{split} を実行します。

@item junk
もし分割がシンボル @code{junk} だったら、そのメッセージを保存しませ
ん (すなわち、消去してしまいます)。非常に注意して使ってください。

@item (: @var{function} @var{arg1} @var{arg2} @dots{})
もし分割がリストで、最初の要素が @code{:} だったら、二番目の要素
が @var{args} を引数として関数として呼ばれます。関数は @var{split} を返
さなければなりません。

@cindex body split
例えば以下の関数は、記事のボディーに基づいた分割に使えるでしょう:

@lisp
(defun split-on-body ()
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (when (re-search-forward "Some.*string" nil t)
        "string.group"))))
@end lisp

@var{function} が実行されるとき、バッファーは対象となるメッセージのヘッ
ダー部分に狭められています。それが上記の例
で @code{save-excursion} と @code{save-restriction} の後
で @code{(widen)} を呼ぶ必要がある理由です。さらに @code{nnimap} バック
エンドの場合、ディフォルトでは記事のボディーがダウンロードされないことに
注意してください。それをするために
は @code{nnimap-split-download-body} を @code{t} に設定する必要がありま
す (@pxref{Client-Side IMAP Splitting})。

@item (! @var{func} @var{split})
分割がリストで最初の要素が @code{!} だったら、@var{split} が実行され、
@var{func} は @var{split} の結果を引数として呼ばれます。@var{func} は分
割を返さなければなりません。

@item nil
分割が @code{nil} だったら、それは無視されます。
@end table

これらの分割で @var{fileld} は完全なフィールド名 (と言うかヘッダー名) に
合致しなければなりません。

通常これらの分割における @var{value} は、基礎モード (fundamental
mode) 構文テーブル (syntax table) に従って、完全に @emph{語} (word) に合
致しなければなりません。言い換えれば、すべての @var{value} は暗
に @code{\<...\>} 印 (語の区切り記号) で囲まれます。したがって、例えば以
下の分割を使うと、

@example
(any "joe" "joemail")
@end example

@noindent
@samp{joedavis@@foo.org} からやって来たメッセージは、通
常 @samp{joemail} には格納されないでしょう。この振る舞いを変更したければ、
以下の三つのやり方のどれでもを使うことができます:

@enumerate
@item
@vindex nnmail-split-fancy-match-partial-words
@code{nnmail-split-fancy-match-partial-words} 変数を @code{nil} ではない
値に設定することによって、語の境界を無視させることができます。すると、合
致はより grep ふうになります。この変数は、特級分割で語の境界をまたいだ合
致を行なうかどうかを制御します。ディフォルト値は @code{nil} です。

分割の規則のすべての @var{value} に影響することに注意してください。

@item
@code{.*} で始まる @var{value} は、語の前にある語の境界を無視させます。
同様に @code{.*} で終わる @var{value} は、語の後ろにある語の境界を無視さ
せます。例えば @code{"@@example\\.com"} とい
う @var{value} は @samp{foo@@example.com} に合致しませんが、
@code{".*@@example\\.com"} ならば合致します。

@item
この章の最初の方で述べた @var{invert-partial} フラグを、
@samp{(@var{field} @var{value} @dots{})} 型の分割規則で使うことができま
す。このフラグが設定されていると、
@code{nnmail-split-fancy-match-partial-words} が @code{nil} であっても、
語の両側にある語の境界は無視されます。逆に、このフラグが設定されていると、
@code{nnmail-split-fancy-match-partial-words} が @code{nil} ではない値で
あっても、語の境界は無視されません。(Gnus 5.10.7 の新機能)
@end enumerate

@vindex nnmail-split-abbrev-alist
@var{field} と @var{value} は Lisp シンボルであることもできます。その場
合それらは @code{nnmail-split-abbrev-alist} で指定された内容に従って展開
されます。これはセルの @sc{car} がキーを含んでいて、@sc{cdr} が関連付け
られた値を持っているコンスセル (cons cell) の連想リストです。以下の項目
が、あらかじめ @code{nnmail-split-abbrev-alist} に定義されています:

@table @code
@item from
@samp{From}、@samp{Sender} および @samp{Resent-From} の各フィールドに合
致します。
@item to
@samp{To}、@samp{Cc}、@samp{Apparently-To}、@samp{Resent-To} およ
び @samp{Resent-Cc} の各フィールドに合致します。
@item any
@code{from} と @code{to} を統合したものです。
@item list
@samp{List-ID}、@samp{List-Post}、@samp{X-Mailing-List}、@samp{X-BeenThere} お
び @samp{X-Loop} フィールドに合致します。
@end table

@vindex nnmail-split-fancy-syntax-table
@code{nnmail-split-fancy-syntax-table} は、これらのすべての分割が実行さ
れているときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、Gnus に動的にグループを作らせた
い (例えば、グループ名の一部を @code{replace-match} のようなやり方で置き
換えさせたい) ならば、次のようなことができます。

@example
(any "debian-\\b\\(\\w+\\)@@lists.debian.org" "mail.debian.\\1")
@end example

この例では、@samp{debian-foo@@lists.debian.org} に送られたメール
は @samp{mail.debian.foo} というグループに入れられます。

文字列が要素 @samp{\\&} を含んでいる場合は、直前に合致した文字列で置き換
えられます。同様に、要素 @samp{\\1} から @samp{\\9} までは、合致した文字
列の一部で置き換えられます (訳注: 正規表現の中
に @samp{\\(} と @samp{\\)} を使ってグループにまとめられたものが一つ以上
ある場合に、@samp{\\@var{n}} はその正規表現の @var{n} 個目のグループに合
致する文字列の一部で置き換えられます)。

@vindex nnmail-split-lowercase-expanded
その際、合致した文字列を小文字にしたもので置き換えるべきかどうか
を @code{nnmail-split-lowercase-expanded} が決定します。これを
非-@code{nil} にすることによって、アドレスで大文字と小文字が区別せずに使
われている (例えば mailing-list@@domain と Mailing-List@@Domain) 場合で
も、複数のグループが生成されてしまうことを避けることができます。ディフォ
ルトは @code{t} です。

@findex nnmail-split-fancy-with-parent
関数 @code{nnmail-split-fancy-with-parent} は、フォローアップ記事を親記
事と同じグループに振り分けるために使います。メールの振り分けを一生懸命設
定してみても完璧にはできないことがありますね。例えば、上司から個人宛ての
メールが届いたとします。自分が携っているプロジェクトとは別の話です。けれ
ど「他のメールと区別できるようにこれこれこういう言葉を表題に書いてくださ
い」と上司に向かって指図するわけにはいきませんから、結局自分の手を煩わし
てひとつひとつメールを正しいグループに振り分けるはめになります。そんなと
きにこの関数を使うと、この面倒な作業を一スレッドにつき一回きりで済ますこ
とができます。

この機能を利用するためには、まず変
数 @code{nnmail-treat-duplicates} およ
び @code{nnmail-cache-accepted-message-ids} の値を @code{nil} ではない値
に設定する必要があります。それができた
ら @code{nnmail-split-fancy-with-parent} を使ってみてください。コロンを
使ってこんな風に書きます:

@lisp
(setq nnmail-treat-duplicates 'warn     ; @r{または @code{delete}}
      nnmail-cache-accepted-message-ids t
      nnmail-split-fancy
      '(| (: nnmail-split-fancy-with-parent)
          ;; @r{残りの振り分け方はここに書く}
        ))
@end lisp

この機能は実際、次の様に働いています: 変
数 @code{nnmail-treat-duplicates} の値が非-@code{nil} の場合、Gnus は見
つけた全記事のメッセージ ID を変
数 @code{nnmail-message-id-cache-file} で指定されたファイルに記録します。
このとき、それぞれの記事が格納されたグループの名前を併記します (ただしメー
ルではないメッセージの場合は、グループ名は省略されます)。さて、いよいよ
メールの振り分けが始まると、関
数 @code{nnmail-split-fancy-with-parent} は、分割される各記事
の References (と In-Reply-To) ヘッダーを調べ、
@code{nnmail-message-id-cache-file} で指定されたファイルにそれらのメッセー
ジ ID があるかどうか調べます。親記事が見つかると、そのグループ名が正規表
現 @code{nnmail-split-fancy-with-parent-ignore-groups} に合致しなければ、
この関数は対応するグループ名を返すわけです。ここで、変
数 @code{nnmail-message-id-cache-length} の値をディフォルトよりも幾らか
大きな値に設定することを勧めます。そうすると、今調べられたメッセー
ジ ID たちは今しばらくキャッシュの中に存続できます (5000 に設定するとキャッ
シュファイルの大きさはだいたい 300 キロバイトぐらいになるみたいです)。
@vindex nnmail-cache-accepted-message-ids
さらに、変数 @code{nnmail-cache-accepted-message-ids} の値を
非-@code{nil} に設定すれば、Gnus は移動された記事のメッセージ ID をも記
録するので、フォローアップ記事は親記事の移動先と同じグループに入るように
なります。

特定のグループをキャッシュに記録したくない場合は、変
数 @code{nnmail-cache-ignore-groups} も参照してください。例えば、外に出
すすべてのメッセージを“outgoing”グループに保存しているのならば、
@code{nnmail-cache-ignore-groups} をそのグループ名に合致するように設定す
れば良いでしょう。さもないとあなたのすべてのメッセージに対する返事が
“outgoing”グループに入ってしまいます。

@code{nnmail-debug-splitting} を @code{nil} 以外の値にしておくと、実施し
たすべてのメール分割 の判定結果を @samp{*nnmail split*} バッファーに記録
します。

@node Group Mail Splitting
@subsection グループメール分割
@cindex mail splitting
@cindex group mail splitting

@findex gnus-group-split
何ダースものメーリングリストを購読しているけれど、手でメール分割規則を維
持したくないというときのために、グループメール分割というものがあります。
あなたがしなければならないことは、グループパラメーターかグループカスタマ
イズで @code{to-list}, @code{to-address} の両方もしくはどちらかを設定し
て @code{nnmail-split-methods} を @code{gnus-group-split} に設定するだけ
です。分割関数はすべてのグループでこれらのパラメーターを走査し、それに従っ
て分割します。すなわち、メールグループのパラメー
ター @code{to-list} か @code{to-address} で指定されたアドレスから投稿さ
れたものか、そのアドレスへ投稿されたメッセージがそのグループに保存されま
す。

ときには、メーリングリストには複数のアドレスがあり、メール分割にそれらす
べてを認識させる必要があるかもしれません: @code{extra-aliases} グループ
パラメーターを追加のアドレスのリストに設定するだけで終りです。あえて正規
表現を使いたければ、@code{split-regexp} を設定してください。

これらのすべてのグループのパラメーターは、@code{nnmail-split-fancy} の分
割を作成するために使用されます。その分割の仕様の中身
は、@var{field} の値が @samp{any} であり、
@var{value} の値
が @code{to-list} と @code{to-address} と @code{extra-aliases} のすべて
と @code{split-regexp} に合致するもののすべてに合致する単一の正規表現、
そして @var{split} がグループの名前になります。@var{restrict} も使うこと
ができます: それには @code{split-exclude} パラメーターを正規表現のリスト
に設定してください。

これらのすべてのパラメーターを使って正しい分割が生成されないときや、何か
もっと凝ったものが必要なときは、@code{split-spec} パラメーター
を @code{nnmail-split-fancy} の分割に設定することができます。この場合は、
前もって書かれたすべてのパラメーターは @code{gnus-group-split} に無視さ
れます。特に、@code{split-spec} は @code{nil} (訳注: これ
も @code{nnmail-split-fancy} の分割の一種です) に設定することができ、そ
の場合そのグループは @code{gnus-group-split} に無視されます。

@vindex gnus-group-split-default-catch-all-group
それぞれのグループのために、一つの分割を含む単一の @code{&} 特級分割を定
義することによって、@code{gnus-group-split} は合致するすべてのグループに
クロスポストをします。どの分割にも合致しないメッセージは、どれかのグルー
プで @var{split-spec} が @code{catch-all} に設定されていない場合
は @code{gnus-group-split-default-catch-all-group} で指定された名前のグ
ループに格納されます。その場合、そのグループはすべてを受け取
る (catch-all) グループとして使われます。この変数はしばしばグループを指
定するためだけに使われますが、任意の複雑な特級分割に設定することもできる
ので (結局のところグループ名は特級分割なのです)、個人のメールフォルダー
にそれらのメールが格納されるどのメーリングリストにも当てはまらないメール
を、分割するのに便利でしょう。なおこの特級分割は、@code{|} 分割リス
ト (それは、グループパラメーターから抽出された規則を持った @code{&} 分割
をも含んでいます) の最後の要素として追加されることに注意してください。

そろそろ例を出すべきでしょう。以下のグループパラメーターが定義されている
ことを仮定します:

@example
nnml:mail.bar:
((to-address . "bar@@femail.com")
 (split-regexp . ".*@@femail\\.com"))
nnml:mail.foo:
((to-list . "foo@@nowhere.gov")
 (extra-aliases "foo@@localhost" "foo-redist@@home")
 (split-exclude "bugs-foo" "rambling-foo")
 (admin-address . "foo-request@@nowhere.gov"))
nnml:mail.others:
((split-spec . catch-all))
@end example

@code{nnmail-split-methods} を @code{gnus-group-split} に設定すると、
@code{nnmail-split-fancy} が選択されていて、かつ変
数 @code{nnmail-split-fancy} が以下のように設定されているかのように振舞
います:

@lisp
(| (& (any "\\(bar@@femail\\.com\\|.*@@femail\\.com\\)" "mail.bar")
      (any "\\(foo@@nowhere\\.gov\\|foo@@localhost\\|foo-redist@@home\\)"
           - "bugs-foo" - "rambling-foo" "mail.foo"))
   "mail.others")
@end lisp

@findex gnus-group-split-fancy
グループ分割をすべてのメールグループで積極的には使いたくなければ、
@code{nnmail-split-fancy} の分割を次のように使用することで、いくつかのグ
ループだけで使うことができます。

@lisp
(: gnus-group-split-fancy @var{groups} @var{no-crosspost} @var{catch-all})
@end lisp

@var{groups} は、出力の分割を生成するためにパラメーターが走査されるグルー
プ名のリストか、それらのグループ名に合致する正規表現です。
@var{no-crosspost} はクロスポストを禁止するために使うことができ、その場
合は、単一の @code{|} 分割が出力されます。
@var{catch-all} は @code{gnus-group-split-default-catch-all-group} のよ
うに、最後の手段として使われる特級分割です。
@var{catch-all} が @code{nil} に設定されているか、@code{split-regexp} が
どれかの選択されたグループで空の文字列に合致すると、すべてを受け取
る (catch-all) 分割は発行されません。そうでない場合、あるグループ
に @code{catch-all} に設定されている @code{split-spec} があると、そのグ
ループは @var{catch-all} 引数の値よりも優先されます。

@findex gnus-group-split-setup
不運なことに、すべてのグループとそれらのパラメーターを走査することは、特
にすべてのメッセージに対して行なわなければならないことを考慮に入れると、
非常に遅くなるでしょう。でも、絶望してはいけません。
@code{gnus-group-split-setup} 関数を、はるかに効率的な方法
で @code{gnus-group-split} を動作させるために使うことができます。それ
は @code{nnmail-split-methods} を @code{nnmail-split-fancy} に設定し、
@code{nnmail-split-fancy} を @code{gnus-group-split-fancy} で生成される
分割に設定します。そうすることによって、どんなに分割するメッセージがたく
さんあっても、グループパラメーターは一度だけ走査されるようになります。

@findex gnus-group-split-update
しかしながら、グループパラメーターを変更すると、
@code{nnmail-split-fancy} を手で更新しなければならなくなるでしょう。
@code{gnus-group-split-update} を実行することによって、それを行なうこと
ができます。どちらかと言えば、それを自動的に更新したい場合には、
@code{gnus-group-split-setup} にそれを実行するように指示してください。例
えば、@file{~/.gnus.el} に以下のものを追加すれば良いでしょう:

@lisp
(gnus-group-split-setup @var{auto-update} @var{catch-all})
@end lisp

@var{auto-update} が @code{nil} でなけれ
ば @code{gnus-group-split-update} が @code{gnus-get-top-new-news-hook} に
追加されるので、二度と @code{nnmail-split-fancy} の更新について心配する
必要はありません。@var{catch-all} を省略しない場合は (それはオプション
で @code{nil} と等価で
す)、@code{gnus-group-split-default-catch-all-group} がその値に設定され
ます。

@vindex gnus-group-split-updated-hook
@code{gnus-group-split-update} によって設定され
た @code{nnmail-split-fancy} を後で変更する必要があるときのために、この
関数 (@code{gnus-group-split-update}) は終了する直前
に @code{gnus-group-split-update-hook} を実行します。

@node Incorporating Old Mail
@subsection 古いメールを取り込む
@cindex incorporating old mail
@cindex import old mail

たいていの人は色々なファイルフォーマットで保存されたたくさんの古いメール
を持っているでしょう。Gnus の粋なメールバックエンドの一つを使うように設
定したのであれば、おそらく古いメールをメールグループに取り込みたいと思い
ますよね。

それをすることはとても簡単です。

例を挙げましょう: @code{nnml} (@pxref{Mail Spool}) を使ってメールを読ん
でいて、@code{nnmail-split-methods} を申し分の無い値に設定しているものと
しましょう。重要な、しかし古いメールで、古い Unix mbox ファイルが満たさ
れています。あなたはそれを @code{nnml} グループに移動したいと思っていま
す。

方法です:

@enumerate
@item
グループバッファーに行ってください。

@item
@kbd{G f} をタイプしてください。@code{nndoc} グループを作成するための元
になる mbox ファイルの名前を求められるので、それを入力してくださ
い (@pxref{Foreign Groups})。

@item
@kbd{@key{SPC}} をタイプして、新しく作られたグループに入ってください。

@item
@kbd{M P b} をタイプして、グループバッファーのすべての記事に実行印を付け
てください (@pxref{Setting Process Marks})。

@item
@kbd{B r} をタイプしてプロセス印の付いたすべての記事を再スプールしてくだ
さい。その際に入力を求められるので、@samp{nnml} と答えてくださ
い (@pxref{Mail Group Commands})。
@end enumerate

今や mbox ファイルのすべてのメールメッセージは、あなたの @code{nnml} グ
ループ群にもばらまかれています。それらに入って、ものごとが変な故障も無く、
うまくいったかどうかを調べてください。大丈夫なようであれば、mbox ファイ
ルを消そうと思うかもしれませんが、私はすべてのメールがあるべきところに納
まったことを完全に確認するまでは、そうはしません。

再スプールすることは、あるメールバックエンドを別のものに変更するときにも
便利なものです。古いメールグループにあるメールは、新しいメールバックエン
ドを使ってただ再スプールすれば良いのです。

@node Expiring Mail
@subsection メールの期限切れ消去
@cindex article expiry
@cindex expiring mail

伝統的なメールリーダーは、既読の印を付けるとメールの記事を何らかの方法で
削除する傾向があります。Gnus はメールを読むことに対して、基本的に違う方
法を取ります。

基本的に Gnus は、メールを少々変わった方法で受け取られたニュースであると
みなします。実際にメールを変更したり、メールメッセージを消す権限があると
は考えません。あなたがメールグループに入って記事に「既読」の印を付けたり、
何らかの他のやり方で切ったりしても、メールの記事はまだシステムに存在して
います。繰り返します: Gnus はあなたの古い既読のメールを消去しません。も
ちろん、あなたがそうしろと要求しない限りの話ですが。

要らないメールを Gnus に削除させるには、記事に「期限切れ消去可能」
(expirable) の印を付けなければなりません。(ディフォルトのキー割り当てで
は、@kbd{E} をタイプしなければならないということです。) しかしながら、こ
れは記事が即座に消え去るということではありません。一般的にメール記事は、
1) 期限切れ消去可能の印が付いていて、かつ 2) 一週間以上経っている、とい
う場合に、システムによって削除されます。記事を期限切れ消去可能にしなけれ
ば、それは地獄が凍りつくまでシステムに残り続けます。このことは、もう一度
強調付きで繰り返されるに足るものです: 「もし」あなたが記事を「期限切れ消
去可能」に「しない」なら、Gnus は「決して」それらの「記事」を消去しませ
ん。

@vindex gnus-auto-expirable-marks
手作業で記事に期限切れ消去可能の印を付けなければならないわけではありませ
ん。Gnus は“auto-expire”および“total-expire”と呼ばれる二つの機能を提
供して、あなたの手助けをします。かいつまんで言えば“auto-expire”はあな
たが記事を選択したときに Gnus が @kbd{E} を叩いてくれることを意味します。
そして“total-expire”は、すべての既読の記事は期限切れ消去可能である
と Gnus が解釈することを意味します。したがって @samp{E} の印が付けられた
記事に加えて、@samp{r}, @samp{R}, @samp{O}, @samp{K}, @samp{Y} (およびそ
の類) の印が付けられた記事も期限切れ消去可能であると解釈されます。これら
の印の完全なリストは @code{gnus-auto-expirable-marks} にあります。

では auto-expire または total-expire は、いつ使用されるべきなのでしょう
か?  メーリングリストを購読しているほとんどの人々は、それぞれのリストが
それ用のグループに分割されるようにして、それらのグループに対し
て auto-expire または total-expire を有効にしています。(それぞれのリスト
をそれ用のグループへの分割する件についてのさらなる情報は @ref{Splitting
Mail} を参照してください。)

auto-expire と total-expire のどちらが良いのでしょうか?  それに答えるの
は簡単ではありません。概して言えば、たぶん auto-expire が速いでしょう。
auto-expire の別の利点は、より多くの印を後で読み返すつもりの記事に使うこ
とができる、つまり今までどおりに可視 (tick)、保留 (dormant) または既
読 (read) の中から選ぶことができるということです。しかし total-expire で
は、dormant と ticked からしか選べません。total-expire の利点は、適応ス
コア付け (@pxref{Adaptive Scoring}) で良好に働くことです。auto-expire は
通常のスコア付けでは動作しますが、適応スコア付けではだめです。

@vindex gnus-auto-expirable-newsgroups
正規表現 @code{gnus-auto-expirable-newsgroups} に合致するグループでは、
読んだすべての記事に自動的に期限切れ消去可能の印が付けられます。期限切れ
消去可能の印の付いたすべての記事は、概略バッファーの最初の桁
に @samp{E} が表示されます。

自動期限切れ消去を有効にすると、ディフォルトではあなたが読んだすべての記
事に、以前に読まれたかどうかに関わらず、 Gnus は期限切れ消去可能の印を付
けます。既読の印が付いている記事に、自動的に期限切れ消去可能の印が付けら
れるのを避けるには、以下のようなものを @file{~/.gnus.el} ファイルに置い
ておけば良いでしょう:

@vindex gnus-mark-article-hook
@lisp
(remove-hook 'gnus-mark-article-hook
             'gnus-summary-mark-read-and-unread-as-read)
(add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)
@end lisp

グループを自動期限切れ消去可能にしても、すべての既読の記事が期限切れ消去
されるわけではなく、期限切れ消去可能の印が付いている記事だけが期限切れ消
去されることに気を付けてください。また、@kbd{d} 命令が自動的に記事を期限
切れ消去可能にするのでは無いことにも気を付けてください---自動期限切れ消
去可能にしたグループでは、記事に既読の印が半自動で付けられることによって
のみ、記事が期限切れ消去可能になるということです。

2〜3 のメーリングリストを講読していて、読み終わってしばらく経ったら記事
が消えてしまうようにしたいなら、例えばこんな風に設定しましょう:

@lisp
(setq gnus-auto-expirable-newsgroups
      "mail.nosense-list\\|mail.nice-list")
@end lisp

自動期限切れ消去を行なわせるもう一つの方法は、そのグループのグループパラ
メーターに @code{auto-expire} という要素を持たせることです。

もし適応スコア付け (@pxref{Adaptive Scoring}) と自動期限切れ消去を使用し
ていると、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあまり
良く調和しません。

@vindex nnmail-expiry-wait
変数 @code{nnmail-expiry-wait} で、期限切れ消去可能な記事をどれくらいの
期間残しておくかのディフォルトの時間を設定します。この変数の値は日数 (整
数である必要はない) か、もしくは期限切れ消去しないことを意味す
る @code{never} か即時消去を意味する @code{immediate} のうち、どちらか一
つのシンボルの、いずれかを指定できます。Gnus はメッセージが送り出された
ときではなく、それが @emph{到着} してからの日数を計算します。ディフォル
トは 7日間です。

@vindex nnmail-expiry-wait-function
@code {nnmail-expiry-wait-function} 変数を使うと、記事が存在するグループ
に基づいて記事の存続期間を微調整することできます。関数に設定すると、その
戻り値が @code{nil} でなければ @code{nnmail-expiry-wait} の値を上書きし
ます。そうでなければ代わりに @code{nnmail-expiry-wait} の値が使われます。

例えば @samp{mail.private} グループは一ヶ月、@samp{mail.junk} グループは
一日、その他全部は六日間に期限を設定するのならば、以下のやり方で可能です:

@lisp
(setq nnmail-expiry-wait-function
      (lambda (group)
        (cond ((string= group "mail.private")
               31)
              ((string= group "mail.junk")
               1)
              ((string= group "important")
               'never)
              (t
               6))))
@end lisp

この関数に与えられるグループ名には「装飾」すなわち @samp{nnml:} のような
ものは付きません。

変数 @code{nnmail-expiry-wait} また
は @code{nnmail-expiry-wait-function} の代わりに、@code{expiry-wait} グ
ループパラメータを使って有効期間を選択的に変更することもできま
す (@pxref{Group Parameters})。

@vindex nnmail-expiry-target
記事を期限切れ消去するときに取られる通常の動作は、それらを消去することで
す。しかし、場合によってはそれらを消去するよりも別のグループに移動した方
が有意義かもしれません。変数 @code{nnmail-expiry-target} (とグループパラ
メーター @code{expiry-target}) はこれを制御します。この変数の値はすべて
のグループに対するディフォルトになりますが、特定のグループごとにグループ
パラメーターを使って指定すれば、そちらを優先させることができます。ディフォ
ルトの値は @code{delete} ですが、文字列 (記事を移動する先のグループ名)
または移動先のグループ名か @code{delete} を返す関数にすることができま
す (関数の場合は、記事に範囲を狭めたバッファーで、その記事が存在している
グループ名が引数として与えられます)。

グループ名を指定する場合の例:
@lisp
(setq nnmail-expiry-target "nnml:expired")
@end lisp

@findex nnmail-fancy-expiry-target
@vindex nnmail-fancy-expiry-targets
Gnus には期限切れのメールをグループに移動させるための関数があります。そ
れは変数 @code{nnmail-fancy-expiry-targets} に従って動作します。例です:

@lisp
 (setq nnmail-expiry-target 'nnmail-fancy-expiry-target
       nnmail-fancy-expiry-targets
       '((to-from "boss" "nnfolder:Work")
         ("subject" "IMPORTANT" "nnfolder:IMPORTANT.%Y.%b")
         ("from" ".*" "nnfolder:Archive-%Y")))
@end lisp

この設定を行なうことにより、表題ヘッダーに @code{IMPORTANT} を持っていて、
@code{YYYY} 年 @code{MMM} 月に発信されたいかなるメールも、期限になる
と @code{nnfolder:IMPORTANT.YYYY.MMM} グループに移動させられます。また、
From または To ヘッダーが文字列 @code{boss} を含んでいるメール
は @code{nnfolder:Work} に、それ以外のすべてのメール
は @code{nnfolder:Archive-YYYY} に、それぞれ期限になると移動させられます。

@vindex nnmail-keep-last-article
@code{nnmail-keep-last-article} が @code{nil} でないと、Gnus はメールグ
ループの最後の記事を決して期限切れ消去しません。これは procmail の利用者
の人生をより楽にするためのものです。

@vindex gnus-total-expirable-newsgroups
補足: 上記の、Gnus が決して期限切れ消去可能でない記事を期限切れ消去する
ことはない、というのは嘘です。@code{total-expire} をグループパラメーター
に入れても、記事に期限切れ消去の印が付くことはありませんが、読んだすべて
の記事は期限切れ消去の処理に通されます。非常に注意して使ってください。さ
らに危険なのは変数 @code{gnus-total-expirable-newsgroups} です。この正規
表現に合致するすべてのグループでは、読んだすべての記事が期限切れ消去の処
理に通されます。これは、当のグループの @emph{すべて} の古いメールの記事
は、しばらく後で削除されるということです。非常に注意して使ってください。
そして、あなたが使った正規表現が間違ったグループに合致してしまい、すべて
の重要なメールが消えてしまったと言って、私に泣き付いて来ないでください。
しっかしりなさい! (直訳: 男になりなさい、あるいは女になりなさい、さもな
ければもっと気持ちいい何にでもなりなさい!) ほうら、言わんこっちゃない!

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ消
去可能) にしますが。

@vindex gnus-inhibit-user-auto-expire
@code{gnus-inhibit-user-auto-expire} が @code{nil} でなければ、グループ
で自動期限切れ消去が有効になっていても、利用者が印を付ける命令が記事に期
限切れ消去可能の印を付けることはありません。

@vindex gnus-mark-copied-or-moved-articles-as-expirable
記事の期限切れ消去可能の印は、自動期限切れ消去が有効になっていないグルー
プにコピーするか移動するとき削除されます。これは記事が不意に期限切れ消去
されてしまうことを防ぐためです。一方、自動期限切れ消去が有効になっている
グループにコピーまたは移動される記事の期限切れ消去可能の印は、ディフォル
トでは変化しません。つまり、そのようなグループにコピーまたは移動されると
き、期限切れ消去可能だった記事は期限切れ消去可能のままにされ、期限切れ消
去可能ではなかった記事に期限切れ消去可能の印が付くことはありません。した
がって、たとえ自動期限切れ消去のグループであっても、いくつかの記事は期限
切れ消去されないでしょう (それらを再び読まない限りは)。自動期限切れ消去
のグループに期限切れ消去しない記事が紛れ込んでしまうかもしれないその動作
が気に入らないなら、
@code{gnus-mark-copied-or-moved-articles-as-expirable} を @code{nil} で
はない値に設定することができます。その場合、読み終わった記事は自動期限切
れ消去が有効になっているグループにコピーまたは移動するとき、期限切れ消去
可能の印が自動的に付けられます。ディフォルト値は @code{nil} です。

@node Washing Mail
@subsection メール洗濯
@cindex mail washing
@cindex list server brain damage
@cindex incoming mail treatment

メイラーやメーリングリストのサーバーは、メールに対して本当に本当に馬鹿げ
たことをすることで悪名高いです。「わぁ、RFC 822 はサーバーを通っていくメッ
セージのすべての行の最後に @code{wE aRe ElItE!!!!!1!!} を加えることを明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1!」えぇ、そのとおりです
が、RFC 822 とその後継はおろか者が読むようには書かれていません。当たり前
なこと (訳注: 良識から逸脱すること) はそこでは議論されていません。ですか
ら、この章が必要なのです。

適例: ドイツ語版の Microsoft Exchange は返答の表題に @samp{Re: } の代わ
りに @samp{AW: } を付け加えます。私はこれに動揺して狼狽しているふりをす
ることもできましたが、そうする気力がありませんでした。それは笑うべきこと
です。

Gnus は表示する記事を洗濯するために多すぎるほどの関数を提供していますが、
メールをディスクに保存する前にふるいにかけることができた方が良いかもしれ
ません。その目的のために、三つのフックとそれらのフックに入れることができ
る色々な関数を用意しています。

@table @code
@item nnmail-prepare-incoming-hook
@vindex nnmail-prepare-incoming-hook
このフックはメールに何かをする前に呼ばれ、総括的に掃除してきれいにする所
作のためにあります。それは新しいすべての入ってきたメールを含んでいるバッ
ファーで呼ばれます。使うことのできる関数は:

@table @code
@item nnheader-ms-strip-cr
@findex nnheader-ms-strip-cr
それぞれの行から、最後にあるキャリッジリターン (carriage return) を取り
除きます。これは MS のマシン上で動作している Emacs のディフォルトです。
@end table

@item nnmail-prepare-incoming-header-hook
@vindex nnmail-prepare-incoming-header-hook
このフックはそれぞれのメールのヘッダーに範囲を狭められて呼ばれます。ヘッ
ダーをきれいにするときに使うことができます。使うことのできる関数は:

@table @code
@item nnmail-remove-leading-whitespace
@findex nnmail-remove-leading-whitespace
「役に立つ」メーリングリストのサーバーが、見栄えを良くするためだと称して、
ヘッダーの前の方に付け加えた空白を無くします (訳注: 例え
ば @samp{Subject:} などの直後に二つ以上の空白文字があったら、一つを残し
て消します)。まったくもう。

(この関数はすべてのメッセージのボディーの中にあるヘッダー (ボディーの中
にある別のメッセージが持っているヘッダー行のようなもの) に対しても動作す
るので、使用に際しては潜在的な危険を孕んでいます。したがってバグを修正す
るよりは、そういう特徴があることを文書で説明するのが、もちろん正しい解決
の道です。)

@item nnmail-remove-list-identifiers
@findex nnmail-remove-list-identifiers
いくつかのメーリングリストのサーバーは、そのリストが配信したメールである
ことを同定するための識別子---例えば @samp{(idm)}---をすべて
の @code{Subject} ヘッダーの先頭に付け加えます。石器時代のメールリーダー
を使っている人たちには、それは確かに良いことです。この関数は正規表
現 @code{nnmail-list-identifiers} に合致する文字列を取り除きます。それは
正規表現のリストでも構いません。ただし正規表現に @code{\\(..\\)} を含め
てはいけません。

例えば @samp{(idm)} と @samp{nagnagnag} という識別子を取り除きたいのなら:

@lisp
(setq nnmail-list-identifiers
      '("(idm)" "nagnagnag"))
@end lisp

これは @code{gnus-list-identifiers} で非破壊的に行なうこともできます。
@xref{Article Hiding}.

@item nnmail-remove-tabs
@findex nnmail-remove-tabs
すべての @samp{@key{TAB}} 文字を @samp{@key{SPC}} 文字に変換します。

@item nnmail-ignore-broken-references
@findex nnmail-ignore-broken-references
@c @findex nnmail-fix-eudora-headers
@cindex Eudora
@cindex Pegasus
いくつかの MUA (例えば Eudora と Pegasus) は壊れた @code{References} ヘッ
ダーを作成しますが、@code{In-Reply-To} ヘッダーにはちゃんとしたものを入
れます。この関数は、ヘッダー部に正規表
現 @code{nnmail-broken-references-mailers} に合致する行があったら、
@code{References} ヘッダーを取り除きます。
@end table

@item nnmail-prepare-incoming-message-hook
@vindex nnmail-prepare-incoming-message-hook
このフックはそれぞれのメッセージに範囲を狭められて呼ばれます (訳注: 一度
に複数のメールを受信した場合でも、一通ずつ呼ばれるということです)。使う
ことのできる関数は:

@table @code
@item article-de-quoted-unreadable
@findex article-de-quoted-unreadable
Quoted Readable エンコードをデコードします (訳注: 実際に行なうの
は quoted printable のデコードです)。
@end table
@end table

@node Duplicates
@subsection 重複

@vindex nnmail-treat-duplicates
@vindex nnmail-message-id-cache-length
@vindex nnmail-message-id-cache-file
@cindex duplicate mails
いくつかのメーリングリストのメンバーなら、時々同じメールを二つ受け取るこ
とがあるでしょう。これはとても煩わしいので、@code{nnmail} はそれが見つけ
たどんな重複をも、調べて処理します。これをするために、@code{nnmail} は古
い @code{Message-ID} を @code{nnmail-message-id-cache-file} (ディフォル
トでは @file{~/.nnmail-cache}) に保存します。それに保存され
る @code{Message-ID} のおおよその最大数は変
数 @code{nnmail-message-id-cache-length} で制御され、ディフォルト
は 1000 です。(ですから千個の @code{Message-ID} が溜められます。) これで
怖気をふるったなら、@code{nnmail-treat-duplicates} を @code{warn} (ディ
フォルトではそのようになっていますが) に設定しても良いでしょう。そうする
と、@code{nnmail} は重複したメールを消去しない代わりに、それが別のメッセー
ジの重複であるという警告をメールのヘッダーに挿入します。

この変数は関数であることもできます。その場合、関数は当のメッセージに範囲
を狭められたバッファーから @code{Message-ID} を引数として呼ばれます。こ
の関数は @code{nil}, @code{warn}, @code{delete} のどれかを返さなければな
りません。

変数を @code{nil} に設定することによって、この機能を完全に使わないように
することができます。

もしすべての重複したメールを特別な @dfn{duplicates} グループに入れたいの
であれば、普通のメール分割方法を使ってそれをすることができます:

@lisp
(setq nnmail-split-fancy
      '(| ;; @r{重複したメッセージは分かれたグループへ。}
        ("gnus-warning" "duplicat\\(e\\|ion\\) of message" "duplicate")
        ;; @r{デーモンやポストマスターなどからのメッセージは他へ。}
        (any mail "mail.misc")
        ;; @r{他の規則。}
        [ ... ] ))
@end lisp

@noindent
もしくは次のようなもの:

@lisp
(setq nnmail-split-methods
      '(("duplicates" "^Gnus-Warning:.*duplicate")
        ;; @r{他の規則。}
        [...]))
@end lisp

すてきな使い方があるよ: 受け手である彼女がメールを Gnus で読んでいること
と、彼女が @code{nnmail-treat-duplicates} を @code{delete} に設定してあ
ることを知っていれば、彼女がすでに受け取ったことがわかっているメール
の @code{Message-ID} そのものを使って、考えられる限りたくさんの侮辱を送
ることができるんだぜ。その面白さを考えてみてよ! 彼女はそれらを決して見る
ことはないんだ! わぉ!

@node Not Reading Mail
@subsection メールを読むのではない

あなたが使い始めたどんなメールバックエンドでも、あなたがそれらでメールを
読みたいと思っていると仮定するという、悩ましい癖を持っていることに気が付
くでしょう。これは決して不合理ではないかもしれませんが、あなたの望むこと
ではないかもしれません。

@code{mail-sources} と @code{nnmail-spool-file} を @code{nil} に設定すれ
ば、どのバックエンドも入ってくるメールを読もうとしなくなって、それは助け
になるはずです。

@vindex nnbabyl-get-new-mail
@vindex nnmbox-get-new-mail
@vindex nnml-get-new-mail
@vindex nnmh-get-new-mail
@vindex nnfolder-get-new-mail
でも、それは行き過ぎでしょう。あなたが、例えば @code{nnml} でメールを読
むことと、しまいこんである古い (Emacs 23 より前の) Rmail ファイル
を @code{nnbabyl} を使ってざっと覗くことだけで、まったく満足していている
のならば。すべてのバックエンドには  バックエンド-@code{get-new-mail} と
いう変数があります。もし @code{nnbabyl} がメールを読み込みをやめさせたい
のであれば、そのグループの仮想サーバー編集して、
@code{nnbabyl-get-new-mail} を @code{nil} に設定しましょう。

すべてのメールバックエンドは、入ってくるメールを読み込むときに、保存され
るべき記事に範囲を狭めて @code{nn}*@code{-prepare-save-mail-hook} を呼び
ます。

@node Choosing a Mail Back End
@subsection メールバックエンドを選ぶ

メールグループを動作するようにすると Gnus はメールスプールを読み込みます。
メールのファイルはまずあなたのホームディレクトリーに複写されます。その後
で何が起こるかは、メールをどの様式で格納したいかによります。

標準の Gnus では六つの違ったメールバックエンドがあり、さらに多くのバック
エンドを個別に手に入れることができます。ほとんどの人が使うメールバックエ
ンドは (それがたぶん最速なので) @code{nnml} です (@pxref{Mail Spool})。

@menu
* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Babyl::                       Rmail の旧バージョンは Babyl を使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* nnmaildir Group Parameters::
* Article Identification::
* NOV Data::
* Article Marks::
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察
@end menu

@node Unix Mail Box
@subsubsection Unix メールボックス
@cindex nnmbox
@cindex unix mail box

@vindex nnmbox-active-file
@vindex nnmbox-mbox-file
@dfn{nnmbox} バックエンドはメールを格納するために標準の Un*x mbox ファイ
ルを用います。@code{nnmbox} はそれぞれのメール記事にそれがどのグループに
属しているかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

@table @code
@item nnmbox-mbox-file
@vindex nnmbox-mbox-file
利用者のホームディレクトリーのメールボックスの名前。ディフォルト
は @file{~/mbox} です。

@item nnmbox-activate-file
@vindex nnmbox-active-file
メールボックスのアクティブファイルの名前。ディフォルト
は @file{~/.mbox-active} です。

@item nnmbox-get-new-mail
@vindex nnmbox-get-new-mail
@code{nil} でなければ、@code{nnmbox} は入って来たメールを読み込んでグルー
プに分割します。ディフォルトは @code{t} です。
@end table

@node Babyl
@subsubsection Babyl
@cindex nnbabyl

@vindex nnbabyl-active-file
@vindex nnbabyl-mbox-file
@dfn{nnbabyl} バックエンドはメールを格納するために Babyl メールボック
スを使います。@code{nnbabyl} はそれぞれの記事にそれがどのグループに属し
ているかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

@table @code
@item nnbabyl-mbox-file
@vindex nnbabyl-mbox-file
Babyl ファイルの名前。ディフォルトは @file{~/RMAIL} です。

@item nnbabyl-active-file
@vindex nnbabyl-active-file
Babyl ファイルのためのアクティブファイルの名前。ディフォルト
は @file{~/.rmail-active} です。

@item nnbabyl-get-new-mail
@vindex nnbabyl-get-new-mail
@code{nil} でなければ、@code{nnbabyl} は入ってくるメールを読み込みます。
ディフォルトは @code{t} です。
@end table

@node Mail Spool
@subsubsection メールスプール
@cindex nnml
@cindex mail @acronym{NOV} spool

@dfn{nnml} スプールメール様式は他の知られている様式とは互換性がありませ
ん。それは少し注意して使われるべきです。

@vindex nnml-directory
このバックエンドを使うと、Gnus は入ってくるメールを、それぞれのメール
を 1 ファイルとしてファイルに分割し、記事を変数 @code{nnml-directory} で
指定されたディレクトリーの下の対応するディレクトリーに入れます。ディフォ
ルトの値は @file{~/Mail/} です。

前もってディレクトリーを作っておく必要はありません。その面倒は Gnus がす
べて見てくれます。

あなたのアカウントに保存できるファイルの数に厳密な制限があるなら、このバッ
クエンドを使うべきではありません。それぞれのメールはそれ自身のファイルを
伴うので、数週間で数千の iノードを占有する可能性は十分にあります。あなた
にとってこれが問題でなく、親切なシステム管理者が気が狂ったように「誰が僕
の i ノードを食いつぶしているんだ? 誰だ? 誰!?!」と叫びながら歩き回ること
も問題でないなら、これがおそらく使うことのできる一番速い様式であるという
ことは知っておくべきでしょう。新しいメールを読むためだけに大きな mbox ファ
イルを重い足取りで探す必要はありません。

@code{nnml} は記事分割に関してはおそらく一番遅いバックエンドでしょう。多
くのファイルを作らなければならず、入ってくるメールのため
の @acronym{NOV} データベースも作成しなければなりません。これのために、
メールを読むことに関してはたぶん最速のバックエンドになるのです。

仮想サーバーの設定:

@table @code
@item nnml-directory
@vindex nnml-directory
すべての @code{nnml} ディレクトリーはこのディレクトリーの下に置かれます。
ディフォルトは @code{message-directory} の値 (そのディフォルト値
は @file{~/Mail}) です。

@item nnml-active-file
@vindex nnml-active-file
@code{nnml} サーバーのためのアクティブファイル。ディフォルト
は @file{~/Mail/active} です。

@item nnml-newsgroups-file
@vindex nnml-newsgroups-file
@code{nnml} グループ記述ファイル。@xref{Newsgroups File Format}. ディフォ
ルトは @file{~/Mail/newsgroups} です。

@item nnml-get-new-mail
@vindex nnml-get-new-mail
@code{nil} でなければ、@code{nnml} は入って来たメール読み込みます。ディ
フォルトは @code{t} です。

@item nnml-nov-is-evil
@vindex nnml-nov-is-evil
@code{nil} でなければ、このバックエンドはどの @acronym{NOV} ファイルも無
視します。ディフォルトは @code{nil} です。

@item nnml-nov-file-name
@vindex nnml-nov-file-name
@acronym{NOV} ファイルの名前。ディフォルトは @file{.overview} です。

@item nnml-prepare-save-mail-hook
@vindex nnml-prepare-save-mail-hook
保存する前に一つの記事に範囲を狭めて実行するフックです。

@item nnml-use-compressed-files
@vindex nnml-use-compressed-files
非-@code{nil} だったら、@code{nnml} は圧縮されたメッセージファイルを扱う
ことができるようになります。ただし @code{auto-compression-mode} が有効に
なっていなければなりません (@pxref{Compressed Files, ,Compressed Files,
emacs, The Emacs Editor})。@code{nnml-use-compressed-files} の値が文字列
だった場合、それは圧縮プログラムを指定するファイル拡張子として使われます。
Emacs がそれをサポートしていれば、それを @samp{.bz2} に設定することがで
きます。値 @code{t} は @samp{.gz} と等価です。

@item nnml-compressed-files-size-threshold
@vindex nnml-compressed-files-size-threshold
メッセージファイルを圧縮するかどうかを判断するための、サイズの閾値です。
@code{nnml-use-compressed-files} が非-@code{nil} に設定されていて、本文
の文字数がこの変数の値より大きかったら、メッセージファイルは圧縮されます。
@end table

@findex nnml-generate-nov-databases
@code{nnml} グループと @acronym{NOV} ファイルの調子が完全に狂ってしまっ
たら、@kbd{M-x nnml-generate-nov-databases} とタイプすることによって、完
全に更新することができます。この命令は、それぞれすべてのファイルを見るこ
とによって @code{nnml} 階層全体をトロール魚網でさらうので、それが終わる
までには時間がかかるかもしれません。この機能へのより良いインターフェース
はサーバーバッファーで見つかるでしょう (@pxref{Server Commands})。

訳注: 単一の @code{nnml} グループの @acronym{NOV} データベースを再生成さ
せるための @code{nnml-generate-nov-databases-1} という命令もあります。

@node MH Spool
@subsubsection MH スプール
@cindex nnmh
@cindex mh-e mail spool

@code{nnmh} は、@acronym{NOV} データベースを作らないこととアクティブファ
イルや印ファイルを保持しないことを除いて、@code{nnml} と似ています。この
ことは @code{nnmh} を @code{nnml} より @emph{かなり} 遅いバックエンドに
していますが、procmail のスクリプトを書くことはずっとやりやすくなっても
います。

仮想サーバーの設定:

@table @code
@item nnmh-directory
@vindex nnmh-directory
すべての @code{nnmh} ディレクトリーはこのディレクトリーの下に置かれます。
ディフォルトは @code{message-directory} の値 (そのディフォルト
は @file{~/Mail}) です。

@item nnmh-get-new-mail
@vindex nnmh-get-new-mail
@code{nil} でなければ、@code{nnmh} は入ってくるメールを読み込みます。ディ
フォルトは @code{t} です。

@item nnmh-be-safe
@vindex nnmh-be-safe
@code{nil} でなければ、@code{nnmh} はフォルダーにある記事が実際
に Gnus が考えているものと同じであるかを調べるという馬鹿げたことをやりま
す。それは日付と目に入るすべての情報を調べるので、これを @code{t} に設定
すると深刻な速度低下が起こります。@code{nnmh} の記事を読むのに Gnus 以外
のものを使っていないのであれば、この変数を @code{t} に設定する必要はあり
ません。ディフォルトは @code{nil} です。
@end table

@node Maildir
@subsubsection Maildir
@cindex nnmaildir
@cindex maildir

@code{nnmaildir} は各々の Gnus のグループに対応する maildir に、
maildir フォーマットでメールを格納します。このフォーマット
は @uref{http://cr.yp.to/proto/maildir.html} で文書化されています。ま
た @code{nnmaildir} は maildir の中の @file{.nnmaildir/} ディレクトリー
に追加の情報を格納します。

Maildir フォーマットは、配送と講読を、ロックを必要とせずに同時に行なうこ
とができるようにするために設計されました。他のバックエンドでは、メールを
何らかのスプールに渡した後で、そのスプールからグループに分割するために、
Gnus を設定しなければならないでしょう。それは今まで通
り @code{nnmaildir} で行なうことができますが、もっと普通のやり方は、
Gnus のグループとして現われる maildir に配送されたメールを、直接手にする
ことです。

@code{nnmaildir} は完全に信頼できることを目指しています: @kbd{C-g} はメ
モリー中のデータを壊さないし、@code{SIGKILL} がファイルの中のデータを壊
すことはありません。

@code{nnmaildir} は記事の印と @acronym{NOV} データを、それぞれ
の maildir に格納します。それによって、ある Gnus の環境から別の場所
に maildir 全体をコピーすることができ、印は保持されます。

仮想サーバーの設定:

@table @code
@item directory
それぞれの @code{nnmaildir} サーバー (一つを越えるサーバーが必要だとはと
ても思えませんが) に対してディレクトリーを作り、それを maildir また
は maildir へのシンボリックリンクとして実装する必要がありま
す (maildir のためだけにです。他の目的のためにすでに使われているディレク
トリーを選んではいけません)。それぞれの maildir は、そのサーバーのニュー
スグループとして Gnus に現れ、シンボリックリンクのファイル名がそのグルー
プの名前になります。ディレクトリーにある @samp{.} で始まるどんなファイル
名も無視されます。ディレクトリーは最初に Gnus を起動したときとグループバッ
ファーで @kbd{g} をタイプしたときはいつでも走査され、どれかの maildir が
削除または追加されていると、@code{nnmaildir} はそのときにそれを知ります。

@code{directory} パラメーターの値は Lisp 式でなければなりません。それは
このサーバーのためのディレクトリーのパスを得るため
に @code{eval} と @code{expand-file-name} で処理されます。その式はサーバー
が開かれたときだけ @code{eval} され、その結果得られた文字列が、サーバー
が閉じられるまで使われます (もし、式や @code{eval} を知らなくでも心配ご
無用; 単なる文字列で動作します)。このパラメーターは任意ではなく、必ず設
定しなければなりません。@code{"~/Mail"} やそれのサブディレクトリーを使う
ことは推奨しません。なぜかと言うと、Gnus の他の複数の部分がそれをディフォ
ルトでいろんなものに使うので、@code{nnmaildir} でもそれを使うと混乱する
かもしれないからです。@code{"~/.nnmaildir"} が一般的な値です。

@item target-prefix
これは Lisp 式でなければなりません。それ
は @code{eval} と @code{expand-file-name} で処理されます。その式
が @code{eval} されるのはサーバーが開かれたときだけで、その結果得られた
文字列がサーバーが閉じられるまで使われます。

@code{nnmaildir} サーバーにグループを作ると、その名前の頭
に @code{target-prefix} が付加された maildir と、その maildir を指し示す
シンボリックリンクが素のグループ名の名前で作成されます。したがって、
@code{directory} が @code{"~/.nnmaildir"} で、
@code{target-prefix} が @code{"../maildirs/"} だった場合に @code{foo} と
いうグループを作ると、@code{nnmaildir} は maildir とし
て @file{~/.nnmaildir/../maildirs/foo} を、@file{../maildirs/foo} へのシ
ンボリックリンクとして @file{~/.nnmaildir/foo} を作成します。

同じ @code{directory} に maildirs とシンボリックリンクの両方を作成するた
めに、スラッシュを含まない文字列を @code{target-prefix} に設定することが
できます。この場合は、@code{directory} で見つかる名前
が @code{target-prefix} で始まるどの maildir も、グループとは見なされま
せん (が、それらを指し示すシンボリックリンクがグループになります)。

特別な場合として @code{target-prefix} が @code{""} (それがディフォルトで
す) だったら、グループを作るときに、対応するシンボリックリンクを持たな
い maildir が @code{directory} において作成されます。そのようなグループ
に対しては、@code{force} 引数を与えない
と @code{gnus-group-delete-group} が使えないことに気をつけてください。

@item directory-files
これは @code{directory-files} と同じインターフェースを持っている関
数 (または @code{directory-files} そのもの) でなければなりません。これ
は maildir 用のサーバーの @code{directory} を走査するために使われます。
このパラメーターは任意です。ディフォルトは、
@code{nnheader-directory-files-is-safe} が @code{nil} だった
ら @code{nnheader-directory-files-safe} で、それ以外の場合
は @code{directory-files} で
す (@code{nnheader-directory-files-is-safe} はサーバーが開いたときに一回
だけ検査されますが、ディレクトリーが走査されるときに毎回チェックさせたい
のならば、それを行なう関数をあなたが自前で用意する必要があります)。

@item get-new-mail
非-@code{nil} にしておくと、いつもの通りにグループの maildir 自体におい
て新着メールを走査した後で、このサーバーはさらに @code{mail-sources} か
ら、@code{nnmail-split-methods} か @code{nnmail-split-fancy} の設定に従っ
て、従来の Gnus の方法でメールを取り込みます。ディフォルト値
は @code{nil} です。

@code{mail-sources} と @code{nnmaildir} グループの両方で同じ maildir を
使っては @emph{いけません}。その結果は運良く有益になるかもしれませんが、
そんな意図では設計されていませんし、将来は違う結果をもたらす可能性があり
ます。あなたの分割規則が新しいグループを作るようになっている場合は、
@code{create-directory} サーバーパラメーターを設定することを忘れないでく
ださい。
@end table

@node nnmaildir Group Parameters
@subsubsection グループパラメーター

@code{nnmaildir} は複数のグループパラメーターを使います。これらのすべて
を無視しても安全です。ディフォルトの @code{nnmaildir} の動作は、他のメー
ルバックエンドのディフォルト (記事が一週間後に消去される、など) と同じで
す。期限切れ消去のパラメーターを除いて、この機能はすべ
て @code{nnmaildir} だけにあるものです。したがって、別のバックエンドです
でに行なっている動作を単に踏襲させようというのであれば、これを無視するこ
とができます。

これらのパラメーターのうちのどれでも、その値がベクトルである場合は、オリ
ジナルの値に代わって、第一の要素が Lisp 式として評価された結果が使われま
す。値がベクトルでない場合は、その値そのものが Lisp 式として評価されます。
(それが、これらのパラメーターが他とは違う名前、すなわち他のバックエンド
でサポートされているものとは違うけれども似た意味を持っている同様のパラメー
ターを使っている理由です。)  (数値、文字列、@code{nil}、およ
び @code{t} についても @code{eval} の関与を無視することができます。他の
値について、そうすることがふさわしい場合には、追加のクオートを使い、かつ
ベクトルで値を包むことを忘れないでください。)

@table @code
@item expire-age
記事が消去されるまでの寿命の秒数を指定する整数、あるいは記事が期限切れ消
去されてはならないことを指定する @code{never} というシンボルです。このパ
ラメーターが設定されていないと、いつもの @code{nnmail-expiry-wait} 変数
または @code{nnmail-expiry-wait-function} 変数を最後のよりどころにしま
す (@code{expiry-wait} グループパラメーターが設定されていると、その値
が @code{nnmail-expiry-wait} より優先して使われ、
@code{nnmail-expiry-wait-function} は無効にされます)。3日の値が必要なら
ば、@code{[(* 3 24 60 60)]} のようなものを使ってください。
@code{nnmaildir} は式を評価して、その結果を使います。記事の寿命は記事ファ
イルの変更時刻を基点に計測されます。通常これは記事が配送された時刻と同じ
ですが、記事の編集はそれを若くします。(期限切れ消去以外の) 記事の移動も
また、記事を若くしてしまうでしょう。

@item expire-group
これが以下のような完全な Gnus のグループ名の文字列で、

@example
"backend+server.address.string:group.name"
@end example

@noindent
かつこのパラメーターが設定されているグループの名前と同じではなかったら、
期限切れ消去が行なわれる際に、記事は消去される代わりに、これで指定された
グループに移動させられます。@emph{これが @code{nnmaildir} グループに設定
されていると、移動先のグループにおいて、記事は元のグループにあったときと
ちょうど同じ古さになります。} したがって、移動先のグループにおけ
る @code{expire-age} には注意してください。これがパラメーターが設定され
ているのと同じグループの名前に設定されると、記事はまったく期限切れ消去さ
れません。ベクトルの式を使うと、最初の要素が一回、それぞれの記事について
評価されます。したがって記事をどこに置くかを決めるために、その式
は @code{nnmaildir-article-file-name} などに照会することができます。
@emph{たとえこのパラメーターが設定されていなくても、
@code{nnmaildir} は @code{expiry-target} グループパラメーター
や @code{nnmail-expiry-target} 変数を顧みません。}

@item read-only
これが @code{t} に設定されていると、@code{nnmaildir} はその記事をこ
の maildir では読み出し専用として扱います。この意味は、記事
は @file{new/} から @file{cur/} に改名されない、記事は @file{cur/} では
なく @file{new/} でのみ見つかる、記事は消去されない、記事は編集できない、
ということです。@file{new/} は他の maildir の @file{new/} ディレクトリー
へのシンボリックリンクであると想定されます (そのディレクトリーには、例え
ばみんなが興味があるメーリングリストを含んでいる、システムで共通のメール
ボックスがあります)。@file{new/} 以外の maildir にあるすべてのものは、読
み出し専用として扱われ @emph{ません}。したがって、みんなで共有するメール
ボックスに対しては、あなた自身の maildir を設置する (または 共有のメール
ボックスに書き込み権限を持つ) 必要が依然としてあります。そうすれば、あな
たの maildir は記事の余分なコピーをまったく含まなくて済むでしょう。

@item directory-files
@code{directory-files} と同じインターフェースの関数です。記事を見つける
ために、このグループに対応する maildir のディレクトリーを走査するために
使われます。ディフォルトはそのサーバーの @code{directory-files} パラメー
ターで設定されている関数です。

@item distrust-Lines:
非-@code{nil} にしておくと、@code{nnmaildir} は @code{Lines:} ヘッダー
フィールドを使う代わりにいつも記事の行数を数えます。@code{nil} だった場
合は、あればそのヘッダーフィールドが使われます。

@item always-marks
@code{['(read expire)]} のような印シンボルのリストです。Gnus が記事の印
を @code{nnmaildir} に尋ねるときはいつでも、ファイルシステムに格納されて
いる印が何であるかとは無関係に、@code{nnmaildir} はすべての記事がこれら
の印を持っていると答えます。これは機能を検証するためのもので、おそらく結
局は削除されるでしょう。それは Gnus 本体で行なわれるか、あるいは有益でな
ければ放棄されるべきです。

@item never-marks
@code{['(tick expire)]} のような印シンボルのリストです。Gnus が記事の印
を @code{nnmaildir} に尋ねるときはいつでも、ファイルシステムに格納されて
いる印が何であるかとは無関係に、@code{nnmaildir} はこれらの印を持ってい
る記事は無いと答えます。@code{never-marks} は @code{always-marks} よりも
優先されます。これは機能を検証するためのもので、おそらく結局は削除される
でしょう。それは Gnus 本体で行なわれるか、あるいは有益でなければ放棄され
るべきです。

@item nov-cache-size
@acronym{NOV} メモリーキャッシュのサイズを指定する整数です。スピードアッ
プのために、@code{nnmaildir} はそれぞれのグループの限定された数の記事に
対して、メモリー上に @acronym{NOV} データを保持します。(これはたぶん有用
ではなく、将来はおそらく削除されるでしょう)。このパラメーターの値は、サー
バーが開かれた後で最初にグループが見られたとき、すなわち一般には最初
に Gnus を起動したときだけ注目されます。サーバーが閉じられて再び開かれる
までは、@acronym{NOV} キャッシュのサイズは変更されません。ディフォルトは
概略バッファーに表示される記事の数の見積り (@code{tick} 印がある記事の数
か @code{read} が無い記事の数に、少々の余分を加えたもの) です。
@end table

@node Article Identification
@subsubsection 記事の識別
記事はそれぞれの maildir の @file{cur/} ディレクトリーに格納されます。各々
の記事には @code{uniq:info} のような名前が付けられます。ここ
で @code{uniq} はコロンを含みません。@code{nnmaildir} は @code{:info} の
部分を保持しますが無視します。(他の maildir リーダーは一般に印を格納する
ためにこの部分を使います。) @code{uniq} の部分は記事をユニークに識別し、
maildir の @file{.nnmaildir/} サブディレクトリーの色々な場所に、対応する
記事の情報を格納するために使われます。記事の完全なパス名は、概略バッファー
で記事を要求した後で @code{nnmaildir-article-file-name} 変数から得られま
す。

@node NOV Data
@subsubsection NOV データ
@code{uniq} によって識別される記事は、その @acronym{NOV} データ (概略バッ
ファーの行を生成するために使われる) を @file{.nnmaildir/nov/uniq} に格納
します。@code{nnmaildir-generate-nov-databases} 関数はありません。(その
必要はあまりありません。記事の @acronym{NOV} データは記事
か @code{nnmail-extra-headers} が変化したときに自動的に更新されま
す。) 対応する @acronym{NOV} ファイルを消すことによって、単一の記事だけ
の @acronym{NOV} データの生成を @code{nnmaildir} に強制することはできま
す。しかし @emph{ご用心}。これは @code{nnmaildir} にこの記事に新しい記事
番号を割り振らせるので、@code{seen} 印、エージェント、およびキャッシュに
とって面倒なことになります。

@node Article Marks
@subsubsection 記事の印
@file{.nnmaildir/marks/flag/uniq} ファイルがある場合に、@code{uniq} によっ
て識別される記事は、@code{flag} 印を持つものと考えられます。
Gnus が @code{nnmaildir} にグループの印を尋ねると、@code{nnmaildir} はそ
のようなファイルを探して、見つけた印のセットを報告します。
Gnus が @code{nnmaildir} に印のセットを格納することを要求すると、
@code{nnmaildir} は必要に応じて対応するファイルを生成し、または消去しま
す。(実際は、それぞれの印のために新しいファイルを作るのではなく、iノード
を節約するために単に @file{.nnmaildir/markfile} へのハードリンクを張りま
す。)

@file{.nnmaildir/marks/} に新しいディレクトリーを作ることによって、新し
い印を創造することができます。印を保持しつつ maildir を tar でまとめてサー
バーからそれを削除し、後で tar をほどくと、印は保持されています。印ファ
イルを作成または消去することによって、あなた自身が印を追加または削除する
ことができます。Gnus が動作していて @code{nnmaildir} サーバーが開いてい
るときにこれを行なう場合は、最初にすべての @code{nnmaildir} グループの概
略バッファーから退出してグループバッファーで @kbd{s} をタイプし、その後
グループバッファーで @kbd{g} か @kbd{M-g} をタイプするのが最良です。そう
しないと Gnus は変更を捉えてくれずに、それらを元に戻してしまうかもしれま
せん。

@node Mail Folders
@subsubsection メールフォルダー
@cindex nnfolder
@cindex mbox folders
@cindex mail folders

@code{nnfolder} はそれぞれのメールグループを別々のファイルに格納するバッ
クエンドです。それぞれのファイルは標準の Un*x mbox 様式です。
@code{nnfolder} は記事番号と到着時刻を見失わないようにするための追加のヘッ
ダーを加えます。

仮想サーバーの設定:

@table @code
@item nnfolder-directory
@vindex nnfolder-directory
すべての @code{nnfolder} メールボックスはこのディレクトリーの下に置かれ
ます。ディフォルトは @code{message-directory} の値 (そのディフォルト
は @file{~/Mail}) です。

@item nnfolder-active-file
@vindex nnfolder-active-file
アクティブファイルの名前。ディフォルトは @file{~/Mail/active} です。

@item nnfolder-newgroups-file
@vindex nnfolder-newsgroups-file
グループ記述ファイルの名前。@xref{Newsgroups File Format}. ディフォルト
は @file{~/Mail/newsgroups"} です。

@item nnfolder-get-new-mail
@vindex nnfolder-get-new-mail
@code{nil} でなければ、@code{nnfolder} は入ってくるメールを読み込みます。
ディフォルトは @code{t} です。

@item nnfolder-save-buffer-hook
@vindex nnfolder-save-buffer-hook
@cindex backup files
フォルダーを保存する前に実行されるフックです。@code{nnfolder} バッファー
に対してさえも、Emacs は通常とおりファイル名を変更してバックアップを行な
うことに注意してください。この機能を無効にしたいのであれば、
@file{~/.gnus.el} ファイルで次のようなことをすれば良いでしょう:

@lisp
(defun turn-off-backup ()
  (set (make-local-variable 'backup-inhibited) t))

(add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)
@end lisp

@item nnfolder-delete-mail-hook
@vindex nnfolder-delete-mail-hook
これから消去されるメッセージに範囲を狭められて実行されるフックです。この
関数は別の場所にメッセージをコピーしたり、消去する前に何らかの情報を取り
出すために使うことができます。

@item nnfolder-nov-is-evil
@vindex nnfolder-nov-is-evil
もし非-@code{nil} なら、このバックエンドはどんな @acronym{NOV} ファイル
をも無視します。ディフォルトは @code{nil} です。

@item nnfolder-nov-file-suffix
@vindex nnfolder-nov-file-suffix
@acronym{NOV} ファイルの拡張子です。ディフォルトは @file{.nov} です。

@item nnfolder-nov-directory
@vindex nnfolder-nov-directory
@acronym{NOV} ファイルが格納されるディレクトリーです。@code{nil} だった
ら @code{nnfolder-directory} が使われます。
@end table

@findex nnfolder-generate-active-file
@code{nnfolder} で読みたいたくさんの @code{nnfolder} に似たファイルを持っ
ているのなら、そのようなすべてのファイルが @code{nnfolder-directory} に
あることを @code{nnfolder} に気付かせるために、@kbd{M-x
nnfolder-generate-active-file} 命令を使ってください。もっとも、これは長
いファイル名を使っているときだけ動作しますが。

@node Comparing Mail Back Ends
@subsubsection メールバックエンドの比較

まず用語としての「バックエンド」(back end) は、それによってなにものかが
取得される、低次のアクセス手段、あるいはそう言いたければ輸送手段です。そ
れが意図するのはどこからかメールを取ってくることなので、Gnus がすぐに手
が届く距離の範囲内でメールを受け取るための、適当なバックエンドを選択する
必要があります。

同じ概念が Usenet 自身にも存在します。近ごろでは記事へのアクセスは一般的
に @acronym{NNTP} で行なわれますが、凄涼たる暗黒の昔には、世界中の誰もが、
記事を置いてあるマシン (今日では @acronym{NNTP} サーバーと呼ぶもの) でリー
ダーを動作させることによって Usenet に接続したものでした。また、アクセス
は記事のディレクトリーのスプールの領域に直接に踏み込むリーダーによって行
なわれました。たまたまそういうサーバーにいるのなら (あるいは NFS を介し
て、とにかくそれのスプールのディレクトリーを見ることができるのなら)、今
でも @code{nntp} か @code{nnspool} バックエンドのどちらかを選ぶことがで
きます。

@quotation
(訳注:「凄涼たる暗黒の昔には」はポーの詩「大鴉」の冒頭部分“Once upon a
midnight dreary”。)
@end quotation

メールバックエンドを選択することの行き着く先は、元の形式を処理し、かつ将
来便利に使える形式でメールを残すことを、同時に実現するのに適した方法を選
び出すことです。それぞれいくつかの良い点と悪い点があります:

@table @code
@item nnmbox
歴史的に UNIX システムは、とても一般的で行き届いた定義のたった一つの形式
を持っています。すべてのメッセージは単一の「スプールファイル」に到着し、
それらは正規表現 @samp{^From_} に合致する行で区切られています。
(@samp{_} という記号はスペースを意味し、この例ではこれが RFC で規定され
ている @samp{From:} ヘッダーではないことをはっきりさせるために使っていま
す。)  Emacs それに Gnus も歴史的に Unix 環境から始まっているので、元
の mailbox 形式をあまりいじくり回さずに済めば、それが最も単純です。した
がってこのバックエンドを選んだ場合に、本当のスプールからメールを取得し
て Gnus にとって都合が好いディレクトリーにメールを移動するために Gnus が
主に行なうのは、処理の過程で何も (目立つような) 変更をせずに、単にそれを
複製することです。それは Gnus が処理を行なうことができる環境にメールを移
動するための「最も気が利かない」方法です。これは移動させることを速くしま
すが、Gnus がどこに何があるかを調べるときは、解析が遅くなります。

@item nnbabyl
むかしむかしあるところに DEC-10 と DEC-20 がありました。それらは TOPS と
いうオペレーティングシステムや似たようなものを実行していて、メールを読む
ための普通の (もしかしたら唯一の?) 環境は Babyl というものでした。そのシ
ステムに届いたメールでどんな形式が使われていたかはわかりませんが、
Babyl にはメールを変換するための、それ用の内部形式がありました。その変換
とは、Babyl 特有のヘッダーと状態ビットを、ファイルにあるそれぞれのメッセー
ジの先頭に挿入するための仕組みによって、スプールファイル風の実体を作るこ
とでした。Rmail は Emacs の最初のメールリーダーで、Richard Stallman によっ
て書かれました。Stallman はその TOPS/Babyl の環境の出身だったので、すで
に存在していたメールファイルの一族を理解するように Rmail を書きました。
Gnus は (この件に関しては VM も) この形式をサポートし続けています。それ
は、そのメーラー特有のヘッダー/ステータス・ビットというものが、かなり良
質だと認められているからです。Rmail 自身ももちろんまだ存在していて、今で
も Emacs の中で維持されています。Emacs 23 から、Babyl に代わって標準
の mbox 様式が使われるようになりました。

上記の両方の形式は、メールをファイルシステムにおける単一のファイルに置い
たままにするので、メールを見るたびにファイル全体を解析しなければなりませ
ん。

@item nnml
@code{nnml} は、あたかも @code{nnspool} でアクセスされる Usenet システム
で実際に操作しているかのような感じのするバックエンドです。(実際のところ、
@code{nnml} はすごく以前に @code{nnspool} から枝分かれしたものだと思いま
す。)  メールは元のスプールファイルから取り出された後で、個々のファイル
に 1:1 で切り分けられます。Usenet 様式のアクティブファイ
ル (INN や CNews に基づいたニュースシステム
の @file{/var/lib/news/active} ファイル (例えば) や、@samp{NNTP LIST} 命
令で返されるものに類似したもの) を維持し、今ではかなりの年数にわたっ
て @acronym{NNTP} サーバーのために定義されている @dfn{overview} ファイル
も、グループへ入るときの効率を良くするために作成します。たくさんのファイ
ルを作成し、@code{nnml} アクティブファイルを更新し、さらにメッセージ毎
に overview への追加を行なうので、メール分割では遅くなりますが、アクセス
するときには、アクティブファイルと overview によって提供される索引機能に
支援されて、とてつもなく速くなります。

@code{nnml} は @dfn{inode} を非常にたくさん消費します。すなわち、新しい
ファイルを置くことができる場所をファイルシステム上に定めるための資源を、
たくさん占有します。ぎっしりつまった共有ファイルシステムで大量
の inode を占有することを、システム管理者は快く思いません。もっとも、そ
のファイルシステムが自分自身のもので、容量が希少ではない個人のマシンにい
るのならば、@code{nnml} には非常に大きな利点があるのですが。

FAT16 の Windows の世界にいる場合にも、たくさんの小さなファイルで多くの
場所を取られてしまう点で問題があります。

@item nnmh
Rand MH メール閲覧システムは UNIX システムにかなり長い間存在しています。
それはメッセージのスプールファイルを個々のファイルに分割することによって
動作しますが、索引機能は少ししか、あるいはまったくありませ
ん---@code{nnmh} は、意味的には「アクティブファイルまたは overview の無
い @code{nnml}」と等価です。これはおそらく最悪の選択でしょう。なぜならば、
個々のファイルを作ることの遅さが、何がグループで新しいかを知るときに解析
するために行なうアクセスの遅さに結び付くからです。

@item nnfolder
基本的に @code{nnfolder} が実現することは、グループ毎
の @code{nnmbox} (上で説明されている最初の方法) です。すなわ
ち @code{nnmbox} 自体は @emph{すべて} のメールを一つのファイルに入れます。
でも @code{nnfolder} はメールグループのそれぞれが Unix mail box ファイル
を持つように、ほんの少し最適化をします。それぞれのグループは別々に解析さ
れるので @code{nnmobx} よりも速く、しかもなお、メールを移動させるのに最
小限の労力しか要求しない、単純な Unix mail box 形式を提供します。加えて
「アクティブ」ファイルを維持し、Gnus がそれぞれの別のグループにどのくら
いのメッセージがあるかを調べることをとても速くします。

もしたくさんの量のメッセージを受け取ることが予想されるグループがあるなら、
@code{nnfolder} は最善の選択ではありませんが、ほどほどの量のメールしか受
け取らないなら、おそらく @code{nnfolder} はすべての中で最も都合の良いバッ
クエンドでしょう。

@item nnmaildir
期限切れ消去その他もろもろを設定するのに、@code{nnmaildir} は他のメール
バックエンドとは少々異なった、互換性の無いグループパラメーターを使います。

@code{nnmaildir} は大方 @code{nnml} と似たものですが、いくらか顕著な違い
があります。それぞれのメッセージは別々のファイルに格納されますが、ファイ
ル名は Gnus の記事番号と関係がありません。ま
た @code{nnmaildir} は @code{nnml} の overview に相当するファイルを記事
ごとに一つ格納するので、@code{nnml} の約二倍の量の iノードを使います。
(@code{df -i} を使って iノードの割り当てがどれほどたくさんあるかを調べて
ください。) そのために遅くなったり多くの場所を取ってしまうようならば、他
の非ブロック構造のファイルシステムへの転換を検討してください。

maildir は受信配送のためのロックを必要としないので、あなたがグループとし
て使っている maildir は、配送されてきたメールを直接受け取るため
の maildir にすることもできます。これは、メールが配送されてくる過程で異
なるメールボックスに仕分されるようになっているのならば、Gnus のメール分
割を省略できることを意味します。@code{mail-sources} におけ
る @code{directory} の項には (訳注: maildir を使わなくても) 似た効果があ
りますが、配送されてくるメールをスプールするためのメールボックスの一揃
い (mbox 形式ではそのためにメッセージの本文が壊れる) と、他の (何であれ
あなたの好みの形式の) グループとして使われる組が必要です。一
方 maildir は、@code{new/} サブディレクトリーに置かれる組み込みスプール
を持ちます。メール分割による代わりに @code{new/} から @code{cur/} に移動
されたメールは、ダブっているかどうかをチェックするような処理を今のところ
は受けないことに注意してください。

@code{nnmaildir} はグループの記事の印を、それに対応する maildir に格納し
ます。Gnus の外からそれらを簡単に操作できるようにするために、そのように
作られているのです。maildir を tar でまとめてから別のどこかで展開しても、
印はそのままです。

@code{nnmaildir} は速度を上げるためにかなりの量のメモリを使います。
(@code{nnml} の場合はファイルに格納し、@code{nnmh} では何度もメッセージ
ファイルを解析して得るものごとを、それはメモリ上に保持します。) これがあ
なたにとって問題ならば、@code{nov-cache-size} グループパラメーターを何か
小さな値 (0 はおそらくだめですが 1 だったらたぶん働きます) に設定するこ
とによって、少ないメモリで済むようにすることができます。このキャッシュ機
構は、おそらく将来は削除されるでしょう。

起動は他のバックエンドよりも @code{nnmaildir} の方が遅いでしょう。ファイ
ルシステムに依存していないすべての部分では速いでしょう。

@code{nnmaildir} は @code{nnoo} を使わないので、@code{nnmaildir} から派
生したバックエンドを書くのに @code{nnoo} は使えません。
@end table

@node Browsing the Web
@section ウェブの閲覧
@cindex web
@cindex browsing the web
@cindex www
@cindex http

ウェブに基づいた議論の場はどんどん広まっています。多くの分野で、ウェブの
掲示板は最も重要な場になり、メーリングリストやニュースグループの重要性を
翳らせています。理由は簡単です---新しい利用者が使い易いからです。ただ場
所をクリックするだけで、議論の場があります。メーリングリストでは、面倒な
購読手続きをしなければならず、ほとんどの人はニュースグループというものが
が何であるかすら知りません。

この筋書きから浮かび上がる問題は、ウェブブラウザーはニュースリーダーとし
てはあまり良くないということです。どんな記事を読んだかを記録しません。興
味のある表題にスコアを付けることができません。オフラインで読むことができ
ません。何度もクリックすることを要求し、最後にはあなたを怒らせます。

ならば---ウェブブラウザーが掲示板を読むのに適していないのなら、代わり
に Gnus を使いませんか?

Gnus はこれらのソースへのインターフェースを提供するバックエンド群を少し
備えつつあります。

@menu
* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* RSS::                         RDF Site Summary を読む
@end menu

これらのウェブソースの一番の問題は、長期間は動作しない可能性が高いことで
す。@acronym{HTML} のデータから情報を拾い集めるのはせいぜい推測で、その
構造が変化したときには、Gnus バックエンドは動作しません。でも、ある程度
新しいバージョンのバックエンドを使っていれば大丈夫のはずです。

これらのウェブの手段に共通することは、ウェブソースはしばしば落ちていたり、
使用可能でなかったり、はっきり言って楽しむには遅すぎる、ということです。
そういう場合に、Gnus Agent (@pxref{Gnus Unplugged}) に記事のダウンロード
を任せて、ローカルディスクから好きなときに読むようにすることは、大いに意
義があります。これで World Wide Wait とはおさらばです。

@node Archiving Mail
@subsection メールの保存
@cindex archiving mail
@cindex backup of mail

いくつかのバックエンド、特に @code{nnml}, @code{nnfolder} およ
び @code{nnmaildir} は、今ではそれぞれのグループの記事の印を本当に保持す
るようになりました (訳注: そうなったのはだいぶ前ですが)。これらのサーバー
で、グループの印を保ちつつ保存したり元に戻すのはかなり簡単です。

(でも、グループレベルとグループパラメーターをも保持するには、今までとお
り @file{.newsrc.eld} の神に、舞いと生贄を捧げなければなりませんが。)

@code{nnml}, @code{nnfolder} または @code{nnmaildir} サーバーにまるごと
保存するには、サーバーのディレクトリーを再帰的にコピーしてください。
Gnus を終了する必要は無いので、保存は @code{cron} やそれに類するものが行
なうことができます。データを復帰させるにはディレクトリー木 (tree) を元に
戻すことによって行ない、そのディレクトリーを指し示すように Gnus のサーバー
の定義に追加しましょう。@ref{Article Backlog},
@ref{Asynchronous Fetching} およびその他のものはデータを上書きして邪魔を
するかもしれないので、データを復帰させる前に Gnus を終了する必要があるか
もしれません。

@node Web Searches
@subsection ウェブ検索
@cindex nnweb
@cindex Google
@cindex dejanews
@cindex gmane
@cindex Usenet searches
@cindex searching the Usenet

@c 記事をー、ってゆーかあ、なんか調べたい文字が書いてある記事をー、その
@c おー Usenet で探すのってえー、チョー素敵なんだけどさー、えーと何てゆーか
@c あー、そうだっ、ウェブブラウザーとかゆーやつ使ってー、やるのってえー、う
@c ざってーんだよなー、コマーシャル見なきゃなんないしいー、んだけどもおー、
ううむ、まあ、調べたい文字が書いてある記事を、その、Usenet で探すという
ことは、ですね、もちろん素晴らしいことこの上ないのではありますが、しかし、
何と申しましょうか、ウェブブブラウザーといいますか、そういうものを使って
ことを行なうのは、何ともその、はばかりながら、ぶざまと言いますか、そうす
ると、コマーシャルを見ないわけにはいかないのでありまして、しかるに、
@c 「ブブブ」はタイポじゃないんだよーん。
Gnus を使えばブラウザー無しで検索することができます。

@code{nnweb} バックエンドは、強力な検索エンジンへの簡単なインターフェー
スを提供します。@code{nnweb} グループを作成し、検索パターンを入力してか
ら、そのグループに入って他の普通のグループのように記事を読んでください。
グループバッファー (@pxref{Foreign Groups}) の @kbd{G w} 命令によって、
手軽にこれができます。

@code{nnweb} グループは、固定グループになろうとはしません---このグループ
では記事番号はごく一時的なものとして扱われます。実際、@code{nnweb} グルー
プに入るたびに (たとえ検索パターンを変更していなくても)、記事の順序が違っ
ているかもしれません。また、重複抑制 (@pxref{Duplicate Suppression}) を
使っても役に立たないでしょう。というのは、検索エンジ
ン (例えば Google) を使って記事を読み込む前の段階では、@code{nnweb} はそ
れらの @code{Message-ID} を知らないからです。あなたが読んだ記事を憶えて
おくための唯一の方法は、@code{Date} ヘッダーを元にスコアを付けることだけ
です---つまり、そのグループを最後に読んだ日付より前に投稿された記事を、
すべて既読にするということです。

もし検索エンジンの出力形式が実質的に変更されると、@code{nnweb} はそれを
うまく解釈できなくて、処理に失敗するでしょう。ウェブの提供者たちがそんな
ことをしても、彼らを責めることはできないでしょう---それは広告で金を稼ぐ
のが彼らの @emph{レーゾン・デートル} (存在理由) であり、社会にサービスを
提供することではないからです。@code{nnweb} はすべての記事から広告を洗い
流してしまうので、提供者たちがムカついていると思われるかもしれません。ま
あ見ててください。

以下は仮想サーバー変数です。

@table @code
@item nnweb-type
@vindex nnweb-type
どの検索エンジンを使うかを指定します。現在サポートされている種類は、
@code{google}, @code{dejanews} そして @code{gmane} です。
@code{dejanews} は @code{google} の別名になっていることに注意してくださ
い。

@item nnweb-search
@vindex nnweb-search
検索エンジンに与える検索文字列です。

@item nnweb-max-hits
@vindex nnweb-max-hits
一つの検索で表示する最大のヒット数の希望値で、ディフォルトは 999 です。

@item nnweb-type-definition
@vindex nnweb-type-definition
種類と定義の連想リストです。この連想リストは、さまざまな検索エンジンの種
類に対して、@code{nnweb} がどうすべきかを指定します。以下に示す要素を与
えなくてはなりません。

@table @code
@item article
記事をデコードし、Gnus が理解できる何かを提供する関数です。

@item map
メッセージヘッダーと URL を、記事番号を元にして得るための連想リストを作
成する関数です。

@item search
検索エンジンに検索文字列を送るための関数です。

@item address
前述の関数が検索文字列を送るべきアドレスです。

@item id
@code{Message-ID} を元にして記事を取得するための、URL フォーマットの文字
列です。
@end table
@end table

@node RSS
@subsection RSS
@cindex nnrss
@cindex RSS

いくつかのウェブサイトは RDF site summary (@acronym{RSS}) を持っています。
@acronym{RSS} は、ニュース関連のサイト (BBC や CNN のような) の見出しを
要約するためのフォーマットです。しかし、基本的にリストのようなものなら何
でも、@acronym{RSS} feed として提供することができます: weblogs,
changelogs あるいは wiki (例え
ば @url{http://cliki.net/site/recent-changes}) の最新の変更などが対象に
なります。

@acronym{RSS} はとても規則的で良質なインターフェースを持っているので、
Gnus がグループを最新の状態に保っておくために必要な情報を得ることが可能
です。

注: @code{utf-8} coding system をサポートする Emacs を使うのが良いでしょ
う。@acronym{RSS} は非-@acronym{ASCII} テキストをエンコードするために、
ディフォルトで UTF-8 を使うからです。それはまた、非-@acronym{ASCII} グルー
プ名にもディフォルトで使われます。

@kindex G R @r{(グループ)}
Feed を講読するには、グループバッファーから @kbd{G R} を使ってくださ
い---feed の所在、タイトルおよび説明の入力を求められるでしょう。タイトル
はどんな文字でもよく、それはグループ名とグループのデータ・ファイルの名前
に使われます。説明は省略できます。

簡単に @code{nnrss} を始める方法は、グループバッファーで @kbd{B nnrss
@key{RET} @key{RET} y} のようなことを唱え、そしてグループを講読すること
です。

@code{nnrss} バックエンドは、それぞれの @code{nnrss} グループのためのデー
タ・ファイルを @code{nnrss-directory} (下記参照) に保存します。
非-@acronym{ASCII} 文字を含んでいるファイル名
は、@code{nnmail-pathname-coding-system} 変数または他のもので指定され
た coding system でエンコードされます。詳細はここ (@pxref{Non-ASCII Group
Names}) を見てください。

@code{nnrss} バックエンドは、それぞれが @samp{text/plain} パート
と @samp{text/html} パートを含んでい
る @samp{multipart/alternative} 型の @acronym{MIME} 記事を作ります。

@cindex OPML
あなたの講読目録を @acronym{OPML} フォーマット (Outline Processor Markup
Language) でロード/セーブするために、以下のコマンドを使うこともできます。

@defun nnrss-opml-import file
@acronym{OPML} ファイルの入力を促し、そのファイルにあるそれぞれ
の feed を講読します。
@end defun

@defun nnrss-opml-export
現在の @acronym{RSS} 講読目録を @acronym{OPML} フォーマットでバッファー
に書き出します。
@end defun

以下の @code{nnrss} 変数が変更可能です:

@table @code
@item nnrss-directory
@vindex nnrss-directory
@code{nnrss} がファイルを書き込むディレクトリーで、ディフォルト
は @file{~/News/rss/} です。

@item nnrss-file-coding-system
@vindex nnrss-file-coding-system
@code{nnrss} グループのデータ・ファイルを読み書きするときに使われ
る coding system です。ディフォルト
は @code{mm-universal-coding-system} の値 (そのディフォルト
は @code{emacs-mule}) です。

@item nnrss-ignore-article-fields
@vindex nnrss-ignore-article-fields
いくつかのフィードは、記事フィールドの例えばコメント数を、その存続期間を
通じて絶えず更新します。しかしそれはローカルに保存したものとの差異を生む
ので、サーバーに新しい記事があるように解釈されてしまいます。いくつかの
フィールドを無視してこれを防ぐためには、この変数に無視するべきフィールド
のリストを設定してください。ディフォルトは @code{'(slash:comments)} です。

@item nnrss-use-local
@vindex nnrss-use-local
@findex nnrss-generate-download-script
@code{nnrss-use-local} を @code{t} に設定すると、
@code{nnrss} は @code{nnrss-directory} にあるローカルファイルか
ら feed を読みます。@code{nnrss-generate-download-script} コマンドを使う
ことによって、@command{wget} を使ったダウンロード・スクリプトを作ること
ができます。
@end table

概略バッファーに説明を表示させたいならば、以下のコードが役に立つでしょう。

@lisp
(add-to-list 'nnmail-extra-headers nnrss-description-field)
(setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-15,15f%]%) %s%uX\n")

(defun gnus-user-format-function-X (header)
  (let ((descr
         (assq nnrss-description-field (mail-header-extra header))))
    (if descr (concat "\n\t" (cdr descr)) "")))
@end lisp

以下のコードは、概略バッファーから直接 nnrss の url をオープンするのに便
利でしょう。

@lisp
(require 'browse-url)

(defun browse-nnrss-url (arg)
  (interactive "p")
  (let ((url (assq nnrss-url-field
                   (mail-header-extra
                    (gnus-data-header
                     (assq (gnus-summary-article-number)
                           gnus-newsgroup-data))))))
    (if url
        (progn
          (browse-url (cdr url))
          (gnus-summary-mark-as-read-forward 1))
      (gnus-summary-scroll-up arg))))

(with-eval-after-load "gnus"
  (define-key gnus-summary-mode-map
    (kbd "<RET>") 'browse-nnrss-url))
(add-to-list 'nnmail-extra-headers nnrss-url-field)
@end lisp

あなたが @acronym{HTML} パートを見たくないため
に @samp{text/html} を @code{mm-discouraged-alternatives} 変
数 (@pxref{Display Customization, ,表示のカスタマイズ, emacs-mime-ja,
The Emacs MIME Manual}) に加えていたとしても、特に @code{nnrss} グループ
では @samp{text/html} を表示する方が便利かもしれません。以下
は @code{nnrss} グループでだけは @samp{text/html} パートを表示するために、
グループパラメーターとして @code{mm-discouraged-alternatives} を設定する
例です:

@lisp
;; @r{@code{mm-discouraged-alternatives} のディフォルト値を設定。}
(with-eval-after-load "gnus-sum"
  (add-to-list
   'gnus-newsgroup-variables
   '(mm-discouraged-alternatives
     . '("text/html" "image/.*"))))

;; @r{@code{nnrss} グループでは @samp{text/html} パートを表示。}
(add-to-list
 'gnus-parameters
 '("\\`nnrss:" (mm-discouraged-alternatives nil)))
@end lisp

@node Other Sources
@section その他のグループ源

Gnus はただ単にニュースやメールを読む以上のことができます。以下に示す方
法によって、Gnus でディレクトリーやファイルを、あたかもニュースグループ
であるかのように閲覧することができるようになります。

@menu
* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する
* The Empty Backend::           ニュースを何も取得しないバックエンド
@end menu

@node Directory Groups
@subsection ディレクトリーグループ
@cindex nndir
@cindex directory groups

たくさんの記事が個別のファイルとして入っているディレクトリーがあれば、そ
れをニュースグループとして扱うことができます。もちろん、ファイルは数字の
ファイル名をもっていなければなりません。

素晴らしい Emacs のパッケージの中でも最も素晴らしい @code{ange-ftp} (と
その後継の @code{efs}) について触れるのに、ここは良い機会でしょう。私
が @code{nndir} を書いたときは、これ (ディレクトリーを読むバックエン
ド) についてはあまり考えていませんでした。とんでもないことだね。

@code{ange-ftp} はこの情況を劇的に変化させました。例えばディレクトリー名
として @code{ange-ftp} の様式
で @file{/ftp.hpc.uh.edu:/pub/emacs/ding-list/} というファイル名をディレ
クトリー名として入力したとすると、@code{ange-ftp} あるいは @code{efs} は
実に「シナ」の向こうのディレクトリーをニュースグループとして読めるように
なるのです。おーい、分散ニュースだぞーっ!

@quotation
(訳注:「シナ」(原典 @samp{sina}) は China のことか?)
@end quotation

@code{nndir} は @acronym{NOV} ファイル群が存在すればそれらを利用します。

@code{nndir} は「読み出し専用」のバックエンドです---この選択方法では、記
事の削除や期限切れ消去を行なうことはできません。@code{nndir} が使えるも
のなら何でも、@code{nnmh} あるいは @code{nnml} でも使うことができるので、
もし読み出し専用ではない @code{nndir} が必要だと思ったら、これらのどちら
かの方法に切り替えることもできます。

@node Anything Groups
@subsection なんでもグループ
@cindex nneething

@code{nneething} は @code{nndir} バックエンド (単一のスプール風ディレク
トリーを読むバックエンド) のほんの少し先にあるもので、それはどんなディレ
クトリーでもニュースグループに見せかけてしまいます。不思議ですが真実です。

@code{nneething} にディレクトリーを与えると、そのディレクトリーを走査し
て各ファイルに記事番号を割り当てます。そのようなグループに入ったら、
@code{nneething} は Gnus が使える「ヘッダー」を作らなくてはなりません。
つまるところ Gnus はニュースリーダーなんです。忘れているかもしれないので
念のため。@code{nneething} はこれを二段階で処理します。最初に、対象とな
るそれぞれのファイルを覗いてまわります。もしそのファイルが記事のように見
えたなら (すなわち最初の数行がヘッダーのように見えたら) それをヘッダーと
して使います。もしそれがヘッダーの無いただの適当なファイル (例えば C の
ソースファイル) だったら、@code{nneething} はヘッダーを虚空からでっち上
げます。これはファイルの所有者、名前および日付を使い、それらの要素を元に
できることを何でもやります。

これはあなたにとってはすべて自動的に起こることで、あなたはニュースグルー
プにとても良く似た何かを見せられることになるでしょう。本当に寸分違わない、
ニュースグループのようなものを。記事を選択すると、それはいつものように記
事バッファーに表示されるでしょう。

ディレクトリーを表わしている行を選択すると、Gnus はいきなりあなたをこ
の @code{nneething} グループのための新しい概略バッファーに連れて行くでしょ
う。以下同様に、あなたがそうしたければ、この方法で全ディスクを駆け巡るこ
とができます。ですが、Gnus は本当は dired ではないし、そのように意図され
たものでもないことは覚えておいてください。

ここでの動作には二つの全体的なモードがあります--- 一時モードと固定モード
です。一時的な操作を行なっているときは (すなわちグループバッファー
で @kbd{G D})、Gnus はどのファイルを読んだか、どのファイルが新しいか、な
どの情報を憶えておきません。普通に @kbd{G m} で固定 @code{nneething} グ
ループを作れば、Gnus は記事番号とファイル名の対応表を憶えておくので、こ
のグループを他のグループと同様に扱うことができるようになります。固
定 @code{nneething} グループを活かすと、それが未読記事をいくつ含んでいる
かを知らせてもらえる、等々の利便があります。

いくつかの変数があります:

@table @code
@item nneething-map-file-directory
@vindex nneething-map-file-directory
すべての固定 @code{nneething} グループの対応表が、このディレクトリーに格
納されます。このディフォルトは @file{~/.nneething/} です。

@item nneething-exclude-files
@vindex nneething-exclude-files
この正規表現に合致するファイルはすべて無視されます。自動保存ファイルなど
を除外するのに便利に使えます。そしてそれがまさにディフォルトで行なわれる
動作です。

@item nneething-include-files
@vindex nneething-include-files
どのファイルをグループに含めるかを示す正規表現です。この変数
が @code{nil} でなければ、この正規表現に合致するファイルだけが含まれます。

@item nneething-map-file
@vindex nneething-map-file
対応表ファイルの名前です。
@end table

@node Document Groups
@subsection 文書グループ
@cindex nndoc
@cindex documentation group
@cindex help group

@code{nndoc} は単一のファイルをニュースグループとして読むことをできるよ
うにする、ちょっと気の利いたやつです。複数のファイルの種別がサポートされ
ています:

@table @code
@cindex Babyl
@item babyl
Babyl 様式。

@cindex mbox
@cindex Unix mbox
@item mbox
標準 Unix mbox ファイル。

@cindex MMDF mail box
@item mmdf
MMDF 形式のメールボックス。

@item news
一つのファイルにまとめられた複数のニュース記事。

@cindex rnews batch files
@item rnews
rnews のバッチ転送形式。

@item nsmail
Netscape のメールボックス。

@item mime-parts
@acronym{MIME} のマルチパートのメッセージ。

@item standard-digest
標準 (RFC1153) のまとめ送り形式。

@item mime-digest
@acronym{MIME} のまとめ送りメッセージ。

@item lanl-gov-announce
ロスアラモス国立研究所 (LANL) Gov Announce からの発表メッセージ。

@cindex git commit messages
@item git
@code{git} で commit したことを伝えるメッセージ。

@cindex forwarded messages
@item rfc822-forward
RFC 822 またはその後継に従って転送されたメッセージ。

@item outlook
Outlook のメールボックス。

@item oe-dbx
Outlook Express の dbx メールボックス。

@item exim-bounce
Exim MTA から跳ね返されたメッセージ。

@item forward
非公式の規則で転送されたメッセージ。

@item rfc934
RFC934 形式で転送されたメッセージ。

@item mailman
mailman のまとめ送り。

@item clari-briefs
Clarinet のニュース項目を要約したまとめ送り。

@item slack-digest
非標準まとめ送り形式---だいたいのものを扱えるが、下手。

@item mail-in-mail
最後の手段。
@end table

特別な「ファイル種別」である @code{guess} を使うこともできます。これを使
うと、見ているファイルの種別が何かを @code{nndoc} が推測しようとします。
また、@code{digest} というファイル種別は、そのファイルがどのまとめ送り形
式かを @code{nndoc} に推測させます。

@code{nndoc} はファイルを書き換えようとしたり、余分なヘッダーを挿入しよ
うとしたりはしません---単に、ファイルをそのグループを作る元として使える
ようにする、というようなことです。それだけのことです。

保存された古い記事を持っていて、それを新しくてかっこいい Gnus のメールバッ
クエンドに追加したいなら、おそらく @code{nndoc} が助けになるはずです。例
えば新しい @code{nnml} グループに振り分けたいメールが、今は古
い @file{RMAIL} ファイルにメールがあるとしましょう。そういう場合は、その
ファイルを @code{nndoc} を使って開き (グループバッファーで @kbd{G f} 命
令 (@pxref{Foreign Groups}) を使いましょう)、バッファー内の全記事にプロ
セス印を (例えば @kbd{M P b} で) 付けてから、それらが @code{nnml} グルー
プ群に振り分けられるように (@kbd{B r} 命令を使って) 再スプールしてくださ
い。すべてがうまくいけば、@file{RMAIL} ファイル内のすべてのメールは、た
くさんの @code{nnml} ディレクトリーの中にも格納されます。そうしたら、あ
の厄介な @file{RMAIL} を削除してしまっても良いでしょう。あなたにガッツが
あれば!

仮想サーバー変数:

@table @code
@item nndoc-article-type
@vindex nndoc-article-type
これは @code{mbox}, @code{babyl}, @code{digest}, @code{news},
@code{rnews}, @code{mmdf}, @code{forward}, @code{rfc934},
@code{rfc822-forward}, @code{mime-parts}, @code{standard-digest},
@code{slack-digest}, @code{clari-briefs}, @code{nsmail}, @code{outlook},
@code{oe-dbx}, @code{mailman} および @code{mail-in-mail} また
は @code{guess} のいずれかでなくてはなりません。

@item nndoc-post-type
@vindex nndoc-post-type
この変数は、そのグループをニュースグループとみなすかメールグループとみな
すかを Gnus に伝えます。二つの有効な値は @code{mail} (ディフォルト) およ
び @code{news} です。
@end table

@menu
* Document Server Internals::   あなた独自の文書種別を追加する方法
@end menu

@node Document Server Internals
@subsubsection 文書サーバーの内部

@code{nndoc} で認識される新しい文書の種別を追加することは難しくありませ
ん。その文書がどのように見えるかの定義を仕上げ、その文書種別を認識するた
めの述語関数を書いて、@code{nndoc} を手なずけるだけで良いのです。

まず、これが文書の種別の定義の例です:

@example
(mmdf
 (article-begin .  "^\^A\^A\^A\^A\n")
 (body-end .  "^\^A\^A\^A\^A\n"))
@end example

この定義は種別を示すためのユニークな名前 (@dfn{name}) と、それに続く仮想
的な変数名およびその設定値の単純な連なりからなります。以下が使うことがで
きる変数です---変数の数に圧倒されないでください。ほとんどの文書の種別は、
ごくわずかな設定で定義することができます:

@table @code
@item first-article
これが設定されていると、@code{nndoc} はこの正規表現に合致する何かが見つ
かるまで、すべてのテキストを読み飛ばします。それより前のすべてのテキスト
は完全に無視されます。

@item article-begin
この設定は、すべての文書の種別の定義に必ず存在しなければなりません。それ
ぞれの記事の始まりがどのように見えるかを指定する正規表現です。単純な正規
表現では対処できないもっと複雑なことをしたい場合は、これの代わり
に @code{article-begin-function} を使うことができます。

@item article-begin-function
これを設定する場合は、それぞれの記事の開始位置にポイントを移動させる関数
を指定してください。これは @code{article-begin} より優先されます。

@item head-begin
これを設定する場合は、記事のヘッダーの始まりに合致する正規表現を指定して
ください。単純な正規表現では対処できないもっと複雑なことをしたい場合は、
これの代わりに @code{head-begin-function} を使うことができます。

@item head-begin-function
これを設定する場合は、記事のヘッダーの開始位置にポイントを移動させる関数
を指定してください。これは @code{head-begin} より優先されます。

@item head-end
これを設定する場合は、記事のヘッダーの最後に合致する正規表現を指定してく
ださい。ディフォルトは @samp{^$}、つまり空行です。

@item body-begin
これを設定する場合は、記事のボディーの始まりに合致する正規表現を指定して
ください。ディフォルトは @samp{^\n} です。単純な正規表現では対処できない
もっと複雑なことをしたい場合は、これの代わり
に @code{body-begin-function} を使うことができます。

@item body-begin-function
これを設定する場合は、記事のボディーの開始位置にポイントを移動させる関数
を指定してください。これは @code{body-begin} より優先されます。

@item body-end
これを設定する場合は、記事のボディーの最後に合致する正規表現を指定してく
ださい。単純な正規表現では対処できないもっと複雑なことをしたい場合は、こ
れの代わりに @code{body-end-function} を使うことができます。

@item body-end-function
これを設定する場合は、記事のボディーの最後の位置にポイントを移動させる関
数を指定してください。これは @code{body-end} より優先されます。

@item file-begin
これを設定する場合は、ファイルの始まりに合致する正規表現を指定してくださ
い。それより前のすべてのテキストは完全に無視されます。

@item file-end
これを設定する場合は、ファイルの最後に合致する正規表現を指定してください。
それより後ろのすべてのテキストは完全に無視されます。
@end table

このように @code{nndoc} はこれらの変数を使って、文書ファイルをそれぞれヘッ
ダーとボディーを持った記事の連なりとして切り分けることができます。しかし、
すべての文書の種別がこのようなニュース風になっているわけではないので、さ
らにヘッダーやボディーを Gnus の趣味に合うように変形させる変数が、いくら
か必要になります。

@table @code
@item prepare-body-function
これに関数を設定しておくと、記事が要求されたときに呼び出されます。これは
ボディーの開始位置のポイントを引数として呼び出され、文書にいくつかのエン
コードされた内容物のパートがある場合に有用です。

@item article-transform-function
これに関数を設定しておくと、記事が要求されたときに呼び出されます。これは
記事のヘッダーとボディーの両方に、より広範囲な変形を行なうために使われる
ものです。

@item generate-head-function
これに関数を設定しておくと、Gnus が理解できるヘッダーを生成するために呼
び出されます。これは記事番号をパラメーターとして呼び出され、その記事のた
めの良質なヘッダーを生成することを求められます。すべての記事のヘッダーが
要求されるときに呼び出されます。

@item generate-article-function
これに関数を設定しておくと、Gnus が理解できる完全な記事を生成するために
呼び出されます。これはすべての記事のヘッダーが要求されるときに、記事番号
をパラメーターとして呼び出されます。

@item dissection-function
これに関数を設定しておくと、それだけを使って文書ファイルを記事に切り分け
るために呼び出されます。これは @code{first-article},
@code{article-begin}, @code{article-begin-function}, @code{head-begin},
@code{head-begin-function}, @code{head-end}, @code{body-begin},
@code{body-begin-function}, @code{body-end}, @code{body-end-function},
@code{file-begin} および @code{file-end} より優先されます。
@end table

私が出会った中で最も複雑な例を見てください。標準まとめ送り形式のためのも
のです:

@example
(standard-digest
 (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
 (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
 (prepare-body-function . nndoc-unquote-dashes)
 (body-end-function . nndoc-digest-body-end)
 (head-end . "^ ?$")
 (body-begin . "^ ?\n")
 (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
 (subtype digest guess))
@end example

70 文字のダッシュ ('-') の行より前はすべて無視されるというのが分かります
ね。また @samp{^End of} で始まる行より後ろもすべて無視されます。各記事
は 30 文字のダッシュの行で始まり、ヘッダーとボディーの区切りの行は一個の
スペースを含むことがあり、そしてボディーはそれが渡される前
に @code{nndoc-unquote-dashes} を通されます。

あなた独自の文書のための定義を @code{nndoc} で使えるようにするには、
@code{nndoc-add-type} 関数を使ってください。これは二つのパラメーターをと
ります--- 一つ目は定義そのもので、二つ目の (省略可能な) パラメーターは、
この定義を文書の種別を定義する連想リストのどこに置くかを指定します。この
連想リストは順番に走査され、与えられた種別 @var{type} に対し
て @code{nndoc-@var{type}-type-p} が呼び出されます。したがって、例え
ば @code{mmdf} という種別であるかどうかを調べるために
は @code{nndoc-mmdf-type-p} が呼び出され、他の種別の場合も同様です。これ
らの種別述語関数は、文書がその種別でない場合は @code{nil} を返し、その種
別である場合は @code{t} を返し、その種別かもしれないときは数値を返さなく
てはなりません。高い数値は高い可能性を意味し、低い数値は低い可能性を意味
します。@samp{0} は正しい値の中でもっとも低い数値です。

@node Mail-To-News Gateways
@subsection メールからニュースへのゲートウェイ
@cindex mail-to-news gateways
@cindex gateways

あなたのローカルの @code{nntp} サーバーが何らかの理由で投稿を許可してい
なくても、数ある mail-to-news ゲートウェイを使って投稿することができます。
@code{nngateway} バックエンドはこのインターフェースを提供します。

このバックエンドからは何も読み出せないことに注意してください---これは投
稿するためだけに使われます。

以下はサーバー変数です。

@table @code
@item nngateway-address
@vindex nngateway-address
これが mail-to-news ゲートウェイのアドレスです。

@item nngateway-header-transformation
@vindex nngateway-header-transformation
ニュースヘッダーは、mail-to-news ゲートウェイが受け付けられるように、何
か奇妙なやり方で変形しておかなければならないことがしばしばです。この変数
はどんな変形処理が呼び出されるべきかを指示するもので、ディフォルトで
は @code{nngateway-simple-header-transformation} になります。その関数は
変形しようとするヘッダーの領域だけに狭められたバッファーで、ゲートウェイ
のアドレスを一つの引数として呼び出されます。

ディフォルトの関数は、単に @code{Newsgroups} ヘッダーとゲートウェイのア
ドレスに基づいた新しい @code{To} ヘッダーを挿入します。例えば、以下のよ
うな @code{Newsgroups} ヘッダーを持つ記事には、

@example
Newsgroups: alt.religion.emacs
@end example

次のような @code{To} ヘッダーが挿入されます。

@example
To: alt-religion-emacs@@GATEWAY
@end example

以下の関数が用意されています:

@table @code
@item nngateway-simple-header-transformation
@findex nngateway-simple-header-transformation
@var{newsgroup}@@@code{nngateway-address} のような @code{To} ヘッダーを
作ります。

@item nngateway-mail2news-header-transformation
@findex nngateway-mail2news-header-transformation
@code{nngateway-address} のような @code{To} ヘッダーを作ります。
@end table
@end table

例です:

@lisp
(setq gnus-post-method
      '(nngateway
        "mail2news@@replay.com"
        (nngateway-header-transformation
         nngateway-mail2news-header-transformation)))
@end lisp

したがってこれを使うには、単にこんな風にすれば良いでしょう:

@lisp
(setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))
@end lisp

@node The Empty Backend
@subsection 空っぽのバックエンド
@cindex nnnil

実際は必要が無いのにどこかにバックエンドを設定しなければならない場合に、
@code{nnnil} は代用として使うことができるバックエンドです。典型的な例は、
第一の選択方法を必要としないが第二の (secondary) 選択方法だけを使いたい
場合です:

@lisp
(setq gnus-select-method '(nnnil ""))
(setq gnus-secondary-select-methods
      '((nnimap "foo")
        (nnml "")))
@end lisp

@node Combined Groups
@section 合併グループ

Gnus は、すべてのグループの種類を混合して、大きなグループに合併させるこ
とができます。

@menu
* Virtual Groups::              たくさんのグループの記事を合併する
@end menu

@node Virtual Groups
@subsection 仮想グループ
@cindex nnvirtual
@cindex virtual groups
@cindex merging groups

@dfn{nnvirtual} グループは、実は複数のグループを寄せ集めたものに過ぎませ
ん。

例えば、小さなグループをたくさん読むのが嫌になってきたら、それらを一つの
大きなグループに入れて、嫌になるくらい巨大で手に負えないグループを読むこ
とができます。これはコンピューティングの醍醐味だね!

選択方法として @code{nnvirtual} を指定してください。アドレスは、それを構
成するグループに合致する正規表現です。

仮想グループで付けられたすべての印は、その構成要素のグループの記事にくっ
つけられます。つまり、仮想グループで記事に可視記事の印を付けると、その記
事はもともとの構成要素のグループでも可視記事になります。(そして逆も成り
立ちます---構成要素のグループで付けた印は、仮想グループでも表示されま
す。)  空の仮想グループを作るには、グループバッファーで @kbd{G V}
(@code{gnus-group-make-empty-virtual}) を実行し、@kbd{M-e}
(@code{gnus-group-edit-group-method}) で選択方法の正規表現を編集してくだ
さい。

これが、Andrea Dworkin に関するすべてのニュースグループを、一つの巨大で
シアワセなニュースグループにまとめる @code{nnvirtual} 選択方法の例です:

@lisp
(nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")
@end lisp

構成要素のグループは基本グループでも外部グループでも構いません。すべて問
題無く動くはずですが、もしあなたのコンピューターが爆発でもしてしまったら、
それはたぶん私が悪いんでしょうね。

利用者が (訳注: 記事を投稿する人たちが) Distribution ヘッダーを使って配
布範囲を制限している場合に、同じグループを複数のサーバーから寄せ集めるこ
とは、本当にうまい考えかもしれません。@samp{soc.motss} を日本のサーバー
とノルウェーのサーバーの両方から読みたければ、グループの正規表現として以
下のものを使うことができるでしょう:

@example
"^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"
@end example

(でもちょっと注意。@kbd{G m} でグループを作成するときは、バックスラッシュ
を二重に付けてはいけません。そして文字列の最初と最後の引用記
号 (@samp{"..."}) も取り払ってください。)

これはまあ、すらすらと動作するはずです---両方のグループのすべての記事は
一つのグループに入り、重複も無いはずです。スレッド表示 (とその他) も通常
通り動作するでしょうけれど、記事の並ぶ順序には問題があるかもしれません。
日付による並べ替えが、ここでは一つの選択肢になるかもしれませ
ん (@pxref{Selecting a Group})。

なお、ここで一つだけ制限があります---仮想グループに含まれるグループはす
べて生きている (すなわち購読または非購読の) 状態でなくてはなりません。削
除された (killed) グループあるいはゾンビのグループは @code{nnvirtual} グ
ループを構成するグループになることはできません。

@vindex nnvirtual-always-rescan
@code{nnvirtual-always-rescan} 変数が @code{nil} でなけれ
ば (それ、つまり非-@code{nil} がディフォルト)、@code{nnvirtual} は仮想グ
ループに入ったときに常に未読記事を走査します。この変数が @code{nil} になっ
ていて、仮想グループを作った後に構成要素のグループで記事を読んだ場合は、
その構成要素のグループで読まれた記事は、仮想グループに現れてしまうでしょ
う。共通な構成要素のグループを持つ二つの仮想グループがある場合にも、この
影響があります。そういう場合には、この変数を @code{t} にするべきです。さ
もなければ、仮想グループに入る度に、毎回その仮想グループの上
で @code{M-g} を叩いても良いでしょう---これにはほぼ同様の効果があります。

@code{nnvirtual} はメールとニュースの両方のグループを構成要素のグループ
にすることができます。@code{nnvirtual} グループの記事に返答するときは、
@code{nnvirtual} は記事の出所の構成要素のグループのバックエンドに、それ
がニュースのバックエンドであるかメールのバックエンドであるかを尋ねなけれ
ばなりません。しかし @kbd{^} をしたときには、普通は構成要素のバックエン
ドがこれを知るための確実な方法が無いので、その場合 @code{nnvirtual} は、
Gnus に記事はニュースではないバックエンドからやって来たと告げます。(単に
それが安全な側なので。)

これらの場合にメッセージバッファーで @kbd{C-c C-n} を行なうと、応答しよ
うとしている記事から @code{Newsgroups} 行を抜き出して挿入します。

@code{nnvirtual} グループは、記事と印以外は構成要素のグループから継承し
ません---例えばグループパラメーターもそうなのですが、それらは継承されま
せん。

@node Email Based Diary
@section 電子メールによる日程管理
@cindex diary
@cindex email based diary
@cindex calendar

この章では @code{nndiary} という特別なメールバックエンドと、その仲間
の @code{gnus-diary} ライブラリーについて説明します。それが「特別」なの
は、Gnus でメールを読むための標準の選択肢の一つであるつもりは無いからで
す。それ (標準の選択肢) については @ref{Choosing a Mail Back End} を参照
してください。代わりに、特別な方法であなたのメールの @emph{ いくつか} を
扱う、すなわちこれはリマインダー (予定を思い出させるもの) として使われま
す。

典型的な筋書きは、こうです。

@itemize @bullet
@item
あなたはアンディ・マクドウェルかブルース・ウィリス (あなたの好みに合わせ
て、どちらかを選んでください) と、一ヶ月後にデートの約束をしました。それ
を忘れるわけにはいきません。
@item
そこで、自分宛てにリマインダーのメッセージを (本当に毎日一通) 送ることに
しました。
@item
あなたはそのことをすっかり忘れて、いつもどおりに新しいメールを取り込んで
読み続けます。
@item
デートの日が近付いてくると、グループバッファーで @kbd{g} をタイプしたと
きに、ときどきあなたの予定を思い出させるために、あたかも新着で未読のよう
に、メッセージが再びポップアップするでしょう。
@item
これが含まれている「新しい」メッセージたちを読んでください、そして、再び
あなたが過ごす夜を夢見てください。
@item
いったんデートが終わると (実際にはディナーのすぐ後で寝入ってしまったとし
ても)、期限切れ消去の印が付いていれば、メッセージは自動的に消去されます。
@end itemize

Gnus Diary バックエンドは、(常に取り消されることが無い) 定期的な予定を、
几帳面な人たちと同じように扱う能力を持っていて、本当のメールバックエンド
のように動作し、いろんなやり方で設定することができます。このすべてが、以
下の各章で説明されています。

@menu
* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      nndiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること
@end menu

@node The NNDiary Back End
@subsection NNDiary バックエンド
@cindex nndiary
@cindex the nndiary back end

@code{nndiary} は @code{nnml} (@pxref{Mail Spool}) にとてもよく似ている
バックエンドです。現にそれは @code{nnml} と @code{nndraft} を合わせたも
のに見えるでしょう。@code{nnml} をご存知ならば、あなたはすで
に @code{nndiary} がメッセージを格納する仕組み (一通あたり一つのファイル、
一グループあたり一つのディレクトリー) に精通しています。

何はさておき、@code{nndiary} をちゃんと動作させるには、一つの要件があり
ます: Gnus のグループの日付の機能を @emph{使わなければなりません}。それ
がどういうふうに行なわれるかは @ref{Group Timestamp} を見てください。

@menu
* Diary Messages::              メッセージを nndiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル
@end menu

@node Diary Messages
@subsubsection 日程メッセージ
@cindex nndiary messages
@cindex nndiary mails

七つの特別なヘッダーが必須であること以外、@code{nndiary} のメッセージは
まったく普通のものです。それらのヘッダーは @code{X-Diary-<something>} の
様式で表され、@code{<something>} の部分は @code{Minute}, @code{Hour},
@code{Dom}, @code{Month}, @code{Year}, @code{Time-Zone} およ
び @code{Dow} のうちの一つです。@code{Dom} は「日 (Day of Month)」を、
@code{Dow} は「曜日 (Day ofWeek)」を意味します。これらのヘッダー
は crontab の設定のように働いて、予定日を定義します。

@itemize @bullet
@item
@code{Time-Zone} のもの以外のすべてのヘッダーについて、ヘッダーの値は星
印 (可能なすべての値を意味します) かコンマで区切られたフィールドのリスト
です。
@item
フィールドは整数か範囲のどちらかです。
@item
範囲とは、ダッシュ (-) で区切られた二つの整数です。
@item
可能な値は、それぞれ @code{Minute} には 0--59、@code{Hour} には 0--23、
@code{Dom} には 1--31、@code{Month} には 1--12、@code{Year} には 1971 よ
り大きい値、そして @code{Dow} には 0--6 (0 が日曜日) です。
@item
特別な場合として、@code{Dom} または @code{Dow} のどちらか一方における星
印は「可能なすべての値」ではなく、「もう一方のフィールドだけを使う」意味
になります。両方とも星印にした場合は、どちらを使っても同じ結果になること
に注意してください。
@item
@code{Time-Zone} ヘッダーは、値を一つしか持てない (例えば @code{GMT}) 点
で特別です。星印は「可能なすべての値」ではなく (それは意味をなさないので)、
「現在のローカルなタイムゾーン」を意味します。ここではたいてい星印を使う
でしょう。しかし、利用できるタイムゾーンの値については、変
数 @code{nndiary-headers} を見てください。
@end itemize

1999年から 2010年までの毎週月曜日と毎月の一日の 12:00, 20:00, 21:00,
22:00, 23:00 および 24:00 を設定するために、メッセージに加える日程ヘッダー
の具体例です (その時何をしたら良いかは、自分で考えてください):

@example
X-Diary-Minute: 0
X-Diary-Hour: 12, 20-24
X-Diary-Dom: 1
X-Diary-Month: *
X-Diary-Year: 1999-2010
X-Diary-Dow: 1
X-Diary-Time-Zone: *
@end example

@node Running NNDiary
@subsubsection NNDiary を動かす
@cindex running nndiary
@cindex nndiary operation modes

@code{nndiary} には二つの動作モードがあります。一つはディフォルトの
「伝統型 (traditional)」、もう一つは「自律型 (autonomous)」です。伝統型
のモードでは、@code{nndiary} はそれ自身が新着メールを取得することはあり
ません。日程メッセージとして扱うために、あなたはメールを基本のメールバッ
クエンドから nndiary グループに、移動 (@kbd{B m}) またはコ
ピー (@kbd{B c}) しなければなりません。自律型のモードでは、
@code{nndiary} はそれ自身のメールを取ってきて、基本のメールバックエンド
とは独立してそれを扱います。

本質的に Gnus は、同時に複数の「マスター」メールバックエンドを許容するよ
うには設計されていなことに注意すべきです。しかし @code{nndiary} では、こ
れは意味をなします。あなたは本当に、日程メッセージを日程グループに直接送っ
て、それらを受け取りたいのです。そこで @code{nndiary} は、まさに「二番目
の第一メールバックエンド」をサポートします (私が知っている限り、それはこ
の機能を提供する唯一のバックエンドです)。しかしながら制約があって (いつ
の日にか解消することを願いますが)、自律型のモードでは再スプールができま
せん。

自律型のモードで @code{nndiary} を使うためには、いくつかのことをやっても
らわなければなりません:

@itemize @bullet
@item
新着メールを @code{nndiary} が自分で取り込めるようにします。以下の行
を @file{~/.gnus.el} ファイルに記入してください:

@lisp
(setq nndiary-get-new-mail t)
@end lisp

@item
日程メッセージ (@code{X-Diary-*} ヘッダーを含んでいる) が、Gnus がそれら
を処理する @emph{前} に専用のフォルダーに分配されるように、準備を行なわ
なければなりません。繰り返しますが、Gnus が複数の第一メールバックエンド
を適切に扱うことが (まだ ?) できないので、これが必要です。別々のソースか
らそれらのメッセージを取り込むことによって、この欠点はある程度補われます。

日程ファイルを @file{~/.nndiary} (これがディフォルトの @code{nndiary} の
メールソース・ファイルです) に格納するための procmailrc の項目の例です:

@example
:0 HD :
* ^X-Diary
.nndiary
@end example
@end itemize

いったんこれを実施したら、日程メールの取り込みと分割の処理に影響する、以
下の二つのオプションをカスタマイズする必要があるでしょう:

@defvar nndiary-mail-sources
標準の @code{mail-sources} 変数の、日程用に特化した代替品です。同じ構
文 (syntax) を使い、ディフォルトは @code{(file :path "~/.nndiary")} で
す。
@end defvar

@defvar nndiary-split-methods
標準の @code{nnmail-split-methods} 変数の、日程用に特化した代替品です。
同じ構文 (syntax) を使います。
@end defvar

最終的には @code{gnus-secondary-select-methods} に、恒久的
な @code{nndiary} 仮想サーバー (@code{(nndiary "diary")} が行なうべきで
あるようなもの) を追加しても良いでしょう。

うまくいけば、Gnus を再起動すると、ほとんどすべ
て (@file{nndiary.el} の TODO の項を参照) が期待通りに動作するでしょう。
自律型のモードでは、@kbd{g} や @kbd{M-g} をグループバッファーでタイプす
れば新しい日程メールをも取り込んで、日程用に特化した規則に従ってそれらを
分割するし、@kbd{F} は新しい日程グループを見つけてくれる、など。

@node Customizing NNDiary
@subsubsection NNDiary のカスタマイズ
@cindex customizing nndiary
@cindex nndiary customization

さあ @code{nndiary} が立ち上がって動作しています。それをカスタマイズする
ときが来ました。カスタマイズするためのグループは @code{nndiary} です (へ
えー)。どのオプションをカスタマイズし倒したいかを見つけるために、それに
目を通してください。あなたが変更したいのは、おそらく以下のたった二つの変
数でしょう:

@defvar nndiary-reminders
予定を思い出させてもらいたい時刻のリスト (例えば三週間前、それから二日前、
それから一時間前、そしてそのとき) です。「思い出させてもらう」の意味は、
新着メールを取り込んだときに、日程メッセージが真新しく未読になって、ポッ
プアップすることであることを思い出してください。
@end defvar

@defvar nndiary-week-starts-on-monday
読んで字の如し。さもなくば日曜日が仮定されます (それがディフォルトです)。
@end defvar

@node The Gnus Diary Library
@subsection Gnus Diary ライブラリー
@cindex gnus-diary
@cindex the Gnus diary library

@code{nndiary} を手作業で使うこと (ヘッダーを手で書くことなど) は、いさ
さかうんざりします。幸い @code{nndiary} の上位階層に書かれ
た @code{gnus-diary} というライブラリーがあって、たくさんの便利なことを
やってくれます。

それを使うためには、以下の行を @file{~/.gnus.el} ファイルに加えてくださ
い:

@lisp
(require 'gnus-diary)
@end lisp

さらに、どんな @code{gnus-user-format-function-[d|D]} (@pxref{Summary
Buffer Lines}) も、使ってはいけません。@code{gnus-diary} はそれらの両方
を提供します (あなたがそれらを使っていたら、すみません)。

@menu
* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで
@end menu

@node Diary Summary Line Format
@subsubsection 日程の概略行仕様
@cindex diary summary buffer line
@cindex diary summary line format

標準の概略行仕様 (通常 @samp{From Joe: Subject} のようなもの) で日程メッ
セージを表示するのは、まったく役に立ちません。たいていはあなたがメッセー
ジを書いた人で、おおかた予定の日付を見たいと思っているでしょう。

@code{gnus-diary} は、概略行仕様で使う二つの追加の利用者定義の書法仕様を
提供します。@code{D} は次の予定が生じるときのための整形された時刻表
示 (例えば“Sat, Sep 22 01, 12:00”) を表すのに対して、@code{d} は次の予
定が生じるまでのおおよその残り時間 (例えば“in 6 months, 1 week”) を表
します。

ジョーの誕生日が、概略行にどう表示されるかの例です (定期的な予定を指定す
ると消されないことを除いて、メッセージが期限切れ消去可能であることに気を
付けてください):

@example
   E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)
@end example

上記のようなものを得るために、普段だったら、あなたは以下の行を日程グルー
プのパラメーターに加えようとするでしょう:

@lisp
(gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")
@end lisp

しかし @code{gnus-diary} はそれを自動で行ないます (@pxref{Diary Group
Parameters})。それでもあなたは、以下のユーザー・オプション群で提供される
概略行仕様を、カスタマイズすることができます:

@defvar gnus-diary-summary-line-format
日程グループのために使われる概略行仕様を定義します (@pxref{Summary
Buffer Lines})。@code{gnus-diary} はそれを、日程グループのパラメーターを
自動で更新するために使います。
@end defvar

@defvar gnus-diary-time-format
日程の概略バッファーに日付を表示するための書法仕様を定義します。これは利
用者定義の書法仕様 @code{D} で使われます。詳細は変数の説明文を見てくださ
い。
@end defvar

@defvar gnus-diary-delay-format-function
日程の概略バッファーに遅延 (残り時間) を表示するための整形関数を定義しま
す。これは利用者定義の書法仕様 @code{d} で使われます。現在は英語とフラン
ス語のための組み込み関数があり、自分で定義することもできます。詳細は変数
の説明文を見てください。
@end defvar

@node Diary Articles Sorting
@subsubsection 日程記事の並べ替え
@cindex diary articles sorting
@cindex diary summary lines sorting
@findex gnus-summary-sort-by-schedule
@findex gnus-thread-sort-by-schedule
@findex gnus-article-sort-by-schedule

@code{gnus-diary} は並べ替え (@pxref{Sorting the Summary Buffer}) のため
に @code{gnus-summary-sort-by-schedule}、
@code{gnus-thread-sort-by-schedule} およ
び @code{gnus-article-sort-by-schedule} という新しい関数を提供します。こ
れらの関数によって、最も近い予定から最も遠い方まで、日程の概略バッファー
を整理することができます。

@code{gnus-diary} は自動的に概略バッファーの「並べ替え (sort)」メニュー
に @code{gnus-summary-sort-by-schedule} を組み込み、他の二つを第一次
の (ゆえにディフォルトの) 並べ替え関数として、グループパラメー
ター (@pxref{Diary Group Parameters}) に登録します。

@node Diary Headers Generation
@subsubsection 日程ヘッダーの生成
@cindex diary headers generation
@findex gnus-diary-check-message

@code{gnus-diary} は、@code{X-Diary-*} ヘッダーの取り扱いを補佐するため
に、@code{gnus-diary-check-message} という関数を提供します。この関数は、
現在のメッセージがすべての必要な日程ヘッダーを確実に含むようにして、必要
ならば値を入力するか修正することを要求します。

記事を日程グループに移動またはコピーすることによって自動的にそれが発動さ
れるようにするために、この関数は @code{nndiary} バックエンドのフックとし
て組み入れられています。それはさらに、通常のメールを日程用のものに変換す
る操作を簡単にするために、
@code{message-mode} と @code{article-edit-mode} におい
て @kbd{C-c C-f d} キーとして設定もされています。

接頭引数を伴ってこの関数を呼ぶと、それらがあるか、正しいかどうかとは無関
係に、日程ヘッダーの入力を強制します。そうやって、例えばすでに正しく設定
されたメッセージの日程を、とても簡単に変更することができます。

@node Diary Group Parameters
@subsubsection 日程グループのパラメーター
@cindex diary group parameters

新しい日程グループを作るか、またはそれを開くと、@code{gnus-diary} は自動
的にグループパラメーターを検査し、必要なら概略行仕様を日程用に特化した値
に設定し、日程用の並べ替え関数を組み込み、さらにそのグループの投稿様
式 (posting-style) に種々の @code{X-Diary-*} ヘッダーを加えます。そして、
日程メッセージを送るのは、もっと簡単です。メッセージを用意するために、日
程グループで @kbd{C-u a} か @kbd{C-u m} を使うことによって、これらのヘッ
ダーが自動的に挿入されるので (まだ適切な値で満たされていませんが)。

@node Sending or Not Sending
@subsection 送信するべきか、しないべきか

さて、以上の説明をすべて読んでくれたものとして、以下は @code{nndiary} で
メールを送信することに関する、二つの最後の注意事項です:

@itemize @bullet
@item
@code{nndiary} は @emph{本当の} メールバックエンドです。本当にあなたは本
当の日程メッセージを本当に送ります。これは、日程メッセージを送ることによっ
て、誰にでも (彼らが Gnus と @code{nndiary} を使っているのならば) 予定を
伝えることができることをも意味します。
@item
しかしながら @code{nndiary} は @code{request-post} メソッドを持ってもい
るので、日程グループで @kbd{C-u m} の代わりに @kbd{C-u a} を使うことによっ
て、メッセージを実際に送信するのではなく、そのグループにローカルに格納す
ることもできます。これは個人的な予定のためには、とても役に立ちます。
@end itemize

@node Gnus Unplugged
@section Gnus の切り離し
@cindex offline
@cindex unplugged
@cindex agent
@cindex Gnus agent
@cindex Gnus unplugged

いにしえの時代 (およそ 1988年2月頃)、人々はニュースリーダーをネットワー
クに常時接続した大きなマシンで走らせていました。ニュースの配送はニュース
サーバーによって取り扱われ、すべてのニュースリーダーがすべきことはニュー
スを読むことであったのです。信じられないかもしれませんが。

今日では多くの人々は自宅でニュースやメールを読み、ネットワークに接続する
ためにモデムの類を使います。電話代の請求書が莫大なものに上らないように、
すべてのニュースとメールをすすり込んで電話を切り、数時間かけて読んでから
送りたい返信をすべて送信する、という手段を持つことは良いことでしょう。あ
とはこの手順を繰り返すのです。(訳注: この章の前身は 1997年頃に書かれまし
た。)

もちろん、これを行なうためにニュースサーバーを使うこともできます。私
は @code{inn} を @code{slurp}, @code{pop}, @code{sendmail} と一緒にここ
数年使ってきましたが、しかしこれは退屈な仕事です。もしあるマシン上でニュー
スを読む人があなたしかいなければ、ニュースサーバーの機能をニュースリーダー
に任せるようにすることは理にかなっています。

Gnus を「オフライン」のニュースリーダーとして仕立てるのは極めて簡単です。
実際、エージェントは今やディフォルトで有効になっている (@pxref{Agent
Variables, gnus-agent}) ので、あなたは何も設定する必要が無いのです。

もちろん、これをそんなふうに使うには、いくつか新しい命令を覚えなくてはな
りません。

@menu
* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               概略バッファーが変化するかもしれないエージェントの所業
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を追い払う方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and flags::             エージェントはどうフラグを維持するのか
* Agent and IMAP::              エージェントを @acronym{IMAP} で使う方法
* Outgoing Messages::           ニュースやメールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための @file{~/.gnus.el} の例
* Batching Agents::             @code{cron} ジョブでニュースを取得する方法
* Agent Caveats::               あなたが予想することと、それが実際にすること
@end menu

@node Agent Basics
@subsection エージェントの基礎

まず、いくつかの用語を片付けておきましょう。

ネットワークとの接続を切っているとき (かつエージェントにそのことを知らせ
てあるとき)、Gnus エージェントは @dfn{unplugged} です、と言います。ネッ
トワークとの接続が復活したら (かつ Gnus がそのことを知っていれば)、エー
ジェントは @dfn{plugged} です。

「ローカル」マシンとは、あなたがそこで作業しているもので、継続的にネット
ワークに接続されているわけではありません。

「ダウンロード」とは、あなたのローカルマシンに、何かをネットワークから取っ
てくることを意味します。「アップロード」はその逆をすることです。

ご存知のように Gnus はあなたがドジを踏むすべての機会を提供します。それを
柔軟性と言う人もいます。さらに Gnus は大いにカスタマイズ可能で、それは利
用者が、Gnus がどのように動作するかについて発言権を持っていることを意味
します。他のニュースリーダーは有無を言わずあなたにドジを踏ませるかもしれ
ませんが、Gnus ではあなたに選択権があります!

Gnus は実際には plugged または unplugged のどちらの状態にもありません。
もっと正確に言えば、サーバーごとにそれぞれの状態を持ちます。これは、いく
つかのサーバーが unplugged でも、他のサーバーは plugged になることができ
るということです。さらに、エージェントがいくつかのサーバーをまとめて無視
する (それらを常に plugged になっているように見せかける) ようにもできま
す。

さて、エージェントを unplugged にしたのに Gnus がネットに接続しているの
を疑問に思ったら、行なうべき次のステップはサーバーがすべてエージェント化
されているかどうかを確かめることです。エージェント化されていないサーバー
があったら、あなたは犯人を見つけたのです。

もう一つは「オフライン」という状態です。サーバーはときどき接続できなくな
ります。Gnus がこのことに気付くと、そのサーバーをオフラインの状態に切り
換えても良いかどうかを尋ねます。Yes と答えたならば (オンラインに戻して良
いかと Gnus が尋ねた場合以外は)、サーバーはいくらか unplugged だったとき
のように振る舞います。

エージェントを使った典型的な Gnus の対話操作を見てみましょう:

@itemize @bullet
@item
@findex gnus-unplugged
Gnus を @code{gnus-unplugged} で起動します。これは unplugged で Gnus エー
ジェントを立ち上げます。このモードでは、すでに取得しているニュース記事は
すべて読むことができます。

@item
次に、新しいニュースが到着しているかどうかを調べることにします。マシンを
ネットワークに (PPP か何かを使って) 接続してか
ら Gnus を @dfn{plugged} にするために @kbd{J j} を叩き、いつものように新
着メールを検査するために @kbd{g} を使います。Gnus エージェント
が unplugged になっているときに新着メールを検査するには、@ref{Mail
Source Specifiers} を参照してください。

@item
そうすれば、直ちに新しいニュースを読むこともできるし、ニュースをローカル
マシンにダウンロードすることもできます。後者を実行したいときは、
@kbd{g} を押して新しいニュースがあるかどうかを検査し、次に @kbd{J s} で
すべてのグループのすべての適格な (訳注: あなたが指定した条件に合致す
る) 記事を取得します。(どの記事をダウンロードしたいかを Gnus に指示する
には @ref{Agent Categories} を参照してください。)

@item
記事を取得した後で @kbd{J j} を押し、Gnus を再び unplugged にして、
PPP の接続 (か何か) を閉じます。その後でニュースをオフラインで読みます。

@item
そして第二ステップに戻ります。
@end itemize

エージェントを初めて使うときは (またはそのくらいの時期に)、以下のいくつ
かの作業をしなければなりません。

@itemize @bullet
@item
どのサーバーをエージェントで面倒を見るかを決めます。メールのバックエンド
をエージェントに面倒を見させるのはおそらく無意味でしょう。サーバーバッ
ファーに移動し (グループバッファーで @kbd{^})、エージェントに扱って欲し
いサーバー (複数可) で @kbd{J a} を押す (@pxref{Server Agent
Commands}) か、またはエージェントに扱って欲しくないのに自動的に追加され
たサーバーで @kbd{J r} を押します。ディフォルトではどのタイプのサーバー
もエージェント化されません。

@item
ダウンロード方針を決定します。あなたの方針を実装するために、エージェント
分類、トピックパラメーター、グループパラメーターのどれを使うかをいったん
決めてしまえば、これはかなり簡単です。あなたが Gnus の初心者ならば、たぶ
ん分類で始めるのが最良でしょう、@xref{Agent Categories}.

トピックパラメーター (@pxref{Topic Parameters}) とエージェント分
類 (@pxref{Agent Categories}) の両方とも、多数のグループに適用する方針の
設定を用意しています。どれを使うかは完全にあなたの責任です。両方を混ぜて
使う場合は、トピックパラメーターは分類を無効にすることを考慮に入れなけれ
ばならないでしょう。あなたの方針にそぐわない少数のグループがあるのならば、
それらの設定を変更するためにグループパラメー
ター (@pxref{Group Parameters}) を使うことができます。

@item
ええと@dots{}、以上です。
@end itemize

@node Agent Categories
@subsection エージェント分類

ニュースを配送する機構をニュースリーダーに統合する主要な理由の一つは、ど
の記事をダウンロードするかについて、もっと強力に制御できるようにすること
です。莫大な量の記事をダウンロードすることにあまり意味はなく、それらを読
んでもあまり面白くないことが分かるだけです。何をダウンロードするかの選択
ではもう少し保守的になって、その記事がやっぱり面白そうだとわかったら、主
動でダウンロードするための印を付ける方がすぐれています。

何をダウンロードするかを制御するためのより有効な方法の一つは、分
類 (@dfn{category}) を作成して、その分類にいくつか (または全部) のグルー
プを割り当てることです。どんな分類にも属さないグループは「ディフォルト」
の分類に属します。Gnus は分類の作成と管理のための独自のバッファーを持っ
ています。

もしそうしたければ、グループパラメーター (@pxref{Group Parameters}) とト
ピックパラメーター (@pxref{Topic Parameters}) を、エージェントを制御する
代替手段に使うことができます。実際に違うのは、グループとトピックパラメー
ターが何でもかんでも (kitchen sink) 含むのに対して、分類はエージェントに
特化している (したがってあまり学ばなくても良い) ということだけです。

エージェントパラメーターは複数の違う場所で設定することができるので、どの
ソースが信用できるかを決めるための規則を設けました。この規則は、パラメー
ターのソースが次の順序で調べられることを定めます: グループパラメーター、
トピックパラメーター、エージェント分類、そして最後はカスタマイズできる変
数群です。したがって、広い範囲で動作を起こさせるためにこれらのソースをす
べて混合することができます。どこに設定を置いたのかを忘れてしまったからと
いって、私を責めないでくださいよ。

@menu
* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス
@end menu

@node Category Syntax
@subsubsection 分類の文法

分類は、名前、その分類に属するグループのリスト、およびカスタマイズ可能な
変数よりも優先される多くの任意なパラメーターから成ります。エージェントパ
ラメーターの完全なリストを以下に示します。

@cindex Agent Parameters
@table @code
@item agent-groups
この分類にあるグループのリスト。

@item agent-predicate
(通常) どの記事をダウンロードするのが適当かという大まかな輪郭を与える述
語。そして

@item agent-score
(通常) どの記事をダウンロードするかを決めるときのよりきめの細かいスコア
規則。(このダウンロードスコア (@dfn{download score}) は通常のスコアとは
必ずしも関係が無いことに注意してください。)

@item agent-enable-expiration
このグループの古い記事をエージェントが期限切れ消去すべきかどうかを示す
ブール変数。大抵のグループはディスク空間を浪費しないために期限切れ消去さ
れるべきです。いや、実際には gnus.* 階層は期限切れ消去されるべきではな
いグループだけを含んでいると言っても、たぶん差し支えありません。

@item agent-days-until-old
既読の記事を期限切れ消去しても差し支えないことを判断する前に、エージェン
トが待っているべき日数を示す整数。

@item agent-low-score
@code{gnus-agent-low-score} よりも優先される整数。

@item agent-high-score
@code{gnus-agent-high-score} よりも優先される整数。

@item agent-short-article
@code{gnus-agent-short-article} よりも優先される整数。

@item agent-long-article
@code{gnus-agent-long-article} よりも優先される整数。

@item agent-enable-undownloaded-faces
ダウンロードされていない記事
を @code{gnus-summary-*-undownloaded-face} のフェース群を使って概略バッ
ファーに表示すべきかどうかを示すシンボル。@code{nil} 以外ならどんなシン
ボルでも、ダウンロードされていない記事用のフェースを使うようになります。
@end table

いったん分類が作られたら、分類の名前を変えることはできません。

それぞれの分類は、その分類の排他的な (他の分類には無い) メンバーであるグ
ループのリストを維持します。排他規則は自動的に執行され、新しい分類にグルー
プを追加すると、それは古い分類から自動的に取り除かれます。

述語の一番単純な形式は @code{true} や @code{false} のような単独の述語か
らなります。これらの二つはそれぞれ、すべての可能な記事をダウンロードする
か、まったく何もしないか、です。これらの二つの特別な述語の場合は、追加の
スコア規則は不要です。

@code{high} や @code{low} という述語は下で説明されているように、
@code{gnus-agent-high-score} と @code{gnus-agent-low-score} との記事のス
コアとの関係により記事をダウンロードします。

何をもってダウンロードすることが適格だと見なされるかについて、さらに細か
い制御を得るために、述語は論理演算子が間に散りばめられた述語の組み合わせ
からなることができます。

おそらくいくつかの例が必要でしょう。

以下は簡単な述語です。(これはディフォルトの述語です。実際に他のどの分類
にも含まれないすべてのグループに対して使用されます。)

@lisp
short
@end lisp

とっても簡単でしょ? この述語は、記事が短い (「短い」ことを意味する何らか
の価値がある) 場合に限り真になります。

これはもっと複雑な述語です:

@lisp
(or high
    (and
     (not low)
     (not long)))
@end lisp

この意味は、高いスコアを持っているか、あるいはスコアが低くなくてかつ長く
ない、という記事をダウンロードする、ということです。様子はわかりましたね。

使ってもよい論理演算子は @code{or}, @code{and} および @code{not} です。
(もし使いたければ、より“C”風の演算子 @samp{|}, @code{&}, @code{!} を代
りに使うことができます。)

以下の述語があらかじめ定義されていますが、これらのどれもあなたのやりたい
ことに適さなければ、自分で独自のものを書くこともできます。

それぞれのこれらの述語を評価するとき、名前が付けられた定数は、適切なパラ
メーターを与えて @code{gnus-agent-find-parameter} を呼ぶことによって決定
される値に束縛されます。例え
ば gnus-agent-short-article は @code{(gnus-agent-find-parameter group
'agent-short-article)} に束縛されます。これは、あなたの分類で述語を指定
してから、その述語を個々のグループについて調整できることを意味します。

@table @code
@item short
記事が @code{gnus-agent-short-article} の行数より短かければ真です。ディ
フォルトは 100 です。

@item long
記事が @code{gnus-agent-long-article} の行数より長ければ真です。ディフォ
ルトは 200 です。

@item low
記事のダウンロードスコアが @code{gnus-agent-low-score} の値より小さけれ
ば真です。ディフォルトは 0 です。

@item high
記事のダウンロードスコアが @code{gnus-agent-high-score} の値より大きけれ
ば真です。ディフォルトは 0 です。

@item spam
Gnus エージェントがその記事を spam だと推測した場合に真です。この検出法
は今後変更されるかもしれませんが。現時点では、これはチェックサムを計算し、
記事が一致するかどうかを調べているだけです。

@item true
常に真です。

@item false
常に偽です。
@end table

独自の述語関数を作成したければ、このことを知っておかなければなりませ
ん: 関数は引数無しで呼び出されますが、
@code{gnus-headers} と @code{gnus-score} という動的な変数が有意な値に束
縛されるということを。

例えば、一定の日数以上前に投稿された記事 (例え
ば @code{gnus-agent-expire-days} の日数以上前に投稿されたもの) をダウン
ロードしないと決断することもできます。その場合、以下のような関数を書いて、

@lisp
(defun my-article-old-p ()
  "Say whether an article is old."
  (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
     (- (time-to-days nil) gnus-agent-expire-days)))
@end lisp

そして述語はこのように定義すれば良いでしょう:

@lisp
(not my-article-old-p)
@end lisp

もしくは @file{~/.gnus.el} か何かで、あらかじめ定義されてい
る @code{gnus-category-predicate-list} の値に、自分の述語を追加すること
もできます。

@lisp
(require 'gnus-agent)
(setq gnus-category-predicate-alist
      (append gnus-category-predicate-alist
              '((old . my-article-old-p))))
@end lisp

この場合は、次のように述語を指定するだけです:

@lisp
(not old)
@end lisp

上のようなものを使うときは、世の中には正しく設定されていないシステム/メー
ラーがあり、記事の日付はいつ投稿されたかを常に確実に示すわけではないこと
を知っていてください。困ったことに、それを少しも気にかけない人もいるんで
す。

上記の述語はその分類に属する @emph{すべて} のグループに適用されます。し
かし、分類中の個々のグループのための特定の述語を設定したかったり、単に不
精を決め込んで新しい分類を設定したくないのならば、グループの個々の述語を
次のようにグループパラメーターに入れることができます:

@lisp
(agent-predicate . short)
@end lisp

これは agent 分類のディフォルトと等価なグループ/トピックパラメーターです。
このように単一の語で述語を指定するときは、@code{agent-predicate} の設定
値はドット対で表記しなければならないことに注意してください。

上のものと等価な長い方の例はこうなるでしょう:

@lisp
(agent-predicate or high (and (not low) (not long)))
@end lisp

述語の値がドット対で表記されていなくて、その値はリストだと仮定されるので、
分類の設定で要求される外側の括弧が、ここでは入れられません。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じですが、
例外があります。記事そのものを実際に調べる必要がある要素は厳禁です。つま
り、以下のヘッダーだけがスコア付けできるということです: @code{Subject},
@code{From}, @code{Date}, @code{Message-ID}, @code{References},
@code{Chars}, @code{Lines} および @code{Xref}。

述語の場合のように、@code{ダウンロードスコア規則} の設定は、それをグルー
プに関して使う限りは、そこのすべてのグループに適用できるものならば分類の
定義、グループに特有ならばグループパラメーター、のどちらかにできます。

これら両方の場所で、@code{ダウンロードスコア規則} は以下の三つの形式の一
つを取ることができます:

@enumerate
@item
スコア規則

上で書かれているように、スコア付けキーワードの一部分しか使えないことを除
けば、これは普通の Gnus スコアファイルの構文と同じです。

例:

@itemize @bullet
@item
分類指定

@lisp
(("from"
       ("Lars Ingebrigtsen" 1000000 nil s))
("lines"
       (500 -100 nil <)))
@end lisp

@item
グループ/トピックパラメーター指定

@lisp
(agent-score ("from"
                   ("Lars Ingebrigtsen" 1000000 nil s))
             ("lines"
                   (500 -100 nil <)))
@end lisp

ここでも一番外側の括弧が省略されていることに注意してください。
@end itemize

@item
エージェントスコアファイル

これらのスコアファイルは、上で述べられている使用可能なスコア付けキーワー
ド @emph{だけ} を含んでいなければなりません。

例:

@itemize @bullet
@item
分類指定

@lisp
("~/News/agent.SCORE")
@end lisp

または、もしかすると

@lisp
("~/News/agent.SCORE" "~/News/agent.group.SCORE")
@end lisp

@item
グループパラメーター指定

@lisp
(agent-score "~/News/agent.SCORE")
@end lisp

ここでも前述のように、追加のスコアファイルを指定することができます。括弧
について言わなければいけませんか?
@end itemize

@item
@code{普通} のスコアファイルの使用

あるグループのためにあなたが望んだ「ダウンロード」の基準が、「読む」基準
と同じならば、一つのグループのために二つのスコア規則を維持管理したいとは
思わないでしょう。そういう場合は、何をダウンロードするかを決める際に、エー
ジェントに @code{普通} のスコアファイルを参照させることができます。

分類の定義やグループパラメーターでこれらの指示を行なうと、エージェントは
あるグループに適用することができるすべてのスコアファイルを読み込んで、使
うことが許されているスコア付けキーワードの副セットではない項目
を @emph{選別して取り除きます}。

@itemize @bullet
@item
分類指定

@lisp
file
@end lisp

@item
グループパラメーター指定

@lisp
(agent-score . file)
@end lisp
@end itemize
@end enumerate

@node Category Buffer
@subsubsection 分類バッファー

通常すべての分類は分類バッファーから管理します。これに (グループバッファー
で @kbd{J c} 命令を使って) 初めて入ると、ディフォルトの分類だけが表示さ
れます。

このバッファーでは以下の命令を使うことができます:

@table @kbd
@item q
@kindex q @r{(分類)}
@findex gnus-category-exit
グループバッファーに戻ります (@code{gnus-category-exit})。

@item e
@kindex e @r{(分類)}
@findex gnus-category-customize-category
選択された分類のパラメーターを一括して設定するために、カスタマイズバッファー
を使います (@code{gnus-category-customize-category})。

@item k
@kindex k @r{(分類)}
@findex gnus-category-kill
現在の分類を消去します (@code{gnus-category-kill})。

@item c
@kindex c @r{(分類)}
@findex gnus-category-copy
現在の分類を複製します (@code{gnus-category-copy})。

@item a
@kindex a @r{(分類)}
@findex gnus-category-add
新しい分類を追加します (@code{gnus-category-add})。

@item p
@kindex p @r{(分類)}
@findex gnus-category-edit-predicate
現在の分類の述語を編集します (@code{gnus-category-edit-predicate})。

@item g
@kindex g @r{(分類)}
@findex gnus-category-edit-groups
現在の分類に属するグループのリストを編集しま
す (@code{gnus-category-edit-groups})。

@item s
@kindex s @r{(分類)}
@findex gnus-category-edit-score
現在の分類のダウンロードスコア規則を編集しま
す (@code{gnus-category-edit-score})。

@item l
@kindex l @r{(分類)}
@findex gnus-category-list
すべての分類を表示します (@code{gnus-category-list})。
@end table

@node Category Variables
@subsubsection 分類変数

@table @code
@item gnus-category-mode-hook
@vindex gnus-category-mode-hook
分類バッファーで実行するフックです。

@item gnus-category-line-format
@vindex gnus-category-line-format
分類バッファーの行様式です (@pxref{Formatting Variables})。有効な要素は:

@table @samp
@item c
分類の名前です。

@item g
その分類に属するグループの数です。
@end table

@item gnus-category-mode-line-format
@vindex gnus-category-mode-line-format
分類モード行の様式です (@pxref{Mode Line Formatting})。

@item gnus-agent-short-article
@vindex gnus-agent-short-article
この値より少ない行数の記事は短いと見なします。ディフォルトは 100 です。

@item gnus-agent-long-article
@vindex gnus-agent-long-article
この値より多い行数の記事は長いと見なします。ディフォルトは 200 です。

@item gnus-agent-low-score
@vindex gnus-agent-low-score
この値より小さいスコアを持つ記事は低スコアだと見なします。ディフォルト
は 0 です。

@item gnus-agent-high-score
@vindex gnus-agent-high-score
この値より大きいスコアを持つ記事は高スコアだと見なします。ディフォルト
は 0 です。

@item gnus-agent-expire-days
@vindex gnus-agent-expire-days
期限切れ消去する前に、既読記事をエージェントのローカルディスクに留めてお
かなければならない日数 (「期限切れ消去」という名前は同じですが、サーバー
で期限切れ消去することではありません。単に記事のローカルな複製を消すこと
を意味します)。さらに理解すべき大事なことは、記事が読まれた時ではなくロー
カルディスクに記事が書かれた時から計数が始まるということです。ディフォル
トは 7日です。

@item gnus-agent-enable-expiration
@vindex gnus-agent-enable-expiration
グループの記事が、ディフォルトで期限切れ消去されるか、無期限に保持される
かを決定します。ディフォルトは @code{ENABLE} で、あなたが望むならば期限
切れ消去をさせないようにしなければならないことを意味します。一方、これ
を @code{DISABLE} に設定することができます。その場合、選択されたグループ
での期限切れ消去を有効にしなければなりません。
@end table

@node Agent Commands
@subsection エージェント命令
@findex gnus-agent-toggle-plugged
@kindex J j @r{(エージェント)}

すべての Gnus エージェント命令は @kbd{J} サブマップにあります。
@kbd{J j} (@code{gnus-agent-toggle-plugged}) 命令はすべてのモードで動作
し、Gnus エージェントの plugged/unplugged 状態を切り替えます。

@menu
* Group Agent Commands::        グループを設定してそれらの記事を取得する
* Summary Agent Commands::      手動で記事を選択し、指定した取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択
@end menu

@node Group Agent Commands
@subsubsection グループエージェント命令

@table @kbd
@item J u
@kindex J u @r{(エージェント グループ)}
@findex gnus-agent-fetch-groups
現在のグループの適格な (訳注: あなたが指定した条件に合致する) 記事をすべ
て取得します (@code{gnus-agent-fetch-groups})。

@item J c
@kindex J c @r{(エージェント グループ)}
@findex gnus-enter-category-buffer
エージェント分類バッファーに入ります (@code{gnus-enter-category-buffer})。

@item J s
@kindex J s @r{(エージェント グループ)}
@findex gnus-agent-fetch-session
全グループの適格な (訳注: あなたが指定した条件に合致する) 記事をすべて取
得します (@code{gnus-agent-fetch-session})。

@item J S
@kindex J S @r{(エージェント グループ)}
@findex gnus-group-send-queue
順番待ち (queue) グループにある送信可能なメッセージをすべて送信しま
す (@code{gnus-group-send-queue})。@xref{Drafts}.

@item J a
@kindex J a @r{(エージェント グループ)}
@findex gnus-agent-add-group
現在のグループをエージェント分類に追加しま
す (@code{gnus-agent-add-group})。この命令はプロセス/接頭引数の習慣を理
解します (@pxref{Process/Prefix})。

@item J r
@kindex J r @r{(エージェント グループ)}
@findex gnus-agent-remove-group
現在のグループを、もし存在していれば、その分類から消去しま
す (@code{gnus-agent-remove-group})。この命令はプロセス/接頭引数の習慣を
理解します。(@pxref{Process/Prefix})。

@item J Y
@kindex J Y @r{(エージェント グループ)}
@findex gnus-agent-synchronize-flags
リモートサーバーが unplugged のときに変更されたフラグがあれば同期させま
す。
@end table

@node Summary Agent Commands
@subsubsection 概略エージェント命令

@table @kbd
@item J #
@kindex J # @r{(エージェント 概略)}
@findex gnus-agent-mark-article
記事にダウンロード印を付けます (@code{gnus-agent-mark-article})。

@item J M-#
@kindex J M-# @r{(エージェント 概略)}
@findex gnus-agent-unmark-article
記事からダウンロード印を消去します (@code{gnus-agent-unmark-article})。

@cindex %
@item @@
@kindex @@ @r{(エージェント 概略)}
@findex gnus-agent-toggle-mark
記事をダウンロードするかどうかを切り替えま
す (@code{gnus-agent-toggle-mark})。ディフォルトではダウンロードの印
は @samp{%} です。

@item J c
@kindex J c @r{(エージェント 概略)}
@findex gnus-agent-catchup
キャッシュされていない、ダウンロードされていない、またはダウンロードでき
ないすべての記事を既読にします (@code{gnus-agent-catchup})。

@item J S
@kindex J S @r{(エージェント 概略)}
@findex gnus-agent-fetch-group
このグループのすべての望ましい (訳注: あなたが指定した条件に合致する) 記
事 (@pxref{Agent Categories}) をダウンロードしま
す。(@code{gnus-agent-fetch-group})。

@item J s
@kindex J s @r{(エージェント 概略)}
@findex gnus-agent-summary-fetch-series
このグループのすべてのプロセス印が付いた記事をダウンロードしま
す。(@code{gnus-agent-summary-fetch-series})。

@item J u
@kindex J u @r{(エージェント 概略)}
@findex gnus-agent-summary-fetch-group
現在のグループのダウンロード可能な記事を、すべてダウンロードしま
す (@code{gnus-agent-summary-fetch-group})。
@end table

@node Server Agent Commands
@subsubsection サーバーエージェント命令

@table @kbd
@item J a
@kindex J a @r{(エージェント サーバー)}
@findex gnus-agent-add-server
現在のサーバーを Gnus エージェントで扱われるサーバーのリストに追加しま
す (@code{gnus-agent-add-server})。

@item J r
@kindex J r @r{(エージェント サーバー)}
@findex gnus-agent-remove-server
現在のサーバーを Gnus エージェントで扱われるサーバーのリストから削除しま
す (@code{gnus-agent-remove-server})。
@end table

@node Agent Visuals
@subsection エージェントの視覚効果

Unplugged のときに概略を開くと、現在エージェントに格納されているヘッダー
よりも多くの記事があることを Gnus がそのグループの active (訳注: 何番か
ら何番までの記事があるかを示す管理情報) の範囲から知っている場合には、表
題が @samp{[Undownloaded article #####]} のようになっているいくつかの記
事を見るかもしれません。それらは見当たらないヘッダーのための穴埋
め (placeholders) です。印を設定することは別として、それらの穴埋めの一つ
でできることは多くはありません。最終的に Gnus がグループのヘッダーを取っ
て来る機会を得たときに、それらの穴埋めは実際のヘッダーで自動的に置き換え
られるでしょう。気になるならば、それらの穴埋めを読み飛ばすために、概略バッ
ファーの動作を操作することができます (@code{gnus-auto-goto-ignores} 参照)。

すべての人にとって明白かもしれませんが、オフラインのときに利用できるのは、
plugged だった期間にエージェントに取り込まれたヘッダーと記事だけです。言
い換えると「plugged だった期間に取り込むことを忘れると、オフラインのセッ
ションを満足できるものにするには足りない」ということです。この理由のため
に、エージェントは概略バッファーに二つの視覚効果を加えます。これらの効果
は、オフラインのときにどの記事が利用できるかをいつも知らせるために、それ
ぞれの記事のダウンロードの状態を表示します。

第一の視覚効果は @samp{%O} 仕様です。@code{gnus-summary-line-format} を
カスタマイズしてこの指示子を含めると、記事のダウンロードの状態を示すため
に単一の文字を表示する場所が加わります。エージェントかキャッシュのどちら
かに取り込まれた記事は、@code{gnus-downloaded-mark} (ディフォルト
は @samp{+}) を表示します。それら以外のすべての記事
は @code{gnus-undownloaded-mark} (ディフォルトは @samp{-}) を表示します。
エージェント化されていないグループを開くと、空白 (@samp{ }) が表示されま
す。

第二の視覚効果はダウンロードされていないことを示すフェースです。多く
の Gnus の利用者に好感と嫌悪をもたらすであろう、記事のスコアを三段
階 (low, normal, high) で表示するフェースがあります。問題は、フェースの
選択が条件検査とフェース名のリスト (@code{gnus-summary-highlight} 参
照) によって制御されることです。それぞれの条件は、それがリストの中に現れ
る順に検査されるので、後の条件よりも前の条件が優先されます。これが意味す
るすべては、ダウンロードされていない記事に可視記事 (ticked) の印を付けて
も、その記事は可視記事のフェースではなくて、ダウンロードされていない記事
のフェースで表示し続けられるということです。

(記事を読むたびに同じ記事をダウンロードしないようにするため、または接続
時間を最小にするために) エージェントをキャッシュとして使う場合は、ダウン
ロードされていない記事のフェースはおそらく良い考えのように思えるでしょう。
ダウンロードされた記事に対してすべての仕事 (印を付ける、読む、削除す
る) を行なえば、いつも通常のフェースが現れるからです。しかし、
@acronym{NOV} をキャッシュすることによってオンライン性能を改善するために
エージェントを使っている利用者にとっては (Gnus 5.10.2 以降のほとんどの利
用者にとっては)、ダウンロードされていない記事のフェースが見えるかもしれ
ないことは、まったくひどいものでしょう。これは、それらのどの記事もエージェ
ントに取り込まれていないので、ダウンロードされていない記事のフェースのた
めに、すべての普通のフェースが目立たなくなってしまうだろうという問題です。

ダウンロードされていない記事のフェースを使いたい場合は、
@code{agent-enable-undownloaded-faces} グループパラメーター
を @code{t} に設定して、ダウンロードされていない記事のフェースを有効にし
なければなりません。このパラメーターは他のすべてのエージェントパラメーター
と同様に、エージェント分類 (@pxref{Agent Categories})、グループトピッ
ク (@pxref{Topic Parameters})、あるいは個々のグルー
プ (@pxref{Group Parameters}) に対して設定することができます。

エージェントを使うすべての利用者に共通した一つの問題は、それがディスクの
容量をいかに速く使い尽くすことができるかということです。あなたが多くのグ
ループでエージェントを使っている場合、事実上ディスク容量を回復することは
さらにもっと困難です。一つの解決手段は @code{gnus-group-line-format} で
用意されている @samp{%F} 形式です。この形式は、エージェントとキャッシュ
の両方で取得した記事によって占められる実際のディスク容量を表示します。ど
のグループが最も多い容量を使うかを知ることによって、利用者は記事を「エー
ジェント期限切れ消去」する場合に、どこに努力を集中するべきかがわかります。

@node Agent as Cache
@subsection キャッシュとしてのエージェント

Gnus が plugged であるときに、すでにヘッダーや記事がエージェントに格納さ
れているのならば、それらを再びダウンロードするのは効率的ではありません。
そのため Gnus は通常ヘッダーを一回だけダウンロードしてエージェントに格納
します。それらのヘッダーは後に概略バッファーを生成するときに、
plugged か unplugged にかかわらずに使われます。ディフォルトでは記事
は (それはたくさんのディスク容量を浪費するかもしれないので) エージェント
にキャッシュされませんが、すでにエージェントにダウンロードした記事がある
ならば、Gnus はサーバーから再び記事をダウンロードせずに、手元に格納され
たコピーを使います。

あなたがそう望むのであれば、plugged な期間は常にヘッダーと記事をダウンロー
ドするように、エージェント (@code{gnus-agent-cache} 参照 @ref{Agent
Variables}) を設定することができます。Gnus はほとんど確かにもっと遅くな
りますが、サーバーとの同期は保たれます。nntp か nnimap バックエンドを使っ
ている場合は、たぶんこの最後の点は意味をなさないでしょう。

@node Agent Expiry
@subsection エージェント期限切れ消去

@vindex gnus-agent-expire-days
@findex gnus-agent-expire
@findex gnus-agent-expire-group
@cindex agent expiry
@cindex Gnus agent expiry
@cindex expiry, in Gnus agent

エージェントバックエンド @code{nnagent} は期限切れ消去を扱いません。えー
と、少なくとも他のバックエンドのようにそれを扱いません。その代わりに、
@code{gnus-agent-expire-days} の日数よりも古い既読記事をすべて消去する、
特別な @code{gnus-agent-expire} と @code{gnus-agent-expire-group} 命令が
あります。これらはあなたがディスク容量を使い切りそうだと思ったときに、い
つでも実行することができます。どちらも特に速くも効率的でもなく、それらの
一つをいったん始めてしまったら (@kbd{C-g} やその他で) 中断することもあま
り良いことではありません。

他の関数がエージェントをグループに同期させるため
に @code{gnus-agent-expire} を実行するかもしれないことに注意してください。

@code{agent-enable-expiration} というエージェントのパラメーターを、選択
したグループでの期限切れ消去を抑制するために使うことができます。

@vindex gnus-agent-expire-all
@code{gnus-agent-expire-all} が @code{nil} でなければ、エージェントの期
限切れ消去コマンド群はすべての記事---未読、既読、可視、保留記事を消去し
ます。もし @code{nil} (これがディフォルト) であれば、既読記事のみが消去
の対象となり、未読、可視、さらに保留記事は無期限に保持されます。

期限切れ消去されるはずなのに残っている記事を見つけたならば、もしかすると
いくつかの Gnus エージェントファイルが壊れています。起こりうる問題を修復
するために、
@code{gnus-agent-regenerate} と @code{gnus-agent-regenerate-group} とい
う特別なコマンドがあります。

@node Agent Regeneration
@subsection エージェントを作り直す
@cindex agent regeneration
@cindex Gnus agent regeneration
@cindex regeneration

@code{nnagent} によって使われるローカルのデータ構造は、ある例外的な条件
によっておかしくなってしまうかもしれません。これが起こる
と @code{nnagent} の機能性が下がるかもしれないし、失敗しさえするかもしれ
ません。この問題の解決策は、内部の矛盾をすべて削除することによって、ロー
カルのデータ構造を修復することです。

例えば、記事をエージェントにダウンロードしている間にサーバーへの接続が切
れてしまう場合、ローカルのデータ構造は接続が切れる前に記事が首尾良くダウ
ンロードされたかどうかを知りません。@code{gnus-agent-regenerate} また
は @code{gnus-agent-regenerate-group} を実行すると、そのような記事を二回
ダウンロードしなくても済むようにデータ構造を更新します。

@findex gnus-agent-regenerate
@code{gnus-agent-regenerate} コマンドは、すべてのエージェント化されたグ
ループで @code{gnus-agent-regenerate-group} を実行します。どのバッファー
上でも @code{gnus-agent-regenerate} を実行することができますが、最初にす
べての概略バッファーを閉じることを強く勧めます。

@findex gnus-agent-regenerate-group
@code{gnus-agent-regenerate-group} コマンドは、ローカル
の @acronym{NOV} (ヘッダー) データベースを修復するために、個々の記事のロー
カルなコピーを使います。その後それは、どの記事がローカルに格納されるかを
記録しておくための内部データ構造を更新します。引数を与えると、エージェン
トの中の記事に未読の印を付けます。

@node Agent and flags
@subsection エージェントとフラグ

エージェントは Gnus のどんなバックエンドでも、例えばサーバーにフラグ (既
読(read)、可視(ticked) など) を格納する nnimap のようなものでも動作しま
す。しかし悲しいかな、エージェントはどのバックンドがそれらのフラグ
を @file{.newsrc} ではなく、そのバックエンドのサーバーで維持するかを、実
際には知りません。そのためエージェントは、unplugged または接続されていな
い間に行なったすべてのフラグへの変更を、常に自身のファイルに記録します。

再び接続すると、Gnus は変更されたすべてのフラグを検査して、それらをサー
バーと同期させるかどうかを尋ねます。この挙動
は @code{gnus-agent-synchronize-flags} でカスタマイズすることができます。

@vindex gnus-agent-synchronize-flags
@code{gnus-agent-synchronize-flags} が @code{nil} だったら、エージェント
は自動的にフラグを同期させることはしません。それがディフォルト
の @code{ask} だったら、エージェントはあなたが再接続したときにあなたが何
らかの変更を行なっていたかどうかを調べて、もしそうだったら、それらを同期
させたいかどうかを尋ねます。それら以外の値だった場合は、すべてのフラグは
自動的に同期させられます。

再接続したときに自動でフラグを同期させたくないなら、手動でそれを行なうこ
ともできます。これにはグループバッファーの @kbd{J Y} キーに割り当てられ
た @code{gnus-agent-synchronize-flags} コマンドを使ってください。

技術的注釈: すべてのローカルなフラグをサーバーに「押し込む」同期のアルゴ
リズムは動作しませんが、利用者によって変更されたフラグだけを変更して、サー
バー側で見えるフラグを一つずつ更新することは可能です。したがって、あなた
が記事の一つのフラグをセットして、そのグループを抜け出てから再度そのグルー
プを選択してそのフラグを消せば、あなたが「同期」の操作を行なったときに、
そのフラグはセットされてサーバーからは削除されます。順番待ち (queue) に
入れられたフラグに関する動作は、エージェントディレクトリーにあるサーバー
毎の @code{flags} ファイルの中で見つかるでしょう。それらはあなたがフラグ
を同期させたときに空になります。

@node Agent and IMAP
@subsection エージェントを IMAP で使う方法

エージェントは nnimap を含む Gnus のどんなバックエンドでも動作します。し
かし @acronym{NNTP} と @acronym{IMAP} にはいくつかの概念の違いがあるので、
この章ではサーバーとの接続が絶たれたモードでの @acronym{IMAP} のクライア
ントとして、Gnus エージェントをより円滑に使えるようにするための、いくつ
かの情報を提供します。

サーバーとの接続が絶たれているときの @acronym{IMAP} クライアントにあなた
が期待するであろういくつかの機能は、現在のエージェントには盛り込まれてい
ません。それらは以下の通りです:

@itemize @bullet
@item
Unplugged のときの nnimap グループへのコピーと移動。

@item
Unplugged のときの nnimap グループの作成と削除。
@end itemize

@node Outgoing Messages
@subsection 差出用メッセージ

Gnus が unplugged のとき、ディフォルトではすべての差出用メッセージ (メー
ルとニュースの両方) は下書きグループ“queue”(@pxref{Drafts}) に格納され
ます。投稿した後でも、そこでそのメッセージを見たり編集するのは意のままで
す。

送出するメールが queue される (順番待ちになる) 状況を制御することは可能
です (@code{gnus-agent-queue-mail}, @ref{Agent Variables} 参照)。
Gnus が unplugged のとき、外に送り出すニュースは常に queue されるだけで
す。

下書きグループから、そこで使える特別な命令を使ってメッセージを送信するこ
ともできるし、グループバッファー内で @kbd{J S} を使って、下書きグループ
内のすべての送信可能なメッセージを送信することもできます。ニュースの投稿
は Gnus が plugged のときだけできますが、メールはいつでも送信することが
できます。

Unplugged のときにメールの送信ができなくて、かつ unplugged のときにうっ
かり @kbd{J S} を叩いてしまうことが心配ならば、Gnus にあなたの行動を確認
させることができます (@code{gnus-agent-prompt-send-queue}, @ref{Agent
Variables} 参照)。

@node Agent Variables
@subsection エージェント変数

@table @code
@item gnus-agent
@vindex gnus-agent
エージェントが有効になっているかどうか。ディフォルトは @code{t} です。最
初に有効にされると、いくつかのバックエンドを自動的にエージェント化するた
めに、エージェントは @code{gnus-agent-auto-agentize-methods} を使います。
サーバーバッファーでエージェントのコマンドを使うことによって、どのバック
エンドをエージェント化するかを変更することができます。

サーバーバッファーに入るには、グループバッファー
で @kbd{^} (@code{gnus-group-enter-server-mode}) を使ってください。

@item gnus-agent-directory
@vindex gnus-agent-directory
Gnus エージェントがファイルを格納する場所です。ディフォルト
は @file{~/News/agent/} です。

@item gnus-agent-handle-level
@vindex gnus-agent-handle-level
この変数の値より高いレベル (@pxref{Group Levels}) のグループは、エージェ
ントからは無視されます。ディフォルトは @code{gnus-level-subscribed} で、
これはディフォルトでは、購読しているグループのみがエージェントの処理の対
象となるということです。

@item gnus-agent-plugged-hook
@vindex gnus-agent-plugged-hook
ネットワークに接続されたときに実行されるフックです。

@item gnus-agent-unplugged-hook
@vindex gnus-agent-unplugged-hook
ネットワークから切断されたときに実行されるフックです。

@item gnus-agent-fetched-hook
@vindex gnus-agent-fetched-hook
記事を取り込み終わったときに実行されるフックです。

@item gnus-agent-cache
@vindex gnus-agent-cache
Plugged のときに、ローカルに格納されている @acronym{NOV} と記事を使うか
どうかを制御する変数で、例えばエージェントをキャッシュとして使うには必須
です。ディフォルトでは非-@code{nil} で、エージェントをキャッシュとして使
います。

@item gnus-agent-go-online
@vindex gnus-agent-go-online
@code{gnus-agent-go-online} が @code{nil} だったら、エージェントはオフラ
イン状態のサーバーをオンライン状態にしません。@code{ask} だったら、それ
がディフォルトですが、エージェントは再接続するときにオフライン状態のサー
バーをオンライン状態にしたいかどうかを尋ねます。それ以外の値だったら、オ
フライン状態のサーバーは自動的にオンライン状態になります。

@item gnus-agent-mark-unread-after-downloaded
@vindex gnus-agent-mark-unread-after-downloaded
@code{gnus-agent-mark-unread-after-downloaded} が 非-@code{nil} だったら、
ダウンロードした後で記事に未読の印を付けます。これは通常、新しくダウンロー
ドされた記事を明確に未読にするための安全な行為です。ディフォルト
は @code{t} です。

@item gnus-agent-synchronize-flags
@vindex gnus-agent-synchronize-flags
@code{gnus-agent-synchronize-flags} が @code{nil} だったら、エージェント
は決して自動的にフラグを同期させません。それが @code{ask} だったら (それ
がディフォルトです)、エージェントはすべての変更を検査して、再び接続した
ときにそれらを同期させるかどうかを尋ねます。@code{nil} で
も @code{ask} でもなかったら、すべてのフラグが自動的に同期させられます。

@item gnus-agent-consider-all-articles
@vindex gnus-agent-consider-all-articles
@code{gnus-agent-consider-all-articles} が非-@code{nil} だったら、エージェ
ントはすべての記事について、それらをダウンロードする必要があるかどうかを
エージェントの述語に決定させます。@code{nil} だった場合、それがディフォ
ルトですが、エージェントは未読の記事をダウンロードするかどうかだけを述語
に決定させます。これを有効にするのならば、後でエージェントが期限切れ消去
する記事を何度も繰り返しダウンロードしないように、エージェントの期限切れ
消去の設定 (@pxref{Category Variables}) を見直す必要があるでしょう。

@item gnus-agent-max-fetch-size
@vindex gnus-agent-max-fetch-size
エージェントは、取得した記事を個々のファイルに入れるための解析を行なう前
に、それらを一時的なバッファーへ取り込みます。最大のバッファーサイズを超
過しないようにするために、記事がすべて取得されるまで、エージェントは取得
と解析を交互に行ないます。@code{gnus-agent-max-fetch-size} は、繰り返し
がどれくらい頻繁に起きるかを制御するための、サイズの限界を規定します。大
きな値は性能を向上させます。小さな値は、万が一取得している間に接続が切れ
た場合に、遅れ時間を最小にします (グループの状態を更新するため
に @code{gnus-agent-regenerate-group} を実行する必要があるかもしれませ
ん。でも、接続が切れる前に解析されたすべての記事は、unplugged の期間に利
用することができるでしょう。)。繰り返しに遭遇することは珍しいので、ディ
フォルトは 10M です

@item gnus-server-unopen-status
@vindex gnus-server-unopen-status
エージェント変数ではないかもしれないけれどエージェントに密接に関連するこ
の変数は、Gnus がサーバーに接続できないときに何をするかを指示します。エー
ジェントが活性化されると、ディフォルトの @code{nil} では、サーバーとの接
続を絶つかエージェントを unplugged にするかを利用者に尋ねます。エージェ
ントが不活性化されると、Gnus はいつも単にサーバーとの接続を絶ちます。こ
の変数の他の選択肢には @code{denied} と @code{offline} があり、後者はエー
ジェントを使う場合だけ有効です。

@item gnus-auto-goto-ignores
@vindex gnus-auto-goto-ignores
おおかたの人は、エージェント変数ではないけれども密接に関連するもう一つの
変数をここで探すでしょう。この変数は、ダウンロードされていない (ヘッダー
だけがエージェントに格納された)、そして取り込まれていない (記事もヘッダー
も格納されていない) 記事の周りでどう移動するかを概略バッファーに伝えます。

有効な値は @code{nil} (どの記事にも移動する)、
@code{undownloaded} (unplugged のときは取り込まれていない記事を無視する)、
@code{always-undownloaded} (取り込まれていない記事を常に無視する)、
@code{unfetched} (ヘッダーが取り込まれていない記事を無視する) です。

@item gnus-agent-queue-mail
@vindex gnus-agent-queue-mail
@code{gnus-agent-queue-mail} を @code{always} にすると、Gnus はメールを
いきなり送信してしまうのではなく、常に queue (順番待ち) に入れます。
@code{t} だったら Gnus は unplugged のときだけメールを queue に入れます。
@code{nil} だったら queue に入れません。ディフォルトは @code{t} です。

@item gnus-agent-prompt-send-queue
@vindex gnus-agent-prompt-send-queue
@code{gnus-agent-prompt-send-queue} が非-@code{nil} だったら、
unplugged であるのにもかかわらず @kbd{J S} を叩いた場合に、Gnus は本当に
それを行なっても良いかどうかを確認します。ディフォルトは @code{nil} です。

@item gnus-agent-auto-agentize-methods
@vindex gnus-agent-auto-agentize-methods
あなたが以前にエージェントを使ったことが無い (もっと技術的に
は @file{~/News/agent/lib/servers} が無い場合)、Gnus はほんの少数のサー
バーを自動的にエージェント化します。この変数はどのバックエンドを自動でエー
ジェント化すべきかを制御します。一般に、エージェント化することが有用なの
は遠隔バックエンドに対してだけです。自動的にエージェント化することは、サー
バーに対して @kbd{J a} を実行するのと同じ効果があります (@pxref{Server
Agent Commands})。もしファイルが存在するならば、それらを追加したり削除す
るためにサーバーを手動で操作しなければなりません。この変数は最初
に Gnus を起動したときだけ適用されます。ディフォルトは @samp{nil} です。
@end table

@node Example Setup
@subsection 設定例

あなたがこのマニュアルを読みたくなくて、ごく標準的な設定を行なっているの
ならば、@file{~/.gnus.el} ファイルとして何か以下のようなものを使って始め
ても良いでしょう。

@lisp
;; @r{Gnus がどのようにニュースを取得するかを定義します。ここ}
;; @r{では ISP のサーバーから @acronym{NNTP} で取ってくることにします。}
(setq gnus-select-method '(nntp "news.your-isp.com"))

;; @r{Gnus がどのようにメールを読むかを定義します。}
;; @r{ISP の @acronym{POP} サーバーからメールを読むことにします。}
(setq mail-sources '((pop :server "pop.your-isp.com")))

;; @r{Gnus がメールをどのように格納するかを指定します。}
;; @r{nnml グループを使うことにします。}
(setq gnus-secondary-select-methods '((nnml "")))

;; @r{Gnus をオフラインニュースリーダーにします。}
;; (gnus-agentize) ; @r{旧式の設定。}
;; (setq gnus-agent t) ; @r{現在のディフォルト。}
@end lisp

基本的にはこれだけで良いはずです。これを @file{~/.gnus.el} ファイルに入
れて、必要に応じて編集し、PPP (や何か) を起動して、@kbd{M-x gnus} とタイ
プしてください。

あなたが Gnus を走らせたのが初めてであれば、自動的にわずかなディフォルト
のニュースグループが読めるようになります。おそらくもっとたくさんのグルー
プを購読したくなるでしょう。そのためには、@kbd{A A} 命令でグループの完全
なリストを @acronym{NNTP} サーバーに問い合わせなければなりません。これは
普通はとても時間がかかりますが、一度だけしか実行する必要はありません。

読み込みと解析にしばらく時間を費やした後で、グループの一覧が現れます。そ
うしたら、読みたいグループを @kbd{u} 命令で購読できるようにしてください。
読みたいグループを全部購読できるようにしたら、@kbd{l} で killed (削除さ
れた) グループをすべて画面から消去しましょう。(@kbd{A k} で killed グルー
プはすべて戻ってきます。)

今やすぐにグループを読むこともできるし、@kbd{J s} 命令で記事をダウンロー
ドすることもできます。あとはこのマニュアルの残りを読んで、他の億千万の項
目からカスタマイズしたいことを見つけ出してください。

@node Batching Agents
@subsection 一括エージェント処理
@findex gnus-agent-batch

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何かのメッ
セージを投稿するのは)、いったんものごとを正しく設定してしまえば非常に簡
単です。以下のシェルスクリプトは必要なことをすべてやってくれるでしょう。

以下の呪文をコマンドラインで使うことによって、完全なバッチコマンドを走ら
せることができます:

@example
#!/bin/sh
emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1
@end example

@node Agent Caveats
@subsection エージェントの問題点

Gnus エージェントは、よくある他のオフラインニュースリーダーのようには動
作しません。これらは架空の人々からの良くある質問です:

@table @dfn
@item Plugged のときに記事を読んだら、それはエージェントに入るのですか?

@strong{いいえ}。この動作をお望みなら @code{gnus-select-article-hook} に
関数 @code{gnus-agent-fetch-selected-article} を加えてください。

@item Plugged のときに記事を読んで、エージェントに記事が存在している場合、
もう一回ダウンロードされるのですか?

@strong{いいえ}、ただし @code{gnus-agent-cache} が @code{nil} でなかった
ら、ですが。
@end table

要約すると、Gnus が unplugged のときはローカルに保存された記事を見るだけ
です。Plugged のときは ISP と話し、かつローカルに持っている記事も使うで
しょう。

@node Scoring
@chapter スコア
@cindex scoring

ほかの人たちは「削除ファイル」(@dfn{kill files}) を使いますが、こ
こ Gnus タワーにいる私たちは削除よりもスコアの方が好きです。彼らとけんか
をするよりは切り替えてしまう方がましでしょう。それらは完全に違うことをす
るので、真っ直ぐに座って注意を払ってください!

@vindex gnus-summary-mark-below
すべての記事はディフォルトのスコ
ア (@code{gnus-summary-default-score}) の値を持っていて、ディフォルトで
は 0 です。このスコアは対話的に、またはスコアファイル (score file) によっ
て、上げられるか下げられるかします。@code{gnus-summary-mark-below} より
も低いスコアを持っている記事には既読の印が付きます。

Gnus は概略バッファーを作成する前に、現在のグループに適用されるどんな
「スコアファイル」も読み込みます。

現在の記事に基づいてスコアのエントリーを挿入する、複数の概略バッファーの
命令があります。例えば、Gnus に特定の表題の記事のスコアを下げたり上げた
りするように求めることができます。

二種類のスコア・エントリーがあります: 永続的なものと一時的なものです。一
時的なスコア・エントリーは、自分自身で期限切れ消去するエントリーです。例
えば一週間以上使われていないエントリーは、スコアファイルの大きさを小さく
しておくために静かに削除されます。

@menu
* Summary Score Commands::      現在のグループのためのスコア・エントリーを追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
* Score File Format::           スコアファイルには何が入っているか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            Big Sister Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア・エントリーがどこへ行くかを指示する方法
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                効果的にスコアを付ける方法
* Reverse Scoring::             歳をとった問題児は問題ではない
* Global Score Files::          地を覆い、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに翻訳する
* Advanced Scoring::            スコアの規則を作るために論理表現を使う
* Score Decays::                スコアを減衰させるのは役に立つこともある
@end menu

@node Summary Score Commands
@section 概略スコア命令
@cindex score commands

スコア・エントリーを変更するスコア命令は、実際に本当のスコアファイルを修
正するわけではありません。それはあまりに非効率です。Gnus は以前にロード
されたスコアファイルのキャッシュを保持していて、その一つが「現在のスコア
ファイルの連想リスト」だと見なされます。スコア命令は単にこのリストにエン
トリーを挿入し、グループから出るときに、このリストは保存されます。

現在のスコアファイルは、実際にそのようなスコアファイルが存在しない場合で
も、ディフォルトでグループのローカルスコアファイルになります。スコア命令
を何か他のスコアファイル (例えば @file{all.SCORE}) に挿入するには、まず
このスコアファイルを現在のものにしなければなりません。

以下はスコアファイルを実際に変更しない、一般的なスコア命令です:

@table @kbd
@item V s
@kindex V s @r{(概略)}
@findex gnus-summary-set-score
現在の記事のスコアを設定します (@code{gnus-summary-set-score})。

@item V S
@kindex V S @r{(概略)}
@findex gnus-summary-current-score
現在の記事のスコアを表示します (@code{gnus-summary-current-score})。

@item V t
@kindex V t @r{(概略)}
@findex gnus-score-find-trace
現在の記事に使われているすべてのスコア規則を表示しま
す (@code{gnus-score-find-trace})。@file{*Score Trace*} バッファーにおい
て、現在の行のスコア規則に対応するスコアファイルを編集するに
は @kbd{e} を、スコアファイルの清書 (@code{gnus-score-pretty-print}) と
編集を行なうためには @kbd{f} をタイプしてください。

@item V w
@kindex V w @r{(概略)}
@findex gnus-score-find-favourite-words
スコアで使われている語のリストを表示しま
す (@code{gnus-score-find-favorite-words})。

@item V R
@kindex V R @r{(概略)}
@findex gnus-summary-rescore
現在の概略でスコアの処理を実行します (@code{gnus-summay-rescore})。
Gnus には内緒でスコアファイルをいじり回して、その効果を見たいときに役立
つでしょう。

@item V c
@kindex V c @r{(概略)}
@findex gnus-score-change-score-file
違うスコアファイルを現在のものにしま
す (@code{gnus-score-change-score-file})。

@item V e
@kindex V e @r{(概略)}
@findex gnus-score-edit-current-scores
現在のスコアファイルを編集します (@code{gnus-score-edit-current-scores})。
@code{gnus-score-mode} バッファーが現れるしょ
う (@pxref{Score File Editing})。

@item V f
@kindex V f @r{(概略)}
@findex gnus-score-edit-file
スコアファイルを編集して、このスコアファイルを現在のものにしま
す (@code{gnus-score-edit-file})。

@item V F
@kindex V F @r{(概略)}
@findex gnus-score-flush-cache
キャッシュされているスコアを捨てます (@code{gnus-score-flush-cache})。こ
れはスコアファイルを編集した後で役に立ちます。

@item V C
@kindex V C @r{(概略)}
@findex gnus-score-customize
視覚的に快適な方法でスコアファイルをカスタマイズしま
す (@code{gnus-score-customize})。
@end table

以下の命令はローカルスコアファイルを変更します:

@table @kbd
@item V m
@kindex V m @r{(概略)}
@findex gnus-score-set-mark-below
スコアの入力を求めて、それよりも低いスコアのすべての記事に既読の印を付け
ます (@code{gnus-score-set-mark-below})。

@item V x
@kindex V x @r{(概略)}
@findex gnus-score-set-expunge-below
スコアの入力を求めて、そのスコアより低いすべての記事を削除するためのスコ
ア規則を現在のスコアファイルに付け加えま
す (@code{gnus-score-set-expunge-below})。
@end table

スコア・エントリーを実際に作るためのキー操作は、非常に規則正しい様式にのっ
とっているので、それらすべての (何百もある) 命令を列挙する必要は無いでしょ
う。

@findex gnus-summary-increase-score
@findex gnus-summary-lower-score
@enumerate
@item
最初にタイプするキーは、スコアを増やすときは @kbd{I} (i の大文字) で、ス
コアを下げるときは @kbd{L} です。
@item
二番目のキーは、どのヘッダーでスコアを付けるかを指定します。以下のキーを
使うことができます:

@table @kbd
@item a
著者 (author) の名前でスコアを付けます。

@item s
表題 (subject) の行でスコアを付けます。

@item x
@code{Xref} 行、すなわちクロスポスト行でスコアを付けます。

@item r
@code{References} 行でスコアを付けます。

@item d
日付 (date) でスコアを付けます。

@item l
行数 (number of lines) でスコアを付けます。

@item i
@code{Messsage-ID} ヘッダーでスコアを付けます。

@item e
@acronym{NNTP} サーバーが追加のヘッダーのデータを overview で捕捉してい
れば、その「追加」のヘッダー (すなわち (@code{gnus-extra-headers} に設定
されているもの) の一つでスコアを付けます。

@item f
フォローアップ (followup) でスコアを付けます---これは著者名と合致するか
どうかを調べて、この著者へのフォローアップでスコアを加えます。(このキー
を使うことは、@file{ADAPT} ファイルの生成をもたらします。)

@item b
記事の本文でスコアを付けます。

@item h
ヘッダーでスコアを付けます。

@item t
スレッドでスコアを付けます。(このキーを使うことは、@file{ADAPT} ファイル
の生成をもたらします。)
@end table

@item
三番目のキーは合致の型です。どの合致の型が有効なのかは、どのヘッダーでス
コアを付けようとしているかに依ります。

@table @code
@item 文字列 (strings)

@table @kbd
@item e
正確な (exact) 合致です。

@item s
文字列の一部の (substring) 合致です。

@item f
大雑把な (fuzzy) 合致です (@pxref{Fuzzy Matching})。

@item r
正規表現 (regexp) の合致です。
@end table

@item 日付 (date)

@table @kbd
@item b
日付の前 (before) です。

@item a
日付の後 (after) です。

@item n
その日付です。
@end table

@item 数値 (number)

@table @kbd
@item <
数値より小さいものです。

@item =
数値と等しいものです。

@item >
数値より大きいものです。
@end table
@end table

@item
普通はこれで最後の四つ目のキーは、これが一時的な (すなわち期限切れ消去さ
れる) スコア・エントリーか、永続的な (すなわち期限切れ消去でない) スコア・
エントリーか、またはスコアファイルに追加せずにただちにスコア付けを行なう
か、のどれかを指定します。

@table @kbd
@item t
一時的な (temporary) スコア・エントリーです。

@item p
永続的な (permanent) スコア・エントリーです。

@item i
ただちに (immediate) スコア付けを行ないます。
@end table

@item
もし @samp{e} (追加の (extra)) ヘッダーでスコア付けを行なっていると、そ
れでスコア付けをしたいヘッダーの名前を尋ねられるでしょう。これ
は @code{gnus-extra-headers} にある名前でなければなりません。
@samp{@key{TAB}} による補完ができます。
@end enumerate

そういうわけで、現在の著者への、正確な合致に基づいて、永続的なスコアを、
増やしたい、という場合のキーは @kbd{I a e p} です。表題への、文字列の一
部合致に基づいて、一時的なスコア・エントリーを作り、そのスコアを下げたい、
という場合のキーは @kbd{L s s t} です。ずいぶん簡単ですね。

ものごとを少し複雑にするためにショートカット・キーがあります。二番目か三
番目のキーに大文字を使うと、Gnus は残る一つか二つのキーにディフォルト値
を使います。ディフォルトは「文字列の一部」と「一時的」です。ですか
ら @kbd{I A} は @kbd{I a s t} と同じで、@kbd{I a R} は @kbd{I a r t} と
同じです。

これらの関数は、数値接頭引数とシンボル接頭引数を受け付けま
す (@pxref{Symbolic Prefixes})。数値接頭引数はどのくらい記事のスコアを下
げる (もしくは上げる) かを指定します。シンボル接頭引数 @code{a} は、現在
のスコアファイルの代わりに @file{all.SCORE} ファイルをその命令のために使
うことを指示します。

@vindex gnus-score-mimic-keymap
@code{gnus-score-mimic-keymap} はこれらの命令がキーマップであるかのよう
に振る舞うかどうかを指定します。

@node Group Score Commands
@section グループスコア命令
@cindex group score commands

残念ながら、まだたくさんはありません。

@table @kbd
@item W e
@kindex W e @r{(グループ)}
@findex gnus-score-edit-all-score
すべてのグループに適用される all.SCORE ファイルを編集します。
@code{gnus-score-mode} のバッファーが現れるでしょう (@pxref{Score File
Editing})。

@item W f
@kindex W f @r{(グループ)}
@findex gnus-score-flush-cache
何度もスコア連想リストを再読み込みすることを避けるために、Gnus はそれら
のキャッシュを保持しています。この命令はキャッシュを空っぽにしま
す (@code{gnus-score-flush-cache})。
@end table

以下のようなやり方で、コマンド行からスコア付けをすることができます:

@findex gnus-batch-score
@cindex batch scoring
@example
& emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score
@end example

@node Score Variables
@section スコア変数
@cindex score variables

@table @code
@item gnus-use-scoring
@vindex gnus-use-scoring
@code{nil} であれば、Gnus はスコアファイルを調べず、一般的にはスコア関連
の仕事をまったくしません。これはディフォルトで @code{t} です。

@item gnus-kill-killed
@vindex gnus-kill-killed
この変数が @code{nil} であれば、Gnus はすでに削除 (kill) の処理を実行さ
れた記事に決してスコアファイルを適用しません。これはたくさんの時間を節約
する一方、削除ファイルをグループに適用していて、削除ファイルを変更し、もっ
と多くの記事を削除するためにそれを再実行しても、それは動作しないというこ
とにもなります。それをするためにはこの変数を @code{t} にしなければなりま
せん。(これはディフォルトで @code{t} です。)

@item gnus-kill-files-directory
@vindex gnus-kill-files-directory
すべての削除 (kill) とスコアのファイルはこのディレクトリーに格納されま
す。その値は、ディフォルトでは環境変数 @env{SAVEDIR} によって初期化され
ます。ディフォルトは @file{~/News/} です。

@item gnus-score-file-suffix
@vindex gnus-score-file-suffix
スコアファイルの名前を得るためにグループ名に加える接尾語です (ディフォル
トは @file{SCORE} です)。

@item gnus-score-uncacheable-files
@vindex gnus-score-uncacheable-files
@cindex score cache
通常すべてのスコアファイルは、スコアファイルの過剰な再読み込みを避けるた
めにキャッシュされます。しかし、このために Emacs が大きく肥大化するかも
しれません。そこで、再び必要とされそうもないスコアファイルを取り除くため
にこの正規表現を使うことができます。@file{all.SCORE} のキャッシュをやめ
てしまうのは間違った考えですが、
@file{comp.infosystems.www.authoring.misc.ADAPT} をキャッシュしないのは
良い考えかもしれません。実際のところ、この変数のディフォルトは
@samp{ADAPT$} で、適応スコアファイルはキャッシュされません。

@item gnus-save-score
@vindex gnus-save-score
もし本当に複雑なスコアファイルを持っていて、たくさんの一括 (batch) スコ
ア付けを行なうのであれば、この変数を @code{t} に設定しても良いでしょう。
これは Gnus にスコアを @file{.newsrc.eld} ファイルに保存させます。

これを @code{t} に設定しないと、手動で付けたスコア (@kbd{V s}
(@code{gnus-summary-set-score}) で設定したようなもの) は訪れたグループ群
を横切って保持されることはありません。

@item gnus-score-interactive-default-score
@vindex gnus-score-interactive-default-score
スコアを上げ/下げするために、すべての対話的スコア上げ/下げ命令によって使
われるスコアです。ディフォルトは 1000 で、過剰に思えるかもしれませんが、
適応スコア付けをするための十分な余地を確保するためです。手で入力したデー
タを、適応スコア付けからの小さな変更で上書きされたくはないのです。

@item gnus-summary-default-score
@vindex gnus-summary-default-score
記事のスコアのディフォルトで、ディフォルトでは 0 になっています。

@item gnus-summary-expunge-below
@vindex gnus-summary-expunge-below
この変数より低いスコアを持つ記事は概略の行に表示されません。ディフォルト
は @code{nil} で、どの記事も隠されないということです。これは各概略バッ
ファーにおけるローカル変数で、@code{gnus-summary-mode-hook} によって設定
されなければなりません。

@item gnus-score-over-mark
@vindex gnus-score-over-mark
ディフォルトのスコアより大きなスコアを持つ記事に対して (概略行の三桁目
で) 使われる印です。ディフォルトは @samp{+} です。

@item gnus-score-below-mark
@vindex gnus-score-below-mark
ディフォルトのスコアより小さなスコアを持つ記事に対して (概略行の三桁目
で) 使われる印です。ディフォルトは @samp{-} です。

@item gnus-score-find-score-files-function
@vindex gnus-score-find-score-files-function
現在のグループのためのスコアファイルを見つけるために使われる関数です。こ
の関数はグループ名を引数として呼ばれます。

あらかじめ定義されている使用可能な関数は:

@table @code
@item gnus-score-find-single
@findex gnus-score-find-single
グループ自身のスコアファイルだけを適用します。

@item gnus-score-find-bnews
@findex gnus-score-find-bnews
すべての合致するスコアファイルを bnews 構文を使って適用します。これがディ
フォルトです。例えば、現在のグループが @samp{gnu.emacs.gnus} ならば、
@file{gnu.all.SCORE}, @file{not.alt.SCORE} と @file{gnu.all.SCORE} がす
べて適用されます。要するに、スコアファイル名
の @samp{all} が @samp{.*} に変換され、それから正規表現の合致がなされま
す。

これは、すべてのグループに適用したいスコア・エントリーがいくつかある場合
は、それらのエントリーを @file{all.SCORE} ファイルに入れるということです。

Gnus は、より一般的なスコアファイルを、より特定のスコアファイルより前に
適用しようとするものの、スコアファイルはややランダムな順番で適用されます。
これはスコアファイル名の要素の数を調べることによって行なわれま
す---@samp{all} 要素を取り除いて。

@item gnus-score-find-hierarchical
@findex gnus-score-find-hierarchical
すべての親グループから、順にすべてのスコアファイルを適用します。これ
は @file{all.SCORE} のようなスコアファイルを持つことはできないけれど、
@file{SCORE}, @file{comp.SCORE} および @file{comp.emacs.SCORE} を、それ
ぞれのサーバーに対して持つことができるということです。
@end table

この変数は関数のリストであることもできます。その場合、これらすべての関数
がグループ名を引数として呼ばれ、返されたすべてのスコアファイルのリストが
適用されます。これらの関数は、直接スコア連想リストのリストのリストを返す
こともできます。その場合、それらのファイルでないスコア連想リストを返す関
数は、返される最後のスコアファイルがローカルスコアファイルであることを確
実にするために、おそらく「本当の」スコアファイル関数よりも前に置かれるべ
きでしょう。ふぅ。

例えば、サーバーを特定しない全体スコアファイルを使って、階層的に (親グルー
プから順に) スコア付けを行なうならば、次の値を使えば良いでしょう。

@example
(list (lambda (group) ("all.SCORE"))
      'gnus-score-find-hierarchical)
@end example

@item gnus-score-expiry-days
@vindex gnus-score-expiry-days
この変数は、使われていないスコアファイルエントリーが期限切れ消去されるま
でに、どのくらいの日数が経過すべきかを指定します。この変数
が @code{nil} であると、スコアファイルエントリーは削除されません。ディフォ
ルトは 7 です。

@item gnus-update-score-entry-dates
@vindex gnus-update-score-entry-dates
この変数が @code{nil} でないと、一時的に合致したスコア・エントリーは日付
が更新されます。(これは Gnus が期限切れ消去を操作している方法です---すべ
ての合致しないエントリーは古くなりすぎるのに対して、合致するエントリーは
新鮮で若いままです。) しかし、この変数を @code{nil} に設定すると、合致す
るエントリーでさえも古くなって、ああ、そう、あの冷酷な死神と直面すること
になるでしょう。

@item gnus-score-after-write-file-function
@vindex gnus-score-after-write-file-function
スコアファイルが書かれた直後に、その名前を引数として呼ばれる関数です。

@item gnus-score-thread-simplify
@vindex gnus-score-thread-simplify
この変数が @code{nil} でないと、記事の表題は表題でスコア付けを行なうため
に、スレッドと同じやり方で (現在
の @code{gnus-simplify-subject-functions} の値に従って) 単純化されます。
スコア・エントリーが「文字列の一部への合致」か「正確な合致」を使っている
と、その合致もこのやり方で単純化されます。
@end table

@node Score File Format
@section スコアファイル様式
@cindex score file format

スコアファイルは普通は単一の様式だけを含む @code{emacs-lisp} ファイルで
す。無頓着な利用者はこれを編集しないでください。すべては概略バッファーか
ら変更することができます。

にもかかわらず、それを自分でいじってみたくなったのなら、例があります:

@lisp
(("from"
  ("Lars Ingebrigtsen" -10000)
  ("Per Abrahamsen")
  ("larsi\\|lmi" -50000 nil R))
 ("subject"
  ("Ding is Badd" nil 728373))
 ("xref"
  ("alt.politics" -1000 728372 s))
 ("lines"
  (2 -100 nil <))
 (mark 0)
 (expunge -1000)
 (mark-and-expunge -10)
 (read-only nil)
 (orphan -10)
 (adapt t)
 (files "/hom/larsi/News/gnu.SCORE")
 (exclude-files "all.SCORE")
 (local (gnus-newsgroup-auto-expire t)
        (gnus-summary-make-false-root empty))
 (eval (ding)))
@end lisp

この例はたいていのスコアファイルの要素を説明しています。別のやり方につい
ては、@ref{Advanced Scoring} を見てください。

これがとても Lisp コードのように見えるとしても、実際はここにあるものは何
も @code{eval} (評価) されません。しかしこの様式を読み込むために Lisp リー
ダーが使われるので、意味的に有効でないとしても、文法的には正当なものです。

この連想リストでは六つのキーがサポートされています:

@table @code
@item 文字列 (STRING)
キーが文字列だったら、それは合致が実行されるヘッダーの名前です。スコア付
けはこれら八つのヘッダーだけで行なうことができます: @code{From},
@code{Subject}, @code{References}, @code{Message-ID}, @code{Xref},
@code{Lines}, @code{Chars} および @code{Date} です。これらのヘッダーに加
えて、Gnus に、記事全体を取得して記事のより大きな部分で合致を行なわせる
三つの文字列があります: @code{Body} は記事の本文で合致を行ない、
@code{Head} は記事のヘッダーで合致を行ない、@code{All} は記事全体で合致
を行ないます。これら最後の三つのキーを使うと、グループに入る速度
を @emph{かなり} 遅くしてしまうことに気を付けてください。スコアを付ける
ことができる最後の「ヘッダー」は @code{Followup} です。これらのスコア・
エントリーは、これらのスコア・エントリーに合致する記事へのすべてのフォロー
アップのための追加が行なわれている、新しいスコア・エントリーに帰着するで
しょう。

このキーに続くのは任意の数のスコア・エントリーで、それぞれのスコア・エン
トリーは一つから四つまでの要素を持ちます。
@enumerate

@item
最初の要素は「合致要素」です。これはたいていのヘッダーでは文字列ですが、
Lines と Chars ヘッダーでは整数でなければなりません。

@item
もし二番目の要素があるなら、それは数値の「スコア要素」でなければなりませ
ん。この数値は負の無限大から正の無限大までの間の整数でなければなりません。
合致が成功すると、この数値が記事のスコアに加えられます。この要素が存在し
ていない場合は、代わりに @code{gnus-score-interactive-default-score} の
数値が使われます。ディフォルトは 1000 です。

@item
もし三番目の要素があるなら、それは数値の「日付要素」でなければなりません。
この日付は最後にこのスコア・エントリーが合致した時刻を示し、それはスコア・
エントリーを期限切れ消去するための機構を提供します。この要素が存在してい
ないと、スコア・エントリーは永続になります。日付は紀元前 1年12月31日から
の経過した日数で表されます。

@item
もし四番目の要素があるなら、それはシンボルの「型要素」でなければなりませ
ん。この要素は、このスコア・エントリーが記事に合致するかどうかを調べるた
めに、どの関数が使われるべきかを指定します。

@table @dfn
@item From, Subject, References, Xref, Message-ID
たいていのヘッダー型のために、@code{r} と @code{R} (正規表現(regexp))、
@code{s} と @code{S} (文字列の一部(substring)) 型、@code{e} と @code{E}
(正確な合致(exact match))、および @code{w} (語の合致((word match)) 型が
あります。もしこの要素が無いと、Gnus は文字列の一部の合致が用いられるべ
きであると仮定します。@code{R}, @code{S}, @code{E} は、合致が大文字と小
文字を区別する方法で行なわれる点で他のものと異なります。これらすべての一
文字型は、本当は @code{regexp}, @code{exact}, @code{word} 型の短縮形で、
この方が好みならば代わりに使うことができます。

@item Extra
overview ヘッダーの標準の文字列に的を絞って @code{gnus-extra-headers} を
使っていれば、それらのヘッダーの値でスコアを付けることができます。この場
合スコア・エントリーの五番目の要素が、スコアを付けるヘッダーの名前になり
ます。@acronym{NNTP} サーバーが overview で @samp{NNTP-Posting-Host} を
捕捉しているならば、@file{all.SCORE} ファイルの以下のエントリーは、単一
のホストを起源とする spam の攻撃に対して有効です:

@lisp
("111.222.333.444" -1000 nil s
 "NNTP-Posting-Host")
@end lisp

@item Lines, Chars
これらの二つのヘッダーは別の合致の型を使います: @code{<}, @code{>},
@code{=}, @code{>=}, @code{<=} です。

これらの述語は

@example
(PREDICATE HEADER MATCH)
@end example

の評価が @code{nil} ではない場合に真です。例えば、上級合
致 @code{("lines" 4 <)} (@pxref{Advanced Scoring}) は結果として以下の式
になります:

@lisp
(< header-value 4)
@end lisp

言い換えると、4 を合致として @code{<} を @code{Lines} で使っているときは、
記事が 4 行よりも少ないときにスコアが加算されるということです。(混乱して、
それが反対ではないかと考えがちです。でも、そうではないのです。私が思う
に。)

合致を @code{Lines} で行なっていると、いくつかのバックエン
ド (@code{nndir} のようなもの) は @code{Lines} ヘッダーを作成しないので、
すべての記事が 0 行であるとして扱われてしまうことに気を付けてください。
これは、少しの行しかない記事のスコアを下げている場合に、変な結果を導くこ
とがあり得ます。

@item Date
Date (日付) ヘッダーには三つのなんとなくばかげている合致の型があります:
@code{before}, @code{at}, @code{after} です。私は本当にこれが役立つよう
な機会を想像できないのですが、この関数を提供しないのもなんとなくばかげて
います。そうした場合のためにあるのです。いつ必要になるかは誰にもわかりま
せん。転ばぬ先の杖。羹(あつもの)に懲りて膾(なます)を吹く。本をカバーで判
断してはいけません。初めてのデートでエッチしてはいけません。(しかし、私
は少なくとも一人、引用しますが、「この関数は欠かせないものであることがわ
かった」と言った人がいると聞いています。)

@cindex ISO8601
@cindex date
もっと役に立つ合致の型は「正規表現」です。それによって、日付の文字列に正
規表現を使って合致させることができます。日付はまず ISO8601 の短縮様
式 (compact format) に標準化されま
す---@var{YYYYMMDD}@code{T}@var{HHMMSS} です。例えば、すべての年
の 4月1日に投稿されたすべての記事に合致させたいのであれば、合致文字列と
して @samp{....0401.........} を使うことができます。(日付は元々の標準時
で保存されているので、その記事が投稿された場所での 4月1日に投稿された記
事に合致することに注意してください。“Time zones”は家族全員の健全な楽し
みですね? (訳注: いくつかある“Time zones”というタイトルの曲のことを言っ
ているのかもしれません。))

@item Head, Body, All
これらの三つの合致のキーは @code{From} ヘッダー (など) と同じ合致の型を
使います。

@item Followup
この合致のキーはやや特別で、それは @code{From} ヘッダーに合致し、合致し
た記事だけでなくその記事へのすべてのフォローアップのスコアにも影響します。
これは、あなた自身の記事へのフォローアップのスコアを増やしたり、良く知ら
れた問題児へのフォローアップ記事のスコアを下げたりするのに使われます。
@code{From} ヘッダーが使うのと同じ型の合致を使います。(この合致キーを使
うと、@file{ADAPT} ファイルを作ることになります。)

@item Thread
この合致キーは @code{Followup} 合致キーと同じ方針に沿って動作します。
@code{Message-ID} @var{x} で始まっているスレッド (または副スレッド) にス
コアを付けたいのであれば、@samp{thread} 合致を付け加えてください。これ
は @code{Reference} ヘッダーに @var{x} を持つそれぞれの記事に、新し
い @samp{thread} 合致を追加します。(これらの新しい @samp{thread} 合致は
これらの合致する記事の @code{Message-ID} を使います。) これはスレッドの
いくつかの記事が完全な @code{References} ヘッダーを持っていなかったとし
ても、スレッド全体のスコアを上げ/下げできることを保証します。これを使う
と、スレッドの記事に決定的でないスコアが付くかもしれないということに注意
してください。(この合致キーを使うと、@file{ADAPT} ファイルを作ることにな
ります。)
@end table
@end enumerate

@cindex score file atoms
@item mark
このエントリーの値は数値でなければなりません。この数値より低いスコアのど
んな記事にも既読の印が付きます。

@item expunge
このエントリーの値は数値でなければなりません。この数値より低いスコアのど
んな記事も概略バッファーから削除されます。

@item mark-and-expunge
このエントリーの値は数値でなければなりません。この数値より低いスコアのど
んな記事にも既読の印が付き、概略バッファーから削除されます。

@item thread-mark-and-expunge
このエントリーの値は数値でなければなりません。スコアの総計がこの数値より
低いスレッドのすべての記事には既読の印が付き、概略バッファーから削除され
ます。@code{gnus-thread-score-function} はスレッドのスコアの総計をどのよ
うに計算するかを指定します。

@item files
このエントリーの値は任意の数のファイル名でなければなりません。それらのファ
イルもスコアファイルであるとみなされ、これがされたのと同じ方法で読み込ま
れます。

@item exclude-files
このエントリーの手がかりは任意の数のファイル名でなければなりません。これ
らのファイルが何らかの理由で普通は読み込まれるようになっていたとしても、
読み込まれません。

@item eval
このエントリーの値は @code{eval} (評価) されます。この要素はグローバルス
コアファイルを扱っているときは無視されます。

@item read-only
読み込み専用スコアファイルは更新されたり保存されたりしません。グローバル
スコアファイルはこのアトムを使用するべきです (@pxref{Global Score
Files})。(注意: 「グローバル」はここでは本当に「全体的」という意味です。
個人的なすべてのグループに適用するスコアファイルのことではありません。)

@item orphan
このエントリーの値は数値でなければなりません。親記事を持たない記事のスコ
アにこの数値が加えられます。@samp{comp.lang.c} のような流通量の多いニュー
スグループを追いかけていると想像してください。おそらくほんの少しのスレッ
ドだけを追いたいでしょう。さらに新しいスレッドは見たいでしょう。

以下の二つのスコアファイルエントリーによって、それをすることができます:

@example
        (orphan -500)
        (mark-and-expunge -100)
@end example

最初にこのグループに入ったときは、新しいスレッドだけを見るでしょう。そう
したら、興味を持ったスレッドのスコアを上げ (@kbd{I T} また
は @kbd{I S} で)、残りを無視 (@kbd{c y}) してください。次にグループに入っ
たときは、興味を持ったスレッドの新しい記事と、まったく新しいスレッドを見
ることになります。

すなわち orphan (孤児) スコアアトムは、普通のスコア規則では自動的に発見
できない、興味深いスレッドが少し存在しする、流通量が多いグループのために
あります。

@item adapt
このエントリーは適応スコア付けを制御します。これが @code{t} だったら、ディ
フォルトの適応スコア規則が使われます。@code{ignore} だったら、このグルー
プでは適応スコア付けは行なわれません。もしリストだったら、そのリストが適
応スコア規則として用いられます。もしそれが存在しない
か @code{t} や @code{ignore} 以外の何かだったら、ディフォルトの適応スコ
ア規則が使われます。たいていのグループで適応スコア付けを使いたいのであれ
ば、@code{gnus-use-adaptive-scorint} を @code{t} に設定し、適応スコア付
けをしたくないグループに @code{(adapt ignore)} を挿入すればよいでしょう。
少しのグループでだけ適応スコアを行ないたいのであれば、
@code{gnus-use-adaptive-scoring} を @code{nil} に設定し、それを行ないた
いグループのスコアファイルに @code{(adapt t)} を挿入しましょう。

@item adapt-file
すべての適応スコア・エントリーは、このエントリーによって名づけられたファ
イルに入ります。さらにそれはグループに入るときにも適用されます。このアト
ムは、多くのグループで同じ適応スコアファイルを用いることによって、複数の
グループに一度に適応スコアを付けたいときに便利でしょう。

@item local
@cindex local variables
このエントリーの値は @code{(@var{var} @var{value})} の形式の対のリストで
なければなりません。それぞれの @var{var} は現在の概略バッファーでバッファー
ローカルになり、指定された値 (@var{value}) に設定されます。これは少し風
変わりですが、フックがあまり好きでないならば、いくつかのグループで変数を
設定するのに便利な方法です。@var{value} は評価されないことに注意してくだ
さい。
@end table

@node Score File Editing
@section スコアファイルの編集

普通はすべてのスコア命令を概略バッファーから発行しますが、手でそれらを編
集したくなることもあるかもしれないので、それのためのモードを用意していま
す。

それは以下に列挙する命令を使えるように、少しカスタマイズしただけ
の @code{emacs-lisp} モードです:

@table @kbd
@item C-c C-c
@kindex C-c C-c @r{(スコア)}
@findex gnus-score-edit-exit
あなたが行なった変更を保存して概略バッファーに戻りま
す (@code{gnus-score-edit-exit})。

@item C-c C-d
@kindex C-c C-d @r{(スコア)}
@findex gnus-score-edit-insert-date
現在の日付を数値の様式で挿入します (@code{gnus-score-edit-insert-date})。
これはどのようなものだろうと考えているのなら、これは本当に日の数値です。

@item C-c C-p
@kindex C-c C-p @r{(スコア)}
@findex gnus-score-pretty-print
適応スコアファイルは整形されずに保存されます。もしこれらのファイルの一つ
を読むつもりなら、まず @dfn{pretty print} (整形して印字) したいでしょう。
この命令 (@code{gnus-score-pretty-print}) がそれを行ないます。
@end table

このモードを使うには @kbd{M-x gnus-score-mode} とタイプしてください。

@vindex gnus-score-mode-hook
@code{gnus-score-menu-hook} がスコアモードのバッファーで実行されます。

概略バッファーでは、@kbd{V f}、@kbd{V e} および @kbd{V t} のような命令で
スコアファイルの編集を始めることができます。

@node Adaptive Scoring
@section 適応スコア付け
@cindex adaptive scoring

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、Gnus に
はこれらをすべて自動的に---まるで魔法でも使ったように作成する方法があり
ます。いやむしろ、人工無能によって、という方が正確かな。

@vindex gnus-use-adaptive-scoring
記事を読んだとき、記事に既読の印を付けたとき、あるいは記事を削除したとき
に、その印を残しておいてください。グループから出るときに、Gnus はそれら
の印の辺りを嗅ぎ回り、何の印を見つけたかに応じてスコア要素を追加します。
この機能
は @code{gnus-use-adaptive-scoring} を @code{t} か @code{(line)} に設定
すると有効になります。もしスコアを、表題に現れる個別の単語をもとに適
応させたければ、この変数を @code{(word)} に設定してください。両方の適応
方法を使いたければ、この変数を @code{(word line)} に設定してください。

@vindex gnus-default-adaptive-score-alist
スコア付けの処理を完全に制御するため
に @code{gnus-default-adaptive-score-alist} 変数をカスタマイズしてくださ
い。例えば、こんな感じになるでしょう:

@lisp
(setq gnus-default-adaptive-score-alist
      '((gnus-unread-mark)
        (gnus-ticked-mark (from 4))
        (gnus-dormant-mark (from 5))
        (gnus-del-mark (from -4) (subject -1))
        (gnus-read-mark (from 4) (subject 2))
        (gnus-expirable-mark (from -1) (subject -1))
        (gnus-killed-mark (from -1) (subject -3))
        (gnus-kill-file-mark)
        (gnus-ancient-mark)
        (gnus-low-score-mark)
        (gnus-catchup-mark (from -1) (subject -1))))
@end lisp

ご覧のように、この連想リストの各要素は、キーとして印 (変数名か「実際の」
印すなわち文字のいずれか) を持ちます。このキーの後には任意の数のヘッ
ダー/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が一つも
なければ、そのキーが記事の印として付いている記事に対しては適応型スコア付
けは行なわれません。例えば上記の例では、@code{gnus-unread-mark} が付いて
いる記事は、適応型スコア付けのエントリーを持ちません。

各記事は一つしか印を持ち得ないので、それぞれの記事にはこれらの規則のうち
の一つだけが適用されます。

@code{gnus-del-mark} を例に取りましょう---この連想リストでの意味は、この
印 (すなわち @samp{e} の印) が付いている記事はすべて、@code{From} ヘッダー
をもとに @minus{}4 下げられ @code{Subject} で @minus{}1 下げられるスコア・
エントリーが追加されます。これをあなたの偏見に合わせて変更してください。

もし 10 個の記事に同じ subject で @code{gnus-del-mark} の印が付いていた
とすると、この印に対する規則は十回適用されます。それはつまり、そ
の subject は @minus{}1 の十倍のスコアを得ます。その値は、私が大きく誤解
していないかぎり @minus{}10 のはずです。

もし自動期限切れ消去 (メール) グループ (@pxref{Expiring Mail}) があれば、
既読記事にはすべて @samp{E} 印が付けられます。これはおそらく適応型スコア
付けをちょっとばかりやりにくくするので、自動期限切れ消去と適応型スコア付
けは、一緒には現実にあまりうまくやっていけません。

スコアを付けられるヘッダーには @code{from}, @code{subject},
@code{message-id}, @code{references}, @code{xref}, @code{lines},
@code{chars} および @code{date} があります。さらに @code{followup} にも
スコア付けができて、これは現在の記事の @code{Message-ID} を使っ
て @code{References} ヘッダーに合致、すなわちこれに続くスレッドに合致す
る適応型スコア・エントリーを作成します。

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避けるた
めに、スコアファイルの @code{mark} アトムを何か小さい値---ひょっとする
と @minus{}300 くらいに設定しておくべきです。

適応型スコア付けを一週間かそこら使ってくると、Gnus はそれ相応に調教され、
あなたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きではな
い投稿者を消去するようになるはずです。

どのグループにおいて適応型スコア付けを作動させるかは、スコアファイ
ル (@pxref{Score File Format}) を使うことによって制御できます。またこれ
を使って、違ったグループに対して違った規則を使うようにもできます。

@vindex gnus-adaptive-file-suffix
適応型スコア・エントリーは、グループ名
に @code{gnus-adaptive-file-suffix} を付加した名前のファイルに入れられま
す。ディフォルトは @file{ADAPT} です。

@vindex gnus-adaptive-pretty-print
適応型スコアファイルは巨大になり得るので、人の手で編集されることは想定さ
れていません。@code{gnus-adaptive-pretty-print} が @code{nil} (ディフォ
ルト) であると、それらのファイルは人に読めるような形式では書かれません。

@vindex gnus-score-exact-adapt-limit
適応型スコア付けを行なうときは、部分文字列一致やファジーな一致を行なった
方が、おそらくほとんどの場合において良い結果が得られるでしょう。しかし、
ヘッダーの一致する部分が短い場合、意図に反する動作をする可能性が大きいの
で、@code{gnus-score-exact-adapt-limit} より短い長さしか一致しない場合は
完全一致が行なわれます。この変数が @code{nil} であれば、この問題が起こら
ないように常に完全一致が行なわれます。

@vindex gnus-default-adaptive-word-score-alist
上で述べたように、個別の単語ででもヘッダー全体ででも適応を行なうことがで
きます。単語で適応を行なう場合には、それぞれの単語の事例が、ある印にどん
なスコアを加えるかを、@code{gnus-default-adaptive-word-score-alist} 変数
によって指定します。

@lisp
(setq gnus-default-adaptive-word-score-alist
      `((,gnus-read-mark . 30)
        (,gnus-catchup-mark . -10)
        (,gnus-killed-mark . -20)
        (,gnus-del-mark . -15)))
@end lisp

これがディフォルト値です。単語での適応を有効にすると、
@code{gnus-read-mark} の印が付いている記事の表題に現れるすべての単語が、
スコアに 30 点追加するというスコア規則を生み出します。

@vindex gnus-default-ignored-adaptive-words
@vindex gnus-ignored-adaptive-words
@code{gnus-default-ignored-adaptive-words} のリストに現れる単語は無視さ
れます。無視したい単語を追加したいときは、この変数ではな
く @code{gnus-ignored-adaptive-words} リストの方を使ってください。

@vindex gnus-adaptive-word-length-limit
短い単語では適応型スコア付けを作動させるべきではないと思う人もいるでしょ
う。もしそうなら @code{gnus-adaptive-word-length-limit} に整数を設定する
ことができ、この数値より短い単語は無視されます。この変数のディフォルト
は @code{nil} です。

@vindex gnus-adaptive-word-syntax-table
スコア付けが行なわれるとき、@code{gnus-adaptive-word-syntax-table} が実
際に使われるシンタックステーブルです。これは標準シンタックステーブルと似
ていますが、数字を単語の構成要素ではない文字だと認識します。

@vindex gnus-adaptive-word-minimum
もし @code{gnus-adaptive-word-minimum} に数値が設定されていると、単語適
応型スコア付け処理において、記事のスコアがこの数値よりも小さくなることは
ありません。ディフォルトは @code{nil} です。

@vindex gnus-adaptive-word-no-group-words
@code{gnus-acaptive-word-no-group-words} が @code{t} に設定されていると、
Gnus はグループ名のすべての語について、単語適応型スコア付けをしません。
ほとんどの表題が @samp{emacs} という語を含んでい
る @samp{comp.editors.emacs} のようなグループで便利です。

この機構をしばらく使ってみた後で、規則を解析することによってあなたがどん
な単語が好きでどんな単語が嫌いかを診断す
る @code{gnus-psychoanalyze-user} (利用者精神分析命令) を書いてみると良
いかもしれません。いや、良くないかな。

単語適応型スコア付けは高度に実験的なものなので、将来変更されるであろうこ
とは心に留めておいてください。第一印象では、これは現状ではまったく使い物
にならないように思えます。これをもっと使えるようにするためには、(より厳
密な統計的手法を巻き込んで) さらなる作業が行なわれる必要があるでしょう。

@node Home Score File
@section ホームスコアファイル

新しいスコアファイルエントリーが入れられるスコアファイルは、ホームスコア
ファイル @dfn{home score file} と呼ばれます。これは通常 (ディフォルト
で) そのグループ自身のためのスコアファイルになります。例え
ば @samp{gnu.emacs.gnus} 用のホームスコアファイル
は @file{gnu.emacs.gnus.SCORE} です。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグルー
プの間で共通のホームスコアファイルを共有することはしばしば便利です---例
えばすべての @samp{emacs} グループが、ことによると同じホームスコアファイ
ルを使うことができます。

@vindex gnus-home-score-file
これを制御する変数が @code{gnus-home-score-file} です。これは以下の値を
取り得ます:

@enumerate
@item
文字列。この場合、このファイルがすべてのグループでホームスコアファイルと
して使用されます。

@item
関数。この関数の結果がホームスコアファイルとして使用されます。この関数は
グループの名前を引数として呼び出されます。

@item
リスト。このリストの要素は以下の値を取り得ます:

@enumerate
@item
@code{(@var{regexp} @var{file-name})}。@var{regexp} がグループ名に合致す
ると、@var{file-name} がホームスコアファイルとして使用されます。

@item
関数。この関数が @code{nil} 以外を返せば、その戻り値がホームスコアファイ
ルとして使用されます。グループ名が引数として関数に渡されます。

@item
文字列。この文字列をホームスコアファイルとして使用します。
@end enumerate

このリストは、合致するものを探すために先頭から終りに向かってなぞられます。
@end enumerate

というわけで、単一のスコアファイルだけを使いたい場合は、以下のようにすれ
ば良いでしょう:

@lisp
(setq gnus-home-score-file
      "my-total-score-file.SCORE")
@end lisp

すべての @samp{gnu} グループに対して @file{gnu.SCORE} を、すべて
の @samp{rec} グループに対して @file{rec.SCORE} (等々) を使いたい場合は、
このように設定することができます:

@findex gnus-hierarchial-home-score-file
@lisp
(setq gnus-home-score-file
      'gnus-hierarchial-home-score-file)
@end lisp

これは利用者の便宜のために、あらかじめ提供されている関数です。他に以下の
関数があります:

@table @code
@item gnus-current-home-score-file
@findex gnus-current-home-score-file
「現在の」標準スコアファイルを返します。これはスコア命令群に「最深」の合
致するスコアファイルにエントリーを加えさせます。
@end table

@samp{emacs} グループ用に一つのスコアファイルを、それとは別のもの
を @samp{comp} グループ用に用意する一方、他のすべてのグループではそれぞ
れ独自のスコアファイルを使うようにしたいなら、こんな設定で良いでしょう:

@lisp
(setq gnus-home-score-file
      ;; @r{正規表現 @code{"\\.emacs"} に合致するすべてのグループ}
      '(("\\.emacs" "emacs.SCORE")
        ;; @r{すべての comp グループを単一のスコアファイルで}
        ("^comp" "comp.SCORE")))
@end lisp

@vindex gnus-home-adapt-file
@code{gnus-home-adapt-file} は @code{gnus-home-score-file} とまったく同
じやり方で動作しますが、代わりにこれで、何をホーム適応スコアファイルにす
るかを指定します。すべての新しい適応ファイルエントリーは、この変数で指定
されるファイルに入れられ、同じ文法を使うことができます。

@code{gnus-home-score-file} と @code{gnus-home-adapt-file} を使うことに
加えて、グループパラメーター (@pxref{Group Parameters}) とトピックパラメー
ター (@pxref{Topic Parameters}) を使っても、ほぼ同様のことを成し遂げるこ
とができます。グループ、トピックパラメーターはこの変数よりも優先されます。

@node Followups To Yourself
@section 自分自身へのフォローアップ

Gnus は現在のバッファーから @code{Message-ID} ヘッダーを見つけ出すための
二つの命令を提供します。そして Gnus は、他の記事の @code{References} ヘッ
ダーにあるこの @code{Message-ID} を使ってスコアを付けるためのスコア規則
を追加します。これは事実上、現在のバッファーにある記事に返答したすべての
記事のスコアを増加させます。これは、あなたが言ったことに人々が答えたら、
それに容易に気付かせてもらいたいときに、とても便利です。

@table @code
@item gnus-score-followup-article
@findex gnus-score-followup-article
これは、あなた自身の記事に直接フォローアップした記事にスコアを加えます。

@item gnus-score-followup-thread
@findex gnus-score-followup-thread
これは、あなたの記事より「下」のスレッドに現れるすべての記事にスコアを加
えます。
@end table

@vindex message-sent-hook
これら二つの関数は、本来どちらも @code{message-sent-hook} のようなフック
の中で、例えばこのように使うためのものです:

@lisp
(add-hook 'message-sent-hook 'gnus-score-followup-thread)
@end lisp

自分の @code{Message-ID} をじっくりと眺めてみると、はじめの二〜三文字は
常に同じであることに気が付くでしょう。以下の二つは私のものです:

@example
<x6u3u47icf.fsf@@eyesore.no>
<x6sp9o7ibw.fsf@@eyesore.no>
@end example

したがって、このマシンでは @samp{x6} で「私」かどうかを見分けることがで
きます。これは使えます---以下の規則は、私自身へのすべてのフォローアップ
のスコアを上げるでしょう:

@lisp
("references"
 ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@@.*eyesore\\.no>"
  1000 nil r))
@end lisp

「あなたの」が最初の二文字になるか最初の三文字になるかは、システムに依存
します。

@node Scoring On Other Headers
@section 他のヘッダーにスコアを付ける
@cindex scoring on other headers

Gnus が「伝統的」なヘッダー ---@samp{From}, @samp{Subject} など---にスコ
アを付けるのはとても速いです。ですが、他のヘッダーにスコアを付けるに
は @code{head} のスコアのための規則を書く必要があり、それは合致を探すた
めに Gnus が毎回バックエンドから単独の記事を取り寄せなければならないこと
を意味します。これは大きなグループでは長い時間がかかります。

@vindex gnus-inhibit-slow-scoring
ヘッダーまたは本文の遅いスコア付けは、変
数 @code{gnus-inhibit-slow-scoring} を設定することによって禁止することが
できます。もし @code{gnus-inhibit-slow-scoring} が正規表現だったら、グルー
プがその正規表現に合致する場合に遅いスコア付けが禁止されます。それ
が @code{t} だったら、すべてのグループで遅いスコア付けが禁止されます。

さて、これに関してニュースグループでの遅さのためにできることは多くはあり
ませんが、メールグループのためにはより優れた手段があります。
@ref{To From Newsgroups} の章でこの機構がどう働くかが詳しく説明されてい
ますが、ここではどうしたら @code{nnml} で @samp{To} と @samp{Cc} ヘッダー
にスコアを付けることができるかの調理の例を挙げましょう。

以下を @file{~/.gnus.el} ファイルに置いてください。

@lisp
(setq gnus-extra-headers '(To Cc Newsgroups Keywords)
      nnmail-extra-headers gnus-extra-headers)
@end lisp

Gnus を再起動して、@kbd{M-x nnml-generate-nov-databases} コマンド
で @code{nnml} の overview ファイルを作り直してください。たくさんのメー
ルを持っていると、これには長い時間がかかるでしょう。

そして @kbd{I e s p To @key{RET} <your name> @key{RET}} のようにすると、
@samp{To} と @samp{Cc} ヘッダーに“extra headers”としてスコアを付けるこ
とができます。

わかったかな? 簡単だよね。

@node Scoring Tips
@section スコア付けの奥義
@cindex scoring tips

@table @dfn
@item クロスポスト
@cindex crossposts
@cindex scoring crossposts
クロスポストのスコアを低くしたければ、合致させるべき行は @code{Xref} ヘッ
ダーです。

@lisp
("xref" (" talk.politics.misc:" -1000))
@end lisp

@item 複数のクロスポスト
ある数、例えば三つ以上のグループにクロスポストされている記事のスコアを低
くしたければ、

@lisp
("xref"
  ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
   -1000 nil r))
@end lisp

@item 本文への合致
これは一般的にはあまり良い考えではありません---とても長い時間がかかるか
らです。実際 Gnus は、それぞれの記事を個別にサーバーから取得してこなけれ
ばならないのです。でも、とにかくあなたはやりたいのでしょうね。合致させる
キーは三つ (@code{Head}, @code{Body}, @code{All}) あるのですが、それぞれ
のスコアファイルで一つを選んで、それに固執すべきです。もし二つを使うと、
それぞれの記事は @emph{二回} 取得されてしまいます。もし @code{Head} で
ちょっとだけ、@code{Body} でもちょっとだけ合致させたい、というのであれば、
素直に @code{All} を使って全部合致させてください。

@item 既読として印を付ける
ある一定の値より低いスコアを持つ記事には、おそらく既読の印を付けてしまい
たくなるでしょう。これは @file{all.SCORE} ファイルに以下のものを入れてお
くことによって、最も簡単に実現できます。

@lisp
((mark -100))
@end lisp

同様のことを @code{expunge} で行なうことを考えても良いでしょう。

@item 否定文字クラス
もし @code{[^abcd]*} みたいなものを指定すると、期待外れの結果で終わるか
もしれません。これは改行文字にも合致してしまうので、えーと、未知のものま
で引きずり出してしまうもしれません。代わりに @code{[^abcd\n]*} を使いま
しょう。
@end table

@node Reverse Scoring
@section 逆スコア
@cindex reverse scoring

もし、表題ヘッダーに @samp{Sex with Emacs} という文字がある記事だけを残
して、その他の記事すべてを消去してしまいたければ、スコアファイルに以下の
ようなものを入れることができます:

@lisp
(("subject"
  ("Sex with Emacs" 2))
 (mark 1)
 (expunge 1))
@end lisp

これで @samp{Sex with Emacs} に合致するすべての記事のスコアが上がって、
残りの記事には既読の印が付き、おまけにそれらは消去されるでしょう。

@node Global Score Files
@section グローバルスコアファイル
@cindex global score files

間違いなく、他のニュースリーダーは「グローバル削除ファイル (global kill
file)」を持っています。それらは普通、すべてのグループに適用される、利用
者のホームディレクトリーに格納されている一つの削除ファイル以上の何物でも
ありません。ふふん!  つまらない、低能なニュースリーダーだね。

私がここで話しているのはグローバルスコアファイルです。全世界の、あらゆる
地域の利用者のスコアファイル。それはすべての国家を巨大な一つの幸せなスコ
アファイル同盟に団結させる!  スコア天使!  新しい、でもテストされていない!

@vindex gnus-global-score-files
他人のスコアファイルを使うためにしなければならないのは、
@code{gnus-global-score-files} 変数を設定することがすべてです。それぞれ
のスコアファイルにつき一つ、またはそれぞれのスコアファイルディレクトリー
につき一つのエントリーになります。Gnus はどのスコアファイルをどのグルー
プに使うのが適切であるかを自分で決定します。

例えばスコアファイ
ル @file{/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE} およ
び @file{/ftp@@ftp.some-where:/pub/score} ディレクトリーにあるすべてのス
コアファイルを使いたければ、このように設定してください:

@lisp
(setq gnus-global-score-files
      '("/ftp@@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
        "/ftp@@ftp.some-where:/pub/score/"))
@end lisp

@findex gnus-score-search-global-directories
@noindent
単純でしょう?  ディレクトリー名は @samp{/} で終わらなくてはなりません。
これらのディレクトリーは、一般に Gnus を使う一回の期間中に一回だけしか読
み込まれません。もし遠隔ディレクトリーを手動で再読み込みすることが必要だ
と思ったら、@code{gnus-score-search-global-directories} 命令を使ってくだ
さい。

ただし、現時点ではこのオプションを使うと、グループに入るのがいくらか遅く
なります。(つまり---かなり、ですけど。)

他の人たちに使ってもらうためにスコアファイルを維持管理したくなったら、単
にあなたのスコアファイルを匿名 ftp に置いて、世界に公表してください。逆
行司会者になりましょう!  その後に続いて間違いなく起こる逆行司会者戦争、
すなわち人々の共感を勝ち取るための戦いに参加して、彼らのスコアファイルに
偽りの前提を使わせるように誘導するのです!  やったね!  これでネットは救わ
れる!

@quotation
@samp{retro-} を「逆行」と訳しました。日本では「レトロ」を「古き善き時代
の」のような肯定的な意味で使うことが少なくないのですが、ここでは本来の
「時代に逆行した」「使えねー」のような意味で使っています。
@end quotation

以下に、逆行司会者なりたがりのための秘技をいくつか、即席で述べます:

@itemize @bullet
@item
非常に多くの場所にクロスポストされている記事は間違いなく屑である。
@item
一個の不適切な記事を減点するには、@code{Message-ID} で減点する。
@item
特に素晴らしい投稿者たちは永続的な基準で加算して良い。
@item
そのグループの憲章を無視した投稿を頻繁に繰り返す投稿者は、絶滅させてしまっ
て差し支えない。
@item
@code{mark} と @code{expunge} アトムを設定し、汚らわしい記事を完全に葬り
去る。

@item
期限切れ消去のスコア・エントリーを使って、ファイルの大きさを小さく抑える。
もっとも、サイトによって古い記事を長期間保存するように、おそらく長い期限
切れ消去の期間を取るでしょうけれども。
@end itemize

@dots{} 果たして他のニュースリーダーは、将来グローバルスコアファイルをサ
ポートするでしょうか?  @emph{うふふ}。そう、どう考えてみたって、Blue
Wave や xrn や 1stReader とかいったニュースリーダーは、スコアをサポート
するべきですね。今は固唾を飲んで見守ることにしましょうか?

@node Kill Files
@section 消去ファイル
@cindex kill files

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がスコ
アファイルを考え出す前に私が書いたものなので、そのコードはまだ残してある
のです。

要するに、消去処理はスコア処理よりもかなり (私に言わせれ
ば @emph{ものすごく}) 遅いので、あなたの消去ファイルはスコアファイルに書
き換えた方が良いかもしれません。

いずれにせよ、消去ファイルは普通の @code{emacs-lisp} ファイルです。この
ファイルの中にはどんな形式でも入れることができます。つまり消去ファイルを
グループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります:

@lisp
(gnus-kill "From" "Lars Ingebrigtsen")
(gnus-kill "Subject" "ding")
(gnus-expunge "X")
@end lisp

これは私が書いたすべての記事に既読の印を付け、概略バッファーから印の付い
た記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムではまったく違う消去ファイルの構文を使っています。
Gnus は @code{rn} の消去ファイルらしきものに出会うと、何とかそれを解釈し
ようとします。

@sc{gnus} 消去ファイルを編集するための二つの概略バッファー関数があります:

@table @kbd
@item M-k
@kindex M-k @r{(概略)}
@findex gnus-summary-edit-local-kill
このグループの消去ファイルを編集しま
す (@code{gnus-summary-edit-local-kill})。

@item M-K
@kindex M-K @r{(概略)}
@findex gnus-summary-edit-global-kill
一般消去ファイルを編集します (@code{gnus-summary-edit-global-kill})。
@end table

消去ファイルを編集する二つのグループモード関数があります:

@table @kbd
@item M-k
@kindex M-k @r{(グループ)}
@findex gnus-group-edit-local-kill
このグループの消去ファイルを編集しま
す (@code{gnus-group-edit-local-kill})。

@item M-K
@kindex M-K @r{(グループ)}
@findex gnus-group-edit-global-kill
一般消去ファイルを編集します (@code{gnus-group-edit-global-kill})。
@end table

消去ファイル変数:

@table @code
@item gnus-kill-file-name
@vindex gnus-kill-file-name
@samp{soc.motss} グループ用の消去ファイルは通
常 @file{soc.motss.KILL} という名前です。このファイル名を得るためにグルー
プ名に付加される接尾語は、@code{gnus-kill-file-name} 変数で与えられます。
「グローバル」消去ファイルは (スコアファイルの意味での「グローバル」じゃ
ないよ、もちろん) 単に @file{KILL} という名前です。

@vindex gnus-kill-save-kill-file
@item gnus-kill-save-kill-file
この変数が @code{nil} 以外であれば、Gnus は処理の後に消去ファイルを保存
します。これは期限切れ消去を行なう消去を使っているときに必要です。

@item gnus-apply-kill-hook
@vindex gnus-apply-kill-hook
@findex gnus-apply-kill-file-unless-scored
@findex gnus-apply-kill-file
グループに消去ファイルを適用するために呼び出されるフック。これはディフォ
ルトでは @code{(gnus-apply-kill-file)} です。同じグループのためのスコア
ファイルがある場合に消去ファイルを無視したければ、このフック
を @code{(gnus-apply-kill-file-unless-scored)} に設定してください。消去
ファイルを処理させたくなければ、この変数を @code{nil} に設定してください。

@item gnus-kill-file-mode-hook
@vindex gnus-kill-file-mode-hook
消去ファイルモードのバッファー内で呼び出されるフック。
@end table

@node Converting Kill Files
@section 消去ファイルの変換
@cindex kill files
@cindex converting kill files

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコアファ
イルに変換したくなるでしょう。もしそれらが「普通の」ものであれば、
@file{gnus-kill-to-score.el} パッケージを使うことができます。そうでなけ
れば、手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では Emacs には
含まれていません。それは Gnus の配布の contrib ディレクトリー、また
は @uref{http://heim.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el} か
ら入手することができます。

あなたの消去ファイルが非常に複雑なのであれば---それ
に @code{gnus-kill} 形式以外のものがたくさん含まれているのなら、それらを
手で変換しなければならないでしょう。あるいは、単そのままにしておいてくだ
さい。Gnus は以前と同様にそれらを使ってくれるでしょう。

@node Advanced Scoring
@section 上級スコア付け

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、本当に興味がある
のが、特定の表題に関してある人が言っていることだけだった場合はどうすれば
良いでしょう?  もしくは、A さんが B さんにフォローアップしているときは彼
女が言っていることを読みたくないけれど、C さんにフォローアップしていると
きは何を言っているかを知りたいという場合は?

上級スコア規則を使えば、どんな複雑なスコアのパターンでも作成することがで
きます。

@menu
* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する
@end menu

@node Advanced Scoring Syntax
@subsection 上級スコア付け構文

普通のスコア規則では、規則の最初の要素が文字列です。上級スコア付け規則で
は、最初の要素はリストです。二番目の要素は、最初の要素が @code{nil} でな
い値として評価されたときに適用されるスコアです。

これらのリストは三つの論理演算子、一つのリダイレクト演算子 (訳注: 本文で
は間接演算子と表記されています)、および様々な合致演算子で構成することが
できます。

論理演算子:

@table @code
@item &
@itemx and
この論理演算子は、それぞれの引数を順に評価して、ある評価の結果
が @code{false} になったら停止します。すべての引数が @code{true} の値に
評価された場合、この演算子は @code{true} を返します。

@item |
@itemx or
この論理演算子は、それぞれの引数を順に評価して、ある評価の結果
が @code{true} になったら停止します。どの引数も @code{true} でなかったら、
この演算子は @code{false} を返します。

@item !
@itemx not
@itemx ¬
この論理演算子はたった一つの引数を取ります。その引数の値の論理否定を返し
ます。
@end table

スコア付けされている現在の記事の先祖たちに対して、その引数群を適用する
「間接演算子」があります。例えば @code{1-} は、現在の記事の親にもスコア
規則を適用します。@code{2-} は現在の記事の祖父母にスコア規則を適用します。
代わりに @code{^^} を書くこともでき、@code{^} (caret==キャレット) の数で
どのくらい祖先の記事までさかのぼるかを示します。

最後に合致演算子があります。これらが本当の仕事をするものです。合致演算子
はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合致演
算子は @samp{("form" "Lars Ingebrigtsen" s)} のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。

@node Advanced Scoring Examples
@subsection 上級スコア付けの例

以下の例はスコアファイルの規則であることに注意してください。それらを使っ
て完璧なスコアファイルを作るには、別の括弧の組でそれらを囲んでください。

Lars が Gnus に関して話をしているときに、彼によって書かれた記事のスコア
を増やしたいとしましょう:

@example
@group
((&
  ("from" "Lars Ingebrigtsen")
  ("subject" "Gnus"))
 1000)
@end group
@end example

ふん、簡単すぎるかな?

彼が長い記事を書くとき、時々何か素敵なことを言います:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (|
   ("subject" "Gnus")
   ("lines" 100 >)))
 1000)
@end example

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

@example
((&
  ("from" "Lars Ingebrigtsen")
  (1- ("from" "Reig Eigil Logge")))
 -100000)
@end example

Redmondo が消えた靴下について書いたときにフォローアップしたすべての人の
スコアが上げられますが、それは彼らが白い靴下について語っているときのみで
す。しかし Lars が靴下について話をしているときは、たいていあまりおもしろ
くありません:

@example
((&
  (1-
   (&
    ("from" "redmondo@@.*no" r)
    ("body" "disappearing.*socks" t)))
  (! ("from" "Lars Ingebrigtsen"))
  ("body" "white.*socks"))
 1000)
@end example

大量の記事が流れているグループを読んでいて、返答にしか興味が無いとしましょ
う。そういう場合にやることは、"Re:"、"Fw:" または "Fwd:" で始まる表題を
持っていないすべての記事のスコアを下げて、返答の印で始まる表題を持ってい
る記事のすべての親のスコアを上げることです。

@example
((! ("subject" "re:\\|fwd?:" r))
  -200)
((1- ("subject" "re:\\|fwd?:" r))
  200)
@end example

可能性は無限大です。

@node Advanced Scoring Tips
@subsection 上級スコアのちょっとした秘訣

@code{&} と @code{|} 論理演算子は、無意味な処理を迂回する論理 (原典:
short-circuit logic) に基づいて動作します。すなわち、その処理の結果が明
らかになった時点で、引数を処理することを止めます。例えば @code{&} の引数
の一つが @code{false} に評価されると、残りの引数を評価する意味がありませ
んから。これは遅い合致 (@samp{body} や @samp{header}) を最後に持ってきて、
速い合致 (@samp{from} や @samp{subject}) を最初に持ってくるべきであるこ
とを示唆します。

間接演算子 (@code{1-} など) は、それらの引数をスレッドの一世代前に作用さ
せます。次のようなことをすると:

@example
...
(1-
 (1-
  ("from" "lars")))
...
@end example

これは「現在の記事の祖父母の from ヘッダーでスコアを付ける」ということを
意味します。間接演算子の処理はとても速いのですが、以下のやり方の方が:

@example
(1-
 (&
  ("from" "Lars")
  ("subject" "Gnus")))
@end example

次のものより良いです:

@example
(&
 (1- ("from" "Lars"))
 (1- ("subject" "Gnus")))
@end example

@node Score Decays
@section スコアを減衰させる
@cindex score decays
@cindex decays

スコアは (特に適応スコアを使っていると) 際限無く膨れ上がる傾向があること
に気が付くでしょう。スコアが大きくなりすぎると、それらはすべての意味を失
います---それらは単に最大値に達してしまうので、意味のある方法で使うこと
は難しくなります。

@vindex gnus-decay-scores
@findex gnus-decay-score
@vindex gnus-decay-score-function
Gnus はこの問題の解決を助けるためにスコアを減衰させる機構を提供します。
スコアファイルが読み込まれて、@code{gnus-decay-scores} が @code{nil} で
はないと、Gnus はスコアファイルを減衰機構に通して、すべての永続でないス
コア規則のスコアを下げます。もし @code{gnus-decay-scores} が正規表現だっ
たら、それに合致するスコアファイルだけが扱われます。例え
ば @emph{adaptive} スコアファイルだけを減衰させるには、それ
を @samp{\\.ADAPT\\'} に設定すれば良いでしょう。減衰そのもの
は @code{gnus-decay-score-function} 関数によって実行され、ディフォルト
は @code{gnus-decay-score} です。以下はその関数の定義です:

@lisp
(defun gnus-decay-score (score)
  "`gnus-score-decay-constant' と `gnus-score-decay-scale' に従って
SCORE を減衰させます。"
  (let ((n (- score
              (* (if (< score 0) -1 1)
                 (min (abs score)
                      (max gnus-score-decay-constant
                           (* (abs score)
                              gnus-score-decay-scale)))))))
    (floor n)))
@end lisp

@vindex gnus-score-decay-scale
@vindex gnus-score-decay-constant
@code{gnus-score-decay-constant} はディフォルトで 3、
@code{gnus-score-decay-scale} は 0.05 です。これは以下のようなことを引き
起こします:

@enumerate
@item
この関数が呼ばれたときに @minus{}3 から 3 の間のスコアは 0 に設定されま
す。

@item
3 から 60 までの間の大きさのスコアは 3 減らされます。

@item
60 より大きいスコアはスコアの 5% が減らされます。
@end enumerate

もしこの減衰関数がお気に召さないなら、自分用の関数を書いてください。それ
は減衰させるべきスコアを唯一の引数として呼ばれ、新しいスコアを整数で返さ
なければなりません。

Gnus は一日に一回スコアを減衰させようとします。例えば Gnus を四日間走ら
せていないと、Gnus はスコアを四回減衰させます。

@node Searching
@chapter 検索
@cindex searching

FIXME: Gnus の検索機能に関する短い概要を追加。nnir, nnmairix,
contrib/gnus-namazu の簡潔な比較もまた良し。

この章は、ある語に合致する記事をグループおよびサーバーで検索してそれらの
記事を取得するための道具について説明します。Gnus はそれらの合致パターン
を概略バッファーの記事たちを通して検索する、より単純な機構を提供します。
@xref{Searching for Articles}.

@menu
* nnir::                     いろんなエンジンで検索する
* nnmairix::                 Mairix で検索する
@end menu

@node nnir
@section nnir
@cindex nnir

この項は @code{nnir} を使って Gnus の記事を検索するやり方を説明します。

@menu
* What is nnir?::               @code{nnir} は何をするか?
* Basic Usage::                 簡単な検索のしかた
* Setting up nnir::             @code{nnir} の設定方法
@end menu

@node What is nnir?
@subsection nnir とは?

@code{nnir} はメールとニュースの倉庫を検索するための数ある道具へ
の Gnus のインターフェースです。異なるバックエン
ド (例えば @code{nnimap} と @code{nntp}) は異なる道具 (@code{nnir} 用語
で言うところの @dfn{エンジン}) で動作しますが、すべて同じ基本的な検索イ
ンターフェースを使います。

@code{nnimap} および @code{gmane} 検索エンジンは設定無しで動くはずです。
他のエンジンはローカルな索引を必要とします。それは Gnus の外で作り、かつ
維持しなければなりません。

@node Basic Usage
@subsection 基本的な使い方

グループバッファーで @kbd{G G} をタイプすると、
@code{gnus-group-make-nnir-group} を呼ぶことによって現在行のグループを検
索します。これは検索語の入力を促して、それに合致する記事を含む一時的な
@code{nnir} グループを作り、それらの記事がある概略バッファーを表示します。
そうしたら、後はいつものコマンドを使って記事を読んだり、移動したり、削除
したりすれば良いのです。

このように作られた @code{nnir} グループは一時的 (@code{ephemeral}) なグ
ループなので、既読、移動および削除は別として、いくつかの変更は永続しませ
ん。つまり元の記事に手を加えることはできません。しかし代わりの手がありま
す。@kbd{A W} (@code{gnus-warp-to-article}) で、現在行の記事の元の記事
に @emph{ワープ} (ジャンプ) できるのです。さらに良いのは概略バッファー
で @kbd{A T} にディフォルトで割り当てられている関
数 @code{gnus-summary-refer-thread} で、それはその魔法を行なう前、最初に
元のグループにワープして、そのスレッドにあるすべての記事を含めます。そこ
から記事を読み、移動し、また削除できるだけでなく、それらをコピーしたり、
印を変更したり、その他何でもできます。ああ、頭がおかしくなりそう (原
典: ``Go nuts'')。

現在行のグループだけでなく、他のグループも検索したいですって?  問題あり
ません。単に検索したいグループにプロセス印を付けてください。さらにもっ
と?  それならトピックの見出しにカーソルを置いて nnir 検索を実行すれば、
その見出しの下のすべてのグループを検索してくれるでしょう。

まだ足りないんですか?  よろしい、サーバーバッファー
で @code{gnus-group-make-nnir-group} (現在は @kbd{G} に割り当てられてい
る) を使えば、現在行のサーバーにあるすべてのグループを検索できます。多す
ぎますか?  検索する際に spam グループのようなグループを無視したいという
ことですね?  であれば @code{nnir-ignored-newsgroups} をカスタマイズして
ください。

さらにもう一つ。個々の検索エンジンは特別な検索機能を持っているかもしれま
せん。それらの特別な検索機能は、@code{gnus-group-make-nnir-group} に接頭
引数を与えることによって利用できます。もし複数のグループを異なる検索エン
ジンで検索するのであれば、それぞれのエンジン毎に別れて特別な検索機能を使
うかどうかを尋ねられるでしょう。

@node Setting up nnir
@subsection nnir の設定方法

nnir を設定するには、いくらか準備作業が必要です。まず、使おうと思ってい
る検索エンジンを設定しましょう。それらのうちのいくつか、例え
ば @code{imap} と @code{gmane} については特別な設定は要りません。他の、
例えば @code{namazu} と @code{swish} については後述の設定が必要です。次
に、サーバーまたはバックエンドと検索エンジンを関連付ける必要があります。

もし単に @code{nnimap} サーバーを検索するために @code{imap} エンジンを、
そして @code{gmane} を検索するために @code{gmane} エンジンを使いたいので
あれば、何もする必要はありません。しかしながら検索語の書き方の詳細説明は、
とにかく読む必要があるでしょう。

@menu
* Associating Engines::                 エンジンと関連付ける方法
* The imap Engine::                     Imap の設定と使い方
* The gmane Engine::                    Gmane の設定と使い方
* The swish++ Engine::                  Swish++ の設定と使い方
* The swish-e Engine::                  Swish-e の設定と使い方
* The namazu Engine::                   Namazu の設定と使い方
* The notmuch Engine::                  Notmuch の設定と使い方
* The hyrex Engine::                    Hyrex の設定と使い方
* Customizations::                      カスタマイズできる設定
@end menu

@node Associating Engines
@subsubsection エンジンとの関連付け

グループを検索するときに @code{nnir} はどの検索エンジンを使うかを知って
いる必要があります。サーバー変数 @code{nnir-search-engine} をエンジンの
名前に設定することによって、所定のサーバーが特定のエンジンを使うように設
定してください。例えば @code{home} という名前のサーバーを検索するため
に @code{namazu} エンジンを使うには以下のようにします:

@lisp
(setq gnus-secondary-select-methods
      '((nnml "home"
              (nnimap-address "localhost")
              (nnir-search-engine namazu))))
@end lisp

あるいは、一つのバックエンドがまかなうすべてのサーバーのために、特定の一
つのエンジンを使う必要があるかもしれません。例えば @code{nnimap} バック
エンドを使うすべてのサーバーで @code{imap} エンジンを使いたい場合です。
その場合は変数 @code{nnir-method-default-engines} をカスタマイズしてくだ
さい。これは @code{(backend . engine)} 形式のペアの連想リストです。この
変数はディフォルトでは @code{nnimap} バックエンドを使うすべてのサーバー
で @code{imap} エンジンを、そして @code{nntp} サーバーに
は @code{gmane} エンジンを使うように設定されています。(@code{gmane} 検索
エンジンは gmane ではない @code{nntp} サーバーを実際に検索しようとしませ
んから、ご心配なく。)  でも @code{nnimap} バックエンドを使うすべてのサー
バーのために @code{namazu} を使いたかったのであれば、以下のように変更す
ることができます:

@lisp
'((nnimap . namazu)
  (nntp . gmane))
@end lisp

@node The imap Engine
@subsubsection Imap エンジン

@code{imap} エンジンは設定不要です。

@code{imap} エンジンを使う検索には、簡単な検索語の書き方があります。検索
は常に大文字と小文字を区別せず、以下の機能を持っています (Google 検索の
検索語の書き方に倣っています)。

@table @samp
@item ブール演算子
AND、OR、および NOT をサポートし、演算子の優先順位を制御するために括弧を
使うことができます。例えば「(emacs OR xemacs) AND linux」のように。演算
子はそれであると認知されるために、すべて大文字で書かなければならないこと
に注意してください。さらに、語に先立つ @minus{} 記号は「NOT 語」と等価で
す。

@item 自動 AND 検索
もし複数の語を指定すると、それらはすべての要素に合致することを意図し
た AND 検索として扱われます。

@item 熟語検索
もし検索語を 2重引用符で囲むと、それはひとまとまりの文字列として扱われま
す。
@end table

ディフォルトではメッセージ全体が検索されます。接頭引数を使うことによって、
検索をメッセージの指定する部分だけに制限することができ、そうすると検索語
が入力された後で、メッセージの部分を (補完付きで) 尋ねられます。選択肢に
は ``Whole message'' (メッセージ全体)、``Subject''、``From''、およ
び ``To'' があります。それ以外はどんな入力もヘッダー名であると解釈されま
す。例えばこの問いに @kbd{Message-ID} とタイプして応えると、検索
は Message-ID ヘッダーだけに制限されます。

最終的に ``Imap'' を選ぶと、それは生の @acronym{IMAP} 検索と解釈されます。
そのような検索のフォーマットは RFC3501 で見つかるはずです。

もしディフォルトのメッセージ全体検索が好みでないのであれ
ば @code{nnir-imap-default-search-key} をカスタマイズしてください。ディ
フォルトで @acronym{IMAP} 検索を使いたい場合は、こうしてください:

@lisp
(setq nnir-imap-default-search-key "Imap")
@end lisp

@node The gmane Engine
@subsubsection Gmane エンジン

@code{gmane} エンジンは設定不要です。

@code{gmane} エンジンを使う検索には、簡単な検索語の書き方があります。

@table @samp
@item ブール演算子
AND、OR、NOT (または AND NOT) および XOR をサポートし、演算子の優先順位
を制御するために括弧を使うことができます。例えば「(emacs OR xemacs) AND
linux」のように。演算子はそれであると認知されるために、すべて大文字で書
かなければならないことに注意してください。

@item 必須の、または除外すべき語
+ と @minus{} は語が必須であるか、または除外すべきかを指定します。例え
ば: 「football @minus{}american」

@item Unicode の取扱い
検索エンジンはすべてのテキストを utf-8 に変換するので、どんな言語でも検
索できるはずです。

@item Stopwords
ありふれた英単語 ('the' や 'a' のようなもの) はディフォルトで無視されま
す。そのような単語でも + を前置き (例: +the) したり、引用符で囲
む (例: "the") ことによって検索対象にすることができます。
@end table

接頭引数を使うことによって、検索を指定した著者による記事に限定することが
できます。そうすると検索語が入力された後で、合致する著者名 (または名前の
一部) が尋ねられます。

@node The swish++ Engine
@subsubsection Swish++ エンジン

FIXME: ここで何かもっと言う。

Swish++ の資料は sourceforge の swish++ のページで見つかるでしょ
う: @uref{http://swishplusplus.sourceforge.net}

@table @code
@item nnir-swish++-program
Swish++ の実行形式の名前。ディフォルトは @code{search} です。

@item nnir-swish++-additional-switches
Swish++ に追加の引数として与えられる文字列のリスト。ディフォルト
は @code{nil} です。

@item nnir-swish++-remove-prefix
グループ名を得るために swish++ が返すそれぞれのファイル名から取り除く接
頭語。これはディフォルトでは @code{$HOME/Mail} です。
@end table

@node The swish-e Engine
@subsubsection Swish-e エンジン

FIXME: ここで何かもっと言う。

Swish-e の資料は swish-e ホームページで見つかるでしょ
う: @uref{http://swish-e.org}

@table @code
@item nnir-swish-e-program
Swish-e 検索プログラムの名前。ディフォルトは @code{swish-e} です。

@item nnir-swish-e-additional-switches
Swish-e に追加の引数として与えられる文字列のリスト。ディフォルト
は @code{nil} です。

@item nnir-swish-e-remove-prefix
グループ名を得るために swish-e が返すそれぞれのファイル名から取り除く接
頭語。これはディフォルトでは @code{$HOME/Mail} です。
@end table

@node The namazu Engine
@subsubsection Namazu エンジン

Namazu を使うには索引ファイルを作って維持する必要があります。すべての索
引ファイルは一つのディレクトリーに置いてあるはずで、その所在
を @code{nnir-namazu-index-directory} 変数を設定することによって nnir に
伝えなければなりません。

正しく働かせるには @code{nnir-namazu-remove-prefix} 変数も正しくなければ
なりません。これは、正しいグループ名を得るために Namazu が返すそれぞれの
ファイル名から取り除く接頭語です (@samp{.} は @samp{/} に置き代わります
が)。

例えば Namazu が @samp{/home/john/Mail/mail/misc/42} のようなファイル名
を返すとしましょう。この例では次の設定を使ってください:

@lisp
(setq nnir-namazu-remove-prefix "/home/john/Mail/")
@end lisp

最後のスラッシュに注意してください。ディレクトリーからこの接頭語を取り除
くと @samp{mail/misc/42} になります。@code{nnir} は正しいグループ
名 @samp{mail.misc} を導くために @samp{/42} を取り除い
て @samp{/} を @samp{.} で置き換えるべきであることは承知しています。

他のオプションは @code{nnir-namazu-additional-switches} を設定することに
よって namazu 検索コマンドに渡されます。とりわけ、出力の形式を変更してし
まうどんなオプションも namazu に渡さないことが重要です。使っても良いオプ
ションは @option{--sort}、@option{--ascending}、@option{--early} およ
び @option{--late} です。さらなる有効なオプションについては Namazu の説
明書を参照してください。

メールは @command{mknmz} プログラムで最初に索引付けされなければなりませ
ん。設定ファイルを作るためには namazu の説明書を読んでください。ここに例
があります:

@cartouche
@example
 package conf;  # この行は消さないこと!

 # 索引付けされないパス。'^' または '$' アンカーを使わないこと。
 $EXCLUDE_PATH = "spam|sent";

 # 検索すべきヘッダー・フィールド。大文字/小文字の区別は無い。
 $REMAIN_HEADER = "from|date|message-id|subject";

 # 検索できるフィールド。大文字/小文字の区別は無い。
 $SEARCH_FIELD = "from|date|message-id|subject";

 # 最も長い語の長さ。
 $WORD_LENG_MAX = 128;

 # 最も長いフィールドの長さ。
 $MAX_FIELD_LENGTH = 256;
@end example
@end cartouche

例えばメールが @samp{~/Mail/mail/}、@samp{~/Mail/lists/} およ
び @samp{~/Mail/archive/} ディレクトリーに格納されるのであれば、それらに
索引付けをするためには @code{nnir-namazu-index-directory} に設定されてい
る索引ディレクトリーに行って、以下のコマンドを発行します。

@example
mknmz --mailnews ~/Mail/archive/ ~/Mail/mail/ ~/Mail/lists/
@end example

最大の検索効率を得るためには、このコマンドを定期的に (例えば 4時間毎
に) 実行する cron ジョブを走らせる必要があるでしょう。

@node The notmuch Engine
@subsubsection Notmuch エンジン

@table @code
@item nnir-notmuch-program
Notmuch 検索エンジンの実行形式の名前です。ディフォルト
は @samp{notmuch} です。

@item nnir-notmuch-additional-switches
@samp{notmuch} に追加の引数として与える文字列のリストです。

@item nnir-notmuch-remove-prefix
@samp{notmuch} が返すそれぞれのファイルの名前からグループ名を得る
ために取り除く接頭辞です (得られる名前は @samp{.} の代わり
に @samp{/} を使っているものですが)。これは正規表現です。

@item nnir-notmuch-filter-group-names-function
@samp{notmuch} の ``path:'' 検索キーワードとして使うために、検索するグルー
プの名前を変換する関数です。ディフォルトは @code{nil} で、``path:'' キー
ワードは使いません。関数にする場合、これは単一のグループ名を受け取って、
@samp{notmuch} が認識できる変換された名前を返すように呼び出すことができ
るものでなければなりません。例えば、多くのメールバックエンドではグループ
名のドットをスラッシュに変換する必要がありますが、それを成し遂げるにはこ
のオプションを次のようにしてください:

@example
(lambda (g) (replace-regexp-in-string "\\." "/" g))
@end example
@end table

@node The hyrex Engine
@subsubsection Hyrex エンジン
このエンジンはもはや使われていません。

@node Customizations
@subsubsection カスタマイズ

@table @code
@item nnir-method-default-engines
サーバーのバックエンドと検索エンジンのペアよりなる連想リスト。ディフォル
トの関連付けは次の通りです:

@example
(nnimap . imap)
(nntp . gmane)
@end example

@item nnir-ignored-newsgroups
一つのサーバーにあるすべてのグループを検索するときに、active ファイルに
ある読み飛ばすべきニュースグループに合致する正規表現。

@item nnir-summary-line-format
nnir 概略バッファーの行のために使われる書法仕様。
@code{gnus-summary-line-format} のすべての書法仕様指示子とともに nnir 概
略バッファー独自の以下の三つの指示子を使うことができます:

@example
%Z    検索結果のスコアの値 (整数)
%G    記事があった元の完全なグループ名 (文字列)
%g    記事があった元の短縮形のグループ名 (文字列)
@end example

もし @code{nil} だったら (それがディフォルト)、
@code{gnus-summary-line-format} を使います。

@item nnir-retrieve-headers-override-function
もし @code{nil} でなければ、Gnus に組み込まれている関数を使わずに記事の
ヘッダーを取得するための関数。この関数は引数として記事のリストとグループ
を取り、取得したヘッダーで @code{nntp-server-buffer} を満たします。そし
て、取得したヘッダーの形式を示すために @code{nov} また
は @code{headers} を返さなければなりません。ヘッダーの取得に失敗したとき
は @code{nil} を返します。

もしこの変数が @code{nil} だったら、または用意した関数が検索結果とし
て @code{nil} を返したら、代わりに @code{gnus-retrieve-headers} が呼ばれ
ます。
@end table

@node nnmairix
@section nnmairix

(訳注: Mairix は @acronym{ASCII} 文字しかサポートしません。)

@cindex mairix
@cindex nnmairix
この項は、メールに索引を付けて Gnus 内で検索するために、どうやっ
て mairix とバックエンド @code{nnmairix} を設定するかを説明します。さら
に mairix 検索に結び付けられて自動的に更新される恒久的
な ``賢い'' (smart な) グループを作ることができます。

@menu
* About mairix::                メール検索エンジン mairix について
* nnmairix requirements::       nnmairix を使うために必要なこと
* What nnmairix does::          nnmairix は実際に何をするのか?
* Setting up mairix::           mairix の設定
* Configuring nnmairix::        nnmairix バックエンドの設定
* nnmairix keyboard shortcuts:: 利用できるショートカットキー
* Propagating marks::           nnmairix グループの印を伝搬させる方法
* nnmairix tips and tricks::    ヒント、こつ、およびいくつかの例
* nnmairix caveats::            さらに知っておく必要があること
@end menu

@c FIXME: この項のマークアップは改善する必要がある。
@c 例えば @samp、@var、@file、@command などを加える。
@c (info "(texinfo)Indicating") を参照。
@node About mairix
@subsection メール検索エンジン mairix について

Mairix はローカルに格納されたメールに索引を付けたり単語を検索するための
道具です。書いたのは Richard Curnow で GPL でライセンスされます。
Mairix は最もポピュラーな GNU/Linux の配布に付属していますが Windows (た
だし cygwin を併用)、macOS および Solaris のもとでも動作します。ホームペー
ジは @uref{http://www.rpcurnow.force9.co.uk/mairix/index.html} です。

@code{nnir} バックエンドを介して使うことができる swish++ や namazu のよ
うな他の検索ツールほどには mairix は融通がきかないかもしれませんが、それ
には信じられないほど速いというすばらしい特長があります。現在のシステムで
は 1秒で何千通ものメールのヘッダーと記事のボディーの隅々までを容易に捜す
ことができます。検索するために必要なデータベースの構築には 1〜2分かかる
かもしれませんが、一度それを完全に行なえば良いのです。それ以後、更新は追
加的 (インクリメンタル) に行なわれることもあって、本当に速いのです。付け
加えておくと、mairix の設定はとてもやさしいです。

しかし最高速で動かすために mairix は @code{Maildir} または @code{MH} の
形式 (これは @code{nnml} バックエンドを含みます) で格納されたメールで使
わなければなりません。もっとも mbox でも動作するのですけれど。Mairix は
実際のメッセージファイルを指し示すシンボリックリンクを「仮想」
の maildir/MH フォルダーに置くことによって検索結果を提示します (mbox を
使っている場合はコピーが作られます)。Mairix はそのような仮想フォルダーに
すでに検索結果を提示しているので、あるメール検索の結果を提示する「賢い」
メール・フォルダーを作成するために外部のプログラムとして使用するのに非常
によく適しています。

@node nnmairix requirements
@subsection nnmairix を使うために必要なこと

Mairix はローカルなメールを検索します---つまり mairix はメール・フォルダー
を必ず直接にアクセスできなければなりません。もしメールが別のサーバー (例
えば @acronym{IMAP} サーバー) にあって、たまたま shell でアクセスするこ
とができるのならば、@code{nnmairix} は例えば ssh を介して mairix を遠隔
で動作させることもできます。

加えて、@code{nnmairix} は Gnus のバックエンド @code{nnml}、
@code{nnmaildir} および @code{nnimap} だけをサポートします。
@code{nnmairix} を使うには、必ずこれらのバックエンドの一つを使わなければ
なりません。@code{nnmbox}、@code{nnfolder} または @code{nnmh} のような他
のバックエンドでは動作しないでしょう。

もしどうしても mbox を使わなければならなくて、それで
も @code{nnmairix} を使いたいのならば、ローカルな @acronym{IMAP} サーバー
を立ち上げることによって @code{nnimap} を介してアクセスすることができま
す。これはいくつかの mbox ファイルにアクセスするためにしてはかなり大がか
りな作業になるので、もう MH か Maildir に変えてしまいましょう。それで
も mbox を使うことに本当に本当に情熱を持っているのなら、Emacs 23 に付属
している @file{mairix.el} パッケージを研究する必要があるでしょう。

@node What nnmairix does
@subsection nnmairix は実際に何をするのか?

バックエンド @code{nnmairix} は、ある検索語で mairix に尋ねたりデータベー
スを更新させるために Gnus から mairix を呼ぶことを可能にします。概略バッ
ファーでメッセージを見ている間、あらかじめ用意されている mairix を呼ぶた
めのいくつかのショートカットを使うことができます。例えば現在見ているメッ
セージの送信者からのすべてのメールをすばやく探したり、メールが異なったフォ
ルダーにあっても、そのメッセージに関連している全体のスレッドを表示するな
どです。

さらに、ある mairix 検索に結び付いた恒久的な @code{nnmairix} グループを
作ることができます。この例では、ある送信者から来て、かつ、ある表題行 (ま
たは Message-ID に基づく一つの特定のスレッドさえ) を持つメールを含むグルー
プを容易に作ることができます。これらのフォルダーで新しいメールをチェック
する (例えば @kbd{g} または @kbd{M-g} を押す) と、mairix を呼ぶことによっ
てそれら自体が自動的に更新します。

Mairix はすでにグループを作っていて、Gnus でアクセスできるようにそれらの
メールへのリンクを用意しているのに、いったいなぜ @code{nnmairix} が必要
なのかと尋ねるかもしれませんね。そうではありませんか? えーと、それは動
く@emph{かも}しれませんが、だめなことが多いでしょう---問題無しには。最も
ありそうなのは、記事数がおかしくなって、しかも時々は Gnus があるはずだと
言い張るメールがすでにキャンセルされていてアクセスできないことを思い知ら
されることでしょう。これは、ものごとが Gnus の後ろに隠れて起こっていると
き、Gnus は本当は不満に思っているという事実のためです。例え
ば @acronym{IMAP} サーバーで mairix を使っているのなら、もう一つの問題は
メールバックエンド自体であるかもしれません (mairix が検索グループの内容
を変えたとき、Dovecot は間違った索引ファイルについて私に不平を言いました)。
@code{nnmairix} を使えば、これらの問題は回避されるはずです。

実は @code{nnmairix} はメールバックエンドではありません---それ
は mairix が検索結果を格納する「本当の」メールバックエンドと Gnus フロン
トエンドの間に位置していて、むしろ実際にはラッパーに似ています。
Mairix フォルダーのために三つの異なるメールバックエンド @code{nnml}、
@code{nnmaildir} または @code{nnimap} の中から選ぶことができます。
@code{nnmairix} は検索結果をこのメールバックエンド
の @code{zz_mairix-<NAME>-<NUMBER>} という名前のフォルダーに格納するため
に mairix バイナリーを呼びますが、それらのフォルダーは Gnus フロントエン
ドには名前が @code{<NAME>} だけになって渡されます。すでにメールを格納し
ている既存のメールバックエンドを使うことができますが、あなたの他のメール
と並べて新しいメールグループを作る @code{nnmairix} が気持ち悪いのであれ
ば、例えば新しい @code{nnmaildir} または @code{nnml} サーバー
を mairix 専用に作ることもできます。ただし、それらのサーバーが間違って新
着メールを取り込んでしまわないようにしてくださ
い (@pxref{nnmairix caveats})。もし @code{nnimap} ととも
に @acronym{IMAP} サーバーで mairix をリモートに使いたいのであれば、特別
な事情が生じます---ここでは mairix フォルダーと他のメールが同
じ @code{nnimap} バックエンド上になければなりません。

@node Setting up mairix
@subsection mairix の設定

まずはメールフォルダーのバックアップを作りましょう (@pxref{nnmairix
caveats})。

Mairix の設定は簡単です。(少なくとも) 以下のエントリーを含
む @file{.mairixrc} ファイルを作ってください:

@example
# Your Maildir/MH base folder
base=~/Maildir
@end example

これはすべてのメールの基点になるフォルダーです。以下のすべてのディレクト
リーはこのフォルダーを基点に相対的な値をとります。
@code{nnmairix} を @code{nnimap} で使いたい場合、この基点のディレクトリー
は @acronym{IMAP} サーバーがメールフォルダーを格納するメールディレクトリー
を表すものでなければなりません!

@example
maildir= ... 索引を付ける maildir フォルダー ...
mh= ... 索引を付ける nnml/mh フォルダー ...
mbox= ... 索引を付ける mbox フォルダー ...
@end example

Mairix で索引を付けたいすべてのメールフォルダーと mbox ファイルをこれ
で (基点ディレクトリーへの相対値で!) 指定します。@code{nnml} バックエン
ドはメールを MH 形式で保存するので、それらのディレクトリー
を @code{mh} 行に置いておかなければならないことに注意してください。さら
に詳しいことについては、この章の最後にある例と mairixrc の man ページを
見てください。

@example
omit=zz_mairix-*
@end example

@vindex nnmairix-group-prefix
これは mairix の検索結果に偶然に索引付けをしてしまわないためのものです。
これらのフォルダーの接頭辞は、変数 @code{nnmairix-group-prefix} で変える
ことができます。

@example
mformat= ... 'maildir' または 'mh' ...
database= ... データベース・ファイルの置き場所 ...
@end example

@code{mformat} の設定は mairix 検索フォルダーへの出力形式を指定します。
検索結果に @code{nnml} でアクセスしたい場合は、これを @code{mh} に設定し
てください。さもなければ @code{maildir} を選びましょう。

要約するために、私の @file{.mairixrc} ファイルを短くしたものを例に挙げま
しょう:

@example
base=~/Maildir
maildir=.personal:.work:.logcheck:.sent
mh=../Mail/nnml/*...
mbox=../mboxmail/mailarchive_year*
mformat=maildir
omit=zz_mairix-*
database=~/.mairixdatabase
@end example

この場合、基点のディレクトリーは @file{~/Maildir} で、そこに私のすべて
の Maildir フォルダーが格納されています。ご覧のようにそれぞれのフォルダー
はコロンで区切られています。なぜどのフォルダーもドットで始まるのかっ
て? それは私が @acronym{IMAP} サーバーとして Dovecot を使い、さらにそれ
は @code{Maildir++} フォルダーを使うからです。@code{nnmairix} をテストす
るために @file{~/Mail/nnml} にセーブされている @code{nnml} のメールもい
くつか持っています。これは @code{base} ディレクトリーへの相対値で指定し
なければならないので @code{../Mail} の表記が必要です。@code{*...} で終わ
る行は、このディレクトリーにあるすべてのファイルを再帰的に走査するためで
あることに注意してください。三個のドット無しのワイルドカード @code{*} で
は再帰的に働きません。さらに私は @file{~/mboxmail} のあたりにアーカイブ
されたメールを含む古い @code{mbox} ファイルを持っています。その他の行の
意味は言うまでもないですね。

詳細およびさらなるオプションについては @code{mairixrc} の man ページを見
てください。とりわけワイルドカードの使い方は、今まで使っていたのとは少し
違うでしょう。

さあ、それでは最初に @code{mairix} を実行して索引を作りましょう。これに
は数分かかるでしょう。でもあらゆる索引が追加的 (インクリメンタル) に更新
を行なうので非常に速いです。

@node Configuring nnmairix
@subsection nnmairix バックエンドの設定

グループモード
で @kbd{G b c} (@code{nnmairix-create-server-and-default-group}) をタイ
プしてください。これは必要なすべての情報を質問して、@code{nnmairix} サー
バーを外部 (foreign) グループとして作成します。以下を指定する必要がある
でしょう:

@itemize @bullet
@item
@code{nnmairix} サーバーの @strong{名前} です---好きなものを選んでくださ
い。

@item
Mairix がその検索結果を格納する @strong{バックエンド・サーバー} の名前で
す。これは @code{nnml:mymail} のような完全なサーバー名でなければなりませ
ん。今のところ @code{nnmaildir}、@code{nnimap} および @code{nnml} でアク
セスするサーバーがサポートされています。上で説明したように、ローカルに格
納されるメールのためには、あなたがメールを格納している既存のサーバーにす
れば良いでしょう。しかし @code{nnmairix} 専用に、例えば新し
い @code{nnmaildir} または @code{nnml} サーバーを第二の (secondary) 選択
方法に加えることもできます (@pxref{Finding the News})。もしまさに第二
の @code{nnml} サーバーを mairix 用に使っているのであれば、サーバー変
数 @code{nnml-get-new-mail} を確実に @code{nil} に設定してください。さも
ないとメールを失うことになりかねません (@pxref{nnmairix caveats})。
Mairix を @acronym{IMAP} サーバー上で遠隔動作させたいのならば、そこでそ
れに対応する @code{nnimap} サーバーを選ばなければなりません。

@item
@vindex nnmairix-mairix-search-options
Mairix バイナリーを呼ぶための @strong{コマンド} です。通常これは単
に @code{mairix} で良いのですが、例えば @acronym{IMAP} サーバー上
で mairix を遠隔動作させたいのであれば、@code{ssh SERVER mairix} のよう
なものにすることもできます。Mairix へのディフォルトのオプションを加えた
い場合、それをここでやっても構いません。でも、代わりに変
数 @code{nnmairix-mairix-search-options} を使う方が良いです。

@item
@strong{ディフォルトの検索グループ} の名前です。これは mairix のすべての
検索結果、つまり恒久的な @code{nnmairix} グループに結び付けられないすべ
ての検索結果を格納するグループです。好きなものを選んでください。

@item
もしメールバックエンドが @code{nnimap} か @code{nnmaildir} だったら、
@strong{Maildir++} つまり隠された (= @samp{.} で始まる ) maildir フォル
ダーを使うかどうかを尋ねられるでしょう。例えば Dovecot @acronym{IMAP} サー
バーを使っている場合は、そこで @samp{yes} と回答しなければなりません。そ
れ以外の場合は @samp{no} と答えるべきです。
@end itemize

@node nnmairix keyboard shortcuts
@subsection nnmairix で利用できるショートカットキー

グループモードで:

@table @kbd
@item G b c
@kindex G b c @r{(グループ)}
@findex nnmairix-create-server-and-default-group
@code{nnmairix} サーバーと、このサーバーのためのディフォルトの検索グルー
プを作ります (@code{nnmairix-create-server-and-default-group})。これはす
でに行なっておいてある必要があります (@pxref{Configuring nnmairix})。

@item G b s
@kindex G b s @r{(グループ)}
@findex nnmairix-search
Mairix に送られる検索語を与えます。検索結果はディフォルトの検索グループ
に格納され、それは自動的に表示されます (@code{nnmairix-search})。

@item G b m
@kindex G b m @r{(グループ)}
@findex nnmairix-widget-search
Mairix の検索または恒久的なグループをもっと快適に、常にグループのカスタ
マイズに似たグラフィックなウィジェットを使って作るようにします。それがど
んなものかを知るには、まずは試してみてくださ
い (@code{nnmairix-widget-search})。

@item G b i
@kindex G b i @r{(グループ)}
@findex nnmairix-search-interactive
もう一つの快適な mairix 検索コマンドですが、ミニバッファーしか使いませ
ん (@code{nnmairix-search-interactive})。

@item G b g
@kindex G b g @r{(グループ)}
@findex nnmairix-create-search-group
検索に関連させられた恒久的なグループを作りま
す (@code{nnmairix-create-search-group})。このグループを @kbd{g} また
は @kbd{M-g} で更新するときに @code{nnmairix} バックエンドは自動的
に mairix を呼びます。

@item G b q
@kindex G b q @r{(グループ)}
@findex nnmairix-group-change-query-this-group
カーソル位置の @code{nnmairix} グループの検索条件を変更しま
す (@code{nnmairix-group-change-query-this-group})。

@item G b t
@kindex G b t @r{(グループ)}
@findex nnmairix-group-toggle-threads-this-group
カーソル位置の @code{nnmairix} グループの 'スレッド' パラメーターをトグ
ルに切り替えます。つまり見つかったメッセージのすべてのスレッドを見たい場
合に使います (@code{nnmairix-group-toggle-threads-this-group})。

@item G b u
@kindex G b u @r{(グループ)}
@findex nnmairix-update-database
@vindex nnmairix-mairix-update-options
データベースを更新するために mairix バイナリーを呼びま
す (@code{nnmairix-update-database})。ディフォルトのパラメーターは、これ
をできるだけ速くするための @code{-F} および @code{-Q} です (これらのディ
フォルトのオプションを定義するには変
数 @code{nnmairix-mairix-update-options} を見てください)。

@item G b r
@kindex G b r @r{(グループ)}
@findex nnmairix-group-toggle-readmarks-this-group
この @code{nnmairix} グループの記事を常に既読または未読に保つか、または
印を変更しないようにしま
す (@code{nnmairix-group-toggle-readmarks-this-group})。

@item G b d
@kindex G b d @r{(グループ)}
@findex nnmairix-group-delete-recreate-this-group
「本当の」メールバックエンドで @code{nnmairix} グループを作り直しま
す (@code{nnmairix-group-delete-recreate-this-group})。
@code{nnmairix} グループの記事数がいつも間違っている場合に、これを行なう
ことができます。

@item G b a
@kindex G b a @r{(グループ)}
@findex nnmairix-group-toggle-allowfast-this-group
カーソル位置の @code{nnmairix} グループのための @code{allow-fast} パラメー
ターをトグルに切り替えま
す (@code{nnmairix-group-toggle-allowfast-this-group})。ディフォルト
の @code{nnmairix} の動作は、グループを更新したり入ったときに mairix の
検索を行なうことです。@code{allow-fast} パラメーターが設定されると、グルー
プ入ったときではなく、明示的にグループを更新するときだけ mairix が呼ばれ
ます。これはグループに入るときに速くなりますが、更新したときとま
だ mairix データベースに無いグループに入るときの期間に何かが変化した場合
に、実体の無いシンボリックリンクを生じさせるかもしれません。

@item G b p
@kindex G b p @r{(グループ)}
@findex nnmairix-group-toggle-propmarks-this-group
このグループの印を伝搬させるかどうかをトグルに切り替えま
す (@code{nnmairix-group-toggle-propmarks-this-group})。
(@pxref{Propagating marks})。

@item G b o
@kindex G b o @r{(グループ)}
@findex nnmairix-propagate-marks
印を主動で伝搬させます (@code{nnmairix-propagate-marks})。これ
は @code{nnmairix-propagate-marks-upon-close} が @code{nil} である場合だ
け必要です。
@end table

概略モードで:

@table @kbd
@item G G m
@kindex G G m @r{(概略)}
@findex nnmairix-widget-search-from-this-article
現在のメッセージに基づいた mairix の検索またはグループを、グラフィックな
ウィジェットを使って作ります (@code{nnmairix-widget-search} と同じで
す) (@code{nnmairix-widget-search-from-this-article})。

@item G G g
@kindex G G g @r{(概略)}
@findex nnmairix-create-search-group-from-message
現在のメッセージに基づいた検索条件で新しい検索グループを対話的に作ります。
グラフィックなウィジェットの代わりにミニバッファーを使います
が (@code{nnmairix-create-search-group-from-message})。

@item G G t
@kindex G G t @r{(概略)}
@findex nnmairix-search-thread-this-article
現在の記事のスレッドを捜しま
す (@code{nnmairix-search-thread-this-article})。事実上これは現在の記事
の @samp{m:msgid} で @code{nnmairix-search} を呼んでスレッドを得るための
ショートカットです。

@item G G f
@kindex G G f @r{(概略)}
@findex nnmairix-search-from-this-article
現在の記事の送信者からのすべてのメッセージを探しま
す (@code{nnmairix-search-from-this-article})。これ
は @samp{f:From} で @code{nnmairix-search} を呼ぶためのショートカットで
す。

@item G G o
@kindex G G o @r{(概略)}
@findex nnmairix-goto-original-article
(これが使えるのは @code{nnmairix} グループだけです!) この記事に正しい投
稿様式 (posting styles) とグループパラメーターを適用して返信するために、
この記事が元々来たグループを特定して、そのグループでその記事を表示しよう
とします (@code{nnmairix-goto-original-article})。この関数はもし利用可能
ならレジストリーを使いますが、代替手段として記事ファイルの名前を分析する
こともできます。

@item G G u
@kindex G G u @r{(概略)}
@findex nnmairix-remove-tick-mark-original-article
元の記事から、もしあれば可視記事の印 (tick mark) を取り除きま
す (@code{nnmairix-remove-tick-mark-original-article}) (@pxref{nnmairix
tips and tricks})。
@end table

@node Propagating marks
@subsection nnmairix グループの印を伝搬させる方法

初めに: 印を伝搬させる機能を効率良く使うためには、実際にはパッチを当て
た mairix のバイナリーが必要です。そうしないといつも mairix データベース
を更新しなければならないでしょう。パッチはここで手に入ります:

@uref{http://www.randomsample.de/mairix-maildir-patch.tar}

このパッチには mairix v0.21 のソースコードが必要です。それに付いてい
る readme ファイルでどんなことも説明されています。印の伝搬を使わなくても
良いと思うならこれらのパッチを当てなくても構いませんが、それでもなお、そ
れらは maildir フラグの変更にまつわるやっかいごとを修正してもくれるので
有用でしょう。

パッチを当てた mairix のバイナリーとともに @code{nnmairix} をメール分
割 (@pxref{Fancy Mail Splitting}) の代わりとして使うことができます。例え
ば @samp{david@@foobar.com} からのすべてのメールをあるグループに放り込む
代わりに、単に @samp{f:david@@foobar.com} を探す検索グループを作ることが
できます。実のところこれが「賢いフォルダー」の肝心なところで、単にすべて
を一つのメールフォルダーに放り込んだら、分割する代わりに動的に検索結果を
作るのです。これは、したいときはいつでもフォルダーを変更できるので、より
融通が効きます。このことは、あなたが実際のメールグループの代わりに、いつ
もは @code{nnmairix} グループにあるメールを読むであろうことも暗示します。

しかし、一つ問題があります。@samp{david@@foobar.com} から新しいメールを
受け取ったとすると、それは二つのグループに現れるのです。「実際」のグルー
プ (例えば INBOX) および @code{nnmairix} 検索グループです (後者は、も
し mairix データベースを更新してあれば)。@code{nnmairix} グループに入っ
てそのメールを読むと既読の印が付きますが、それは @code{nnmairix} グルー
プでだけです---「実際」のメールグループでは未読のままです。

そのメールグループをキャッチアップする (すべての記事を既読にする) ことは
できます。しかしこれは退屈だし、そのための @code{nnmairix} グループを作っ
ていないメールを見落とすかもしれない点で事故を起こしやすいでしょう。もち
ろん最初に @code{nnmairix-goto-original-article} (@pxref{nnmairix
keyboard shortcuts}) を使ってから元のグループでそのメールを読むことはで
きますが、それはもっとやっかいでしょう。

明らかに、元の記事にどうにかして印を自動的に付けることできれば、それが最
も楽なやり方でしょう。これがまさに @emph{印の伝搬} が行なおうとしている
ことです。

ディフォルトでは印の伝搬はしないようになっています。あるグループのための
それは @code{nnmairix-group-toggle-propmarks-this-group} (@kbd{G b p} に
バインドされています) で有効にすることができます。この関数はディフォルト
の検索グループで使おうとすると警告を発します。なぜかと言うとディフォルト
の検索グループは一時的な検索のためにあるので、印が偶然にこのグループから
伝搬してしまいやすいからです。もっとも本当にそれをやりたいのなら、その警
告を無視することはできます。

印の伝搬を有効にしてあると @code{nnmairix} グループで付けたすべての印が
元のグループに伝搬するはずです。例えば記事に可視 (tick) の印を (ディフォ
ルトでは @kbd{!} で) 付けると、この印は魔法のように元の記事にも付くはず
です。

あなたが知っている必要がある、または無い、さらなることがらがあります:

@vindex nnmairix-propagate-marks-upon-close
印はすぐにではなく、グループを閉じたときだけ付けられます。これは印の伝搬
を性急に行なわない以外に maildir ファイルを扱うときのシンボリックリンク
にまつわる問題の回避もします (フラグの変更はファイル名の変化を伴うので)。
印の伝搬を @code{nnmairix-propagate-marks-upon-close} を通じて制御するこ
ともできます (詳しくは変数の説明を見てください)。

当然ながら、あなたが印を付けたいあらゆる記事のために @code{nnmairix} は
元のグループを調べなければならないでしょう。元のグループを特定するため
に @code{nnmairix} は、もし使えるなら最初にレジストリーを使います。レジ
ストリーは非常に速いです。したがって印の伝搬を使うなら本当にレジストリー
を使えるようにすべきです。本当に。RAM とディスクの容量に心配が無いな
ら @code{gnus-registry-max-entries} を十分に大きな値に設定してください。
大事を取るためには、おおよそ mairix で索引を付けるメールの量を選んでくだ
さい。

@vindex nnmairix-only-use-registry
レジストリーを使いたくない、またはレジストリーがまだ元の記事を見たことが
無い場合、その記事のファイル名を特定するために @code{nnmairix} は追加
の mairix 検索を行ないます。もちろんこれはレジストリーより遅くなりま
す---もしこのやり方で数百ないしは数千の印を付けると、いくらか時間がかか
るかもしれません。この状況
は @code{nnmairix-only-use-registry} を @code{t} に設定することによって
避けることができます。

おそらくあなたは逆方向にも印を伝搬させたいでしょう。つまり「本当の」メー
ルグループで記事に可視 (tick) 印を付けたら @code{nnmairix} グループにあ
る同じ記事も可視になって欲しいということです。いくつかのもっともな理由に
より、これは maildir を使う場合だけ効率的に行なうことができます。すぐに
矛盾したことを言いますが、それは @code{nnmaildir} では働きません。なぜな
ら @code{nnmaildir} は印を外部のしかもファイルではないところに格納するか
らです。したがって @code{nnmairix} グループへの印の伝搬は、通常はファイ
ル形式として maildir を使う @acronym{IMAP} サーバーの場合だけ働きます。

@vindex nnmairix-propagate-marks-to-nnmairix-groups
今この設定作業を行なっているのな
ら @code{nnmairix-propagate-marks-to-nnmairix-groups} を @code{t} に設定
して何が起きるか見てください。もしあなたが見るものが好きではないならば、
再びそれを @code{nil} に戻しましょう。一つの問題は未読記事の数を間違える
ことかもしれません。これは元のグループで記事を消去したり、または期限切れ
消去されたときに普通に起きます。これが起きたらそのバックエンドで @kbd{G
b d} を使って、その @code{nnmairix} グループを作り直してください。

@node nnmairix tips and tricks
@subsection nnmairix のヒント、こつ、およびいくつかの例

@itemize
@item
メールのチェック

@findex nnmairix-update-groups
私は大事なメールのグループをグループレベル 1 にしています。Mairix グルー
プのグループレベルは 5 なので、それらは起動時にチェックされませ
ん (@pxref{Group Levels})。

メールをチェックするために私は以下を使っています:

@lisp
(defun my-check-mail-mairix-update (level)
  (interactive "P")
  ;; 接頭引数が与えられなかったらレベルを 1 に設定する。
  (gnus-group-get-new-news (or level 1))
  (nnmairix-update-groups "mairixsearch" t t)
  (gnus-group-list-groups))

(define-key gnus-group-mode-map "g" 'my-check-mail-mairix-update)
@end lisp

@samp{"mairixsearch"} の代わりにあなたの @code{nnmairix} サーバーの名前
を使いましょう。詳しくは @code{nnmairix-update-groups} の説明を見てくだ
さい。

@item
可視 (ticked) 記事のための検索グループの例

例えばすべての可視記事のためのグループを作ることができます。そこでは記事
が常に未読になっています:

@kbd{G b g} をたたいてグループ名を入力し、検索条件として @samp{F:f} を使っ
てください。そしてスレッドを含めないようにします。

次に @kbd{G b p} を使ってこのグループのための印の伝搬を有効にしましょう。
そうしたら @kbd{G b r} を二回使って「常に未読」機能を有効にします。

これはこれで良いでしょう---しかしどうやって @code{nnmairix} グループの可
視印を消したら良いでしょうか? それには二つの選択肢があります:
@code{nnmairix-remove-tick-mark-original-article} (@kbd{G G u} にバイン
ドされています) を使って元の記事から可視印を取り除くことができます。もう
一つの可能なこと
は @code{nnmairix-propagate-marks-to-nnmairix-groups} を @code{t} に設定
することです。しかし上記のこのオプションに関するコメントを見てください。
もしそれが動作するなら可視印は @code{nnmairix} グループにあるはずで、そ
れらはいつものように、例えば記事を既読にすることによって取り除くことがで
きます。

元の記事から可視印を取り除くと、mairix データベースを更新しかつグループ
を更新した後で、その記事は @code{nnmairix} グループから消え去るはずです。
幸いにまさにそれを行なうための関数があります:
@code{nnmairix-update-groups} です。詳しくは前述のコードの断片と関数の説
明を見てください。

@item
メールグループの自動講読の取り扱い

先に説明したように、すべての @code{nnmairix} グループは実際に
は @samp{zz_mairix-<NAME>-<NUMBER>} の様式でメールバックエンドに格納され
ます。それらはサーバーバッファーでそのバックエンドに入ると見ることができ
ます。これらのグループを講読してはいけません! 残念ながらこれらのグループ
は @code{nnmaildir} または @code{nnml} を使うと通常 @emph{自動講読} にな
ります。つまり @samp{zz_mairix*} 様式のグループが突然グループバッファー
に現れるのを見ることになります。もしこれが起こったら単に @kbd{C-k} でそ
れらのグループを kill してください。これを避けるに
は @code{gnus-auto-subscribed-groups} を @code{nil} に設定して自動講読を
恒久的に無効にする (@pxref{Filtering New Groups} か、またはもしこの機能
を維持したいのであれば @samp{zz_} ではじまるすべてのグループでそれを無効
にする以下のその場しのぎの手を使ってください:

@lisp
(setq gnus-auto-subscribed-groups
      "^\\(nnml\\|nnfolder\\|nnmbox\\|nnmh\\|nnbabyl\\|nnmaildir\\).*:\\([^z]\\|z$\\|\\z[^z]\\|zz$\\|zz[^_]\\|zz_$\\).*")
@end lisp
@end itemize

@node nnmairix caveats
@subsection nnmairix でさらに知っておく必要があること

@itemize
@item
第二の @code{nnml} サーバーを、まさに nnmairix のために作ることができま
す。しかしその場合、対応するサーバー変数 @code{nnml-get-new-mail} を明示
的に @code{nil} に設定する必要があります。そうしておかないと新着メールが
この第二のサーバーに取り込まれてしまうかもしれません (そして、それらを二
度と見ることはないでしょう)。サーバー定義の例です:

@lisp
(nnml "mairix" (nnml-directory "mairix") (nnml-get-new-mail nil))
@end lisp

(@code{nnmaildir} にもサーバー変数 @code{get-new-mail} があるのですが、
それはディフォルトで @code{nil} なので、@code{nnmaildir} サーバーをまさ
に mairix 用に使う場合でも、それを明示的に設定する必要はありません。)

@item
もし Gnus レジストリーを使っているなら、@code{nnmairix} グループでレジス
トリーを使わないください (ディフォルト
で @code{gnus-registry-unfollowed-groups} に含まれています)。も
し @code{gnus-registry-split-fancy-with-parent} を使っているな
ら @emph{特別な注意} が必要です。分割されて @code{nnmairix} グループに入っ
たメールは、通常そのグループの新着メールをチェックしたとたんに永久に無く
なってしまいます (はい、私はそれをやってしまいました@dots{})。

@item
したがって:
@emph{絶対に、断じて}「本当の」メールを @code{nnmairix} グループに入れて
はいけません (とにかくそれができるべきではありません)。

@item
もし Gnus エージェント (@pxref{Gnus Unplugged}) を使っているなら:
@code{nnmairix} グループをエージェント化しないでください (もっとも、それ
をやったら何が起きるか私は知りませんが)。

@item
Mairix は @acronym{US}-@acronym{ASCII} 文字だけをサポートします。

@item
@code{nnmairix} は mairix が呼ばれた後で Gnus にメールバックエンドのグルー
プを完全に読み直させる、かなり力まかせな手段を使います---つまり単純にそ
のメールバックエンドのグループを消して作り直します。これまでのところ、こ
れは何ら問題無く働き、@code{nnmairix} がそれ自身のもの以外のメールグルー
プを削除するとは思えません。しかしとにかく本当に、メールフォルダーのバッ
クアップを持つべきです。

@item
すべての必要な情報はグループパラメーターに格納されます (@pxref{Group
Parameters})。これにはアクティブファイルを必要としないという利点がありま
すが、それは暗に @code{nnmairix} グループを kill すると永久に失われてし
まうことをも意味します。

@item
@findex nnmairix-purge-old-groups
たくさんの @code{nnmairix} グループを作って kill すると、メールバックエ
ンドのサーバーに ``zz_mairix-*'' という名前のグループが溜まってしまいま
す。もはや不要になった古いグループを削除するに
は @code{nnmairix-purge-old-groups} を呼んでください。これは当
然 @code{zz_mairix-<NAME>-<NUMBER>} の様式ではどんな「本当の」メールもフォ
ルダーにセーブしないことを想定していることに注意してください。
@code{nnmairix} グループの接頭辞は変数 @code{nnmairix-group-prefix} を変
更することによって変えることができます。

@item
以下は先に言及した mairix のためのパッ
チ (@pxref{Propagating marks}) を @emph{使わない} 場合だけに当てはまりま
す:

@code{nnmairix} を maildir フォルダーとともに使うと問題が起きる場合があ
ります。それは maildir がメールのフラグを @samp{Seen} また
は @samp{Replied} のように、それぞれ文字 @samp{S} および @samp{R} をメッ
セージのファイル名に付け加えることによって格納するという事実によります。
これは、今のところ、新しいメールが届いたときだけでなくメールのフラグが変
化したときも、mairix のデータベースを更新しなければならないであろうこと
を暗示しています。同じことが、まだ @samp{new} フォルダーにあるうちに索引
が作られたものの Gnus がそのメールを見たときに @samp{cur} に移された新し
いメールにも当てはまります。これが起きた後でデータベースを更新しないと、
mairix 検索は存在しないファイルを指すシンボリックリンクをもたらします。
Gnus では通常それらのメッセージはヘッダーに ``(none)'' が表示されて現れ、
アクセスすることができません。もしこれが起こった場合、普通
は @kbd{G b u} を使い、かつグループを更新すれば解決します。
@end itemize

@iftex
@iflatex
@chapter Message
@include message-ja.texi
@chapter Sieve
@include sieve-ja.texi
@chapter EasyPG
@include epa.texi
@chapter SASL
@include sasl-ja.texi
@end iflatex
@end iftex

@node Various
@chapter いろいろ

@menu
* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* Image Enhancements::          Emacs の最新バージョンは画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける簡単な方法
* Spam Package::                Spam を濾過して処理するためのパッケージ
* The Gnus Registry::           記事を Message-ID で辿るためのパッケージ
* The Gnus Cloud::              Gnus の印を同期するためのパッケージ
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの
@end menu

@node Process/Prefix
@section プロセス/接頭引数
@cindex process/prefix convention

多くの関数、その中でも記事の移動、デコード、保存をするための関数は、「プ
ロセス/接頭引数の習慣」として知られているものを使います。

これは、利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

数値接頭引数が N だったら、現在の記事を含めた次の N 個の記事に対して作業
を実行します。もし数値接頭引数が負だったら、現在の記事を含めた前の N 個
の記事に対して作業を実行します。

@vindex transient-mark-mode
@code{transient-mark-mode} が @code{nil} ではなく、リージョンが設定され
ていたら、リージョンにあるすべての記事で作業が行なわれます。

数値接頭引数が無くても、いくつかの記事はプロセス印が付いている場合には、
プロセス印が付いている記事で作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事でだけ作
業を実行します。

これは実際とても単純なのですが、びっくりされないためにも、はっきりさせて
おく必要があります。

プロセス印に反応するコマンドは、現在プロセス印が付いている記事のリストを
スタックに積んで、記事のすべてのプロセス印を消去します。前回の設定
を @kbd{M P y} で復旧させることができます (@pxref{Setting Process Marks})。

@vindex gnus-summary-goto-unread
多くの人々をぎょっとさせ、恐がらせると思われることの一つは、例え
ば @kbd{3 d} が、本当に @kbd{d} @kbd{d} @kbd{d} と同じことをすることです。
それぞれの @kbd{d} (これは現在の記事に既読の印を付けます) は、ディフォル
トでは印を付けた後で次の未読記事に移動するので、@kbd{3 d} は概略バッファー
がどうなっていても、次の三つの未読記事を既読にします。動作をもっと分かり
やすくするには、@code{gnus-summary-goto-unread} を @code{nil} に設定して
ください。

多くのコマンドはプロセス/接頭引数の習慣を使いません。それをしないすべて
のコマンドは、このマニュアルで明記されています。そういうコマンドにプロセ
ス/接頭引数の習慣を適用するには、@kbd{M-&} コマンドを使ってください。例
えば、そのグループのすべての記事を期限切れ消去可能として印を付けるに
は @kbd{M P b M-& E} とします。

@node Interactive
@section 利用者との相互作用
@cindex interaction

@table @code
@item gnus-novice-user
@vindex gnus-novice-user
この変数が @code{nil} でないのは、あなたは Usenet の世界の新参者か非常に
慎重な人のどちらかだというです。これは本当に良いことです。何か危険なこと
をする前に、「本当にこれをしたいのですか?」というような質問を受けます。
これはディフォルトでは @code{t} です。

@item gnus-expert-user
@vindex gnus-expert-user
この変数を @code{nil} でない値にすれば、Gnus から質問を受けることが滅多
に無くなるでしょう。これは単純に、どんな変なことをしても、あなたが何をし
ているかをわかっているものと見なします。例えば @file{.newsrc} ファイルを
保存せずに Gnus を終了したり、既読情報などを更新せずにグループを抜けたり、
グループの記事をすべて既読にしたり、期限切れ消去される記事を消去したり、
ニュース記事にメールで返信しようとしたときに、確認を求められなくなります。

@item gnus-interactive-catchup
@vindex gnus-interactive-catchup
@code{nil} でないと、グループに追いつく (catchup, 未読の記事を読んだこと
にしてしまう) 前に、確認を求めます。ディフォルトで @code{t} です。

@item gnus-interactive-exit
@vindex gnus-interactive-exit
もし @code{nil} 以外だったら Gnus を終了するときに確認を求めます。
@code{quiet} にしておくと、活きている概略バッファーを確認無しで自動的に
更新します。ディフォルト値は @code{t} です。
@end table

@node Symbolic Prefixes
@section シンボルの接頭引数
@cindex symbolic prefixes

非常に多くの Emacs の命令が (数値) 接頭引数に反応します。例え
ば @kbd{C-u 4 C-f} はポイントを 4 文字先に移動し、
@kbd{C-u 9 0 0 I s s p} は 900 のスコア (永続、@code{Suject}、文字列の一
部、という規則) を現在の記事に加えます。

これはすべて素敵で良いのですが、命令にもう少し追加の情報を与えたいときは
どうすれば良いのでしょう?  えーと、たいていの命令がしていることは「生の」
接頭引数を何らかの特別な方法で解釈することです。例え
ば @kbd{C-u 0 C-x C-s} は、現在の記事を保存するときにバックアップファイ
ルを作らないで欲しいことを意味します。でも、バックアップファイルを作らな
いで保存するのと同時に、Emacs に閃光を放って、素敵な音楽を演奏して欲しい
ときはどうすれば良いでしょう?  それができなくても、あなたは申し分なく幸
せですね(?)。

@kindex M-i @r{(概略)}
@findex gnus-symbolic-argument
私はそうではありません。そこで、私は二つめの接頭引数「シンボル接頭引数」
を加えました。接頭キーは @kbd{M-i} (@code{gnus-symbolic-argument}) で、
次に押される文字が値です。いくらでも @kbd{M-i} 接頭語を積み重ねることが
できます。@kbd{M-i a C-M-u} は「@kbd{C-M-u} 命令にシンボル接頭引
数 @code{a} を与える」ということです。@kbd{M-i a M-i b C-M-u} は
「@kbd{C-M-u} 命令にシンボル接頭引数 @code{a} @code{b} を与える」という
ことです。趣旨はわかりましたね。

シンボル接頭引数を受け付けない命令にそれを打ち込んでも何も悪いことをしま
せんが、良いことも何もしません。現在のところ、あまり多くの関数がシンボル
接頭引数を利用しているわけではありません。

Gnus がこれを実装しているやり方に興味があるなら、
@ref{Extended Interactive} を見てください。

@node Formatting Variables
@section 書法仕様変数
@cindex formatting variables

このマニュアルを通して、おそらく @code{gnus-group-line-format} また
は @code{gnus-summary-mode-line-format} のように呼ばれるたくさんの変数が
あることに気付いたでしょう。これらは Gnus が色々なバッファーでどのように
行を出力するかを制御します。非常にたくさんのものがあります。幸運なことに、
それらはすべて同じ構文を使うので、あまり嫌な目には会わないでしょう。

書法仕様 (format) 指定の例です (グループバッファーより):@*
@samp{%M%S%5y: %(%g%)\n}。それは極めて醜く、たくさんのパーセント記号がい
たるところにあります。

@menu
* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を変化させる
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う
@end menu

現在のところ Gnus は以下の書法仕様変数を使います:
@code{gnus-group-line-format}, @code{gnus-summary-line-format},
@code{gnus-server-line-format}, @code{gnus-topic-line-format},
@code{gnus-group-mode-line-format},
@code{gnus-summary-mode-line-format},
@code{gnus-article-mode-line-format},
@code{gnus-server-mode-line-format}, およ
び @code{gnus-summary-pick-line-format}。

これらすべての書法仕様変数は任意の elisp 式であることもできます。その場
合、それらは要求される行に挿入するために @code{eval} (評価) されます。

@findex gnus-update-format
Gnus は、あなたが自分用の書法仕様指定を作っているときに、手助けをする命
令を備えています。@kbd{M-x gnus-update-format} は現在の式
を @code{eval} し、当の仕様を更新し、行を生成するための Lisp 式を検査す
ることができるバッファーに移動します。

@node Formatting Basics
@subsection 書法仕様の基本

それぞれの @samp{%} の要素は、当のバッファーが作成されるときに何らかの文
字列や他のもので置き換えられます。@samp{%5y} は「@samp{y} 指定を挿入して、
5 文字の場所を得るために空白を詰め込みなさい」ということです。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、
@samp{%} と書法仕様の型の文字の間の数値修飾子は、常に少なくともその長さ
になるように、出力に (空白文字などを)「詰め込み」ます。@samp{%5y} はその
場所が常に (少なくとも) 5 文字の長さになるように、左に空白を詰め込みます。
もし @samp{%-5y} とすれば、代わりに右側に詰め込みます。

特に広い幅の値に対して保護するために、その場所の長さを制限したいこともあ
るでしょう。そのために @samp{%4,6y} などと指定することができます。これは、
その場所は決して 6 文字を超える幅にはならず、かつ 4 文字より少ない幅にも
ならないということです。

Gnus は @samp{%&user-date;} のような、いくつかの拡張様式指示もサポートし
ます。

@node Mode Line Formatting
@subsection モード行書法仕様

モード行書法仕様変数 (例えば @code{gnus-summary-mode-line-format}) は、
以下の二つの違い以外は、バッファー行に適応した書法仕様変
数 (@pxref{Formatting Basics}) と同じ規則に従います:

@enumerate
@item
最後に改行 (@samp{\n}) があってはなりません。

@item
特別な @samp{%%b} 仕様をバッファー名を表示するために使うことができます。
えーと、実はそれは仕様ではないのです---@samp{%%} というものは、
Emacs が @samp{%b} を受け取って、そのモード行表示機能に「バッファー名を
表示しなさい」と解釈させるために、単に書法仕様の処理系を無傷で通り抜ける
ことができるように @samp{%} を囲う方法なのです。Emacs が理解するモード行
指定の完全な一覧については、変数 @code{mode-line-format} の説明文を見て
ください。
@end enumerate

@node Advanced Formatting
@subsection 上級書法仕様

表示された領域を後で何らかの方法で処理するのは、しばしば役に立ちます。詰
め込み、制限、切り取り、および特定の値の抑制は、「チルダ修飾子」を使うこ
とによって実現することができます。よくあるチルダ仕様は、
@samp{%~(cut 3)~(ignore "0")y} のように見えるでしょう。

これらは有効な修飾子です:

@table @code
@item pad
@itemx pad-left
領域の左側に、要求された長さになるまで空白を詰め込みます。

@item pad-right
領域の右側に、要求された長さになるまで空白を詰め込みます。

@item max
@itemx max-left
指定された長さになるように、文字列の左側を切り取ります。

@item max-right
指定された長さになるように、文字列の右側を切り取ります。

@item cut
@itemx cut-left
指定された数の文字を左側から切り落とします。

@item cut-right
指定された数の文字を右側から切り落とします。

@item ignore
領域が指定された値と等しい (equal) ならば、空文字列を返します。

@item form
@samp{@@} 仕様が使われたときに、指定された式を領域の値として使います。

これは例です:

@lisp
"~(form (current-time-string))@@"
@end lisp
@end table

例を出してみましょう。概略モード行での @samp{%o} 仕様は ISO0861 様式の凝
縮された日付 (@samp{19960809T230410} のようなもの) を返します。これはと
ても発音しにくいので、世紀を表す数と時刻を削ぎ落として、6 文字の日付を残
したいと思います。それは @samp{%~(cut-left 2)~(max-right 6)~(pad 6)o} と
なるでしょう。(切り落とし (cutting) は 最大幅の制限 (maxing) より先に行
なわれるので、表示欄での見栄えを良くするために、日付が 6 文字より少なく
ならないことを保証する詰め込み (padding) が必要になります。)

無視 (ignore) が最初に行なわれます。それから切り落とし (cutting)、次に最
大幅の制限 (maxing)、そして最後の操作である詰め込み (padding) が行なわれ
ます。

@node User-Defined Specs
@subsection 利用者定義の指定

すべての仕様に、利用者が定義した @samp{u} で始まる述語を挿入することがで
きます。書法仕様文字列の次の文字は、アルファベットでなければなりません。
@samp{%u} に続くアルファベットが @samp{X} だったら、Gnus は関
数 @code{gnus-user-format-function-}@samp{X} を呼びます。関数には単一の
引数が与えられますが、その引数の意味は関数がどのバッファーから呼ばれてい
るかによって変わります。関数は文字列を返さなければなりません。それは他の
述語によって生成される情報とまったく同じように、バッファーに挿入されます。
関数は意味の無い値と共に呼ばれる場合もあるので、それの対策をしておくべき
です。

Gnus は利用者定義仕様を拡張した @samp{%u&foo;} のような形式もサポートし
ます。この場合は @code{gnus-user-format-function-}@samp{foo} という関数
を呼び出します。

新しい関数を定義しなくても、ほとんど同じことをチルダ修飾
子 (@pxref{Advanced Formatting}) を使って達成できるでしょう。例です:

@samp{%~(form (count-lines (point-min) (point)))@@}

ここで与えられた式は評価されて現在の行番号をもたらし、それから挿入されま
す。

@node Formatting Fonts
@subsection 書法仕様フォント

@cindex %(, %)
@vindex gnus-mouse-face
すべての書法仕様変数によって共有される、ハイライト (強調表示) のための仕
様があります。述語 @samp{%(} と 述語 @samp{%)} で囲まれたテキストには特
別な @code{mouse-face} 属性が与えられ、そこにマウスのポインターを置いた
ときに (@code{gnus-mouse-face} によって) ハイライトされます。

@cindex %@{, %@}
@vindex gnus-face-0
述語 @samp{%@{} と 述語 @samp{%@}} で囲まれたテキストには、普通のフェー
スである @code{gnus-face-0} (ディフォルトで @code{bold}) が与えられます。
@samp{%1@{} を使うと、代わりに @code{gnus-face-1} が与えられ、以下同様で
す。欲しいだけたくさんのフェースを作ってください。同じこと
が @code{mouse-face} 仕様にも言えます。@samp{hello} がマウスを置いたとき
に @code{gnus-mouse-face-3} でハイライトされるためには、
@samp{%3(hello%)} とすれば良いでしょう。

@cindex %<<, %>>, guillemets
@c @cindex %<<, %>>, %《, %》, guillemets
@vindex gnus-balloon-face-0
述語 @samp{%《} と 述語 @samp{%》} で囲まれたテキストでは、特別
な @code{balloon-help} 属性が @code{gnus-balloon-face-0} に設定されます。
@samp{%1《} とすると @code{gnus-balloon-face-1} が使われ、以下同様です。
@code{gnus-balloon-face-*} 変数は、文字列か文字列を返す関数を指すシンボ
ルのどちらかでなければなりません。この属性が設定されているテキストの上を
マウスが通過すると、吹き出しが現れて文字列を表示します。これの詳しい情報
は @ref{Tooltips, ,Tooltips, emacs, The Emacs Manual} の説明を参照してく
ださい。(技術的な理由のために、ギィメ (guillemets) はこの節で
は @samp{《} と @samp{》} で近似されました。)

@quotation
訳注: guillemets (仏語) はギュメとも表記されます。実際に Gnus で有効なの
は次の二つです:

@lisp
(string (make-char 'latin-iso8859-1 43)) ;; 《
(string (make-char 'latin-iso8859-1 59)) ;; 》
@end lisp

日本語の「」に当たるもので、口頭表現を表記したり、強調したい単語を囲む、
何かからの引用部分を囲む、書物等のタイトルを記す等様々に使われます。
@end quotation

これはグループバッファーで使うことができる、もう一つの調理法です:

@lisp
;; @r{三つのフェースを作ります。}
(setq gnus-face-1 'bold)
(setq gnus-face-3 'italic)

;; @r{記事の数をボールドで緑のフェースにしたいので、}
;; @r{@code{my-green-bold} という新しいフェースを作ります。}
(copy-face 'bold 'my-green-bold)
;; @r{色を設定します。}
(set-face-foreground 'my-green-bold "ForestGreen")
(setq gnus-face-2 'my-green-bold)

;; @r{新しい特製の書法仕様を設定します。}
(setq gnus-group-line-format
      "%M%S%3@{%5y%@}%2[:%] %(%1@{%g%@}%)\n")
@end lisp

あなたがこの案を使って、完全に読めなくて非常に下品な表示を作ることができ
ることを確信しています。楽しんでください!

@samp{%(} 指定 (やその類のもの) は、モード行変数ではまったく意味をなさな
いことに注意してください。

@node Positioning Point
@subsection ポイントの移動

Gnus は通常ほとんどのバッファーで、ポイントを各行のあらかじめ決められた
場所に移動します。ディフォルトでは、ポイントは行の最初のコロンに移動しま
す。この振るまいは、三つの違う方法でカスタマイズすることができます。

また、コロンを行のどの場所にでも移動することができます。

@findex gnus-goto-colon
コロンの位置にポイントを移動させるための関数を定義し直すことができます。
その関数は @code{gnus-goto-colon} と呼ばれています。

でも、行にコロンを含めたくないならば、これを扱うためのおそらく最も手ごろ
な方法は @samp{%*} という述語を使うことです。あなたの行の書法仕様の定義
に @samp{%*} を入れておけば、Gnus はそこにポイントを置きます。

@node Tabulation
@subsection 整列

通常は、空白文字を詰め込んだり端を切り落とすことによって、文字列をディス
プレイに並べることができます。でも大きさが違う異なる文字列を連結させる場
合は、単に文字列を出力してしまうのがより手ごろであることが多いはずで、し
かしそうするとその後に続くテキストを並べるのに悩むことになります。

それを行なうために、Gnus は整列子 (tabulator) の仕様 @samp{%=} を備えて
います。これには二つの形式 @dfn{hard tabulators} およ
び @dfn{soft tabulators} があります。

@samp{%50=} は文字列が 50桁までの場所を占めるように空白文字を詰め込みま
す。もし挿入するテキストの末端が 50桁より後ろになる場合は何も挿入しませ
ん。これは穏やか (soft) な整列子です。

@samp{%-50=} もまた、文字列が 50桁までの場所を占めるように空白文字を詰め
込みます。ですが、もし挿入するテキストの末端が 50桁より後ろになる場合は、
50桁より後ろになる過剰なテキストは削除されます。これは厳密 (hard) な整列
子です。

@node Wide Characters
@subsection 幅広文字

多くの地域において、固定幅フォントは同じ幅の文字を持っています。しかしい
くつかの地域、よく知られている東アジアの国々では、ラテン文字と幅の広い文
字が混在して使われています。

整形において、Gnus は文字列が 10個の文字の幅だとしたら、スクリーンで
も 10個分のラテン文字の幅になると仮定しますが、それは問題です。かの国々
では、それは正しくありません。

@vindex gnus-use-correct-string-widths
それを救済するために、あなた
は @code{gnus-use-correct-string-widths} を @code{t} に設定することがで
きます。これはバッファーの生成を遅くしますが、より美しい結果を得ることが
できるでしょう。ディフォルト値は @code{nil} です。(訳注: 日本語など
を Emacs で表示する場合に、書法仕様によっては @code{t} にしないと概略バッ
ファーの表示が不揃いになることがあります。)

@node Window Layout
@section ウィンドウの配置
@cindex window layout

いえ、X に関することはありませんから、おとなしくしてください。

@vindex gnus-use-full-window
もし @code{gnus-use-full-window} が @code{nil} でないと、Gnus はすべての
他のウィンドウを消して、Emacs の画面全体を占有します。これはディフォルト
で @code{t} です。

この変数を @code{nil} に設定してもそれなりに動作しますが、問題もありま
す。危険を覚悟の上で使ってください。

@vindex gnus-buffer-configuration
@code{gnus-buffer-configuration} はそれぞれの Gnus のバッファーがどのく
らいの空間を与えられるべきかを現します。これはこの変数の抜粋です:

@lisp
((group (vertical 1.0 (group 1.0 point)))
 (article (vertical 1.0 (summary 0.25 point)
                        (article 1.0))))
@end lisp

これは連想リストです。「キー」は何らかの動作を名付けるためのシンボルです。
例えば、グループバッファーを表示するときは、ウィンドウを設定するための関
数は @code{group} をキーとして使います。使用可能な名前の完全な一覧は下に
挙げられています。

「値」(すなわち「分割」) は、それぞれのバッファーがどれくらいの空間を占
めるべきかを指定します。@code{article} の分割を例に取ると:

@lisp
(article (vertical 1.0 (summary 0.25 point)
                       (article 1.0)))
@end lisp

この「分割」は概略バッファーが画面の上の 25% を占めるべきで、それは記事
バッファーの上に配置されると言っています。お気づきのように、
100% + 25% は実際は 125% です (えぇ、皆さんの計算はこの様になったと思い
ます。) しかし、特別な数値 @code{1.0} は、残りのバッファーが必要なものを
取り去った後に、使用可能な残りの空間すべてを吸い取る、ということを合図す
るために使われます。@code{1.0} の大きさを指定するバッファーは、一つの分
割につき一つだけでなくてはなりません。

ポイント (カーソル) は省略可能な三つ目の要素、@code{point} を持つバッファー
に置かれます。@code{frame} 分割では、@code{frame-focus} タグが含まれてい
る枝葉の分割を持っている副分割の、最後のもののフレームがフォーカスを得る
ことになります (@code{frame-focus} タグは、それを含んでいる枝葉リストに
おいて、@code{point} タグが無ければ三番目の、あれば四番目の要素になりま
す。

次はもっと複雑な例です:

@lisp
(article (vertical 1.0 (group 4)
                       (summary 0.25 point)
                       (article 1.0)))
@end lisp

もし大きさの指定が浮動小数点数の代わりに整数だったなら、それは割合ではな
く、どのくらい多くの行をバッファーが占めるべきかを指定するために使われま
す。

もし「分割」が @code{eval} (評価) されるもののように見えるときは (正確に
言うと---分割の @code{car} が関数か原始関数 (subr) であるときは)、この分
割は @code{eval} されます。結果が @code{nil} でないなら、それは分割とし
て用いられます。

まだ複雑ではないですって? それでは、大きさとしてこれを試してみてください:

@lisp
(article (horizontal 1.0
             (vertical 0.5
                 (group 1.0))
             (vertical 1.0
                 (summary 0.25 point)
                 (article 1.0))))
@end lisp

おぉっと。二つのバッファーに謎の 100% タグが付いています。そし
て @code{horizontal} って何でしょう?

もし分割の一つの最初の要素が @code{horizontal} であったなら、Gnus はウィ
ンドウを水平に分割し、二つのウィンドウを横に並べます。これらのそれぞれの
小片の中では、あなたのやりたいことをすべて普通の流儀で行なうことができま
す。@code{horizontal} の後の数値は、この小片に画面のどれくらいの割合が与
えられるかを指定します。

それぞれの分割では、100% のタグを持つ要素が @emph{必ず} 一つある必要があ
ります。分割は決して正確ではないので、分割によって余ったすべての行を、こ
のバッファーが分捕ります。

もう少し形式的に、有効な分割がどのようになるかの定義を挙げておきましょう:

@example
split      = frame | horizontal | vertical | buffer | form
frame      = "(frame " size *split ")"
horizontal = "(horizontal " size *split ")"
vertical   = "(vertical " size *split ")"
buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
size       = number | frame-params
buf-name   = group | article | summary ...
@end example

制限として、@code{frame} は最も上位階層の分割としてしか現れることができ
ないというものがあります。@code{form} は有効な分割を返す Emacs Lisp の
式 (form) でなければなりません。それぞれの分割は完全に再帰的で、任意の数
の @code{vertical} と @code{horizontal} 分割を含むことができます。

@vindex gnus-window-min-width
@vindex gnus-window-min-height
@cindex window height
@cindex window width
正しい大きさを見つけることは、少し複雑になります。どのウィンドウ
も @code{gnus-window-min-height} (ディフォルトは 1) の文字の高さよりも小
さくてはならないし、少なくとも @code{gnus-window-min-width} (ディフォル
トは 1) の文字幅でなくてはなりません。Gnus は分割を適用する前にこれを強
制しようと試みます。もし標準の Emacs のウィンドウの幅/高さ制限を使いたい
なら、この二つの変数を @code{nil} にするだけで良いです。

Emacs の用語になじんでいないのなら、
@code{horizontal} と @code{vertical} の分割は、期待したものと反対の動作
をするでしょう。@code{horizontal} 分割の中のウィンドウは横に並んで表示さ
れ、@code{vertical} 分割の中のウィンドウは上下に表示されます。

@findex gnus-configure-frame
ウィンドウの配置に関して実験をしてみたいのであれば、良い方法は分割を引数
にして直接 @code{gnus-configure-frame} を呼ぶことです。これはバッファー
を分割するときにすべての実際の仕事をする関数です。下のものは五つのウィン
ドウを作るかなりばかげた設定です。二つをグループバッファーに、三つを記事
バッファーのために充てます。(だから、ばかげていると言ったでしょ。) もし
下の文を @code{評価} すると、普通の Gnus の経路を使わないで、すぐにそれ
がどのように見えるかの直観を得ることができます。満足するまでそれで遊んで、
それから @code{gnus-add-configuration} を使って新しい作品をバッファー配
置リストに加えてください。

@lisp
(gnus-configure-frame
 '(horizontal 1.0
    (vertical 10
      (group 1.0)
      (article 0.3 point))
    (vertical 1.0
      (article 1.0)
      (horizontal 4
        (group 1.0)
        (article 10)))))
@end lisp

複数のフレームも欲しいかもしれません。問題ありません---@code{frame} 分割
を使うだけです:

@lisp
(gnus-configure-frame
 '(frame 1.0
         (vertical 1.0
                   (summary 0.25 point frame-focus)
                   (article 1.0))
         (vertical ((height . 5) (width . 15)
                    (user-position . t)
                    (left . -1) (top . 1))
                   (picon 1.0))))
@end lisp

この分割の結果は、最初の (もしくは「主たる」) フレームに見慣れた概略/記
事ウィンドウを配置し、小さな追加のフレームが picon を表示するために作ら
れます。ご覧の通り、普通の最上位階層の @code{1.0} の定の代わりに、それぞ
れの追加の分割が大きさの指定として、フレームパラメーターの連想リストを持
たなければなりません (@pxref{Frame Parameters, ,Frame Parameters, elisp,
The GNU Emacs Lisp Reference Manual})。
@code{gnus-buffer-configuration} で使うことができるすべてのキーの一覧は、
そのディフォルト値で見つけることができます。

キー @code{message} は @code{gnus-group-mail} およ
び @code{gnus-summary-mail-other-window} の両方で使われることに注意して
ください。もし二つを区別するほうが望ましいなら、このような物を使うことが
できます:

@lisp
(message (horizontal 1.0
                     (vertical 1.0 (message 1.0 point))
                     (vertical 0.24
                               (if (buffer-live-p gnus-summary-buffer)
                                   '(summary 0.5))
                               (group 1.0))))
@end lisp

良くある複数のフレーム分割の要望は、メールとニュースの作成には別のフレー
ムを使い、元のフレームはそのままに残すというものです。これの達成には、以
下のようなものでできます。

@lisp
(message
  (frame 1.0
         (if (not (buffer-live-p gnus-summary-buffer))
             (car (cdr (assoc 'group gnus-buffer-configuration)))
           (car (cdr (assoc 'summary gnus-buffer-configuration))))
         (vertical ((user-position . t) (top . 1) (left . 1)
                    (name . "Message"))
                   (message 1.0 point))))
@end lisp

訳注: これを高度に発展させたもの
が @uref{http://www.jpl.org/elips/message-multiple-frames.el.gz} として
入手できます。使い方はファイルの冒頭に書かれています。

@findex gnus-add-configuration
変数 @code{gnus-buffer-configuration} はとても長く複雑なので、単一の設定
の変更を簡単にするための関数があります: @code{gnus-add-configuration} で
す。例えば @code{article} の設定を変えたいのなら、次のようにできます:

@lisp
(gnus-add-configuration
 '(article (vertical 1.0
               (group 4)
               (summary .25 point)
               (article 1.0))))
@end lisp

普通はこれらの @code{gnus-add-configuration} の呼び出し
を @file{~/.gnus.el} ファイルに入れるか、何らかの起動時のフックに入れる
でしょう---それらは Gnus が読み込まれた後で実行されなければなりません。

@vindex gnus-always-force-window-configuration
もし分割の設定で指定されたすべてのウィンドウがすでに見えているのであれば、
Gnus はウィンドウの配置を変更しません。常に「正しい」ウィンドウ設定を強
制したいのであれば、
@code{gnus-always-force-window-configuration} を @code{nil} でない値に設
定してください。

木表示 (@pxref{Tree Display}) を使っていて、木ウィンドウが垂直方向に次の
別のウィンドウで表示されるなら、ウィンドウの大きさが変更されることを避け
るために @code{gnus-tree-minimize-window} をいじるのが良いでしょう。

最後に、@code{gnus-use-atomic-windows} を @code{t} に設定することによっ
て Gnus のウィンドウ配置を ``atomic'' (@pxref{Atomic Windows, , Atomic
Windows, elisp, The GNU Emacs Lisp Reference Manual}) にすることができま
す。これによってポップアップされるバッファー（ヘルプや補完バッファーな
ど）が Gnus ウィンドウ配置全体の下または横に表示されるので、例えば概略バッ
ファーと記事バッファーの間で押しつぶされることはありません。

@subsection ウィンドウ配置の名称

以下は現在知られているほとんどのウィンドウ配置とそれらの用途です:

@table @code
@item group

グループバッファー。

@item summary

あるグループに入ってその概略 (だけ) を表示。

@item article

記事の選択。

@item server

サーバーバッファー。

@item browse

サーバーバッファーから閲覧するグループ。

@item message

(新しい) メッセージの作成。

@item only-article

記事バッファーだけの表示。

@item edit-article

記事の編集。

@item edit-form

グループパラメーターなどの編集。

@item edit-score

サーバーの定義の編集。

@item post

ニュース記事の作成。

@item reply

記事に元記事の引用無しで返信またはフォローアップ。

@item forward

記事の転送。

@item reply-yank

記事に元記事の引用付きで返信またはフォローアップ。

@item mail-bounce

メールの弾き返し。

@item pipe

記事を外部プロセスに送る。

@item bug

バグリポートを送る。

@item score-trace

スコア規則の表示。

@item score-words

スコアに使う単語の表示。

@item split-trace

分割されるメールの行方の表示。

@item compose-bounce

弾き返されたメールの再送信。

@item mml-preview

@acronym{MIME} パートの送信する前の下見。
@end table

@subsection ウィンドウ配置の例

@itemize @bullet
@item
左側を狭めてグループバッファーに。右側を分割して概略バッ
ファー (上 1/6) と記事バッファー (下) に。

@ifinfo
@example
+---+---------+
| G | Summary |
| r +---------+
| o |         |
| u | Article |
| p |         |
+---+---------+
@end example
@end ifinfo

@lisp
(gnus-add-configuration
 '(article
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0
                         (summary 0.16 point)
                         (article 1.0)))))

(gnus-add-configuration
 '(summary
   (horizontal 1.0
               (vertical 25 (group 1.0))
               (vertical 1.0 (summary 1.0 point)))))
@end lisp
@end itemize

@node Faces and Fonts
@section フェースとフォント
@cindex faces
@cindex fonts
@cindex colors

かつてフォントとフェースをいじくるのは非常に難しかったのですが、今日では
非常に簡単です。単に @kbd{M-x customize-face} とやって、変えたいフェース
を選び出して、標準のカスタマイズインターフェースを使って変更することがで
きます。

@node Mode Lines
@section モード行
@cindex mode lines

@vindex gnus-updated-mode-lines
@code{gnus-updated-mode-lines} はどのバッファーがそれらのモード行を常に
最新のものにしておくかを指定します。それはシンボルのリストです。使うこと
のできるシンボルは @code{group}, @code{article}, @code{summary},
@code{server}, @code{browse}, @code{tree} などです。もし対応するシンボル
が存在すると、Gnus は該当する情報でモード行を更新します。この変数
が @code{nil} ならば、画面の再描画はもっと速いでしょう。

@cindex display-time
@vindex gnus-mode-non-string-length
ディフォルトでは、Gnus は概略バッファーと記事バッファーのモード行に現在
の記事の情報を表示します。Gnus が表示したい情報 (例えば記事の表題) はし
ばしばモード行よりも長いことがあるので、どこかで切り落とされなければなり
ません。変数 @code{gnus-mode-non-string-length} はその行の他の要素 (すな
わち情報でない部分) がどのくらいの長さであるかを指定します。もしモード行
に追加の要素を入れたなら、この変数を修正する必要があります:

@c Hook written by Francesco Potortì <pot@cnuce.cnr.it>
@lisp
(add-hook 'display-time-hook
          (lambda () (setq gnus-mode-non-string-length
                           (+ 21
                              (if line-number-mode 5 0)
                              (if column-number-mode 4 0)
                              (length display-time-string)))))
@end lisp

もしこの変数が @code{nil} であるなら (これがディフォルトですが)、モード
行は切り落とされず、詰め込みもされません。ディフォルトでは、バッファーの
完全なパーセント表示さえもモード行から追いやられる可能性もあるので、おそ
らく望ましい設定ではないことに注意してください。利用者が自分の設定に合う
ようにこの変数を適切に設定しなければなりません。

@node Highlighting and Menus
@section ハイライトとメニュー
@cindex visual
@cindex highlighting
@cindex menus

@vindex gnus-visual
変数 @code{gnus-visual} は Gnus を素敵にするたいていの方面の操作をします。
@code{nil} であると、Gnus はメニューを作ったり、素敵な色やフォントを使っ
たりしようとしません。これはさらに @file{gnus-vis.el} ファイルを読み込む
ことも禁止します。

この変数は有効にされている視覚的なプロパティーのリストであることができま
す。以下の要素は有効で、ディフォルトですべて含まれています:

@table @code
@item group-highlight
グループバッファーでハイライト (強調表示) をします。
@item summary-highlight
概略バッファーでハイライトをします。
@item article-highlight
記事バッファーでハイライトをします。
@item highlight
すべてのバッファーでハイライトをするようにします。
@item group-menu
グループバッファーでメニューを作成します。
@item summary-menu
概略バッファーでメニューを作成します。
@item article-menu
記事バッファーでメニューを作成します。
@item browse-menu
ブラウズバッファーでメニューを作成します。
@item server-menu
サーバーバッファーでメニューを作成します。
@item score-menu
スコアバッファーでメニューを作成します。
@item menu
すべてのバッファーでメニューを作成します。
@end table

ですから、記事バッファーだけをハイライトしたくて、すべてのバッファーでメ
ニューを作りたい場合は、このようにすることができます:

@lisp
(setq gnus-visual '(article-highlight menu))
@end lisp

もしハイライトだけで、メニューの類は欲しくないときは、次のようにできます:

@lisp
(setq gnus-visual '(highlight))
@end lisp

@code{gnus-visual} が @code{t} であると、ハイライトとメニューはすべて
の Gnus のバッファーで使用されます。

他のすべてのバッファーの外見に影響する総合的な変数は:

@table @code
@item gnus-mouse-face
@vindex gnus-mouse-face
これは Gnus でマウスのハイライトに使われるフェース (すなわちフォント) で
す。@code{gnus-visual} が @code{nil} であると、マウスハイライトはなされ
ません。
@end table

まったく違ったメニューを作成するために、関連するフックがあります:

@table @code
@item gnus-article-menu-hook
@vindex gnus-article-menu-hook
記事モード (article mode) のメニューを作成した後に呼ばれるフックです。

@item gnus-group-menu-hook
@vindex gnus-group-menu-hook
グループモード (group mode) のメニューを作成した後に呼ばれるフックです。

@item gnus-summary-menu-hook
@vindex gnus-summary-menu-hook
概略モード (summary mode) のメニューを作成した後に呼ばれるフックです。

@item gnus-server-menu-hook
@vindex gnus-server-menu-hook
サーバーモード (server mode) のメニューを作成した後に呼ばれるフックです。

@item gnus-browse-menu-hook
@vindex gnus-browse-menu-hook
概観モード (browse mode) のメニューを作成した後に呼ばれるフックです。

@item gnus-score-menu-hook
@vindex gnus-score-menu-hook
スコアモード (score mode) のメニューを作成した後に呼ばれるフックです。
@end table

@node Daemons
@section デーモン
@cindex demons
@cindex daemons

Gnus、それは (言い伝えによれば) かつて書かれたいかなるプログラムよりも大
きく、あなたがやって欲しいと思うさまざまな奇妙なことを、あなたのいないと
ころで行なってくれるものです。例えば、あなたは時たま新着メールをチェック
してもらいたいかもしれません。あるいは Emacs をしばらく放っておいたとき
すべてのサーバーの接続を切断してもらいたくなるかもしれません。他にも何か
そういったことです。

Gnus はさまざまな「ハンドラー」(処理を行なわせるためのもの) を定義するこ
とによってそのようなことを可能にします。各ハンドラーは三つの要素から成り
ます:「関数」、「時間」、「アイドル」(何もしていない状態を示すもの) パラ
メーターです。

これは Emacs のアイドル状態が三十分続いたときに接続を切断するハンドラー
の例です:

@lisp
(gnus-demon-close-connections nil 30)
@end lisp

これは Emacs がアイドルのとき、一時間毎に @acronym{PGP} ヘッダーを走査す
るハンドラーです:

@lisp
(gnus-demon-scan-pgp 60 t)
@end lisp

この「時間」パラメーターと「アイドル」パラメーターは、奇妙かつ素晴らしい
やり方で一緒に動作します。基本的に「アイドル」が @code{nil} だったら、関
数は「時間」分毎に呼び出されます。

「アイドル」が @code{t} だったら、関数は Emacs がアイドルだったときに限っ
て「時間」分後に呼び出されます。したがって Emacs がアイドルにならなけれ
ば、関数は呼び出されません。いったん Emacs がアイドル状態になると、この
関数は「時間」分毎に呼び出されます。

「アイドル」が数値で「時間」も数値だった場合、Emacs のアイドル状態が「ア
イドル」分続いた場合に限って、「時間」分毎に関数が呼び出されます。

「アイドル」が数値で「時間」が @code{nil} だった場合、関数は Emacs のア
イドル状態が「アイドル」分続く度に一度呼び出されます。

そして「時間」が文字列だった場合 (それは @samp{07:31} のような形式でなけ
ればなりません)、関数は毎日その時刻の頃になると一度呼び出されます。もち
ろん「アイドル」パラメーターによって動作が変わります。

@vindex gnus-demon-timestep
(ここで「分」と言ったとき、それは実際には @code{gnus-demon-timestep} 秒
のことです。これはディフォルトでは 60 です。もしこの変数を変更すると、す
べてのハンドラーの計時に影響を与えます。)

というわけで、ハンドラーを追加したければ、@file{~/.gnus.el} ファイルに以
下のようなものを書き込めば良いでしょう:

@findex gnus-demon-add-handler
@lisp
(gnus-demon-add-handler 'gnus-demon-close-connections 30 t)
@end lisp

@findex gnus-demon-add-scanmail
@findex gnus-demon-add-rescan
@findex gnus-demon-add-scan-timestamps
@findex gnus-demon-add-disconnection
このための既製の関数がいくつか作成されています:
@code{gnus-demon-add-disconnection},
@code{gnus-demon-add-nntp-close-connection},
@code{gnus-demon-add-scan-timestamps}, @code{gnus-demon-add-rescan}, お
よび @code{gnus-demon-add-scanmail} です。これらの機能を必要とするならば、
単にこれらの関数を @file{~/.gnus.el} に入れてください。

@findex gnus-demon-init
@findex gnus-demon-cancel
@vindex gnus-demon-handlers
@code{gnus-demon-handlers} に直接ハンドラーを追加した場合には、それを効
かせるために @code{gnus-demon-init} を実行してください。すべてのデーモン
を取り消すには、@code{gnus-demon-cancel} 関数を使うことができます。

デーモンの追加をやりすぎるのはかなりマズいことです。すべてのサーバーから
すべてのニュースとメールを二秒毎に調べまわす関数を付け加えたりすることは、
どんな立派なシステムからも確実に追い出される方法です。お行儀良くしましょ
う。

@node Undo
@section やり直し
@cindex undo

実行したことのやり直しができると、とても便利です。Emacs の普通のバッファー
では十分に簡単です---単に @code{undo} ボタンを押すだけです。しか
し Gnus のバッファーでは、それは簡単ではありません。

Gnus がバッファー内に表示しているものは、Gnus にとってはまったく何の価値
もありません---これはみんな、利用者に奇麗に見えるようにデザインされてい
るただのデータなのです。@kbd{C-k} でグループバッファーからグループを消去
すると、その行は消え去りますが、それは実際の動作---当のグループ
を Gnus の内部構造体から削除すること、の単なる副作用でしかありません。こ
れらのやり直しは、通常の Emacs の @code{undo} 関数では行なうことができま
せん。

Gnus は利用者がすることを憶えておいて、利用者がすることの逆を行なうこと
によって、これを多少は救済しようとします。利用者が @code{undo} キーを押
すと、一段階または数段階前までの操作を元に戻すコードを実行します。しかし、
すべての操作が簡単に逆戻りできるわけではないので、現在 Gnus は、やり直し
可能なキーの機能を僅かしか提供していません。これらはグループの削除、グルー
プの貼り付け、およびグループの既読記事のリストの変更です。実際それだけで
す。将来はもっと機能が追加されるかもしれませんが、追加されるそれぞれの機
能は保存するべきデータを増やすので、決して Gnus は完全にやり直し可能には
ならないでしょう。

@findex gnus-undo-mode
@vindex gnus-use-undo
@findex gnus-undo
やり直し機能は @code{gnus-undo-mode} マイナーモードによって提供されます。
これは @code{gnus-use-undo} が @code{nil} 以外であれば使用され、これがディ
フォルトです。@kbd{C-M-_} キーが @code{gnus-undo} 命令を実行します。これ
は通常の Emacs の @code{undo} 命令にいくぶん似ているはずです。

@node Predicate Specifiers
@section 述語指示子
@cindex predicate specifiers

いくつかの Gnus の変数は「述語指示子」(predicate specifiers) です。これ
は、その多くをすべて記述する必要なしに、述語の仕様に融通を効かせることが
できる特別な形式です。

これらの指示子は関数、シンボルおよびリストからなるリストです。

例です:

@lisp
(or gnus-article-unseen-p
    gnus-article-unread-p)
@end lisp

利用できるシンボルは @code{or}、@code{and} および @code{not} です。関数
はすべて一つのパラメーターを受け取ります。

@findex gnus-make-predicate
呼ぶことができる関数を作るために、Gnus はこれらの指示子について内部的
に @code{gnus-make-predicate} を使います。この関数へのこの入力パラメーター
は、述語指示子の中のすべての関数に渡されます。

@node Moderation
@section 司会役
@cindex moderation

もしあなたが司会者 (モデレーター) ならば、@file{gnus-mdrtn.el} パッケー
ジを使うことができます。これは標準の Gnus パッケージには含まれていません。
@samp{larsi@@gnus.org} に、どのグループの司会を行なうのかを述べたメール
を書いてください。そうすればコピーを手に入れることができます。

司会者用パッケージは概略バッファーのマイナーモードとして実装されています。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-moderate)
@end lisp

をあなたの @file{~/.gnus.el} ファイルに入れてください。

あなたが @samp{rec.zoofle} の司会者だとすると、これは以下のように動作す
るようになっています:

@enumerate
@item
受信したメールを @samp{Newsgroups:.*rec.zoofle} に合致させることによって
分割します。これは投稿されようとしているすべての記事を、あるメールグルー
プ---例えば @samp{nnml:rec.zoofle} に入れます。

@item
あなたは時折このグループに入り、@kbd{e} (edit-and-post) あるい
は @kbd{s} (just send unedited) 命令を使って記事を投稿します。

@item
@samp{rec.zoofle} ニュースグループを読んでいる途中で、もしあなたが承認し
ていない記事をたまたま見つけたとしたら、@kbd{c} 命令で取り消しできます。
@end enumerate

二つのグループで司会者モードを使うとすれば、こうなります:

@lisp
(setq gnus-moderated-list
      "^nnml:rec.zoofle$\\|^rec.zoofle$")
@end lisp

@node Fetching a Group
@section グループを取得する
@cindex fetching a group

@findex gnus-fetch-group
時々「Gnus が起動しているかどうかを気にしないでこのグループを読みたい。」
ということができれば便利なことがあります。これは、利用者よりもプログラム
のコードを書く人に便利な機能ですが、どちらにし
ろ @code{gnus-fetch-group} コマンドはこの機能を提供します。それはグルー
プの名前を引数としてとります。

@node Image Enhancements
@section 画像の拡張

バージョン 21 以上の Emacs は絵やその種のものを表示することができ
る@footnote{MS ウィンドウズの Emacs 21 は画像をサポートしていません。
Emacs 22 はします。}ので、Gnus はこれを利用することにしました。
@menu
* X-Face::                      ファンキーでちっちゃな白黒の絵を表示する
* Face::                        よりファンキーでちっちゃなカラーの絵を表示する
* Smileys::                     幸せな顔をまさにそのように表示する
* Picons::                      あなたが読んでいるものの絵を表示する方法
* Gravatars::                   あなたが読んでいる人々のアバターを表示します
@end menu

@node X-Face
@subsection X-Face
@cindex x-face

@code{X-Face} ヘッダーは、メッセージの著者を表わすことになってい
る 48×48 画素の白黒 (深さ 1 bit の) の絵を描きます。これは進化し続ける
あまたのメールとニュースリーダーによってサポートされるでしょう。

@cindex x-face
@findex gnus-article-display-x-face
@vindex gnus-article-x-face-command
@vindex gnus-article-x-face-too-ugly
@iftex
@iflatex
\include{xface}
@end iflatex
@end iftex
@c @anchor{X-Face}
@code{X-Face} ヘッダーを見るには @samp{compface} をサポートしてい
る Emacs か、変換または表示のための適切なプログラムをインストールしてあ
ることが必要です。あなたの Emacs が自前で画像の表示をサポートしているな
らば、ディフォルトで @code{From} ヘッダーの前に顔が表示されます。
Emacs が自前で @code{X-Face} をサポートしていない場
合、Gnus は @code{pbmplus} パッケージとその仲間の外部プログラム (下記参
照) を使って @code{X-Face} ヘッダーを変換しようとします。画像をサポート
していない Emacs では、ディフォルトでは表示のための処理
を @code{display} というプログラムに委ねます。

GNU/Linux システムの場合、ImageMagick パッケージに含まれてい
る @code{display} プログラムを使います。外部プログラムとして
は @code{netpbm}、@code{libgr-progs} および @code{compface} のような名前
のものを探します。Windows では @url{http://gnuwin32.sourceforge.net} に
ある @code{netpbm} および @code{compface} パッケージを使っても良いです。
@code{PATH} 環境変数に @code{bin} ディレクトリーを追加する必要があります。
@c 実際には以下の DLL とバイナリーだけが必要と思われます: compface1.dll
@c uncompface.exe libnetpbm10.dll icontopbm.exe です。

変数 @code{gnus-article-x-face-command} で、@code{X-Face} ヘッダーを表示
するために何のプログラムを使うかを制御します。この変数が文字列ならば、こ
の文字列がサブシェルで実行されます。関数ならば、この関数が顔を引数として
呼ばれます。もし @code{gnus-article-x-face-too-ugly} (これは正規表現で
す) が @code{From} 欄に合致すれば、顔は表示されません。

(注: 変数/関数名には @code{xface} ではなく @code{x-face} が使われます。)

フェースと変数:

@table @code
@item gnus-x-face
@vindex gnus-x-face
X-Face を表示するためのフェース。このフェースの色が表示される X-Face の
前景色と背景色として使われます。ディフォルトの色は黒と白です。

@item gnus-face-properties-alist
@vindex gnus-face-properties-alist
Face (@pxref{Face}) と X-Face 画像に適用される、画像の形式とプロパティー
の連想リストです。ディフォルト値は @code{((pbm . (:face gnus-x-face))
(png . nil))} です。例を挙げましょう:

@lisp
;; From ヘッダーにおける Face と X-Face の高さを指定します。
(setq gnus-face-properties-alist
      '((pbm . (:face gnus-x-face :ascent 80))
        (png . (:ascent 80))))

;; Face と X-Face を凹んだボタンのように表示します。
(setq gnus-face-properties-alist
      '((pbm . (:face gnus-x-face :relief -2))
        (png . (:relief -2))))
@end lisp

いろいろな画像の形式で利用可能なプロパティーについて
は @xref{Image Descriptors,,, elisp, The Emacs Lisp Reference Manual}, を
参照してください。今のところ @code{pbm} が X-Face 画像に使わ
れ、 @code{png} が Face 画像に使われます。
@end table

投稿様式 (posting style) を使うのであれば、
@code{gnus-posting-styles} に @code{x-face-file} の項を加えれば良いでしょ
う (@pxref{Posting Styles})。さもなけば、外に出すメッセージに X-Face ヘッ
ダーを簡単に挿入できるようにするために Gnus が提供する、いくつかの便利な
関数と変数を利用することができます。これらの機能のためには、前述
の ImageMagick、netpbm または他の画像を変換するパッケージ (何が必要かは、
下記の変数群の値によります) も必要です。

@findex gnus-random-x-face
@vindex gnus-convert-pbm-to-x-face-command
@vindex gnus-x-face-directory
@code{gnus-random-x-face} は @code{gnus-x-face-directory} にあるすべて
の @samp{pbm} ファイルをくまなく探してランダムに一つを選び取り、シェルコ
マンド @code{gnus-convert-pbm-to-x-face-command} を使ってそれ
を X-Face の形式に変換します。@samp{pbm} ファイルは 48×48 画素の大きさ
でなければなりません。それは X-Face ヘッダーのデータを文字列で返します。

@findex gnus-insert-random-x-face-header
@code{gnus-insert-random-x-face-header} は @code{gnus-random-x-face} を
呼んで、ランダムに生成されたデータによる X-Face ヘッダーを挿入します。

@findex gnus-x-face-from-file
@vindex gnus-convert-image-to-x-face-command
@code{gnus-x-face-from-file} はパラメーターとして GIF ファイルを受け取り、
シェルコマンド @code{gnus-convert-image-to-x-face-command} を使ってその
ファイルを X-Face の形式に変換します。

一番目の関数の一般的な使い方を示します。以下のようなもの
を @file{~/.gnus.el} ファイルに書き込んでください:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . gnus-random-x-face))))
@end lisp

最後の関数を使うのは、このようになるでしょう:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(X-Face . (lambda ()
                                (gnus-x-face-from-file
                                 "~/My-face.gif"))))))
@end lisp

@node Face
@subsection Face
@cindex face

@c #### FIXME: faces and x-faces' implementations should really be harmonized.
@code{Face} ヘッダーは、本質的に @code{X-Face} をよりファンキーに変形し
たものです。それらは、メッセージを書いた人を象徴することになってい
る 48×48 画素のカラー画像を描きます。

@cindex face
@findex gnus-article-display-face
@code{Face} ヘッダーの内容は base64 でエンコードされた PNG の画像でなけ
ればなりません。正確な仕様について、
@uref{http://quimby.gnus.org/circus/face/} を参照してください。

変数 @code{gnus-face-properties-alist} は表示される Face 画像の外観に影
響します。@xref{X-Face}.

@code{Face} ヘッダーを見るには Emacs が PNG 画像を表示できる必要がありま
す。

Gnus は外に出すメッセージに Face ヘッダーを簡単に挿入できるようにするた
めの、便利な関数と変数を少しばかり提供します。

@findex gnus-convert-png-to-face
@code{gnus-convert-png-to-face} は 726-byte 以下の 48×48 の PNG の画像
を受け取って、それを Face に変換します。

@findex gnus-face-from-file
@vindex gnus-convert-image-to-face-command
@code{gnus-face-from-file} は JPEG ファイルの名前をパラメーターとして受
け取り、シェルコマンド @code{gnus-convert-image-to-face-command} を使っ
てそのファイルを Face フォーマットに変換します。

この関数の代表的な使い方を挙げておきましょう。以下のようなもの
を @file{~/.gnus.el} ファイルに入れてください:

@lisp
(setq message-required-news-headers
      (nconc message-required-news-headers
             (list '(Face . (lambda ()
                              (gnus-face-from-file "~/face.jpg"))))))
@end lisp

@node Smileys
@subsection スマイリー
@cindex smileys

@iftex
@iflatex
\gnusfig{-3cm}{0.5cm}{\epsfig{figure=ps/BigFace,height=20cm}}
\input{smiley}
@end iflatex
@end iftex
スマイリー @dfn{smiley} は Gnus とは別のパッケージですが、スマイリーを使っ
ているパッケージは現在 Gnus だけなので、ここで説明します。

ひとことで言えば---Gnus でスマイリーを使うには、以下
を @file{~/.gnus.el} ファイルに書き込んでください。

@lisp
(setq gnus-treat-display-smileys t)
@end lisp

スマイリーは、文字の顔マーク---@samp{:-)}, @samp{8-)}, @samp{:-(} などと
いったもの---を絵に割り当てて、文字の顔マークの代わりにその絵を表示しま
す。この変換は文字に合致する正規表現と、それに割り当てられたファイル名の
リストで制御されます。

@vindex smiley-regexp-alist
使われる連想リストは、変数 @code{smiley-regexp-alist} で設定します。各要
素の最初の項目は合致する正規表現で、二番目の要素は絵で置き換えられる正規
表現のグループ番号、そして三番目の要素は表示されるファイルの名前です。

以下の変数でスマイリーの見栄えをカスタマイズします:

@table @code
@item smiley-style
@vindex smiley-style
スマイリーの形式を指定します。あらかじめ定義されている形式
は @code{low-color} (13×14 画素で 3 色の小さい画像)、@code{medium}
(16×16 画素でもっとカラフルな画像) および @code{grayscale} (14×14 画素
のグレースケール画像) です。ディフォルトはディフォルト face の高さに依存
します。

@item smiley-data-directory
@vindex smiley-data-directory
スマイリーが顔ファイルを探す場所です。もうこの変数はいじらないで、代わり
に @code{smiley-style} をカスタマイズしてください。

@item gnus-smiley-file-types
@vindex gnus-smiley-file-types
スマイリーのファイル名として試してみる拡張子のリストです。
@end table

@node Picons
@subsection Picons

@iftex
@iflatex
\include{picons}
@end iflatex
@end iftex
それで…、あなたはこのニュースリーダーをさらにもっと遅くしたいってわけで
すね! これはそうするのにぴったりな方法です。さらにこれは、あなたがニュー
スを読んでいるんだということを、あなたの肩越しに見つめている人に印象づけ
るための素晴らしい方法でもあります。

Picon とはなんでしょう? Picons ウェブサイトから直接引用しましょう。

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex
@quotation
@dfn{Picon} とは「個人アイコン (personal icons)」の略です。これは、ある
電子メールアドレスのための適切な画像を見つけることができるように、無理矢
理小さくしてデータベースにまとめられた画像たちで、ネット上の利用者やドメ
インを表現するために使われます。利用者とドメイン以外に、Usenet ニュース
グループや天気予報のための picon データベースがあります。picon は白黒
の @code{XBM} 形式、またはカラーの @code{XPM} 形式および @code{GIF} 形式
のいずれでも構いません。
@end quotation

@vindex gnus-picon-databases
Picon データベースの入手とインストールの手順については、ウェブブラウザー
で @uref{http://www.cs.indiana.edu/picons/ftp/index.html} を訪ねてみてく
ださい。

もし Debian GNU/Linux を使っているのなら、@samp{apt-get install
picon-.*} と言えば、Gnus が見つけることができる picon がインストールされ
ます。

Picon の表示ができるようにするためには、picon データベースがあるディレク
トリーが、ただ単に @code{gnus-picon-databases} に設定されているようにし
てください。

@vindex gnus-picon-style
変数 @code{gnus-picon-style} は picon をどのように表示するかを制御します。
@code{inline} だったらテキスト形式の表現が置き換えられます。
@code{right} だったら、テキスト形式の表現の右側に picon が加えられます。

@vindex gnus-picon-properties
変数 @code{gnus-picon-properties} の値は picon に適用される属性のリスト
です。

ものごとの所在を管理するために、以下の変数を設けています。

@table @code
@item gnus-picon-databases
@vindex gnus-picon-databases
Picon データベースの場所です。これは @file{news}, @file{domains},
@file{users} (などなど) のサブディレクトリーが含まれているディレクトリー
のリストです。@code{("/usr/lib/picon" "/usr/local/faces")} がディフォル
トです。

@item gnus-picon-news-directories
@vindex gnus-picon-news-directories
@code{gnus-picon-databases} からニュースグループ用のフェースを探すための
サブディレクトリーのリストです。ディフォルトは @code{("news")} です。

@item gnus-picon-user-directories
@vindex gnus-picon-user-directories
@code{gnus-picon-databases} から利用者のフェースを探すためのサブディレク
トリーのリストです。@code{("local" "users" "usenix" "misc")} がディフォ
ルトです。

@item gnus-picon-domain-directories
@vindex gnus-picon-domain-directories
@code{gnus-picon-databases} からドメイン名のフェースを探すためのサブディ
レクトリーのリストです。ディフォルトは @code{("domains")} です。このリス
トに @samp{"unknown"} を追加しておきたくなる人もいるでしょう。

@item gnus-picon-file-types
@vindex gnus-picon-file-types
Picon のファイル名として試してみる順に並べられた拡張子のリストです。ディ
フォルトは @code{("xpm" "gif" "xbm")} から Emacs に組み込まれていないも
のを除外したものです。

@item gnus-picon-inhibit-top-level-domains
@vindex gnus-picon-inhibit-top-level-domains
もし @code{nil} ではない (それがディフォルト) 値だったら、
@samp{.net} や @samp{.de} のようなものについて picons を表示しません。普
通それらはあまり面白いものではありません。
@end table

@node Gravatars
@subsection Gravatars

@iftex
@iflatex
\include{gravatars}
@end iflatex
@end iftex

Gravatar はそれぞれの電子メールアドレスに対応して登録された画像です。

あなたのものを @uref{http://www.gravatar.com} にオンラインで置くことがで
きます。

以下の変数は、それらがどのように表示されるかの制御を提供します。

@table @code
@item gnus-gravatar-size
@vindex gnus-gravatar-size
Gravatars の画素のサイズ。Gravatars は常に正方形なので、サイズの指定には
単一の数値で十分です。もし @code{nil} ならば @code{gravatar-size} の値が
ディフォルトとして使われます。

@item gnus-gravatar-properties
@vindex gnus-gravatar-properties
Gravatar 画像に適用する属性のリストです (@pxref{Image Descriptors,,,
elisp, The Emacs Lisp Reference Manual})。

@item gnus-gravatar-too-ugly
@vindex gnus-gravatar-too-ugly
表示されるべきではないアバターの持ち主たちのメールアドレスまたは名前に合
致する正規表現です。@code{nil} であるとすべてのアバターを表示します。ディ
フォルトは @code{gnus-article-x-face-too-ugly} の値です (@pxref{X-Face})。
@end table

Gravatar を From フィールドで見たいなら、こうしてください:

@lisp
(setq gnus-treat-from-gravatar 'head)
@end lisp

もしそれらを Cc と To フィールドで見たいなら、こうです:

@lisp
(setq gnus-treat-mail-gravatar 'head)
@end lisp

@subsubsection ツールバー

@table @code
@item gnus-use-toolbar
@vindex gnus-use-toolbar
この変数はツールバーを表示する位置を指定します。@code{nil} だったらツー
ルバーを表示しません。非-@code{nil} の場合、それは @code{default},
@code{top}, @code{bottom}, @code{right} または @code{left} の中の一つの
シンボルでなければなりません。@code{default} だったらディフォルトのツー
ルバーを使い、他のものだったらその名前が示す場所にツールバーを表示します。
ディフォルトは @code{default} です。

@item gnus-toolbar-thickness
@vindex gnus-toolbar-thickness
高さと幅のコンス (cons) で、ツールバーの厚さを指定します。高さは上辺か下
辺に表示するツールバーで使われ、幅は右端か左端に表示するツールバーで使わ
れます。ディフォルトはディフォルトのツールバーの値です。

@item gnus-group-toolbar
@vindex gnus-group-toolbar
グループバッファー内のツールバーです。

@item gnus-summary-toolbar
@vindex gnus-summary-toolbar
概略バッファー内のツールバーです。

@item gnus-summary-mail-toolbar
@vindex gnus-summary-mail-toolbar
メールグループの概略バッファー内のツールバーです。
@end table

@iftex
@iflatex
\margindex{}
@end iflatex
@end iftex

@node Fuzzy Matching
@section ファジーな一致
@cindex fuzzy matching

Gnus はスコア付け、スレッドの形成、およびスレッドの比較などを行なうとき
に、@code{Subject} 行のファジーな合致 @dfn{fuzzy matching} を提供します。

正規表現による合致とは違って、ファジーな合致はとってもファジーです。あま
りにもファジーすぎて、何がファジーであるかという定義さえ無いし、実装も何
度も変更されています。

基本的に、これは比較の前に行から邪魔物を取り除こうとします。@samp{Re: }、
挿入句の印、および空白文字等々が文字列から除去され、その結果を比較します。
これはほとんどの場合妥当な結果をもたらします---たとえニュースリーダーの
仮面をかぶった文字列切り刻み機で生成された文字列が差し出されても、です。

@node Thwarting Email Spam
@section spam メールの裏をかく
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

ここ最近の USENET では、宣伝のハゲタカどもが彼らの詐欺や製品を押し付ける
ための電子メールアドレスを探そうとして、気違いのようにニュース上をうろつ
いて grep しまくっています。これに対する反動として、多くの人々が無意味な
アドレスを @code{From} 行に入れはじめるようになってしまいました。私はこ
れは逆効果を招くと思います---あなたが書いたことに対する返信として人々が
正当なメールを送ることを面倒にさせるだけでなく、誰が書いたものなのかを分
かりづらくします。こんな書き換えは、結局は押し付け宣伝メールそれ自身より
も大きな脅威となるかもしれません。

私にとっての spam メールの最大の問題は、嘘の口実で入ってくるからです。私
が @kbd{g} を押すと、Gnus は十通の新着メールがありますと陽気に私に教えて
くれます。私は「おおっ、わーい! 僕って幸せ!」と言ってメールグループを選
択します。しかしそこには、二つのネズミ講と、七つの広告 (「最新! 奇跡の育
毛トニック、ふさふさでつやつやの髪をあなたのつま先(※)に!」) と、悔い改
め神を信じよ、という一つのメールがあるだけなのです。

これは迷惑千万です。あなたがそれに関してできることがあります。

@quotation
訳注※: ホビット族用の育毛トニック。たぶん。
@end quotation

@menu
* The problem of spam::         背景、そして解決
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する
@end menu

@node The problem of spam
@subsection Spam の問題
@cindex email spam
@cindex spam filtering approaches
@cindex filtering approaches, spam
@cindex UCE
@cindex unsolicited commercial email

初めに spam の背景から。

あなたが電子メールを使っているならば、spam (専門用語としては Unsolicited
Commercial E-mail---望まれない商用電子メール---の頭文
字 @acronym{UCE}) のことはよく知っているでしょう。簡単に言えばそれは紙の
メールに比べて電子メールの配送がとても安くつくために存在し、非常に小さな
割合の人々が UCE に応答するだけで広告主に利益をもたらすのです。皮肉なこ
とに最も一般的な spam の一つは、さらに spam を助長するための電子メールア
ドレスのデータベースを提供します。Spam の送信者はふつ
う @emph{spammers} と呼ばれますが、@emph{vermin}、@emph{scum}、
@emph{sociopaths} および @emph{morons} のような用語もよく使われています。

Spam は種々さまざまな出どころからやって来ます。有用なメッセージを捨てず
にすべての spam を単に始末することは不可能です。良い例は TMDA (訳注: 送
信する度にユニークなアドレスを使う) システムで、それは、あなたが知らない
送信者からの電子メールがあなたのもとに届くことができる前に、彼らに対して
彼ら自身が正当な送信者であることの確認を求めます。正当な出どころからの電
子メールが、それらの出どころが TMDA システムを通して確認できない、または
行なわれない場合は捨てられてしまうかもしれないというマイナス面は、
TMDA の技術的な側面に立ち入らなくても明白です。もう一つの TMDA の問題は、
電子メールの配送と処理への基本的な理解を、利用者に求めていることです。

Spam の除去 (filtering) への最も単純な取り組みは、メールサーバーで、ある
いは入ってきたメールを分類するときに濾過すること (filtering) です。毎
日 @samp{random-address@@vmadmin.com} から 200通の spam メッセージを受け
取るのならば、@samp{vmadmin.com} を阻止すれば良いでしょう。「バイアグラ」
に関するメッセージを 200通受け取るのならば、「バイアグラ」を含むすべての
メッセージを捨ててしまえば良いでしょう。例えばブルガリアからたくさん
の spam がやって来るのならば、ブルガリアの IP から来るすべてのメールを濾
過すれば良いでしょう。

これは、残念ながら正当な電子メールを捨てるためのすぐれた方法です。あなた
に連絡しようとする国 (ブルガリア、ノルウェー、ナイジェリア、中国、等) 全
体、または大陸 (アジア、アフリカ、ヨーロッパ、等) さえも封じ込めてしまう
危険は明らかなので、あなたに選択権があるのならば、そんなことはしないでく
ださい。

もう一つの例として、とても示唆に富んで有益な RISKS ダイジェストは、それ
が spam メッセージと共通の語を @strong{含んで} いるために、熱心すぎるメー
ル濾過器によって阻止されてしまいます。それでもなお孤立した環境では、注意
深く使うことによって直接の濾過は有益になり得ます。

もう一つの電子メール濾過への取り組みは分散型 spam 処理で、DCC (訳
注: Distributed Checksum
Clearinghouse---@uref{http://www.rhyolite.com/anti-spam/dcc/}) がそのよ
うなシステムを導入しています。本質的には、世界中の @var{N} 個のシステム
が、ガーナ、エストニアあるいはカリフォルニアにあるマシ
ン @var{X} が spam 電子メールを送出していることを認めたら、それ
ら @var{N} 個のシステムは @var{X} または @var{X} からやって来た spam メー
ルをデータベースに記入します。Spam 検出の基準は一様ではありません。それ
は送られたメッセージの数やメッセージの内容などであるかもしれません。メッ
セージが spam かどうかを分散処理システムの利用者が知りたい場合、彼はそれ
らの @var{N} 個のシステムのうちの一つを調べます。

分散型 spam 処理は一度にたくさんのメッセージを送る spammers と非常によく
戦ってくれますが、それには利用者がかなり複雑なチェックを設定することが必
要です。商用とフリーな分散型 spam 処理システムがあります。分散型 spam 処
理は、それ自体の危険もはらんでいます。例えば、正当な送信者が spam を送っ
たかどで非難され、彼らのウェブサイトやメーリングリストがその事件のために
暫くの間閉鎖されてしまう、とか。

Spam の濾過への統計的な取り組みもまた普及しています。それは過去
の spam メッセージの統計的な分析に基づいています。通常その分析は、おそら
く単語の対か三つの単語の組合せの合成による、単語の出現頻度の単純な計数で
す。Spam の統計分析はほとんどの場合にとてもよく働くのですが、時として正
当な電子メールを spam として分類してしまうことがあります。分析には時間が
かかります。すべてのメッセージを分析しなければなりません。そして利用者
は spam を分析するためのデータベースを蓄えなければなりません。サーバーで
の統計分析は人気を得ています。これには、利用者は単にメールを読めば良いと
いう長所と、しかしサーバーにそれが過ってメールを分類したことを伝えるのが
困難だという短所があります。

余人の言を待たずとも、spam との戦いは楽ではありません。ママからの電子メー
ルとバイアグラ広告を区別する魔法のスイッチはありません。人々は
非-spam と spam を区別するのに手を焼いているというのに。それは、
spammers が懸命にそれらをママだと思わせようとしているのが本質だからです。
Spamming は、世界が彼らに恩義があると思っている人々の一団からの、腹立た
しく、無責任で、ばかげた行為です。以下の各章が spam なる疫病との戦いの助
けになることを望みます。

@node Anti-Spam Basics
@subsection Spam 退治の基礎
@cindex email spam
@cindex spam
@cindex UCE
@cindex unsolicited commercial email

Spam に対処する一つの方法は、Gnus にすべての spam を @samp{spam} メール
グループに分離させてしまうことです (@pxref{Splitting Mail})。

最初に、あなたに連絡することができる正しいメールアドレスを一つ選び、それ
をすべてのあなたのニュース記事の @code{From} ヘッダーに入れましょう。(こ
こでは @samp{larsi@@trym.ifi.uio.no} を選びましたが、
@samp{larsi+usenet@@ifi.uio.no} の形式のたくさんのアドレスの方が良い選択
です。あなたのサイトの sendmail の設定がメールアドレスのローカル部として
どんなキーワードを受け付けるかは、あなたのサイトのシステム管理者に聞いて
ください。)

@lisp
(setq message-default-news-headers
      "From: Lars Magne Ingebrigtsen <larsi@@trym.ifi.uio.no>\n")
@end lisp

そして @code{nnmail-split-fancy} に以下の分割規則を入てくださ
い (@pxref{Fancy Mail Splitting})。

@lisp
(...
 (to "larsi@@trym.ifi.uio.no"
     (| ("subject" "re:.*" "misc")
        ("references" ".*@@.*" "misc")
        "spam"))
 ...)
@end lisp

この意味は、このアドレスに届いたすべてのメールが疑わしいが、
@samp{Re:} で始まる @code{Subject} が付いているか、@code{References} ヘッ
ダーが付いていればおそらく OK だろう、ということです。残りはすべ
て @samp{spam} グループに行きます。(このアイデアはおそらく Tim Pierce 氏
によるものです。)

これに加えて、多くのメール spam 屋は、あなたのところの @acronym{SMTP} サー
バーと直接話して、@code{To} ヘッダーにあなたのメールアドレスが明示されな
いようにします。なんでそんなことをするのかはわかりませんが---もしかした
ら、この裏をかく機構の裏をかくためかな? どちらにしても、対処は簡単なこと
です---特級分割規則を以下のように終端させることによって、あなた宛てでな
いものを全部 @samp{spam} グループに入れるだけです:

@lisp
(
 ...
 (to "larsi" "misc")
 "spam")
@end lisp

私の経験では、これで実質的にはすべてが正しいグループに分類されます。まあ、
それでもときどき @samp{spam} グループをチェックして、正しいメールがある
かチェックしなくてはいけませんけどね。あなたが自分が良いネットワーク市民
であると思っているなら、それぞれの押し付け宣伝メールの関係当局に苦情を送
り付けることさえもできます---暇なときにでもね。

これで私のところでは動いています。これでみんなは簡単な方法で私に連絡を取
ることができ (普通に @kbd{r} を押すだけでできる)、私は spam に煩わされる
ことはまったくありません。お互いに有利な状況です。私に言わせれば、
@code{From} ヘッダーを偽造して存在しないドメインに送らせるのはすごく良く
ないです。

@quotation
訳注: 以上の文章は 1997年4月に書かれました。
@end quotation

この手法には注意してください。Spammers はそれに気付いています。

@node SpamAssassin
@subsection SpamAssassin, Vipul's Razor, DCC, etc
@cindex SpamAssassin
@cindex Vipul's Razor
@cindex DCC

Spam を避けるための前章のヒントが十分だった日々は過ぎ去りました。今では
受け取ったたくさんの spam を減らすという触れ込みの多くの道具があります。
この章は、新しい道具が古いものに取って代わって行くにつれてすぐに時代遅れ
になってしまうでしょうが、幸いなことにこれらのほとんどの道具は類似のイン
ターフェースを持っているようです。この章は例として SpamAssassin を使って
いますが、他のほとんどの道具にも簡単に適合するはずです。

この章は @code{spam.el} パッケージとは関係無いことに注意してください。そ
れは次の章で論じられます。すべての @code{spam.el} の機能に関心が無いのな
らば、これらの単純なレシピで間に合わせることができます。

もしあなたが使う道具がメールサーバーにインストールされていないならば、あ
なた自身がそれを呼び出す必要があります。以下に @code{:postscript} メール
ソース指示子 (@pxref{Mail Source Specifiers}) を使う場合の考え方を示しま
す。

@lisp
(setq mail-sources
      '((file :prescript "formail -bs spamassassin < /var/mail/%u")
        (pop :user "jrl"
             :server "pophost"
             :postscript
             "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))
@end lisp

いったんメールを受けるスプールをどうにかして処理する、例えばそのメール
に spam であることを表示するヘッダーを含めるようにすれば、それをふるい落
とす準備は完了です。使うのは普通の分割方式 (@pxref{Splitting Mail}) です:

@lisp
(setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                             ...))
@end lisp

または特級分割方式 (@pxref{Fancy Mail Splitting}) です:

@lisp
(setq nnmail-split-methods 'nnmail-split-fancy
      nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                             ...))
@end lisp

いくらかの人たちは @code{:prescript} を使ってメールをいろんなプログラム
にパイプすることを嫌うかもしれません (もし何かのプログラムにバグがあった
ら、すべてのメールを失ってしまうかもしれません)。あなたがそれらの一人な
らば、別の解は分割するときに外部の道具を呼ぶことです。特級分割方式の例で
す:

@lisp
(setq nnmail-split-fancy '(| (: kevin-spamassassin)
                             ...))
(defun kevin-spamassassin ()
  (save-excursion
    (widen)
    (if (eq 1 (call-process-region (point-min) (point-max)
                                   "spamc" nil nil nil "-c"))
        "spam")))
@end lisp

Nnimap バックエンドの場合、ディフォルトでは記事のボディーがダウンロード
されないことに注意してください。それをするために
は @code{nnimap-split-download-body} を @code{t} に設定する必要がありま
す (@pxref{Client-Side IMAP Splitting})。

以上がこれに関することです。ある種の spam はどうしても素通りしてしまいが
ちなので、spam を読むはめになったときに呼ぶための気の利いた関数が必要で
しょう。これがその気の利いた関数です:

@lisp
(defun my-gnus-raze-spam ()
  "SPAM の処理を Vipul の Razor に委ねてから、
それに期限切れ消去可能の印を付けます。"
  (interactive)
  (gnus-summary-save-in-pipe "razor-report -f -d" t)
  (gnus-summary-mark-as-expirable 1))
@end lisp

@node Hashcash
@subsection Hashcash
@cindex hashcash

Spam と戦うための斬新な技法は、いくらか負担にはなるが明らかに独特なこと
を、送信するメッセージに対して送信者が行なうことを求めることです。これは
インターネット標準の一部ではないので、世界中のすべての人がこの技法を使う
ことは当てにできないという明らかな欠点がありますが、小規模な集団では役に
立つでしょう。

前章の道具類は実際にうまく働きますが、それらは新しい形式の spam が現れる
たびにしょっちゅう更新かつ整備されることによってのみ動作します。このこと
は、小さなパーセンテージの spam がいつも素通りしてしまうことを意味します。
それはまた、どこかでだれかがそれらの道具を更新するために、たくさん
の spam を読まなければならないことをも意味します。Hashcash はそれを回避
しますが、代わりにあなたが電子メールで連絡するすべての人たちに、なるべく
その仕組みをサポートしてもらいたいのです。あなたは実際的 (pragmatic) か
独断的 (dogmatic) かの観点で、二つの取り組みを考えることができます。それ
らのやり方には、それら自体の利点もあれば不利な点もありますが、現実の世の
中ではしばしばあるように、それらを連係させたものはどちらか一方より強力で
す。

@cindex X-Hashcash
「いくらか負担にはなる」とは CPU 時間を消費することで、もっと具体的には
一定数のビットまでハッシュの衝突 (hash collision) を計算することです。そ
の結果としての hashcash クッキーは @samp{X-Hashcash:} ヘッダーに挿入され
ます。もっと詳しいこと、そしてこの機能を使うためにインストールする必要が
ある外部アプリケーションの @code{hashcash} について
は @uref{http://www.hashcash.org/} を参照してください。さらなる情報
が @uref{http://www.camram.org/} で見つかるでしょう。

送信するメッセージのそれぞれについて hashcash を生成させようと思うなら、
以下のように @code{message-generate-hashcash} (@pxref{Mail Headers,
,メールヘッダー, message-ja, The Message Manual}) をカスタマイズしてくだ
さい:

@lisp
(setq message-generate-hashcash t)
@end lisp

いくつかの追加の変数の設定もしなければなりません:

@table @code
@item hashcash-default-payment
@vindex hashcash-default-payment
この変数はハッシュの衝突を成すディフォルトのビット数を示します。ディフォ
ルトは 20 です。提唱されている有効な値は 17 から 29 までの数です。

@item hashcash-payment-alist
@vindex hashcash-payment-alist
何人かの受取人は、あなたにディフォルトより多くの CPU 時間を費やすことを
要求するかもしれません。この変数は @samp{(@var{addr} @var{amount})} の形
式の要素のリストで、@var{addr} は受取人 (メールアドレスかニュースグルー
プ)、@var{amount} は衝突で必要とされるビット数です。これはま
た @samp{(@var{addr} @var{string} @var{amount})} の要素を持つことも可能
で、@var{string} は文字列 (通常はメールアドレスかニュースグループ名) と
して使われます。

@item hashcash-path
@vindex hashcash-path
@code{hashcash} バイナリーがインストールされている場所です。この変数
は @code{executable-find} によって自動的に設定されるはずですが、それ
が @code{nil} だった (ありがちなのは @code{hashcash} バイナリーが実
行 path 中に無い) 場合は、hashcash payments をチェックするときに警告され、
hashcash payments を生成するときはエラーになるでしょう。
@end table

Gnus は hashcash クッキーを認証することができますが、手でカスタマイズし
たメール濾過スクリプトで行なうこともできます。メッセージ中の hashcash クッ
キーを認証するには、@code{hashcash.el} ライブラリー
の @code{mail-check-payment} 関数を使ってください。入ってきたメール
の hashcash クッキーを確認し、それによってメールを濾過するために、
@code{spam-use-hashcash} バックエンドで @code{spam.el} を使うこともでき
ます (@pxref{Anti-spam Hashcash Payments})。

@node Spam Package
@section Spam パッケージ
@cindex spam filtering
@cindex spam

Spam パッケージは spam を検出して濾過するために集結された機構を Gnus に
提供します。それは新着メールを濾過し、spam か ham かに応じてメッセージを
処理します。(@dfn{Ham} は spam ではないメッセージを示すために、このマニュ
アルを通して使われる名前です。)

@menu
* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::
@end menu

@node Spam Package Introduction
@subsection Spam パッケージ序説
@cindex spam filtering
@cindex spam filtering sequence of events
@cindex spam

Spam パッケージがどのように働くかを理解するために、必ずこの章を読んでく
ださい。読み飛ばし、速読、または斜め読みしてはいけません。

@code{spam.el} シーケンスのイベントの章をちゃんと読みましょう。
@xref{Extending the Spam package}.

@cindex spam-initialize
@vindex spam-use-stat
Spam パッケージを使うには、@strong{必ず} 最初
に @code{spam-initialize} 関数を実行させてください:

@example
(spam-initialize)
@end example

これは @code{spam.el} を自動読み込み (autoload) して、Spam パッケージに
その仕事をさせるために必要な諸機能が使えるようにします。Spam パッケージ
を利用するために、いくつかのグループパラメーターと変数を設定しなければな
りません。それらは以下で説明します。Spam パッケージを制御するすべての変
数は、@samp{spam} カスタマイズグループで見つかるでしょう。

Spam パッケージと Gnus には二つの「接点」があります。それは新着メール
が spam かどうかを検査するときと、グループを抜け出るときです。

新着メールが spam かどうかの検査は、やって来たメールを分割するときか、グ
ループに入るときのどちらかで行なわれます。

最初のやり方、つまりやって来たメールを分割するときに検査をするのは、新着
メールが単一のスプールファイルに入れられ
る @code{nnml} や @code{nnimap} のようなメールバックエンドに適しています。
Spam パッケージはやって来たメールを処理し、spam と見なすメールを“spam”
用に指定したグループに送ります。@xref{Filtering Incoming Mail}.

二番目のやり方は、@code{nntp} のような (やって来たメールのためのスプール
がない) バックエンドや、やって来たメールの分割をサーバーが担当するバック
エンドに適しています。この場合 Gnus のグループに入ると、そのグループにあ
るまだ読まれたことが無い、または未読になっているメッセージに対し
て spam かどうかの検査が行なわれます。検出された spam メッセージに
は spam 印が付けられます。@xref{Detecting Spam in Groups}.

どちらの場合でも、spam メッセージの検出にどの方法を使うかを Spam パッケー
ジに指示しなければなりません。選択肢として複数の方法、と言うか「spam バッ
クエンド」があります (Gnus のバックエンドと混同しないでくださ
い): spam の「ブラックリスト」と「ホワイトリスト」、辞書に基づいた濾過器、
などです。@xref{Spam Back Ends}.

Gnus の概略バッファーで spam だと同定されたメッセージには、常
に @samp{$} 印が付きます。

Spam パッケージは Gnus のグループを三つに分類します: ham グループ、
spam グループ、および分類されないグループです。講読している各グループが
ham グループと spam グループのどちらなのかを、@code{spam-contents} グルー
プパラメーターを使って指定してくださ
い (@pxref{Group Parameters})。Spam グループには特別な属性があり、
spam グループに入ると、まだ読まれたことが無いすべてのメッセージ
に spam 印が付きます。そのため、spam グループに分割されたメールには自動
的に spam 印が付きます。

Spam メッセージを同定することは、Spam パッケージの仕事の半分に過ぎません。
もう半分は、グループを抜け出るときに実行します。このとき Spam パッケージ
は複数のことを行ないます。

最初に spam か ham かに応じて記事を処理するために @dfn{spam and ham
processors} を呼び出します。各々の spam バックエンドと連係してい
る spam と ham のプロセッサーの対があって、プロセッサーが行なうことはバッ
クエンドに依存しています。現在のところ spam と ham プロセッサーの主な役
割は、辞書に基づいた spam 濾過のためのものです: それらは将来の spam を検
出する性能を改良するために、グループにあるメッセージの内容を濾過器の辞書
に追加します。@code{spam-process} グループパラメーターで、どの spam プロ
セッサーを使うかを指定します。@xref{Spam and Ham Processors}.

Spam 濾過器が spam メッセージに印を付けそこなったら、グループを抜け出る
ときにそのメッセージが spam として処理されるようにするために、あなた自身
がそれに印を付けても良いでしょう。

@table @kbd
@item $
@itemx M-d
@itemx M s x
@itemx S x
@kindex $ @r{(概略)}
@kindex M-d @r{(概略)}
@kindex S x @r{(概略)}
@kindex M s x @r{(概略)}
@findex gnus-summary-mark-as-spam
現在の記事に spam 印を付けて、@samp{$} 印を表示しま
す (@code{gnus-summary-mark-as-spam})。
@end table

@noindent
同様に、記事に誤って付けられた spam 印を消すこともできます。
@xref{Setting Marks}.

普通 ham ではないグループで見つかった ham メッセージは ham として処理さ
れません。つまり、さらに処理されるために、それは ham グループに移動させ
るべきであるということです (以下を見てください)。しか
し @code{spam-process-ham-in-spam-groups} およ
び @code{spam-process-ham-in-nonham-groups} を設定することによって、それ
らの記事を ham として処理することを強制することもできます。

@vindex gnus-ham-process-destinations
@vindex gnus-spam-process-destinations
グループを抜け出るときに、二番目に Spam パッケージが行なうことは、ham 記
事を spam グループの外へ、spam 記事を ham グループの外へ移動させることで
す。Spam グループの ham 記事は、変
数 @code{gnus-ham-process-destinations} またはグループパラメー
ター @code{ham-process-destination} で指定されたグループに移動させられま
す。Ham グループの spam 記事は、変
数 @code{gnus-spam-process-destinations} またはグループパラメー
ター @code{spam-process-destination} で指定されたグループに移動させられ
ます。これらの変数が設定されていない場合、記事はそれらの現在のグループに
残されます。記事を移動させることができない場合 (例えば @acronym{NNTP} の
ような読み出し専用のバックエンドでは)、代わりに記事がコピーされます。

記事が別のグループに移動させられると、その新しいグループを訪れたときに、
記事は再び処理されます。普通これは問題になりませんが、それぞれの記事が一
回だけ処理されるようにしたいならば、@code{gnus-registry.el} パッケージを
読み込んで、変数 @code{spam-log-to-registry} を @code{t} に設定してくだ
さい。@xref{Spam Package Configuration Examples}.

普通 spam グループは @code{gnus-spam-process-destinations} を無視します。
しかし @code{spam-move-spam-nonspam-groups-only} を @code{nil} に設定す
ると、@code{spam-process-destination} パラメーターに従っ
て spam は spam グループの外へ移動させられます。

最後に Spam パッケージが行なうことは、spam 記事に期限切れ消去の印を付け
ることです。普通それは正しい行ないです。

これらのすべてがわけがわからなくても、心配は要りません (訳注: でも訳文が
正確ではないかもしれないので、変だと思ったら原文を見てね :-p)。すぐにそ
れは神経インターフェース上に Lisp で小話を書くように自然なことになりま
す@dots{} え゛ごめん、それにはまだ 50年早いですね。ただ私たちを信頼して
ください。それは捨てたものではありません。

@node Filtering Incoming Mail
@subsection やって来るメールの濾過
@cindex spam filtering
@cindex spam filtering incoming mail
@cindex spam

やって来るメールを濾過するために Spam パッケージを使うには、最初に特級メー
ル分割を使うための設定を行なってください。@xref{Fancy Mail Splitting}.
Spam パッケージは、特級分割のための変数 (メールバックエンドによる
が @code{nnmail-split-fancy} または @code{nnimap-split-fancy}) に追加す
ることができる、特別な分割関数を定義します:

@example
(: spam-split)
@end example

@vindex spam-split-group
@noindent
@code{spam-split} 関数は、あなたが選んだ spam バックエンド (一つまたは複
数) に応じて、やって来たメールを走査します。ディフォルトでは spam グルー
プは @samp{spam} という名前のグループですが、@code{spam-split-group} を
カスタマイズすることによって変更することができます。
@code{spam-split-group} の値に Gnus のバックエンド名やサーバー名を含めな
いでください。例えば @samp{your-server} という @code{nnimap} のサーバー
では、@samp{spam} という名前は @samp{nnimap+your-server:spam} を意味しま
す。したがって @samp{nnimap+server:spam} という値は誤りで、それ
は @samp{nnimap+your-server:nnimap+server:spam} というグループを指すこと
になってしまいます。

@code{spam-split} はいかなる方法によってもメッセージの内容を変更しません。

@vindex nnimap-split-download-body
IMAP の利用者への注意: spam バックエンドとし
て @code{spam-check-bogofilter}、@code{spam-check-ifile} およ
び @code{spam-check-stat} を使う場合は、さらに変
数 @code{nnimap-split-download-body} を @code{t} に設定しなければなりま
せん。これらの spam バックエンドがメッセージの本文を「走査」(scan) する
ことができれば、非常に有用です。ディフォルトでは nnimap バックエンドはメッ
セージヘッダーだけを取り込みますが、@code{nnimap-split-download-body} で
メッセージの本文も取り込むことを指示することができます。それ
は @acronym{IMAP} を遅くしてしまうので、ディフォルトでは設定されません。
そして、利用者に代わってそれを行なうことは、適切な判断ではありません。
@xref{Client-Side IMAP Splitting}.

@code{spam-use-*} 変数を使って、@code{spam-split} が使う一つ以上
の spam バックエンドを設定しなければなりません。@xref{Spam Back Ends}.
通常 @code{spam-use-*} は、あなたがこのようにして設定したすべて
の spam バックエンドを、単に使います。しかし、それらのいくつかだけを使う
ように、@code{spam-split} に指示することもできます。それがなぜ役に立つの
かって?  Spam バックエンドとし
て @code{spam-use-regex-headers} と @code{spam-use-blackholes} を使って
いて、かつ以下の分割規則を使っているとすると:

@example
 nnimap-split-fancy '(|
                      (any "ding" "ding")
                      (: spam-split)
                      ;; @r{ディフォルトのメールボックス。}
                      "mail")
@end example

@noindent
問題は ding 宛てのメッセージをすべて ding フォルダーに入れようとしている
ことです。でもそれは、ding メーリングリスト宛てに送られた明らか
な spam (例えば SpamAssassin と @code{spam-use-regex-headers} によって検
出される spam) を許してしまうでしょう。一方、いくつかの ding 宛てのメッ
セージはブラックホールリストに載っているメールサーバーからやって来るので、
ding の規則より前に @code{spam-split} を発動することができません。

解決策は SpamAssassin ヘッダーに ding の規則を置き換えさせ、ding の規則
の後で別の @code{spam-split} の規則 (二つ目の正規表現によるヘッダーの検
査を含む) を作動させることです。これはパラメーター
を @code{spam-split} に渡すことによって行なわれます:

@example
nnimap-split-fancy
      '(|
        ;; @r{@code{spam-use-regex-headers} で検出された}
        ;; @r{spam は @samp{regex-spam} へ。}
        (: spam-split "regex-spam" 'spam-use-regex-headers)
        (any "ding" "ding")
        ;; @r{spam-split で検出された他のすべての spam は}
        ;; @r{@code{spam-split-group} へ。}
        (: spam-split)
        ;; @r{ディフォルトのメールボックス。}
        "mail")
@end example

@noindent
これは、あなたの特別な必要に応じた特定の @code{spam-split} 検査を起動し、
それらの検査の結果で特定の spam グループを指し示します。すべてのメールに
対して、すべての spam 検査を行なう必要はありません。これが良いもう一つの
理由は、分割規則を設定してあるメーリングリスト宛てのメッセージに対して、
資源集約的なブラックホール・チェックを実行する必要がないということです。
さらに、nnmail の分割のために nnimap のものとは異なる spam 検査のやり方
を設定することもできるでしょう。気が狂うー。

使用するどんな spam バックエンドにも @code{spam-use-*} 変数を設定するべ
きです。そのわけは、@file{spam.el} を読み込むときに、どん
な @code{spam-use-xyz} 変数を設定したかによって、何らかの条件付きの読み
込みが行なわれるからです。@xref{Spam Back Ends}.
@c
@c @emph{TODO: すべての統計データベースをトレーニングするための均一な手段を
@c 提供する必要があります。いくつかはその機能を内蔵していますが、していない
@c ものもあります。}

@node Detecting Spam in Groups
@subsection グループにおける spam の検出

グループに入ったときに spam を検出するためには、そのグループ
の @code{spam-autodetect} と @code{spam-autodetect-methods} グループパラ
メーターを設定してください。これらは通常とおり @kbd{G c} か @kbd{G p} で
行なうことができます (@pxref{Group Parameters})。

使用するどんな spam バックエンドにも @code{spam-use-*} 変数を設定するべ
きです。そのわけは、@file{spam.el} を読み込むときに、どん
な @code{spam-use-xyz} 変数を設定したかによって、何らかの条件付きの読み
込みが行なわれるからです。

ディフォルトでは、まだ読まれたことがない記事だけが spam かどうかを検査さ
れます。@code{spam-autodetect-recheck-messages} を @code{t} に設定するこ
とによって、グループにあるすべての記事の再検査を Gnus に強制することがで
きます。

Spam の検査に @code{spam-autodetect} の手段を使う場合は、異なるグループ
で違う spam 検出手段を指定することができます。例えば @samp{ding} グルー
プは自動検出の手段として @code{spam-use-BBDB} を持つことができる一方で、
@samp{suspect} グループでは @code{spam-use-blacklist} およ
び @code{spam-use-bogofilter} の手段を使うことができます。
@code{spam-split} と違って検査の @emph{順序} を制御できませんが、これは
たぶん重要ではありません。

@node Spam and Ham Processors
@subsection Spam と Ham プロセッサー
@cindex spam filtering
@cindex spam filtering variables
@cindex spam variables
@cindex spam

@vindex gnus-spam-process-newsgroups
Spam と ham プロセッサーには、グループバッファを抜け出るときに行なう動作
に関して特別な性質があります。Spam プロセッサーは spam メッセージに作用
し、ham プロセッサーは ham メッセージに作用するということです。現在のと
ころ、これらのプロセッサーの主な役割は、
Bogofilter (@pxref{Bogofilter}) や Spam 統計パッケージのような辞書に基づ
いた spam バックエンドの辞書を更新することです (@pxref{Spam Statistics
Filtering})。

それぞれのグループに適用される spam と ham プロセッサーは、そのグループ
の @code{spam-process} グループパラメーターで決定されます。このグループ
パラメーターが定義されていないと、それらは変
数 @code{gnus-spam-process-newsgroups} によって決められます。

@vindex gnus-spam-newsgroup-contents
Gnus はあなたが受け取った spam から学びます。あなたは一つ以上の spam グ
ループに spam 記事を集めて、変数 @code{spam-junk-mailgroups} を適切に設
定もしくはカスタマイズしなければなりません。また、spam を含めるグループ
を、そのグループパラメー
ター @code{spam-contents} を @code{gnus-group-spam-classification-spam} に
設定するか、またはそれに対応する変
数 @code{gnus-spam-newsgroup-contents} をカスタマイズすることによって宣
言することができます。@code{spam-contents} グループパラメーター
と @code{gnus-spam-newsgroup-contents} 変数は、それらの種別
を @code{gnus-group-spam-classification-ham} に設定することによって、
@emph{ham} グループであることを宣言するために使うこともできます。グルー
プが @code{spam-junk-mailgroups}, @code{spam-contents} また
は @code{gnus-spam-newsgroup-contents} であることを示す分類が行なわれて
いないと、それらは @emph{未分類} であると解釈されます。すべてのグループ
はディフォルトでは未分類です。

@vindex gnus-spam-mark
@cindex $
Spam グループでは、ディフォルトですべてのメッセージが spam であると解釈
されます: そのグループに入ると、それら
に @samp{$} 印 (@code{gnus-spam-mark}) が付きます。あるメッセージを見て、
いったんそれに spam の印を付けても、後で取り消せば、その後そのグループに
入ったときに、それには spam 印は付きません。
@code{spam-mark-only-unseen-as-spam} パラメーターを @code{nil} にすれば、
そういう動作をやめさせる、つまりすべての未読メッセージに spam 印が付くよ
うにすることができます。そのグループの概略バッファーにいるときに、やっぱ
り spam ではなかったとわかった記事があったら、それらのすべてか
ら @samp{$} 印を消さなければなりません。@samp{$} 印を消すに
は @kbd{M-u} でその記事を「未読」にするか、あるいは @kbd{d} を使っ
て spam ではないものとして読んだことを宣言すれば良いでしょう。グループを
抜けるとき、すべての spam 印 (@samp{$}) が付いた記事は spam プロセッサー
に送られ、それらを spam の標本として学習します。

メッセージは他のいろいろな方法によっても消去されるかもしれないし、
@code{ham-marks} グループパラメーターが無効にされなければ、@samp{R} 印
と @samp{r} 印、および @samp{X} 印と @samp{K} は、@samp{Y} 印と同様
に、すべて spam では無い記事に関連付けられるものと解釈されます (それぞ
れ @samp{R} はディフォルトの既読の印、@samp{r} 明示的な消去の印、
@samp{X} は自動的な削除の印、@samp{K} は明示的な削除の印、そし
て @samp{Y} は低いスコアのため印です)。この仮定は、特に真性の spam を検
出するために消去 (kill) ファイルかスコアファイルを使っている場合は、間違
いかもしれません。そうであれば @code{ham-marks} グループパラメーターを調
整するべきです。

@defvar ham-marks
このグループまたはトピックパラメーターを ham であると解釈したい印のリス
トに設定することができます。ディフォルトでは、消去 (deleted)、既
読 (read)、削除 (killed)、kill ファイルにあるもの (kill-filed) および低
いスコア (low-score、既読だけれども spam ではないと考える) 印のリストで
す。Ham 印のリストに可視 (tick) 印を含めることが役立つこともあります。未
読印を ham 印にすることは、通常それが分類されていないことを表すので、勧
められません。しかし、あなたがそれを行なうことはできるし、私たちに不満は
ありません。
@end defvar

@defvar spam-marks
このグループまたはトピックパラメーターを spam であると解釈したい印のリス
トに設定することができます。ディフォルトでは spam 印だけを持つリストです。
それを変更することは勧めませんが、本当にそうしたいのならご勝手に。
@end defvar

グループを抜けるときに (そのグループが @emph{何} であっても)、そ
の @code{spam-contents} の分類にかかわらず、spam 印が付いているすべての
記事は spam プロセッサーに送られ、それらを spam の標本として学習します。
意図的にたくさんの消去を行なうと、たまにそれは見ていない @samp{K} 印が付
いた記事群で終わるかもしれません。そしてそれらは偶然に spam を含んでいる
かもしれません。最も良いのは、本当の spam に @samp{$} が付いていて、他に
何も印が無いことを確かめることです。

@vindex gnus-ham-process-destinations
@emph{Spam} グループを抜けるときに、spam 印が付いているすべての記事
には spam プロセッサーで処理した後で期限切れ消去の印が付けられます。これ
は @emph{未分類} または @emph{ham} グループに対しては行なわれません。さ
らに spam グループにあるどの @strong{ham} 記事も、
@code{ham-process-destination} グループパラメーターが示す場所
か @code{gnus-ham-process-destinations} 変数の中で合致する場所のどちらか
に移されます。後者はグループ名に合致する正規表現のリストです (@kbd{M-x
customize-variable @key{RET} gnus-ham-process-destinations} によってこの
変数をカスタマイズするのが最も簡単です)。変数を手でカスタマイズする方が
好きな人のために言っておくと、それぞれのグループ名のリストは普通
の Lisp の list です。@code{ham-process-destination} パラメーターが設定
されていないと、ham 記事は移動させられません。
@code{spam-mark-ham-unread-before-move-from-spam-group} パラメーターが設
定されていると、ham 記事には移動させられる前に未読の印が付けられます。

例えば @acronym{NNTP} のような読み込み専用バックエンドであるため
に ham が移動できない場合、それはコピーされます。

グループごとに、または正規表現に合致するグループごとに、複数の移動先を指
定できることに注目してください!  これによって ham 記事を正規のメールグルー
プと @emph{ham トレーニング} グループに送ることができます。

@emph{Ham} グループを抜けるときに、ham 印が付いているすべての記事
は ham プロセッサーに送られ、それらを spam ではない標本として学習します。

@vindex spam-process-ham-in-spam-groups
変数 @code{spam-process-ham-in-spam-groups} はディフォルトで
は @code{nil} です。Spam グループで見つかった ham がプロセッサーに送られ
るようにしたい場合は @code{t} にしてください。通常これは行なわれません。
その代わり、あなたが自分で ham 記事を ham グループに送って、そこで処理す
ることが想定されています。

@vindex spam-process-ham-in-nonham-groups
変数 @code{spam-process-ham-in-nonham-groups} はディフォルトで
は @code{nil} です。Ham ではない (spam または未分類の) グループで見つかっ
た ham がプロセッサーに送られるようにしたい場合は @code{t} にしてくださ
い。通常これは行なわれません。その代わり、あなたが自分で ham 記事
を ham グループに送って、そこで処理することが想定されています。

@vindex gnus-spam-process-destinations
@emph{Ham} または @emph{未分類} グループを抜けるときに、すべて
の @strong{spam} 記事は、@code{spam-process-destination} グループパラメー
ターが示す場所か @code{gnus-spam-process-destinations} 変数の中で合致す
る場所のどちらかに移されます。後者はグループ名に合致する正規表現のリスト
です (@kbd{M-x customize-variable @key{RET}
gnus-spam-process-destinations} によってこの変数をカスタマイズするのが最
も簡単です)。変数を手でカスタマイズする方が好きな人のために言っておくと、
それぞれのグループ名のリストは普通の Lisp の list です。
@code{spam-process-destination} パラメーターが設定されていないと、
spam 記事は単に期限切れ消去されます。グループ名は完全形であること、すな
わちグループバッファーでグループ名の前に @samp{nntp:servername} のような
ものが見える場合は、ここでもそれを使う必要があります。

例えば @acronym{NNTP} のような読み込み専用バックエンドであるため
に spam が移動できない場合、それはコピーされます。

グループごとに、または正規表現に合致するグループごとに、複数の移動先を指
定できることに注目してください!  これによって spam 記事を正規のメールグ
ループと @emph{spam トレーニング} グループに送ることができます。

@vindex spam-log-to-registry
Ham と spam に関する問題は、Gnus がディフォルトではこの処理を追跡してく
れないことです。複数回にわたって処理することを回避するために、
@code{spam.el} が @code{gnus-registry.el} を使って処理された記事を追跡す
るように、@code{spam-log-to-registry} 変数を有効にしてください。
@code{gnus-registry.el} が登録する数を制限してしまうと、制限が無い場合の
ように動作しないことを覚えておいてください。

@vindex spam-mark-only-unseen-as-spam
Spam グループにある、まだ読まれたことが無い記事だけに spam の印を付けた
い場合は、この変数をセットしてください。ディフォルトではセットされていま
す。これを @code{nil} にすると、未読の記事にも spam 印が付けられます。

@vindex spam-mark-ham-unread-before-move-from-spam-group
Ham が spam グループから移動される前に印を消したい場合は、この変数をセッ
トしてください。これは ham に印を付けるために可
視 (tick) 印 (@samp{!}) のようなものを使う場合に、とても役に立ちます。記
事はあたかもそれがメールサーバーから来たばかりのように、無印
で @code{ham-process-destination} に置かれるでしょう。

@vindex spam-autodetect-recheck-messages
この変数は @code{spam.el} が spam の自動検出を行なう場合に、まだ読まれた
ことが無い記事だけか、またはすべての未読記事のどちらに対して spam 検査を
行なうかを指示します。これはそのままにしておくことを勧めます。

@node Spam Package Configuration Examples
@subsection Spam パッケージの設定例
@cindex spam filtering
@cindex spam filtering configuration examples
@cindex spam configuration examples
@cindex spam

@subsubheading Ted の設定

From Ted Zlatanov <tzz@@lifelogs.com>.

@example
;; @r{@code{gnus-registry-split-fancy-with-parent} と spam の自動検出のため。}
;; @r{詳細は @file{gnus-registry.el} を参照。}
(gnus-registry-initialize)
(spam-initialize)

(setq
 spam-log-to-registry t ;; @r{Spam の自動検出のため。}
 spam-use-BBDB t
 spam-use-regex-headers t ;; @r{X-Spam-Flag (SpamAssassin) を捕まえる。}
 ;; @r{名前に @samp{spam} を含むすべてのグループには spam 記事がある。}
 gnus-spam-newsgroup-contents '(("spam"
                                 gnus-group-spam-classification-spam))
 ;; @r{これらの docstring を参照。}
 spam-move-spam-nonspam-groups-only nil
 spam-mark-only-unseen-as-spam t
 spam-mark-ham-unread-before-move-from-spam-group t
 ;; @r{あなたの設定に追加する前に、これが何をするか理解せよ!}
 ;; @r{nnimap 用にたぶん nnimap-split-methods を設定する必要あり。}
 ;; @r{マニュアル参照。}
 nnimap-split-fancy '(|
                      ;; @r{References を親まで辿ってそれらのグループ}
                      ;; @r{を入れる。}
                      (: gnus-registry-split-fancy-with-parent)
                      ;; @r{これはサーバー側の SpamAssassin タグを捕ま}
                      ;; @r{える。}
                      (: spam-split 'spam-use-regex-headers)
                      (any "ding" "ding")
                      ;; @r{Spam 記事はディフォルトで @samp{spam} に行く}
                      ;; @r{ことに注意。}
                      (: spam-split)
                      ;; @r{ディフォルトのメールボックス。}
                      "mail"))

;; @r{@kbd{G p} で設定した私のパラメーター。}

;; @r{すべての nnml グループと、@samp{nnimap+mail.lifelogs.com:train} と}
;; @r{@samp{nnimap+mail.lifelogs.com:spam} を除いたすべての nnimap グループ}
;; @r{のためのパラメーター:}
;; @r{それは手動で検出したはずなので、どの spam も nnimap のトレーニン}
;; @r{ググループに送り込む。}

((spam-process-destination . "nnimap+mail.lifelogs.com:train"))

;; @r{すべての @acronym{NNTP} グループのためのパラメーター:}
;; @r{Spam を blacklist で、ham を BBDB で自動検出。}
((spam-autodetect-methods spam-use-blacklist spam-use-BBDB)
;; @r{すべての spam をトレーニンググループに送る。}
 (spam-process-destination . "nnimap+mail.lifelogs.com:train"))

;; @r{私が spam を自動検出させたい、ほんのいくつかの @acronym{NNTP} グループ}
;; @r{のためのパラメーター:}
((spam-autodetect . t))

;; @r{私の nnimap @samp{nnimap+mail.lifelogs.com:spam} グループ (これは}
;; @r{spam グループ) のためのパラメーター:}

((spam-contents gnus-group-spam-classification-spam)

 ;; @r{どんな spam も私が ham 印を付けなければ}
 ;; @r{@samp{nnimap+mail.lifelogs.com:train} に送り込まれる。(前述の}
 ;; @r{@code{gnus-spam-newsgroup-contents} の設定により、すべての}
 ;; @r{まだ読まれたことが無いメッセージを読むとそうなる。)}

 (spam-process-destination "nnimap+mail.lifelogs.com:train")

 ;; @r{どんな ham も私の @samp{nnimap+mail.lifelogs.com:mail} フォルダー}
 ;; @r{に送り込まれるが、私の @samp{nnimap+mail.lifelogs.com:trainham}}
 ;; @r{フォルダーにもトレーニングのために送り込む。}

 (ham-process-destination "nnimap+mail.lifelogs.com:mail"
                          "nnimap+mail.lifelogs.com:trainham")
 ;; @r{このグループでは @samp{!} 印が付いているものだけが ham。}
 (ham-marks
  (gnus-ticked-mark))
 ;; @r{グループを抜けるときに blacklist に送信者を覚えさせる---これは}
 ;; @r{明らかに不要で、単に私の鬱憤を晴らすためにある。}
 (spam-process (gnus-group-spam-exit-processor-blacklist)))

;; @r{その後 @acronym{IMAP} サーバー上で、私は SpamAssassin が spam を}
;; @r{認識するトレーニングのために @samp{train} グループを、ham を}
;; @r{認識するトレーニングのために @samp{trainham} グループを使う。}
;; @r{でも Gnus はそういうことはやってくれない。}
@end example

@subsubheading サーバー上の IMAP サーバーで、統計的な濾過器と @code{spam.el} を使う

From Reiner Steib <reiner.steib@@gmx.de>.

私のプロバイダーは (@acronym{IMAP}) メールサーバー上で (@acronym{DCC} と
連係した) bogofilter を立ち上げました。認識され
た spam は @samp{spam.detected} へ行き、残りには通常の濾過規則が適用され
る、すなわち @samp{some.folder} か @samp{INBOX} に行きます。誤検出と見逃
しのトレーニングは、それぞれ @samp{training.ham} また
は @samp{training.spam} に記事をコピーするか移動させることによって行なわ
れます。サーバー上の cron ジョブが、それらを適切な ham または spam オプ
ションとともに bogofilter に与え、@samp{training.ham} およ
び @samp{training.spam} フォルダーからそれらを削除します。

以下の @code{gnus-parameters} の要素群によって、@code{spam.el} はほとん
どの仕事を私のためにこなします:

@lisp
   ("nnimap:spam\\.detected"
    (gnus-article-sort-functions '(gnus-article-sort-by-chars))
    (ham-process-destination "nnimap:INBOX" "nnimap:training.ham")
    (spam-contents gnus-group-spam-classification-spam))
   ("nnimap:\\(INBOX\\|other-folders\\)"
    (spam-process-destination . "nnimap:training.spam")
    (spam-contents gnus-group-spam-classification-ham))
@end lisp

@itemize
@item @b{The Spam folder:}
@samp{spam.detected} フォルダーにおいて、私は誤検出 (すなわ
ち bogofilter か DCC が spam であると誤って判定した正当なメール) のチェッ
クをしなければなりません。

@code{gnus-group-spam-classification-spam} の項のために、すべてのメッセー
ジには spam の印 (@code{$}) が付けられます。誤検出を見つけたら、私は記事
にいくつかの他の ham 印 (@code{ham-marks}, @ref{Spam and Ham
Processors}) を付けます。グループを出るとき、それらの記事
は @samp{INBOX} (私が記事を置いておきたいとこ
ろ) と @samp{training.ham} (bogofilter のトレーニング用) の両方のグルー
プにコピーされ、@samp{spam.detected} フォルダーから削除されます。

@code{gnus-article-sort-by-chars} の項は、私の誤検出の発見を簡単にします。
私は、すべて似たサイズの、たくさんのワーム (sweN, @dots{}) を受け取りま
す。それらをサイズ (つまり文字数) でまとめると、他の誤検出を見つけやすく
なるのです。(もちろん厳密にはワームは @i{spam} (@acronym{UCE},
@acronym{UBE}) ではありません。ともあれ、それらの要らないメールを濾過す
るのに bogofilter は私にとって優秀な道具です。)

@item @b{Ham folders:}
私の ham フォルダーで、認識されなかった spam メール (見逃し) を見つけた
ときはいつでも、私は単に @kbd{S x} (@code{gnus-summary-mark-as-spam}) を
叩きます。グループを出るとき、それらのメッセージ
は @samp{training.spam} に移されます。
@end itemize

@subsubheading @code{spam-report.el} で Gmane グループの spam を報告する

From Reiner Steib <reiner.steib@@gmx.de>.

以下の @code{gnus-parameters} に納めた要素によって、@kbd{S x}
(@code{gnus-summary-mark-as-spam}) で @code{gmane.*} グループの spam 記
事に印を付け、グループを出るときに Gmane に報告します:

@lisp
   ("^gmane\\."
    (spam-process (gnus-group-spam-exit-processor-report-gmane)))
@end lisp

加えて、私は news.gmane.org からではなくローカルニュースサー
バー (leafnode) を通して記事を読んでいるので、
@code{(setq spam-report-gmane-use-article-number nil)} を使っています。
つまり、記事番号が news.gmane.org におけるものと異なるので、正しい記事番
号を見つけるために @code{spam-report.el} に @code{X-Report-Spam} ヘッダー
を検査させなければなりません。

@node Spam Back Ends
@subsection Spam バックエンド
@cindex spam back ends

Spam パッケージは spam を検出するための様々なバックエンドを提供します。
それぞれのバックエンドでは、spam を検出する手段の組 (@pxref{Filtering
Incoming Mail}, @pxref{Detecting Spam in Groups}) と spam および ham プ
ロセッサーの対が定義されています (@pxref{Spam and Ham Processors})。

@menu
* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* SpamAssassin back end::
* ifile spam filtering::
* Spam Statistics Filtering::
* SpamOracle::
@end menu

@node Blacklists and Whitelists
@subsubsection ブラックリストとホワイトリスト
@cindex spam filtering
@cindex whitelists, spam filtering
@cindex blacklists, spam filtering
@cindex spam

@defvar spam-use-blacklist
入ってくるメールを分割するときにブラックリストを使いたい場合は、この変数
を @code{t} に設定してください。送信者がブラックリストに載っているメッセー
ジは @code{spam-split-group} に送られます。これは、送信者が spammer であ
ることが定義されているメールに対してだけ動作する、明示的な濾過器です。
@end defvar

@defvar spam-use-whitelist
入ってくるメールを分割するときにホワイトリストを使いたい場合は、この変数
を @code{t} に設定してください。送信者がホワイトリストに載っていないメッ
セージは、次の spam-split 規則 (による検査工程) に送られます。これは、ホ
ワイトリストに載っていない誰かのメッセージは spam とも ham とも見なされ
ないことを意味する、明示的な濾過器です。
@end defvar

@defvar spam-use-whitelist-exclusive
送信者がホワイトリストに載っていないすべてのメッセージが spam だと見なさ
れることを意味する暗黙の濾過器としてホワイトリストを使いたい場合は、この
変数を @code{t} にしてください。注意して使ってください。
@end defvar

@defvar gnus-group-spam-exit-processor-blacklist
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、spam 印が
付いた記事の送信者がブラックリストに追加されます。

@emph{警告}

旧式の @code{gnus-group-spam-exit-processor-blacklist} の代わり
に @code{(spam spam-use-blacklist)} を使うことを推奨します。すべて同等に
動作することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-whitelist
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、ham 印が
付いた @emph{ham} グループの記事の送信者がホワイトリストに追加されます。

@emph{警告}

旧式の @code{gnus-group-ham-exit-processor-whitelist} の代わり
に @code{(ham spam-use-whitelist)} を使うことを推奨します。すべて同等に
動作することは保証されます。
@end defvar

ブラックリストは、あなたが spam の送信者だと考えるアドレスに合致する正規
表現のリストです。例えば @samp{vmadmin.com} の誰からでも来るメールを阻止
するには、あなたのブラックリストに @samp{vmadmin.com} を入れてください。
空のブラックリストで始めましょう。ブラックリストの各項目は Emacs の正規
表現の構文を使います。

逆に、ホワイトリストは何のアドレスが正当だと考えられるかを告げます。ホワ
イトリストにあるアドレスからやって来たすべてのメッセージは、非-spam だと
見なされます。@ref{BBDB Whitelists} も見てください。ホワイトリストの各項
目は Emacs の正規表現の構文を使います。

ブラックリストとホワイトリストのファイルの所在は、
@code{spam-directory} 変数 (ディフォルトは @file{~/News/spam}) また
は直接 @code{spam-whitelist} と @code{spam-blacklist} 変数でカスタマイズ
することができます。ホワイトリストとブラックリストのファイルは、ディフォ
ルトでは @code{spam-directory} のディレクトリーにあり、それぞ
れ @file{whitelist} と @file{blacklist} という名前が付けられます。

@node BBDB Whitelists
@subsubsection BBDB ホワイトリスト
@cindex spam filtering
@cindex BBDB whitelists, spam filtering
@cindex BBDB, spam filtering
@cindex spam

@defvar spam-use-BBDB
@code{spam-use-whitelist} (@pxref{Blacklists and Whitelists}) に似ていま
すが、ホワイトリストのアドレスの源として BBDB を使います。正規表現はあり
ません。@code{spam-use-BBDB} をちゃんと動作させるには BBDB を読み込まな
ければ (load しなければ) なりません。その送信者が BBDB に載っていないメッ
セージは、次の spam-split 規則 (による検査工程) に送られます。これは、
BBDB に載っていない誰かのメッセージは spam とも ham とも見なされないこと
を意味する、明示的な濾過器です。
@end defvar

@defvar spam-use-BBDB-exclusive
送信者が BBDB に載っていないすべてのメッセージが spam だと見なされること
を意味する暗黙の濾過器として BBDB を使いたい場合は、この変数
を @code{t} にしてください。注意して使ってください。BBDB に載っている送
信者だけが通行を許され、他のすべては spammers として分類されます。

@code{spam.el} に関する限りは、@code{spam-use-BBDB} の別名とし
て @code{spam-use-BBDB-exclusive} を使うことができますが、それは別のバッ
クエンドではありません。@code{spam-use-BBDB-exclusive} を @code{t} に設
定すれば、BBDB による分割はすべて排他的になります。
@end defvar

@defvar gnus-group-ham-exit-processor-BBDB
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、ham 印が
付いた @emph{ham} グループの記事の送信者が BBDB に追加されます。

@emph{警告}

旧式の @code{gnus-group-ham-exit-processor-BBDB} の代わりに、
@code{(ham spam-use-BBDB)} を使うことを推奨します。すべて同等に動作する
ことは保証されます。
@end defvar

@node Gmane Spam Reporting
@subsubsection Gmane Spam 報告
@cindex spam reporting
@cindex Gmane, spam reporting
@cindex Gmane, spam reporting
@cindex spam

@defvar gnus-group-spam-exit-processor-report-gmane
グループパラメーターか変数 @code{gnus-spam-process-newsgroups} をカスタ
マイズして、このシンボルをグループの @code{spam-process} パラメーターに
加えてください。これが加えられると、spam 印が付いた記事のグループ
が HTTP 経由で Gmane の管理者に報告されます。

Gmane は @uref{http://gmane.org} で見つけることができます。

@emph{警告}

旧式の @code{gnus-group-spam-exit-processor-report-gmane} の代わり
に @code{(spam spam-use-gmane)} を使うことを推奨します。すべて同等に動作
することは保証されます。
@end defvar

@defvar spam-report-gmane-use-article-number
この変数はディフォルトで @code{t} です。例えばあなた自身がニュースサーバー
を運営しているなどの理由によって、ローカルな記事番号が Gmane の記事番号
と合わない場合は、@code{nil} に設定してください。
@code{spam-report-gmane-use-article-number} が @code{nil} であると、
@code{spam-report.el} はその番号を記事のヘッダーから取得します。
@end defvar

@defvar spam-report-user-mail-address
Gmane への spam の報告に付加される User-Agent に現れるメールアドレスです。
これは、誤った報告が行なわれたときに、Gmane の管理者があなたに連絡できる
ようにするためのものです。ディフォルトは @code{user-mail-address} です。
@end defvar

@node Anti-spam Hashcash Payments
@subsubsection 非-spam Hashcash 印
@cindex spam filtering
@cindex hashcash, spam filtering
@cindex spam

@defvar spam-use-hashcash
@code{spam-use-whitelist} (@pxref{Blacklists and Whitelists}) に似ていま
すが、送信者のアドレスの代わりに、潔白なメッセージの証しとし
て hashcash の印 (tokens) を使います。Hashcash 印が無いメッセージは次
の spam-分割 (spam-split) 規則 (による検査工程) に送られます。これ
は hashcash 印が見当たらないメッセージは spam とも ham とも見なされない
ことを意味する、明示的な濾過器です。
@end defvar

@node Blackholes
@subsubsection ブラックホール
@cindex spam filtering
@cindex blackholes, spam filtering
@cindex spam

@defvar spam-use-blackholes
このオプションはディフォルトで無効になっています。このオプションをセット
すると、Gnus にブラックホール型の分散 spam 処理システム (例えば DCC) を
調べさせることができます。変数 @code{spam-blackhole-servers} は、Gnus が
意見を求めるブラックホール・サーバーのリストを持ちます。現在のリストはか
なり広範囲に渡っていますが、もし時代遅れなサーバーを含んでいたら必ず私た
ちに知らせるようにしてください。

ブラックホール・チェックは @file{dig.el} パッケージを使います。しか
し @code{spam-use-dig} を @code{nil} に設定すれば、より良い性能のため
に @file{dns.el} を代わりに使うことを @code{spam.el} に指示することがで
きます。現状では @code{spam-use-dig} を @code{nil} に設定することは、い
く人かの利用者が使えないかもしれないので、それが可能な性能改善であるにも
かかわらず推奨されません。しかし、それが動くかどうかを確かめることはでき
ます。
@end defvar

@defvar spam-blackhole-servers
ブラックホール・チェックのために意見を求めるサーバーのリストです。
@end defvar

@defvar spam-blackhole-good-server-regex
ブラックホール・サーバーのリストと照合されてはならない IP の正規表現です。
@code{nil} に設定されると無効になります。
@end defvar

@defvar spam-use-dig
@file{dns.el} パッケージの代わりに @file{dig.el} パッケージを使います。
ディフォルトの設定である @code{t} が推奨されます。
@end defvar

ブラックホール・チェックは入って来るメールに対してだけ行なわれます。ブラッ
クホールに spam または ham プロセッサーはありません。

@node Regular Expressions Header Matching
@subsubsection 正規表現によるヘッダーの合致検査
@cindex spam filtering
@cindex regular expressions header matching, spam filtering
@cindex spam

@defvar spam-use-regex-headers
このオプションはディフォルトで無効になっています。このオプションをセット
すると、Gnus に正規表現のリストとメッセージヘッダーを照合させることがで
きます。変数 @code{spam-regex-headers-spam} およ
び @code{spam-regex-headers-ham} が正規表現のリストを持ちます。メッセー
ジが spam か ham かどうかをそれぞれの変数を使って決めるために、Gnus はメッ
セージヘッダーを検査します。
@end defvar

@defvar spam-regex-headers-spam
メッセージヘッダーの中で一致した時に、それが spam であることを断定するた
めの正規表現のリストです。
@end defvar

@defvar spam-regex-headers-ham
メッセージヘッダーの中で一致した時に、それが ham であることを断定するた
めの正規表現のリストです。
@end defvar

正規表現によるヘッダーの検査は、入ってきたメールに対してだけ行なわれます。
正規表現のために特有な spam または ham プロセッサーはありません。

@node Bogofilter
@subsubsection Bogofilter
@cindex spam filtering
@cindex bogofilter, spam filtering
@cindex spam

@defvar spam-use-bogofilter
Eric Raymond の迅速な Bogofilter を @code{spam-split} に使用したい場合は、
この変数をセットしてください。

Spam 記事に @samp{$} 印を関連付ける最小限度の世話だけで、Bogofilter トレー
ニングはすべてかなり自動的になります。Spam とそうでないものそれぞれの種
類について数百通ずつの記事を入手するまで、これをやらなければなりません。
デバッグまたは好奇心のどちらかのために概略モードで @kbd{S t} コマンドを
使うことによって、現在の記事の @emph{spam 度} (spamicity) スコ
ア (0.0〜1.0) を表示させることができます。

Bogofilter はメッセージが spam かどうかを、ある明確な閾値に基づいて見極
めます。閾値はカスタマイズできます。Bogofilter のドキュメントを調べてく
ださい。

Path に @code{bogofilter} の実行ファイルが無い場合、Bogofilter の処理は
取り消されます。

@code{spam-use-bogofilter-headers} を使う場合は、これを有効にしてはいけ
ません。
@end defvar

@table @kbd
@item M s t
@itemx S t
@kindex M s t
@kindex S t
@findex spam-bogofilter-score
Bogofilter の spam 度スコアを得ます (@code{spam-bogofilter-score})。
@end table

@defvar spam-use-bogofilter-headers
メッセージヘッダーだけを調べるために Eric Raymond の迅速
な Bogofilter を @code{spam-split} に使用したい場合は、この変数をセット
してください。これは @code{spam-use-bogofilter} と同じように動作しますが、
あらかじめ @code{X-Bogosity} ヘッダーがメッセージに存在しなければなりま
せん。通常これは procmail の技法か、何かそれに似たもので行なうことになる
でしょう。Bogofilter のインストールに関する文書を調べてください。

@code{spam-use-bogofilter} を使う場合は、これを有効にしてはいけません。
@end defvar

@defvar gnus-group-spam-exit-processor-bogofilter
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、spam 印が
付いた記事が bogofilter の spam データベースに加えらます。

@emph{警告}

旧式の @code{gnus-group-spam-exit-processor-bogofilter} の代わり
に @code{(spam spam-use-bogofilter)} を使うことを推奨します。すべて同等
に動作することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-bogofilter
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、ham 印が
付いた @emph{ham} グループの記事が非-spam 記事用の Bogofilter データベー
スに追加されます。

@emph{警告}

旧式の @code{gnus-group-ham-exit-processor-bogofilter} の代わり
に @code{(ham spam-use-bogofilter)} を使うことを推奨します。すべて同等に
動作することは保証されます。
@end defvar

@defvar spam-bogofilter-database-directory
これは Bogofilter がそのデータベースを格納するディレクトリーです。ディフォ
ルトでは設定されていないので、Bogofilter はそれ自身のディフォルトのデー
タベース・ディレクトリーを使います。
@end defvar

Bogofilter のメール分類器は、意図と目的の点で @command{ifile} に似ていま
す。Ham および spam のプロセッサーが提供され、記事で Bogofilter が使われ
るべきか、または既に使われたかを spam-split に示すため
の @code{spam-use-bogofilter} 変数
と @code{spam-use-bogofilter-headers} があります。この機能を検査するため
に Bogofilter のバージョン 0.9.2.1 が使われました。

@node SpamAssassin back end
@subsubsection SpamAssassin back end
@cindex spam filtering
@cindex spamassassin, spam filtering
@cindex spam

@defvar spam-use-spamassassin
@code{spam-split} に SpamAssassin を使いたい場合は、この変数をセットして
ください。

SpamAssassin は、規則と分析のセット (ベイジアンフィルタを含む) に基づい
て、それぞれの記事のスコアを裁定します。ベイジアンフィルタは、spam 記事
に @samp{$} 印を関連させることによって訓練することができます。Spam のス
コアは、概略モードで @kbd{S t} コマンドを使うことによって見ることができ
ます。

この変数をセットすると、それぞれの記事は @code{spam-split} が呼ばれると
きに SpamAssassin によって処理されます。メールが SpamAssassin で処理され
るようになっていて、SpamAssassin ヘッダーだけを使いたいのならば、代わり
に @code{spam-use-spamassassin-headers} をセットしてください。

@code{spam-use-spamassassin-headers} を使う場合、これを有効にしてはいけ
ません。
@end defvar

@defvar spam-use-spamassassin-headers
メールが SpamAssassin で処理されるようになっている場合に、
SpamAssassin ヘッダーに基づいて @code{spam-split} に分割を行なわせたいの
ならば、この変数をセットしてください。

@code{spam-use-spamassassin} を使う場合、これを有効にしてはいけません。
@end defvar

@defvar spam-spamassassin-program
この変数は SpamAssassin の実行形式を指します。@code{spamd} を稼働してい
るならば、より速い処理のために、この変数に @code{spamc} の実行形式を設定
することができます。@code{spamd}/@code{spamc} の更なる情報は、
SpamAssassin のドキュメントを見てください。
@end defvar

SpamAssassin は、spam を同定するために広範な分析を行なう、強力で融通性の
ある spam 濾過器です。Ham および spam のプロセッサーが提供され、記事
で SpamAssassin が使われるべきか、または既に使われたかを spam-split に示
すための @code{spam-use-spamassassin} 変数
と @code{spam-use-spamassassin-headers} 変数があります。この機能を検査す
るために SpamAssassin のバージョン 2.63 が使われました。

@node ifile spam filtering
@subsubsection ifile による spam の濾過
@cindex spam filtering
@cindex ifile, spam filtering
@cindex spam

@defvar spam-use-ifile
Bogofilter に似た統計分析器であ
る @command{ifile} を @code{spam-split} に使いたい場合は、この変数を有効
にしてください。
@end defvar

@defvar spam-ifile-all-categories
@code{spam-use-ifile} に、単なる spam/非-spam ではなくて ifile のすべて
の区分 (カテゴリー) を与えてもらいたいならば、この変数を有効にしてくださ
い。これを使う場合は、その文献に書かれているように ifile をトレーニング
しておかなければなりません。
@end defvar

@defvar spam-ifile-spam-category
ifile に関する限り、これは spam メッセージのカテゴリーです。実際に使われ
る文字列は無関係ですが、たぶんあなたは @samp{spam} のディフォルト値を残
しておきたいでしょう。
@end defvar

@defvar spam-ifile-database
これは ifile データベースのファイル名です。ディフォルトでは定義されてい
ないので、ifile はそれ自身のディフォルトのデータベース名を使います。
@end defvar

ifile のメール分類器は、意図と目的の点で Bogofilter に似ています。
Spam と ham のプロセッサーが提供され、ifile が使われるべきであること
を spam-split に示すための @code{spam-use-ifile} 変数があります。この機
能を検査するために ifile のバージョン 1.2.1 が使われました。

@node Spam Statistics Filtering
@subsubsection Spam 統計濾過
@cindex spam filtering
@cindex spam-stat, spam filtering
@cindex spam-stat
@cindex spam

このバックエンドは、統計に基づいた濾過を行なう Spam 統計 Emacs Lisp パッ
ケージを使います (@pxref{Spam Statistics Package})。これを使う前に、あな
たの Spam 統計辞書を初期化するための、いくつかの追加の処理を行なう必要が
あるでしょう。@xref{Creating a spam-stat dictionary}.

@defvar spam-use-stat
@end defvar

@defvar gnus-group-spam-exit-processor-stat
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、spam 印が
付いた記事が spam 記事用の spam-stat データベースに追加されます。

@emph{警告}

旧式の @code{gnus-group-spam-exit-processor-stat} の代わり
に @code{(spam spam-use-stat)} を使うことを推奨します。すべて同等に動作
することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-stat
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、ham 印が
付いた @emph{ham} グループの記事が非-spam 記事用の spam-stat データベー
スに追加されます。

@emph{警告}

旧式の @code{gnus-group-ham-exit-processor-stat} の代わり
に @code{(ham spam-use-stat)} を使うことを推奨します。すべて同等に動作す
ることは保証されます。
@end defvar

これは @code{spam.el} が @file{spam-stat.el} と働き合うことを可能にしま
す。@file{spam-stat.el} は (Lisp だけの) spam 内部データベースを提供しま
すが、それは ifile や Bogofilter と違って外部プログラムを必要としません。
Spam と ham のプロセッサー、および @code{spam-split} のため
の @code{spam-use-stat} 変数が提供されます。

@node SpamOracle
@subsubsection Gnus で SpamOracle を使うには
@cindex spam filtering
@cindex SpamOracle
@cindex spam

気軽に spam を濾過する一つのやり方は SpamOracle を使うことです。統計的に
メールを濾過するための道具である SpamOracle は、Xavier Leroy によって書
かれました。これは別にインストールする必要があります。

Gnus で SpamOracle を使うには、複数のやり方があります。すべての場合に、
メールは @emph{mark} モードで動作している SpamOracle にパイプされます。
すると SpamOracle は、そのメールを spam だと見なしたかどうかを示
す @samp{X-Spam} ヘッダーを記入します。

実現可能な一つは、SpamOracle を @code{:prescript} として @ref{Mail
Source Specifiers} から走らせることです。この方法には、利用者
が @emph{X-Spam} ヘッダーを見ることができるという利点があります。

もっとも手軽な方法は、@file{spam.el}
(@pxref{Spam Package}) が SpamOracle を呼ぶようにすることです。

@code{spam.el} で SpamOracle を利用できるようにするためには、変
数 @code{spam-use-spamoracle} を @code{t} にして、
@code{nnmail-split-fancy} または @code{nnimap-split-fancy} を設定してく
ださい。@xref{Spam Package}.  この例では nnimap サーバー
の @samp{INBOX} が SpamOracle を使って濾過されます。Spam であると認定さ
れたメールは、@code{spam-split-group} (この場合は @samp{Junk}) に移動さ
せられます。Ham なメッセージは @samp{INBOX} に残ります:

@example
(setq spam-use-spamoracle t
      spam-split-group "Junk"
      ;; @r{nnimap 用にたぶん nnimap-split-methods を設定する必要あり。}
      ;; @r{マニュアル参照。}
      nnimap-split-inbox '("INBOX")
      nnimap-split-fancy '(| (: spam-split) "INBOX"))
@end example

@defvar spam-use-spamoracle
Gnus に SpamOracle を使って spam の濾過をさせたい場合に @code{t} にして
ください。
@end defvar

@defvar spam-spamoracle-binary
Gnus は利用者の PATH で見つかった @file{spamoracle} という SpamOracle の
バイナリーを使います。これにはカスタマイズ可能な変
数 @code{spam-spamoracle-binary} を使います。
@end defvar

@defvar spam-spamoracle-database
SpamOracle はその解析結果をデータベースとして格納するために、ディフォル
トで @file{~/.spamoracle.db} ファイルを使います。これは変
数 @code{spam-spamoracle-database} で制御され、ディフォルト
は @code{nil} です。それは、ディフォルトの SpamOracle データベースが使わ
れることを意味します。データベースがどこか特別な場所に置きたい場合は、
@code{spam-spamoracle-database} をそのパスに設定してください。
@end defvar

SpamOracle はメッセージが spam か ham かを見極めるために統計的な手法を使
います。間違いや見逃しの少ない良い結果を得るために、SpamOracle はトレー
ニングを必要とします。SpamOracle は spam メールの特徴を学びます。
@emph{add} モード (トレーニング・モード) を使って、良いメー
ル (ham) と spam を SpamOracle に与えなければなりません。これは、概略バッ
ファーで @kbd{|} を押すことによってメールを SpamOracle のプロセスにパイ
プするか、または @file{spam.el} の spam および ham プロセッサーを使うこ
とによって行なうことができます。@xref{Spam Package}.

@defvar gnus-group-spam-exit-processor-spamoracle
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、spam 印が
付いた記事が spam のサンプルとして SpamOracle に送られます。

@emph{警告}

旧式の @code{gnus-group-spam-exit-processor-spamoracle} の代わり
に @code{(spam spam-use-spamoracle)} を使うことを推奨します。すべて同等
に動作することは保証されます。
@end defvar

@defvar gnus-group-ham-exit-processor-spamoracle
このシンボルを、グループパラメーターのカスタマイズによってグループ
の @code{spam-process} パラメーターに加えるか、また
は @code{gnus-spam-process-newsgroups} 変数に加えてください。このシンボ
ルがグループの @code{spam-process} パラメーターに加えられると、
@emph{ham} グループにある ham 印が付いた記事が ham の記事のサンプルとし
て SpamOracle に送られます。

@emph{警告}

旧式の @code{gnus-group-ham-exit-processor-spamoracle} の代わり
に @code{(ham spam-use-spamoracle)} を使うことを推奨します。すべて同等に
動作することは保証されます。
@end defvar

@emph{例:} これらは ham グループとして分類された、つまり ham の記事しか
ないグループのためのグループパラメーターです。

@example
 ((spam-contents gnus-group-spam-classification-ham)
  (spam-process ((ham spam-use-spamoracle)
                 (spam spam-use-spamoracle))))
@end example

このグループでは @code{spam-use-spamoracle} が ham と spam の両方の処理
を行ないます。このグループに spam 記事があって (SpamOracle が十分なサン
プルを食べさせてもらっていなければ、そうなりますね)、かつ利用者がいくつ
かの記事に spam の印を付けたならば、それらの記事は SpamOracle によって処
理されます。そのプロセッサーは、新しい spam のサンプルとし
て SpamOracle に記事を送ります。

@node Extending the Spam package
@subsection Spam パッケージの拡張
@cindex spam filtering
@cindex spam elisp package, extending
@cindex extending the spam elisp package

Blackbox という新しいバックエンドを追加したいとしましょう。入ってくるメー
ルを濾過するために以下のものを用意してください:

@enumerate
@item
コード

@lisp
(defvar spam-use-blackbox nil
  "Blackbox を使うときは t にする。")
@end lisp

Blackbox が入ってくるメールを検査できるのであれば、
@code{spam-check-blackbox} を書いてください。

Blackbox が spam と ham を登録または登録解除できるのであれば、手始め
に bogofilter の登録/解除ルーチンを使って、またはもっと Blackbox にふさ
わしい他の登録/解除ルーチンを使っ
て @code{spam-blackbox-register-routine} およ
び @code{spam-blackbox-unregister-routine} を書いてください。

@item
関数

@code{spam-check-blackbox} 関数は、他の習慣に倣っ
て @samp{nil} か @code{spam-split-group} を返さなければなりません。あな
たに何ができるかの例として、既存の @code{spam-check-*} 関数を参照してく
ださい。また、あなたがそうでない理由を完全に理解していないならば、テンプ
レートに齧り付いてください。
@end enumerate

Spam と ham メッセージを処理するために、以下のものを用意してください:

@enumerate
@item
コード

Spam または ham のプロセッサーを用意する必要はありません。
Blackbox が spam または ham の処理をサポートする場合だけ、それらを用意し
てください。

さらに ham と spam のプロセッサーは単一の変数ではなくされつつあり、代わ
りに @code{(spam spam-use-blackbox)} また
は @code{(ham spam-use-blackbox)} の形式が推奨されます。今のとこ
ろ spam/ham プロセッサー変数はまだあちこちにありますが、長く存続すること
はないでしょう。

@lisp
(defvar gnus-group-spam-exit-processor-blackbox "blackbox-spam"
  "概略を出るときに呼ばれる blackbox の spam プロセッサー。
Spam グループだけに適用される。")

(defvar gnus-group-ham-exit-processor-blackbox "blackbox-ham"
  "概略を出るときに呼ばれる blackbox の ham プロセッサー。
Spam ではない (未分類または ham) グループだけに適用される。")
@end lisp

@item
Gnus のパラメーター

@code{gnus.el} にあるグループパラメーター @code{spam-process} に

@lisp
(const :tag "Spam: Blackbox" (spam spam-use-blackbox))
(const :tag "Ham: Blackbox"  (ham spam-use-blackbox))
@end lisp

を加えてください。それを必ずパラメーターと変数のカスタマイズの二回につい
て行なうようにしてください。

Blackbox が入ってくるメールが spam かどうかを検査できるのであれば、

@lisp
(variable-item spam-use-blackbox)
@end lisp

を @code{gnus.el} のグループパラメー
ター @code{spam-autodetect-methods} に加えてください。

最後に、@code{spam.el} にある適切な @code{spam-install-*-backend} 関数を
使ってください。利用できる関数は次の通りです。

@enumerate
@item
@code{spam-install-backend-alias}

この関数は、オリジナルのバックエンドのようにすべてを行なうバックエンドの
ために、別名を使うことができるようにするだけです。今のところ、これ
は @code{spam-use-BBDB-exclusive} を @code{spam-use-BBDB} のように働かせ
るためだけに使われます。

@item
@code{spam-install-nocheck-backend}

この関数は、検査する機能は無いけれども ham または spam を登録/解除するこ
とができるバックエンドになります。@code{spam-use-gmane} がそのようなバッ
クエンドです。

@item
@code{spam-install-checkonly-backend}

この関数は、入ってくるメールが spam かどうかの検査だけを行なうことができ
るバックエンドになります。それはメッセージを登録または登録解除することが
できません。@code{spam-use-blackholes} と @code{spam-use-hashcash} がそ
のようなバックエンドです。

@item
@code{spam-install-statistical-checkonly-backend}

この関数は、入ってくるメールの検査だけを行なうことができる、統計処理を行
なうバックエンド (検査のためにメッセージの本文全体を必要とします) になり
ます。@code{spam-use-regex-body} がそのような濾過器です。

@item
@code{spam-install-statistical-backend}

この関数は、入ってくるメールの検査と登録/解除ルーチンを持つ、統計処理を
行なうバックエンドになります。@code{spam-use-bogofilter} は、そのように
仕立てられています。

@item
@code{spam-install-backend}

これは最も普通なバックエンドになります。それは検査とメッセージの
登録/解除を行なうことができ、統計処理の能力はありません。
@code{spam-use-BBDB} がそのようなバックエンドです。

@item
@code{spam-install-mover-backend}

移動させる (mover) バックエンドは @code{spam.el} の内部で、概略バッファー
を出るときにある明確なやり方で記事を移動させます。おそらくそのようなバッ
クエンドを使うことは無いでしょう。
@end enumerate
@end enumerate

@node Spam Statistics Package
@subsection Spam 統計パッケージ
@cindex Paul Graham
@cindex Graham, Paul
@cindex naive Bayesian spam filtering
@cindex Bayesian spam filtering, naive
@cindex spam filtering, naive Bayesian

Paul Graham は統計を使った spam の濾過に関する優れたエッセイを書きまし
た: @uref{http://www.paulgraham.com/spam.html,A Plan for Spam}。そこで彼
は SpamAssassin によって使われているような規則ベースの濾過に固有な欠陥に
ついて述べています。例えば: 誰かが規則を書かなければならないし、他のすべ
ての人はこれらの規則をインストールしなければなりません。あなたはいつも遅
れをとってしまいます。それよりも、それが spam または非-spam に何となく似
ているかどうかに基づいてメールを濾過する方が遥かに良いだろうと彼は主張し
ています。これを測定する一つの手段は単語の分布です。その後で彼は、新着メー
ルがあなたの他の spam メールに似ているかどうかをチェックする方法を述べて
います。

基本的な考えはこうです: あなたのメールの二つの集合を作ります。一方
は spam を、もう一方は spam ではないメールを集めたものです。両方の集合に
おける各単語の出現頻度を数えて、集合のメールの総数で重み付けを行ない、こ
の情報を辞書に格納します。新着メールのすべての単語について、
spam か spam ではないメールに属する確率を判定します。15 の最も顕著な単語
を使って、そのメールが spam であることの確率の総計を計算します。この確率
がある閾値より高かったら、そのメールは spam であると見なされます。

Spam 統計パッケージは、この種の濾過のためのサポートを Gnus に追加します。
Spam パッケージ (@pxref{Spam Package}) のバックエンドの一つとして、また
はそれ自体を使うことができます。

Spam 統計パッケージを使う前に、それを使うための準備を行なう必要がありま
す。第一に、あなたのメールの二つの集合が要ります。一方は spam を、もう
一方は spam ではないメールを集めたものです。そして、それらの二つの集合を
使って辞書を作り、それをセーブしてください。そして特に最後に、あなたの特
級分割の規則でこの辞書を使ってください。

@menu
* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::
@end menu

@node Creating a spam-stat dictionary
@subsubsection spam-統計 (spam-stat) 辞書を作る

統計に基づいた spam 濾過を始めるには、前もって二つのメールの集合 (一方
は spam を、もう一方は spam ではないメールを集めたもの) に基づいた統計を
作らなければなりません。そしてそれらの統計は、後で利用するために辞書に格
納されます。それらの統計を意味のあるものにするために、両方の集合につき数
百通のメールが必要です。

今のところ Gnus は nnml バックエンドでだけ辞書の自動生成をサポートします。
nnml バックエンドは一通のメールにつき一つのファイルで、すべてのメールを
一つのディレクトリーに格納します。以下を使ってください:

@defun spam-stat-process-spam-directory
このディレクトリーにあるすべてのファイルについて spam の統計を生成します。
すべてのファイルは一つの spam メールとして扱われます。
@end defun

@defun spam-stat-process-non-spam-directory
このディレクトリーにあるすべてのファイルについて非-spam の統計を生成しま
す。すべてのファイルは一つの spam ではないメールとして扱われます。
@end defun

普通は @file{~/Mail/mail/spam} のようなディレクトリー (通
常 @samp{nnml:mail.spam} グループに対応) につい
て @code{spam-stat-process-spam-directory} を呼ぶことになるでしょう。ま
た @file{~/Mail/mail/misc} のようなディレクトリー (通
常 @samp{nnml:mail.misc} グループに対応) につい
て @code{spam-stat-process-non-spam-directory} を呼びましょう。

@acronym{IMAP} を使っている場合はメールをローカルには持っていないので、
それは働きません。一つの解決策は、Gnus エージェントで記事をキャッシュす
ることです。そうすれば @code{spam-stat-process-spam-directory} とし
て @file{"~/News/agent/nnimap/mail.yourisp.com/personal_spam"} のような
ものを使うことができます。@xref{Agent as Cache}.

@defvar spam-stat
この変数はすべての統計のハッシュテーブル---辞書と言っているもの---を保持
します。このハッシュテーブルは、双方の集合のすべての単語について spam お
よび spam ではないメールにおける出現頻度を表すベクトルを格納します。
@end defvar

統計を最初から作り直したいときは、辞書をリセットする必要があります。

@defun spam-stat-reset
すべての統計を削除して @code{spam-stat} ハッシュテーブルをリセットします。
@end defun

行なったら辞書をセーブしなければなりません。辞書はかなり大きくなるかもし
れません。辞書を追加更新しない場合 (言い換えると、例えば毎月一回作り直す
場合)、頻繁に現れないか、または spam か spam ではないメールのどちらに属
するかがはっきりしないすべての単語を削除することによって、辞書のサイズを
小さくすることができます。

@defun spam-stat-reduce-size
辞書のサイズを小さくします。これは辞書を追加更新したくない場合だけ使って
ください。
@end defun

@defun spam-stat-save
辞書をセーブします。
@end defun

@defvar spam-stat-file
辞書の格納に使うファイル名です。ディフォルトは @file{~/.spam-stat.el} で
す。
@end defvar

@node Splitting mail using spam-stat
@subsubsection spam-統計 (spam-stat) を使ってメールを分割する

この章は Spam 統計パッケージを Spam パッケージ (@pxref{Spam Package}) と
は @emph{独立して} 使う方法について説明します。

最初に以下を @file{~/.gnus.el} ファイルに追加してください:

@lisp
(require 'spam-stat)
(spam-stat-load)
@end lisp

これは必要な Gnus のコードとあなたが作った辞書を読み込みます。

次に、特級分割の規則を改造する必要があります: どうやっ
て @code{spam-stat} を使うかを決めてください。以下の例は nnml バックエン
ド用です。nnimap バックエンドでもまったく同様に動作します。単
に @code{nnmail-split-fancy} の代わりに @code{nnimap-split-fancy} を使っ
てください。

@samp{mail.misc} と @samp{mail.spam} の二つのグループだけがある、最も単
純な事例を想定しましょう。以下の式は、メールが spam でなかった
ら @samp{mail.misc} に行くことを示します。もし spam だった
ら、@code{spam-stat-split-fancy} は @samp{mail.spam} を返します。

@lisp
(setq nnmail-split-fancy
      `(| (: spam-stat-split-fancy)
          "mail.misc"))
@end lisp

@defvar spam-stat-split-fancy-spam-group
Spam 用のグループです。ディフォルトは @samp{mail.spam} です。
@end defvar

特定の表題を持つメールを他のグループに入れる濾過をも行ないたいならば、以
下の式を使ってください。正規表現に合致しないメールだけに spam の可能性が
あると考えます。

@lisp
(setq nnmail-split-fancy
      `(| ("Subject" "\\bspam-stat\\b" "mail.emacs")
          (: spam-stat-split-fancy)
          "mail.misc"))
@end lisp

最初に spam の濾過をしたい場合、辞書を作るときに十分に注意しなければなり
ません。
@code{spam-stat-split-fancy} は @samp{mail.emacs} と @samp{mail.misc} の
どちらのメールも spam ではないと解釈しなければならないので、辞書を作ると
きに spam ではない集合に両方とも入っていなければならないことに注意してく
ださい。

@lisp
(setq nnmail-split-fancy
      `(| (: spam-stat-split-fancy)
          ("Subject" "\\bspam-stat\\b" "mail.emacs")
          "mail.misc"))
@end lisp

これを伝統的な濾過と組み合わせることもできます。ここではすべての HTML だ
けのメールを @samp{mail.spam.filtered} グループに入れるものとしましょう。
@code{spam-stat-split-fancy} はそれらのメールを見ないので、辞書を作ると
きに、@samp{mail.spam.filtered} のメールが spam の集合または spam ではな
い集合のどちらにも入るべきではないことに注意してください!

@lisp
(setq nnmail-split-fancy
      `(| ("Content-Type" "text/html" "mail.spam.filtered")
          (: spam-stat-split-fancy)
          ("Subject" "\\bspam-stat\\b" "mail.emacs")
          "mail.misc"))
@end lisp

@node Low-level interface to the spam-stat dictionary
@subsubsection spam-統計 (spam-stat) 辞書への低階層インターフェース

@code{spam-stat} を使うための主なインターフェースは以下の関数群です:

@defun spam-stat-buffer-is-spam
Spam であると考えられる新着メールがあるバッファーで呼ばれます。まだ処理
されていない新着メールに対して使ってください。
@end defun

@defun spam-stat-buffer-is-no-spam
Spam ではないと考えられる新着メールがあるバッファーで呼ばれます。まだ処
理されていない新着メールに対して使ってください。
@end defun

@defun spam-stat-buffer-change-to-spam
それが spam ではなくて通常のものだとはもはや考えられないメールがあるバッ
ファーで呼ばれます。すでに spam ではないものとして処理されてしまったメー
ルの地位の変更に使ってください。
@end defun

@defun spam-stat-buffer-change-to-non-spam
それが通常のものではなくて spam だとはもはや考えられないメールがあるバッ
ファーで呼ばれます。すでに spam であるものとして処理されてしまったメール
の地位の変更に使ってください。
@end defun

@defun spam-stat-save
ハッシュテーブルをファイルにセーブします。変数 @code{spam-stat-file} で
設定されたファイル名が使われます。
@end defun

@defun spam-stat-load
ハッシュテーブルをファイルから読み込みます。変
数 @code{spam-stat-file} で設定されたファイル名が使われます。
@end defun

@defun spam-stat-score-word
単語の spam スコアを返します。
@end defun

@defun spam-stat-score-buffer
バッファーの spam スコアを返します。
@end defun

@defun spam-stat-split-fancy
特級メール分割のためにこの関数を使ってください。
@code{nnmail-split-fancy} に規則 @samp{(: spam-stat-split-fancy)} を追加
しましょう。
@end defun

それを使う前に、必ず辞書が読み込まれているようにしてください。これに
は @file{~/.gnus.el} ファイルに以下が必要です:

@lisp
(require 'spam-stat)
(spam-stat-load)
@end lisp

以下は一般的なテストのための関数呼び出しです:

@example
リセット: (setq spam-stat (make-hash-table :test 'equal))
Spam の学習: (spam-stat-process-spam-directory "~/Mail/mail/spam")
非-spam の学習: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
辞書をセーブ: (spam-stat-save)
辞書ファイルのサイズ: (file-attribute-size (file-attributes spam-stat-file))
単語数: (hash-table-count spam-stat)
Spam の検査: (spam-stat-test-directory "~/Mail/mail/spam")
非-spam の検査: (spam-stat-test-directory "~/Mail/mail/misc")
辞書のサイズを小さくする: (spam-stat-reduce-size)
辞書をセーブ: (spam-stat-save)
辞書ファイルのサイズ: (file-attribute-size (file-attributes spam-stat-file))
単語数: (hash-table-count spam-stat)
Spam の検査: (spam-stat-test-directory "~/Mail/mail/spam")
非-spam の検査: (spam-stat-test-directory "~/Mail/mail/misc")
@end example

以下は辞書を生成する方法です:

@example
リセット: (setq spam-stat (make-hash-table :test 'equal))
Spam の学習: (spam-stat-process-spam-directory "~/Mail/mail/spam")
非-spam の学習: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
別の必要な非-spam グループに対して繰り返し...
辞書のサイズを小さくする: (spam-stat-reduce-size)
辞書をセーブ: (spam-stat-save)
@end example

@node The Gnus Registry
@section Gnus レジストリー
@cindex registry
@cindex split
@cindex track

Gnus レジストリーは記事の Message-ID を元にすべてのバックエンドを横断的
に追跡するためのパッケージです。これが提供するいくつもある素敵な事をすれ
ば、Gnus ユーザーは近所の人たちから羨ましがられ、床屋がただで散髪してく
れるようになり、世界で起きる様々な問題の専門家になることができるでしょう。
かなり素晴らしい機能が満載です。うーむ、全部がそうではないかもしれません
けれどね。

じきに詳しく説明しますが、まずはそれらの機能の早見表を掲げておきましょう。
あなたの注意力が持続しないかもしれないので@dots{} いや、何でもないです。

@enumerate
@item
記事をそれらの親に分割する

議論を同じグループで続けられるようにする機能です。Message-ID に加えて表
題と送信者を使うことができます。これにはいくつかのやり方があります。

@item
ID に基づいてメッセージを照会する

@code{gnus-summary-refer-parent-article} のようなコマンドは、照会する記
事に行くするために、そのメッセージがあるグループにかかわらず、レジストリー
を利用することができます。

@item
独自のフラグとキーワードを記録する

レジストリーは記事のための独自のフラグとキーワードを記録することができま
す。これで例えば記事に ``To-Do'' の印を付けることができ、記事が nnimap、
nnml、nnmaildir などのどのバックエンドにあっても、そのフラグは立ち続けま
す。

@item
任意のデータを記録する

レジストリーは記事のためのどんなデータでも記憶しておくことができます。簡
単な Elisp インターフェースですが。組み込まれている逆引き機能を有効にし
ておくと、特定の条件に合うすべての記事をすばやく見つけることができます。
@end enumerate

@menu
* Gnus Registry Setup::
* Registry Article Refer Method:: @code{Message-ID} に基づいてレジストリーで記事を取得する
* Fancy splitting to parent::   親への特級分割
* Store custom flags and keywords:: 独自のフラグとキーワードの記録
* Store arbitrary data::        任意のデータの記録
@end menu

@node Gnus Registry Setup
@subsection Gnus レジストリーの設定

良くしたことに Gnus レジストリーの設定はとても簡単です:

@lisp
(setq gnus-registry-max-entries 2500)

(gnus-registry-initialize)
@end lisp

これは Gnus が newsrc をセーブするときの処理にレジストリーをセーブする処
理を加えます (それは Gnus を終了するときと @file{*Group*} バッファー
で @kbd{s} を押したときに発動します。さらにこれは Gnus の記事に関する動
作 (コピー、移動など) にレジストリーを操作する機能を加えるので、この初期
化による結果を元に戻すのは簡単ではありません。その、あまり愉快ではない詳
細については @code{gnus-registry-initialize} を見てください。

以下はレジストリーの持ち主が使うための他の設定です (それらを無頓着にコピー
する前に、それらが何をするかを理解してください)。

@lisp
(setq
 gnus-registry-split-strategy 'majority
 gnus-registry-ignored-groups '(("nntp" t)
                                ("nnrss" t)
                                ("spam" t)
                                ("train" t))
 gnus-registry-max-entries 500000
 ;; これがディフォルト
 gnus-registry-track-extra '(sender subject))
@end lisp

これらが意味するのは、あちこちにあるたくさんの記事を保持し、送信者と表題
で (単なる親の Message-ID でではなく) 記事を追跡し、入ってきた記事をレジ
ストリーが分割するときに記事の行き先として一つ以上の候補があったら多数決
で決める、ということです。加えて ``nntp''、``nnrss''、``spam'' また
は ``train'' に合致するグループの記事をレジストリーに無視させます。

あなたがこのすべてに感銘を受けることは疑いありませんが、こう要求しもする
でしょう。「私は Gnus ユーザーでカスタマイズすることが生きがいです。もっ
と下さい」。では諸設定の一般的な説明に参りましょう。

@defvar gnus-registry-unfollowed-groups
@code{gnus-registry-split-fancy-with-parent} が追跡しないグループです。
それらは、でもレジストリーに記録されます。これは正規表現のリストです。ディ
フォルトでは、名前が ``delayed''、``drafts''、``queue'' また
は ``INBOX'' で終わっている、@code{nnmairix} バックエンドに属している、
あるいは ``archive'' という語を含んでいるどんなグループも追跡しません。
@end defvar

@defvar gnus-registry-max-entries
レジストリーが保持する項目の数 (整数または無制限を意味す
る @code{nil}) です。レジストリーがこのサイズに達してしまう、または越え
てしまうと、新しいエントリーの追加を受け付けなくなります。
@end defvar

@defvar gnus-registry-prune-factor
除去に際してレジストリーをどのくらい減らすかを、このオプション (0 か
ら 1 までの浮動小数) で制御します。一定数のエントリーを削除する代わりに、
レジストリーの数が @code{gnus-registry-max-entries} より小さくなるように
除去を行ないます。このオプションは厳密にどのくらい小さくするかを制御し、
目標値は @w{エントリーの最大数 × (1 - この係数)} になります。ディフォル
トは 0.1 です。つまり、もしあなたのレジストリーが 50000 エントリーを上限
としているなら、除去の際に 45000 エントリーに削減しようとします。貴
重 (precious) であると記されたキーを持っているエントリーは除去されません。
@end defvar

@defvar gnus-registry-default-sort-function
このオプションは除去に際してレジストリーをどのようにソートするかを指示し
ます。関数を与える場合、それはリストの先頭から除去を始めて、最も価値の低
いエントリーを先頭に置くものでなければなりません。ディフォルト値は最も古
いエントリーから除去する @code{gnus-registry-sort-by-creation-time} です。
@code{nil} にするとソートを行なわず、除去の処理速度が上がります。
@end defvar

@defvar gnus-registry-cache-file
Gnus の操作を通じてレジストリーが記録されるファイルです。ディフォルトで
ファイル名は @file{.newsrc.eld} と同じディレクトリーに置かれ
る @file{.gnus.registry.eieio} です。
@end defvar

@node Registry Article Refer Method
@subsection @code{Message-ID} に基づいてレジストリーで記事を取得する

レジストリーは、それぞれの @code{Message-ID} の記事が存在するグループを
知っています。これは「記事を参照する方法」すなわち「ある Message-ID の記
事を参照する方法を Gnus に指示するもの」を増強するためにてこ入れすること
ができます。@xref{Finding the Parent}.

@vindex nnregistry
@vindex gnus-refer-article-method
@code{nnregistry} 参照方法はまさにそれをします。それには、記事がそれがあ
るグループにかかわらず見つかるかもしれないという特長があります---もしそ
の @code{Message-ID} をレジストリーが知っていれば。それは、以下の方針に
沿って、あるもので起動ファイルを増大することにより可能になるはずです:

@example
;; レジストリーを使って記事を参照する場合に良好なヒット率を得るため
;; には、十分なエントリーを維持するようにしてください。記事がどこに
;; あるかを Gnus に知らせるために、長いグループ名を使用してください。
(setq gnus-registry-max-entries 2500)

(gnus-registry-initialize)

(setq gnus-refer-article-method
      '(current
        (nnregistry)
        (nnweb "gmane" (nnweb-type gmane))))
@end example

上記の例は、最初は現在のグループの中で、あるいはレジストリーを使って、そ
してそれらすべてが失敗したら Gmane を使って記事を探すことを Gnus に指示
します。

@node Fancy splitting to parent
@subsection 親への特級分割

簡単に言うと、これでフォローアップの電子メールを、それがあるべき場所に置
くことができます。

すべての記事は固有の Message-ID を持っていて、レジストリーはそれを記憶し
ます。記事を移動またはコピーするとき、レジストリーはそのことに気付いて、
分割方法のひとつの選択肢として新しいグループを提案します。

フォローアップするとき、言及する対象となる元の記事の Message-ID は通常ヘッ
ダーにあります。レジストリーはそれを知り、その記載内容を使って元の記事が
どこにあるかを探します。あなたが特級分割の設定に置いておく必要があるのは、
このような規則だけです:

@lisp
(setq nnimap-my-split-fancy '(|

      ;; split to parent: you need this
      (: gnus-registry-split-fancy-with-parent)

      ;; other rules, as an example
      (: spam-split)
      ;; default mailbox
      "mail")
@end lisp

さらに、以下の変数をカスタマイズする必要があるでしょう。

@defvar gnus-registry-track-extra
これはシンボルのリストです。カスタマイズのインターフェースから変更するの
には、それがベストです。ディフォルト
は @code{(subject sender recipient)} で、それでおそらく動作するでしょう。
メールの流通量が大きくて人々が同じグループにとどまっていないと、煩わしく
なる場合があります。

それら枠外のデータの追跡をやめるときは、コマン
ド @code{gnus-registry-remove-extra-data} を使って、既存のレジストリーか
ら取り除いてください。
@end defvar

@defvar gnus-registry-split-strategy
これはシンボルです。カスタマイズのインターフェースから変更するのには、そ
れがベストです。ディフォルトは @code{nil} ですが、合致の多数決または最初
に見つかったものに基づいて送信者 (sender) または表題 (subject) で分割す
るには @code{majority} または @code{first} に設定する必要があるでしょう。
私は @code{majority} が最も良いことを見つけました。
@end defvar

@node Store custom flags and keywords
@subsection 独自のフラグとキーワードの記録

レジストリーを使って、独自のフラグとキーワードをメッセージごとに設定する
ことができます。Gnus->Registry Marks メニューか @kbd{M M x} ショートカッ
ト・キーを使ってください。ここで @code{x} は印の名前の最初の文字です。

@defvar gnus-registry-marks
レジストリーが扱うことができる独自の印のリストです。もしそうしたいなら、
ディフォルトのリストを変更することができます。それを行なうのならば、それ
らが効果を及ぼす前に Emacs を終了させる必要があります (レジストリーを抜
き取って (unload して) から再読み込み (reload) するか、または必要であろ
う特別なマクロを実行することもできますが、たぶんそんな面倒なことは望まな
いでしょう)。カスタマイズのインターフェースを使って、そのリストを変更し
てください。

ディフォルトでこのリストには @code{Important}、@code{Work}、
@code{Personal}、@code{To-Do} それに @code{Later} の印があります。それら
すべてに、@code{Important} のための @kbd{M M i} のように、最初の文字を使
うショートカット・キーが用意されています。
@end defvar

@defun gnus-registry-mark-article
独自のレジストリーの印を記事に付加するために使う関数です。補完のために、
利用できる印を提示します。
@end defun

概略行にレジストリーの印を表示できる書法を作る関数を、@code{defalias} を
使って設定することができます。このための関数として、@code{:char} プロパ
ティーを使って単一の文字で印を表示するもの、および完全な文で印を表示する
ものの 2つが用意されています。

@lisp
;; 単一の文字で印を表示する
;; ('gnus-registry-marks' の :char プロパティーを参照):
;; (defalias 'gnus-user-format-function-M
;;   'gnus-registry-article-marks-to-chars)

;; 名前で印を表示する ('gnus-registry-marks' を参照):
;; (defalias 'gnus-user-format-function-M
;;   'gnus-registry-article-marks-to-names)
@end lisp

@node Store arbitrary data
@subsection 任意のデータの記録

レジストリーには任意のデータを記録するために、Message-ID をキーとして使
う簡単なインターフェースがあります (データは保存するためにできる限り一つ
のリストに変換されます)。

@defun gnus-registry-set-id-key (id key value)
@code{id} を持つメッセージのために @code{key} について @code{value} を格
納します。
@end defun

@defun gnus-registry-get-id-key (id key)
@code{id} を持つメッセージのために @code{key} についてのデータを取得しま
す。
@end defun

@defvar gnus-registry-extra-entries-precious
特別なエントリーが貴重 (precious) であるなら、たとえその Message-ID の記
事のグループが無くても、またレジストリーのサイズの制限に達しても、それら
が存在しているとレジストリーはすべてのエントリーを永久に保持します。ディ
フォルトではこれはまさに @code{(mark)} なので、独自のレジストリーの印は
貴重であると見なされます。
@end defvar

@node The Gnus Cloud
@section Gnus クラウド
@cindex cloud
@cindex gnus-cloud
@cindex synchronization
@cindex sync
@cindex synch

Gnus クラウドは印や雑多なファイルとデータを複数のマシン間で同期するため
の一つの手段です。

すべての印 (どの記事を読んだか、どれが重要か、など) を数台のマシンの間で
同期させたいという需要が、非常にたびたび生じます。IMAP ではプロトコルに
組み込まれているので、多くのマシンから nnimap グループを読むことができる
し、それらは自動的に同期されます。しかし NNTP、nnrss、および他の多くのバッ
クエンドは印を蓄えないので、それはローカルに行なわなければなりません。

Gnus クラウドは印とあなたが選んだファイルを IMAP サーバーの特別なフォル
ダーに格納します。それは DropTorrentSyncBoxOakTree(TM) のようなものです。
@footnote{「Gnus クラウド」という名前はパロディーです。クラウド・コンピュー
ティング、すなわち
@url{https://www.gnu.org/philosophy/words-to-avoid.html#CloudComputing}
(通常は使わない方が良い誤解を招く用語) とはほとんど関係がありません。}

@menu
* Gnus Cloud Setup::
* Gnus Cloud Usage::
@end menu

@node Gnus Cloud Setup
@subsection Gnus クラウドの設定

Gnus クラウドの設定には 1分もかかりません。グループバッファーから:

サーバーバッファーに行くために @kbd{^} を押してください。そこで
は Gnus が知っているすべてのサーバーが見えるでしょ
う。@xref{Server Buffer}.

そうしたらクラウドで同期させたいどんなサーバーでも、@kbd{i} を押して指定
してください (それらの印が同期されます)。

そしてクラウドのホストになる単一のサーバーを @kbd{I} を押して指定してく
ださい (それは IMAP サーバーでなければなりません。すべての同期データを持
つフォルダーを提供することになります)。これは (カスタマイズの手段を使っ
て) 変数 @code{gnus-cloud-method} を設定し、初めて
の CloudSynchronizationDataPack(TM) をアップロードすることを促します。

@node Gnus Cloud Usage
@subsection Gnus クラウドの使い方

設定した後は、グループバッファーからこれらのショートカットを使うことがで
きます:

@table @kbd
@item ~ @key{RET}
@item ~ d
@findex gnus-cloud-download-all-data
@cindex cloud, download
最新の Gnus クラウドのデータをダウンロードします。

@item ~ u
@item ~ ~
@findex gnus-cloud-upload-all-data
@cindex cloud, download
ローカルな Gnus クラウドのデータをアップロードします。新し
い CloudSynchronizationDataPack(TM) を作成します。
@end table

しかし待ってください。もっとあります。もちろん、もっと。たくさん。以下の
すべてをカスタマイズできます。

@defvar gnus-cloud-synced-files
すべての CloudSynchronizationDataPack(TM) の部分になるファイル群がありま
す。それらはアップロードするたびに付いて行くので、大きなファイルをたくさ
ん同期させるのはやめましょう。100Kb 未満がベストです。
@end defvar

@defvar gnus-cloud-storage-method
いくつかの格納方法から選ぶためのものです。EPG の機能を使うことを強く推奨
します。もし GnuPG がインストールされていて EPG が読み込まれていれば自動
で適用されます。でも Base64+gzip か Base64 を使ったり、またはエンコード
しないことも可能です。
@end defvar

@defvar gnus-cloud-interactive
これがセットされていると (デフォルトでセット)、Gnus クラウドパッケージは
いろんな場面であなたに確認を求めます。不満に感じることがなければ、そのま
まにしておいてください。
@end defvar

@defvar gnus-cloud-method
CloudSynchronizationDataPack(TM) を格納する IMAP サーバーの名前です。サー
バーバッファーから設定するのが最も簡単です (@pxref{Gnus Cloud Setup})。
@end defvar

@node Other modes
@section 他のモードとの相互作用

@subsection Dired
@cindex dired

@code{gnus-dired-minor-mode} は dired バッファーで使えるいくつかの便利な
機能を提供します。これは次の式で有効になります:

@lisp
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
@end lisp

@table @kbd
@item C-c C-m C-a
@findex gnus-dired-attach
@cindex attachments, selection via dired
Dired で印を付けたものを添付ファイルとして送信しま
す (@code{gnus-dired-attach})。どの message バッファーに添付するかを尋ね
られます。

@item C-c C-m C-l
@findex gnus-dired-find-file-mailcap
適切な mailcap 項目に従ってファイルを開きま
す (@code{gnus-dired-find-file-mailcap})。接頭引数を付けると、ファイルを
新しいバッファーで (単に) 開きます。

@item C-c C-m C-p
@findex gnus-dired-print
mailcap 項目に従ってファイルを印刷します (@code{gnus-dired-print})。印刷
コマンドが無い場合は PostScript 画像として印刷します。
@end table

@node Various Various
@section いろいろのいろいろ
@cindex mode lines
@cindex highlights

@table @code
@item gnus-home-directory
@vindex gnus-home-directory
すべての Gnus のファイル名とディレクトリー名の変数は、これを基点にして初
期値が決定されます。ディフォルトは @file{~/} です。

@item gnus-directory
@vindex gnus-directory
Gnus がデータを格納するほとんどのファイルとディレクトリーの名前の変数は、
これを基点にして初期値が決定されます。ディフォルトは @env{SAVEDIR} 環境
変数の値か、その変数が設定されていない場合は @file{~/News/} です。

@file{~/.gnus.el} ファイルが読まれたときは Gnus のほとんどはすでに読み込
まれているということに注意してください。これはつまり、この変数
を @file{~/.gnus.el} の中で設定しても、この変数によって初期化される他の
ディレクトリー変数は正しく設定されないだろうということです。この変数は代
わりに @file{.emacs} で設定してください。

@item gnus-default-directory
@vindex gnus-default-directory
上記の変数にはまったく関係ありません---この変数はすべての Gnus バッファー
のディフォルトディレクトリーをどうすべきかを設定します。も
し @kbd{C-x C-f} のような命令を実行すると、現在のバッファーのディフォル
トディレクトリーを起点にしたプロンプトが出てくるでしょう。この変数
が @code{nil} (これがディフォルト) であれば、Gnus を起動したときにあなた
がいたバッファーのディフォルトディレクトリーがディフォルトディレクトリー
になるでしょう。

@item gnus-verbose
@vindex gnus-verbose
この変数は 0 から 10 までの間の整数です。数値が大きいほどたくさんのメッ
セージが表示されます。この変数が 0 であれば Gnus は何のメッセージも見せ
ません。これが 7 (ディフォルト) であれば特に重要なメッセージが表示され、
10 であれば Gnus は決してお喋りを止めず、たくさんのメッセージであなたに
めまいを起こさせるでしょう。

@item gnus-verbose-backends
@vindex gnus-verbose-backends
この変数は @code{gnus-verbose} と同様の効果をもたらしますが、Gnus 本体で
はなく Gnus のバックエンドに対して適用されます。

@item gnus-add-timestamp-to-message
@vindex gnus-add-timestamp-to-message
この変数は @code{gnus-verbose} と @code{gnus-verbose-backends} で制御さ
れて出力されるメッセージに、時刻 (タイムスタンプ) を付加するかどうかを制
御します。ディフォルト値は時刻を付加しないことを意味する @code{nil} です。
@code{log} だったら @file{*Messages*} バッファーに入るメッセージだけに時
刻を付加します。もし @code{nil} でも @code{log} でもなければ、ログに入る
メッセージだけでなく、エコーエリアに表示されるものにも時刻を付加します。

@item nnheader-max-head-length
@vindex nnheader-max-head-length
バックエンドが記事の連続したヘッダー部を読んでいるときは、できる限り少な
い量だけを読もうとします。この変数 (ディフォルト 8192) は、バックエンド
がヘッダーと本文の間の区切り行の捜索を諦める前に読み込む絶対最大長を指定
します。この変数が @code{nil} であれば、読み込み上限はありません。も
し @code{t} であれば、バックエンドは記事を部分部分で読み込もうとはせず、
記事全体を読み込みます。これは @code{ange-ftp} や @code{efs} のあるバー
ジョンで意味を持ちます。

@item nnheader-head-chop-length
@vindex nnheader-head-chop-length
この変数 (ディフォルト 2048) は、前記の操作を行なっているときに、どれく
らいの大きさの単位で各記事を読み込むかを設定します。

@item nnheader-file-name-translation-alist
@vindex nnheader-file-name-translation-alist
@cindex file names
@cindex invalid characters in file names
@cindex characters in file names
これはファイル名の文字をどのように変換するかを指定する連想リストです。例
えば、もし @samp{:} があなたのシステムではファイル名の文字としては使えな
い場合 (あなたは MS Windows の利用者ですね)、以下のようにすることができ
ます。

@lisp
@group
(setq nnheader-file-name-translation-alist
      '((?: . ?_)))
@end group
@end lisp

実際には、これは MS Windows (ちぇっ!) システム上でのこの変数のディフォル
ト値 (の一部) です。

@item gnus-hidden-properties
@vindex gnus-hidden-properties
これは「不可視」テキストを隠すために使われる属性のリストです。ほとんどの
システムではディフォルトは @code{(invisible t intangible t)} で、これは
不可視テキストを見えなくして触れないようにします。

@item gnus-parse-headers-hook
@vindex gnus-parse-headers-hook
ヘッダーを解釈する前に呼び出されるフック。これは例えば、取得したヘッダー
の統計情報を取るとか、あるいはある種のヘッダーを取り除くことに使うことが
できます。まあ、私は何でこんなものが欲しいかよくわかんないんだけどね。

@item gnus-shell-command-separator
@vindex gnus-shell-command-separator
二つのシェル命令を区切るのに使用される文字列。ディフォルトは @samp{;} で
す。

@item gnus-invalid-group-regexp
@vindex gnus-invalid-group-regexp
利用者にグループ名を尋ねるときに使う、「無効な」グループ名に合致する正規
表現です。ディフォルト値は Gnus の内部動作をめちゃめちゃにしてしまうかも
しれない、いくつかの @strong{本当に} 使えないグループ名を引っかけます。
(通常、選択方法とグループの境界に使っている @samp{:} などを許してしまう
とまずい、ということです。)

@acronym{IMAP} の利用者はグループ名に @samp{/} を使いたいかもしれません
が。

@item gnus-safe-html-newsgroups
@vindex gnus-safe-html-newsgroups
Html 記事中のリンクがすべて安全であると見なされるグループです。値はそれ
らのグループに合致する正規表現、グループ名のリスト、または @code{nil} で
す。これは @code{mm-w3m-safe-url-regexp} より優先されます。ディフォルト
値は @code{"\\`nnrss[+:]"} です。これは emacs-w3m で記事を描画するときだ
け、つまり @code{mm-text-html-renderer} が @code{w3m} に設定されていると
きだけ効果があります。@xref{Display Customization, ,表示のカスタマイズ,
emacs-mime-ja, The Emacs MIME Manual}.
@end table

@node The End
@chapter 終わり

はい、以上がマニュアルです---あなたはもう自分自身の人生を送ることができ
ます。連絡をとってください。あなたの猫によろしく伝えてください。

おお、@strong{神よ}---さよならを耐えることはできません。(すすり泣き。)

チャールズ・レズニコフはそれを非常によく表しているので、ここは彼のために
譲ります:

@quotation
賛美の歌 (テデウム)

勝利ゆえにぼくは@*
歌うのではない、@*
勝利などひとつもないから、@*
ありふれた日光のため、@*
そよ風のため、@*
春の気前よさのために歌う。

勝利のためではなく@*
僕としては精一杯やった@*
一日の仕事のために。@*
玉座のためではなく@*
みんなのテーブルの席で。
@end quotation

(新潮文庫「空腹の技法」著:ポールオースター、訳:柴田元幸、畔柳和代、
ISBN:4102451080 より引用)

@node Appendices
@chapter 付録

@menu
* History::                     どうやって Gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 ここにあるような本当に難しい語を使う
* Customization::               あなたの要求に沿って Gnus を仕立てる
* Troubleshooting::             うまくいかないときに何を試すか
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短かな紹介
* Frequently Asked Questions::  Gnus の FAQ
@end menu

@node History
@section 歴史

@cindex history
@sc{gnus} は梅田政信氏によって書かれました。1994年の秋が忍び寄ってくるこ
ろ、退屈していたラルス・マッグヌ・イングブリグットスン (Lars Magne
Ingebrigtsen) は Gnus を書き直そうと決心しました。

この非道な行為の責任者を調べてみたいのなら、あなたの (いまいましい!) ウェ
ブブラウザーを @uref{http://quimby.gnus.org/} に向けることができます。こ
れは新しくて粋な版の Gnus の第一配布場所で、Newsrc をぶっ壊して人々を激
怒させるサイトとしても知られています。

最初のアルファ版の開発期間に、新しい Gnus は“(ding) Gnus”と呼ばれてい
ました。@dfn{(ding)} はもちろん、@dfn{ding is not Gnus} の短縮形で、これ
はまったく完全な嘘ですが、だれがそんなことを気にするでしょうか? (ところ
で、この短縮形の“Gnus”はおそらく梅田さんの意図通り「ニュース」と発音さ
れるべきで、そうするともっと適切な名前になります。そう思いませんか?)

どちらにせよ、すべてのエネルギーを新しい元気の良い名前を付けるのに使い果
たした後で、その名前は @emph{あまりに} 元気が良すぎるということになり、
それを“Gnus”と再び命名しました。でも、今回は大文字と小文字を混ぜていま
す。“Gnus”と“@sc{gnus}”です。新しいもの と 古いもの。

@menu
* Gnus Versions::               どんなバージョンの Gnus がリリースされているか
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は @sc{gnus} とどれくらい互換性があるの?
* Conformity::                  Gnus はすべての標準を満たそうとする
* Emacsen::                     Gnus は少数の現代的な Emacs で実行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                たくさんの人々
* New Features::                Gnus の新しいことに関する手がかり
@end menu

@node Gnus Versions
@subsection Gnus Versions
@cindex ding Gnus
@cindex September Gnus
@cindex Red Gnus
@cindex Quassia Gnus
@cindex Pterodactyl Gnus
@cindex Oort Gnus
@cindex No Gnus
@cindex Ma Gnus
@cindex Gnus versions

最初の「正しい」Gnus 5 のリリースは 1995年11月に Emacs 19.30 の配布に含
まれたときになされました (132 の (ding) Gnus のリリース 足すこと
の Gnus 5.0 の 15 リリース)。

1996年3月に次の世代の Gnus (別名“September Gnus”(99 リリースの後
で)) が“Gnus 5.2”という名前でリリースされました (40 リリース)。

1996年の 7月28日に Red Gnus の作業が始まり、それは 1997年1月25日
に (84 リリースの後で)“Gnus 5.4”としてリリースされました (67 リリース)。

1997年9月13日に、Quassia Gnus が開始され、37 リリース続きました。それは
“Gnus 5.6”として 1998年3月8日にリリースされました (46 リリース)。

1998年8月29日に Gnus 5.6 から Pterodactyl Gnus が生まれ、1999年12月3日
に (99 リリースと CVS リポジトリでの作業の後)“Gnus 5.8”としてリリース
されました。

2000年10月26日に Oort Gnus が開始され、2003年5月1日に Gnus 5.10 としてリ
リースされました (24 リリース)。

2004年1月4日に No Gnus が始まりました。

2010年4月19日、Gnus の開発は Git に移行しました。詳細
は http://git.gnus.org を見てください (可能なら http://www.gnus.org はそ
の情報で更新されるでしょう。)

2012年1月31日、Ma Gnus が始まりました。

接頭語を持った版の Gnus---“(ding) Gnus”,“September Gnus”,“Red
Gnus”,“Quassia Gnus”,“Pterodactyl Gnus”,“Oort Gnus”,“No
Gnus”,“Ma Gnus”---に出会っても、混乱しないでください。あなたが恐がっ
ていることを知られてはいけません。後ろに下がりなさい。ゆっくりと。他に何
をしても、走ってはいけません。それが届かくなるまで、静かに歩き去りなさい。
正しくリリースされた版の Gnus を見つけて、代わりにそれにすり寄りなさい。

@node Why?
@subsection なぜ?

Gnus の目的は何ですか?

私は、あなたの考え付くことをすべてできる「いかす」「盛り上がってる」「かっ
こいい」「しゃれた」ニュースリーダーを提供したいと思います。これは私の大
元の動機だったのですが、Gnus の作業をしている間に、この世代のニュースリー
ダーは本当に石器時代に属していることが明らかになりました。ニュースリーダー
は、インターネットの揺籃期からほとんど発展していませんでした。もし現在の
増加率で流通量が増加しつづければ、すべての現在のニュースリーダーはまった
く役に立たなくなるでしょう。毎日何千もの新しい記事がやってくるニュースグ
ループを扱うにはどうすれば良いのでしょう? 数百万の投稿者に遅れないように
付いていくにはどうすれば良いのでしょう?

Gnus はこれらの質問に真の解決を提供するわけではありませんが、私
は Gnus がニュースを読み、取得するための新しい方法を実験する場として使わ
れることを、是非とも見届けたいのです。ニュースリーダーをバックエンドから
分離するという梅田さんの賢明な方針を拡張することによって、今や Gnus はメー
ルを取得したり、異なる出所からニュースを取得するための新しいバックエンド
を書きたい人のために、シンプルなインターフェースを提供しています。私は役
に立ちそうなすべての場所に、カスタマイズのためのフックを加えました。それ
によって、探検し、発明したいすべての人を招いているのです。

おそらく Gnus は完成することはないのかもしれません。
@kbd{C-u 100 M-x all-hail-emacs} です。

@node Compatibility
@subsection 互換性

@cindex compatibility
Gnus は @sc{gnus} と完全に互換性があるように設計されています。ほとんどす
べてのキーの割り当てはそのまま残っています。もちろん、多くのキーの割り当
てが追加されましたが、一つか二つの目に付かないものを除いて、古い割り当て
が変更されたことはありません。

私たちのモットーは:

@quotation
@cartouche
@center 鋼鉄の骨組みの空高く
@end cartouche
@end quotation

です。(訳注: チャールズ・レズニコフの自伝 “New York” の
第14章 “The Bridge” の引用。この章の本体はたった一
行 “In a cloud bones of steel.” だけ。直訳すれば「雲の中に鋼の骨たち」。)

すべての命令は名前が変わっていません。いくつかの内部関数は名前を変えまし
た。

@code{gnus-uu} パッケージは劇的に変化しています。@xref{Decoding
Articles}.

主要な互換性の問題の一つは、複数の概略バッファーが存在することです。グルー
プを読んでいるときに関連するすべての変数は、それが属する概略バッファーで
バッファーローカルです。概略バッファーでコマンドが実行されるときはいつで
も、多くの重要な変数がそれのグローバルな値にも複製されますが、あなたが注
意していないと、その変更は正しくない値が使われることをもたらすかもしれま
せん。

@sc{gnus} の内部の知識に依存したすべてのコードは実行できないでしょう。二
つ例を挙げます: @code{gnus-newsrc-alist} の並べ替え (もしくは、実際は何
らかの方法でそれを変更すること) は厳しく禁止されています。Gnus はこの連
想リストの項目を指し示すハッシュテーブルを維持しており (それは多くの関数
の速度を上げます)、直接連想リストを変更することは異常な結果をもたらすで
しょう。

@cindex hilit19
@cindex highlighting
古い hilit19 のコードはまったく動作しません。実際のところ、おそらくすべ
ての hilit コードをすべての Gnus のフッ
ク (@code{gnus-group-prepare-hook} およ
び @code{gnus-summary-prepare-hook}) から取り除くべきです。Gnus はハイラ
イトのためのいろいろな統合された関数を提供します。これらはもっと速くもっ
と正確です。すべての人の人生を楽にするために、Gnus はディフォルトですべ
ての hilit フックからすべての hilit 呼び出しを取り除きます。きたないも
の! 失せろ!

@code{expire-kill} のようなパッケージはもう動作しません。実際 Gnus を使
い始めたときには、おそらくすべての古い @sc{gnus} パッケージ (と他のコー
ド) を消去するべきでしょう。@sc{gnus} に実行させるために書いたコードは、
Gnus がすでに実行しているということは良くあることです。(くすくす。)

ものごとを実行する古いやり方はまだ使うことができますが、新しいやり方だけ
がこのマニュアルに記載されています。もしこのマニュアルを読んでいる間に何
かをする新しいやり方を発見しても、古いやり方を止めなければならないという
ことではありません。

Gnus はすべての @sc{gnus} の起動ファイルを理解します。

@findex gnus-bug
@cindex reporting bugs
@cindex bugs
全体として、@sc{gnus} の内部に依存したコードをほとんど書いていない普通の
利用者は、問題に苦しむことはないでしょう。もし問題が起こったら、魔法
の @kbd{M-x gnus-bug} 命令を実行することによって私に知らせてください。

@node Conformity
@subsection 標準への準拠

理由無き反抗などと申すものはございませんよ、奥様。私たちはすべての知られ
ている標準に準拠しています。もちろん私たちが賛成できない標準と/もしくは
習慣は除きますが。

@table @strong
@item RFC 822
@cindex RFC 822
@cindex RFC 2822
@cindex RFC 5322
この標準またはその後継 (現在は RFC の 2822 と 5322) への知られている違反
はありません。

@item RFC 1036
@cindex RFC 1036
この標準 (今では廃版) も知られている違反はありません。

@item RFC 5536
@cindex RFC 5536
RFC 1036 の後継です。これにはいくつかの違反があります。

@table @emph
@item X-Newsreader
@item User-Agent
これらは「つまらないヘッダー」と見なされていますが、私は消費者の情報であ
ると考えています。@code{tin} と @code{Netscape} から送られてくる非常に多
くの酷い記事を見た後では、私は記事を投稿するためにはそれらを使わない方が
良いということを知っています。もし @code{X-Newsreader} ヘッダーが無けれ
ば、私はその情報を得ることはなかったでしょう。
@end table

@item USEFOR
@cindex USEFOR
USEFOR は IETF の作業部会で、インターネット RFC の 5536 と 5537 を発行し
ました。Gnus タワーはこれらの基準によって具体化された変更を実装すること
を検討します。

@item MIME---RFC 2045--2049 etc
@cindex @acronym{MIME}
@acronym{MIME} 関連のすべての RFC がサポートされています。

@item Disposition Notifications - RFC 2298
Message Mode は受信者からの開封確認を要求することができます。

@item PGP---RFC 1991 and RFC 2440
@cindex RFC 1991
@cindex RFC 2440
RFC 1991 は最初の @acronym{PGP} メッセージの規格で、Informational
RFC (訳注: 後述の標準化トラックではないが有用な情報) として発行されまし
た。現在 Open PGP と呼ばれる後継の RFC 2440 が、標準化トラック (訳注:
Standards Track---国際標準とすべき仕様) に乗せられました。どちらも
非-@acronym{MIME} メッセージのための @acronym{PGP} の様式を定義します。
Gnus はエンコード (署名および暗号化) とデコード (認証および暗号のデコー
ド) の両方をサポートします。

@item PGP/MIME---RFC 2015/3156
RFC 2015 (RFC 1991 の代わりに RFC 2440 に基づいた 3156 で置き換えられま
した) は、RFC 1991/2440 を @acronym{MIME} で囲う様式について述べています。
Gnus はエンコードとデコードの両方をサポートします。

@item S/MIME---RFC 2633
RFC 2633 は @acronym{S/MIME} の形式について述べています。

@item IMAP---RFC 1730/2060, RFC 2195, RFC 2086, RFC 2359, RFC 2595, RFC 1731
RFC 1730 は @acronym{IMAP} バージョン 4 で、RFC 2060 (@acronym{IMAP}
4 改定 1) で多少更新されています。
RFC 2195 は @acronym{IMAP} の CRAM-MD5 認証について述べています。
RFC 2086 は @acronym{IMAP} の使用制限一覧 (ACL) について述べています。
RFC 2359 は @acronym{IMAP} のプロトコルの拡張について述べています。
RFC 2595 は @acronym{IMAP} における適切な @acronym{TLS} の統
合 (STARTTLS) について述べています。
RFC 1731 は @acronym{IMAP} の GSSAPI/Kerberos4 の手法について述べていま
す。
@end table

上に書かれている文章に関することで、Gnus がそれを満たしていないような動
作をしていることに気付いたら、ためらわずに Gnus タワーと私たちに知らせて
ください。

@node Emacsen
@subsection Emacsen
@cindex Emacsen
@cindex Mule
@cindex Emacs

このバージョンの Gnus は以下のもので動作します:

@itemize @bullet
@item
Emacs 23.1 とそれ以上。
@end itemize

この Gnus の版はこれより古いどんな Emacsen でも完全に動作しないでしょう。
少なくとも信頼できる動作はしないでしょう。古い版の Gnus は古い Emacs の
版でも動作するでしょう。特に Gnus 5.10.8 は Emacs 20.7 でも動くはずです。
@c
@c マージしてはいけないものに関するコメント: v5-10 のこの場所では加えら
@c れている項を、こちらにも入れてはいけません!

@node Gnus Development
@subsection Gnus の開発

Gnus は二つのサイクルで開発されています。最初のサイクルでは開発メーリン
グリスト @samp{ding@@gnus.org} でたくさんの議論を行ないます。そこでは人々
が変更や新しい機能の提案をしたり、パッチや新しいバックエンドを投稿します。
この段階は「アルファ」段階と呼ばれています。というのは、この段階でリリー
スされた Gnusae は「アルファリリース」もしくは (他の団体ではより良く使わ
れる)「スナップショット」と呼ばれるものだからです。この段階では Gnus は
不安定で、一般の利用者によって使われるべきではないと考えられています。
Gnus のアルファリリースは“Oort Gnus”や“No Gnus”のような名前になって
います。@xref{Gnus Versions}.

のらくらと 10--100 くらいのアルファリリースをした後で、Gnus は「凍結」さ
れたと宣言され、バグ修正のみが適用されます。Gnus は接頭語を失い、その代
わりに“Gnus 5.10.1”のように呼ばれます。これらは普通の人が使うことがで
きるものと考えられ、主に @samp{gnu.emacs.gnus} ニュースグループで議論さ
れています。このニュースグループは @samp{info-gnus-english@@gnu.org} メー
リングリストにミラーされていて、それは @samp{gmane.emacs.gnus.user} とし
て Gmane にも載っています。これらのリリースは最終的に Emacs に統合されま
す。

@cindex Incoming*
@vindex mail-source-delete-incoming
アルファ版の Gnus とリリースされた版の Gnus ではいくつかの変数、特
に @code{mail-source-delete-incoming}、のディフォルトが異なります。これ
はメールを扱っている際に、アルファリリースがしゃっくりをしてメールを失な
うことを避けるためです。@xref{Mail Source Customization}.

ding メーリングリストと Gnus ニュースグループにおける議論は、純粋に公衆
の関心によって分離されているわけではありません。アルファ Gnus リリース
が (ときどき) するかもしれない恐ろしいことを公衆の場で書くのは、皆を恐れ
させるというのも真実ですが、もっと重要なことは、導入された新しい実験的な
機能について話すことが、一般の利用者を混乱させるかもしれないということで
す。新しい機能は頻繁に導入され、いじくられ、不十分であると判断され、そう
すると捨てられるか、完全に書き換えられるかのどちらかです。メーリングリス
トを読んでいる人は普通はこの速い変更に付いていきますが、ニュースグループ
の人もそうであると見なすことはできません。

したがってアルファ版の問題やそれに関する質問があるなら、それらは ding メー
リングリスト @samp{ding@@gnus.org} に向けてください。このリスト
は Gmane に @samp{gmane.emacs.gnus.general} としてもあります。

@cindex Incoming*
@vindex mail-source-delete-incoming
いくつかの変数、特に @code{mail-source-delete-incoming} のディフォルト値
はアルファ Gnus とリリースされた Gnus で異なっています。これはアルファ版
がメールを扱っているときに、もし、しゃっくりをしても、メールが失われてし
まうことを防ぐためです。
@xref{Mail Source Customization}.

@node Contributors
@subsection 貢献者
@cindex contributors

新しい Gnus の版は (ding) メーリングリストのすべての人たちの助けが無けれ
ばできなかったでしょう。一年以上にわたって、私は毎日彼らから莫大な数の素
敵なバグレポートを受け取り、そのそれぞれが私を喜びで満たしました。投げキッ
ス。このリストの人たちは、私のリリース方針のために耐え難きを耐える試練に
遭いました: 「あぁ、それはすばらしい考えだ <かしゃかしゃかしゃ…> よしっ、
すぐにリリースだ <えいやっ> あれれっ、まったく動かないぞ <かしゃかしゃか
しゃ…> よしっ、すぐに出そう <ほらよっ> おっと、待った、ぜんぜん動作しな
い…」。Micro$oft---あっかんべーだ。アマチュアめ。私は @emph{もっと} 悪
い。(それとも「より悪い」?「もっと悪い」?「最悪」?)

私はこの機会に学会に感謝を@dots{} おおっと、違った。

@itemize @bullet
@item
梅田政信---元の @sc{gnus} を書いた人です。

@item
Shenghuo Zhu---uudecode.el, mm-uu.el, rfc1843.el, nnwarchive, それに一般
的なバグ修正、新しい機能などはもとより @acronym{MIME} と他の形式のエンコー
ド/デコードに関連するほんとうに多くのもの。

@item
Per Abrahamsen---custom、スコア、ハイライトと @sc{soup} コード (他の多く
のことと共に)。

@item
Luis Fernandes---デザインとグラフィック。

@item
Joe Reiss---スマイリーの顔の作者。

@item
Justin Sheehy---@acronym{FAQ} のメインテイナー。

@item
Erik Naggum---手助け、アイデア、支援、コード他。

@item
Wes Hardaker---@file{gnus-picon.el} とマニュアルの @dfn{picon} の
章 (@pxref{Picons})。

@item
Kim-Minh Kaplan---picon コードにおける更なる作業。

@item
Brad Miller---@file{gnus-gl.el} とマニュアルの Grouplens の章。

@item
Sudish Joseph---数え切れないほどのバグの修正。

@item
Ilja Weis---@file{gnus-topic.el}。

@item
Steven L. Baur---たくさんのたくさんのたくさんのバグの発見と修正。

@item
Vladimir Alexiev---refcard とリファレンスの小冊子。

@item
Felix Lee & Jamie Zawinski---私は Felix Lee と JWZ の XGnus 配布からいく
つかの部分を盗みました。

@item
Scott Byer---@file{nnfolder.el} の拡張と改訂。

@item
Peter Mutsaers---孤児記事のスコアコード。

@item
Ken Raebburn---@acronym{POP} メールサポート。

@item
Hallvard B Furuseth---いろいろな小さな物や部分、特に .newsrc ファイルを
扱う部分。

@item
Brian Edmonds---@file{gnus-bbdb.el}。

@item
David Moore---@file{nnvirtual.el} の改訂と多くの他のこと。

@item
Kevin Davidson---@dfn{ding} の名前を思い付きました。ですから、彼を責めて
ください。

@item
François Pinard---多くの、多くの興味深く完全なバグレポートと autoconf の
サポート。
@end itemize

このマニュアル (Gnus 英語版) は Adrian Aichner と Ricardo Nassif, Mark
Borges によって校正され、Jost Krieger によって一部分を校正されました。

以下の人々は多くのパッチと提案で貢献しました:

Christopher Davis,
Andrew Eskilsson,
Kai Grossjohann,
Kevin Greiner,
Jesper Harder,
Paul Jarc,
Simon Josefsson,
David Kågedal,
Richard Pieri,
Fabrice Popineau,
Daniel Quinlan,
Michael Shields,
Reiner Steib,
Jason L. Tibbitts, III,
Jack Vinson,
山岡 克美,
and
Teodor Zlatanov.

それと、以下の人にもパッチやその他のものを感謝します:

Jari Aalto,
Adrian Aichner,
Vladimir Alexiev,
Russ Allbery,
Peter Arius,
Matt Armstrong,
Marc Auslander,
Miles Bader,
Frank Bennett,
Alexei V. Barantsev,
Robert Bihlmeyer,
Chris Bone,
Mark Borges,
Mark Boyns,
Rob Browning,
Lance A. Brown,
Kees de Bruin,
Martin Buchholz,
Joe Buehler,
Kevin Buhr,
Alastair Burt,
Joao Cachopo,
Zlatko Calusic,
Massimo Campostrini,
Castor,
David Charlap,
Dan Christensen,
Kevin Christian,
Jae-you Chung, @c ?
James H. Cloos, Jr.,
Laura Conrad,
Michael R. Cook,
Glenn Coombs,
Andrew J. Cosgriff,
Neil Crellin,
Frank D. Cringle,
Geoffrey T. Dairiki,
Andre Deparade,
Ulrik Dickow,
Dave Disser,
Rui-Tao Dong, @c ?
Joev Dubach,
Michael Welsh Duggan,
Dave Edmondson,
Paul Eggert,
Mark W. Eichin,
Karl Eichwalder,
榎並 嗣智,
Michael Ernst,
Luc Van Eycken,
Sam Falkner,
Nelson Jose dos Santos Ferreira,
Sigbjorn Finne,
Sven Fischer,
Paul Fisher,
Decklin Foster,
Gary D. Foster,
Paul Franklin,
Guy Geens,
Arne Georg Gleditsch,
David S. Goldberg,
Michelangelo Grigni,
Dale Hagglund,
D. Hall,
Magnus Hammerin,
半田 剣一,
Raja R. Harinath,
林 芳樹,
P. E. Jareth Hein,
ひさしげ けんじ,
Scott Hofmann,
Tassilo Horn,
Marc Horowitz,
Gunnar Horrigmo,
Richard Hoskins,
Brad Howes,
Miguel de Icaza,
François Felix Ingrand,
市川 達
哉, 石川 一郎,
Lee Iverson,
岩室 元典,
Rajappa Iyer,
Andreas Jaeger,
Adam P. Jenkins,
Randell Jesup,
Fred Johansen,
Gareth Jones,
Greg Klanderman,
Karl Kleinpaste,
Michael Klingbeil,
Peter Skov Knudsen,
小林 修平,
Petr Konecny,
小関 吉則,
Thor Kristoffersen,
Jens Lautenbacher,
Martin Larose,
Seokchan Lee, @c Lee
Joerg Lenneis,
Carsten Leonhardt,
James LewisMoss,
Christian Limpach,
Markus Linnala,
Dave Love,
Mike McEwan,
Tonny Madsen,
Shlomo Mahlab,
Nat Makarevitch,
Istvan Marko,
David Martin,
Jason R. Mastaler,
Gordon Matzigkeit,
Timo Metzemakers,
Richard Mlynarik,
Lantz Moore,
守岡 知彦,
Erik Toubro Nielsen,
Hrvoje Nikšić,
Andy Norman,
Fred Oberhauser,
C. R. Oldham,
Alexandre Oliva,
Ken Olstad,
大西 雅
晴, 小野 秀貴,
Ettore Perazzoli,
William Perry,
Stephen Peters,
Jens-Ulrik Holger Petersen,
Ulrich Pfeifer,
Matt Pharr,
Andy Piper,
John McClary Prevost,
Bill Pringlemeir,
Mike Pullen,
Jim Radford,
Colin Rafferty,
Lasse Rasinen,
Lars Balker Rasmussen,
Joe Reiss,
Renaud Rioboo,
Roland B. Roberts,
Bart Robinson,
Christian von Roques,
Markus Rost,
Jason Rumney,
Wolfgang Rupprecht,
Jay Sachs,
Dewey M. Sasser,
Conrad Sauerwald,
Loren Schall,
Dan Schmidt,
Ralph Schleicher,
Philippe Schnoebelen,
Andreas Schwab,
Randal L. Schwartz,
Justin Sheehy,
Danny Siu,
Matt Simmons,
Paul D. Smith,
Jeff Sparkes,
Toby Speight,
Michael Sperber,
Darren Stalder,
Richard Stallman,
Greg Stark,
Sam Steingold,
Paul Stevenson,
Jonas Steverud,
Paul Stodghill,
須藤 清一,
Kurt Swanson,
Samuel Tardieu,
Teddy,
戸沢 晶彦,
Chuck Thompson,
Philippe Troin,
James Troup,
Trung Tran-Duc,
Jack Twilley,
Aaron M. Ucko,
Aki Vehtari,
Didier Verna,
Vladimir Volovich,
Jan Vroonhof,
Stefan Waldherr,
Pete Ware,
Barry A. Warsaw,
Christoph Wedler,
Joe Wells,
Lee Willis,
and
Lloyd Zusman.

Gnus のアルファ配布に含まれている ChangeLog は、それぞれの人たちが行なっ
たことの完全な大要を伝える豊かな読み物です。(550KB といくらか)。(訳
注: 非常に古い ChangeLog の記述が何度かばっさり捨てられましたが、それで
も現在は非常に大きなサイズになっています。)

私が忘れてしまったすべての人に謝罪します。間違いなくたくさんの人を忘れて
しまったことでしょう。

わぁ、こんなに人がいるとは思わなかった。これは本当に Gnus を使っている人
がいるということなんでしょう。そんなことを誰が想像したでしょうか!

@node New Features
@subsection 新しい機能
@cindex new features

@menu
* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の新しいこと
* September Gnus::              公式に Gnus 5.2/5.3 として知られているもの
* Red Gnus::                    三番目の最上のもの---Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            神秘の数も P で始まるけれど。Gnus 5.8/5.9 の別名
* Oort Gnus::                   巨大な。遠く遥かな。Gnus 5.10/5.11。
* No Gnus::                     超やばい。Gnus 5.12/5.13
* Ma Gnus::                     祝 Gnus 25 周年。
@end menu

より最近の変更の要約については、通常の Emacs @file{NEWS} ファイルを参照
してください。

これらのリストは、もちろん @emph{たいていの} 重要な新しい機能に関す
る @emph{短い} 要約でしかありません。いいえ、実は違います。もっともっと
たくさんのものがあるのです。そう、事実上私たちは十分に用の無いも
の (feeping creaturism) を持っているのです。

@node ding Gnus
@subsubsection (ding) Gnus

Gnus 5.0/5.1 の新しい機能:

@itemize @bullet
@item
すべてのバッファーの外観は、フォーマットのような変数 (@pxref{Group
Buffer Format} and @pxref{Summary Buffer Format}) によって設定を変えるこ
とができるようになりました。

@item
ローカルスプールと、いくつかの @acronym{NNTP} サーバーを同時に使うことが
できるようになりました (@pxref{Select Methods})。

@item
複数のグループを仮想グループに合併できるようになりました (@pxref{Virtual
Groups})。

@item
多くの異なるメール様式を読めるようになりました (@pxref{Getting Mail})。
すべてのメールバックエンドは、便利なメール期限切れ消去機構を実装していま
す (@pxref{Expiring Mail})。

@item
Gnus は根っこ (root) を失ったスレッドを集めるためのいろいろな戦略 (それ
によってまばらな副スレッドを一つのスレッドにする) を使ったり、完全なスレッ
ドを組み上げるのに十分なヘッダーをいったん戻って取得することができま
す (@pxref{Customizing Threading})。

@item
切られたグループ (killed groups) はグループバッファーに表示することがで
きて、それらも読むことができます (@pxref{Listing Groups})。

@item
Gnus はグループを部分的に更新することができます---2,3 のグループの新しい
記事を調べるために、アクティブファイル全体を取得する必要はありませ
ん (@pxref{The Active File})。

@item
Gnus はグループの段階的購読度を実装しました (@pxref{Group Levels})。

@item
何種類もの基準に従って、記事にスコアを付けることができま
す (@pxref{Scoring})。どのように記事にスコアを付けるかを、Gnus に見つけ
させることもできます (@pxref{Adaptive Scoring})。

@item
Gnus は普通の Emacs の方法で自動保存されるドリブルバッファーを維持するの
で、あなたが何を読んだかのデータをマシンが落ちたときでもあまり失わないで
しょう (@pxref{Auto Save})。

@item
Gnus は @file{.emacs} ファイルをぐちゃぐちゃにすることを避けるために、今
では専用の起動ファイル (@file{~/.gnus.el}) を持つようになりました。

@item
グループと記事の両方にプロセス印を付けることができ、すべての印の付いた項
目で処理を実行することができます (@pxref{Process/Prefix})。

@item
グループの一覧を、えーと、どんな条件ででも、表示することができま
す (@pxref{Listing Groups})。

@item
外部サーバーを概観して、それらのサーバーのグループを購読することができま
す (@pxref{Browse Foreign Server})。

@item
Gnus はサーバーとの二つ目の接続で、記事を非同期に取ってくることができま
す (@pxref{Asynchronous Fetching})。

@item
記事をローカルにキャッシュすることができます (@pxref{Article Caching})。

@item
uudecode の関数が拡張され、一般化されました (@pxref{Decoding Articles})。

@item
uuencode された記事をまだ投稿することができます。これは過去
に @sc{gnus} のあまり知られていない機能でした (@pxref{Uuencoding and
Posting})。

@item
親記事 (と他の記事) の取得は、今では調子が悪くなることも無く、実際に動作
するようになりました (@pxref{Finding the Parent})。

@item
Gnus は @acronym{FAQ} とグループの説明を取得することができま
す (@pxref{Group Information})。

@item
まとめ送りされた記事 (および他のファイル) を、グループとして使えるように
なりました (@pxref{Document Groups})。

@item
記事をハイライトし、カスタマイズすることができます (@pxref{Customizing
Articles})。

@item
URL と他の外部参照がボタンになるようになりました (@pxref{Article
Buttons})。

@item
Gnus のウィンドウとフレームの設定でたくさんの変なことをできるようになり
ました (@pxref{Window Layout})。
@end itemize

@node September Gnus
@subsubsection September Gnus

@iftex
@iflatex
\gnusfig{-28cm}{0cm}{\epsfig{figure=ps/september,height=20cm}}
@end iflatex
@end iftex
Gnus 5.2/5.3 の新しい機能:

@itemize @bullet
@item
新しいメッセージ作成モードが使われます。@code{mail-mode},
@code{rnews-reply-mode} と @code{gnus-msg} のすべての古いカスタマイズ変
数は今や旧式になりました。

@item
Gnus は「まばら」スレッドを作成することができるようになりました---スレッ
ドの失われた記事があるところは、空の節で表現されるようになっていま
す (@pxref{Customizing Threading})。

@lisp
(setq gnus-build-sparse-threads 'some)
@end lisp

@item
外に出ていく記事は、特別な保管サーバーに保存されるようになりまし
た (@pxref{Archived Messages})。

@item
記事が参照されたときに、スレッドの部分作成が行なわれるようになりました。

@item
Gnus は GroupLens の予測を利用することができるようになりました。

@item
Picons (personal icons) (個人アイコン) が表示できるようになりまし
た (@pxref{Picons})。

@item
@code{trn} のような木バッファーを表示できるようになりました (@pxref{Tree
Display})。

@lisp
(setq gnus-use-trees t)
@end lisp

@item
ニュースリーダー @code{nn} のような、選んで読むマイナーモードを概略バッ
ファーで使うことができるようになりました (@pxref{Pick and Read})。

@lisp
(add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)
@end lisp

@item
バイナリーグループで特別なバイナリーマイナーモードを使うことができるよう
になりました (@pxref{Binary Groups})。

@item
グループ群を折り畳みトピック階層にグループ分けできるようになりまし
た (@pxref{Group Topics})。

@lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
@end lisp

@item
メールの再送と、弾かれたメールを送り直すことができるようになりまし
た (@pxref{Summary Mail Commands})。

@item
グループがスコアを持つことができるようになり、訪れる回数に基づいた並べ替
えが可能になりました (@pxref{Group Score})。

@lisp
(add-hook 'gnus-summary-exit-hook 'gnus-summary-bubble-group)
@end lisp

@item
グループにプロセス印を付けられるようになり、グループのグループに対して命
令を実行できるようになりました (@pxref{Marking Groups})。

@item
仮想グループでキャッシュができるようになりました。

@item
@code{nndoc} はすべての種類のまとめ送り、メールボックス、rnews ニュース
の一括配送、ClariNet の要約集、そしてその他のすべてを理解できるようにな
りました (@pxref{Document Groups})。

@item
Gnus は SOUP パケットを作成/読み込みをするための新しいバックエン
ド (@code{nnsoup}) を持っています。

@item
キャッシュがずっと速くなりました。

@item
グループを多くの基準に従って並べ替えることができるようになりまし
た (@pxref{Sorting Groups})。

@item
メーリングリストのアドレスと期限切れ消去の時間を設定する、新しいグループ
パラメーターが導入されました (@pxref{Group Parameters})。

@item
すべてのフォーマット指定で、フェースを指定できるようになりまし
た (@pxref{Formatting Fonts})。

@item
@kbd{M P} 副キーマップに、プロセス印の付いた記事の設定/削除/実行のための
複数の命令が追加されました (@pxref{Setting Process Marks})。

@item
広範囲の基準に基づいて、概略バッファーが利用可能な記事の一部だけを表示す
るように制限できるようになりました。これらの命令は @kbd{/} 副マップのキー
にバインドされています (@pxref{Limiting})。

@item
@kbd{*} 命令によって、記事を永続させることができるようになりまし
た (@pxref{Persistent Articles})。

@item
記事の要素を隠すすべての関数は、トグルになりました。

@item
記事のヘッダーにボタンを付けることができるようになりまし
た (@pxref{Article Washing})。

@item
すべてのメールバックエンドで、@code{Message-ID} による記事の取得をサポー
トするようになりました。

@item
重複メールを適切に扱うことができるようになりました (@pxref{Duplicates})。

@item
すべての概略モード命令を、記事バッファーから直接使用できるようになりまし
た (@pxref{Article Keymap})。

@item
フレームが @code{gnus-buffer-configuration} の部分になることができるよう
になりました (@pxref{Window Layout})。

@item
デーモンのプロセスによって、新着メールを検査できるようになりまし
た (@pxref{Daemons})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fseptember,height=5cm}]{\epsfig{figure=ps/fseptember,height=5cm}}
@end iflatex
@end iftex

@item
グループを常に見えるようにしておくことが (訳注: そのグループに未読記事が
無くても)、できるようになりました (@pxref{Listing Groups})。

@lisp
(setq gnus-permanently-visible-groups "^nnml:")
@end lisp

@item
カスタマイズを楽にするために、多くの新しいフックが導入されました。

@item
Gnus は @code{Mail-Copies-To} ヘッダーを尊重するようになりました。

@item
@code{References} ヘッダーを調べることによって、スレッドを集めることがで
きるようになりました (@pxref{Customizing Threading})。

@lisp
(setq gnus-summary-thread-gathering-function
      'gnus-gather-threads-by-references)
@end lisp

@item
再取得を避けるために、既読記事を特別なバックログ・バッファーに貯めること
ができるようになりました (@pxref{Article Backlog})。

@lisp
(setq gnus-keep-backlog 50)
@end lisp

@item
簡単にトリートメントを行なうことができるようにするために、現在の記事の完
全な複製がいつも別バッファーに置かれるようになりました。

@item
Gnus がどこに記事を保存するかを提案できるようになりました (@pxref{Saving
Articles})。

@item
記事を保存するときに、多くを入力しなくても良いようになりまし
た (@pxref{Saving Articles})。

@lisp
(setq gnus-prompt-before-saving t)
@end lisp

@item
@code{gnus-uu} は記事を取得している間に、非同期でデコードされたファイル
を表示できるようになりました (@pxref{Other Decode Variables})。

@lisp
(setq gnus-uu-grabbed-file-functions 'gnus-uu-grab-view)
@end lisp

@item
記事バッファーで、引用されたテキストの折り返しが適切に動作するようになり
ました (@pxref{Article Washing})。

@item
引用されたテキストを表示するか隠すかを切り替えるためのボタンが追加されま
した。また、どのくらいの引用文を隠すかをカスタマイズできるようになりまし
た (@pxref{Article Hiding})。

@lisp
(setq gnus-cited-lines-visible 2)
@end lisp

@item
興味の無いヘッダーを隠すことができます (@pxref{Article Hiding})。

@item
スコアのディフォルト値をメニューバーから設定できるようになりました。

@item
送信される記事の更なる構文チェックが追加されました。
@end itemize

@node Red Gnus
@subsubsection Red Gnus

Gnus 5.4/5.5 の新しい機能:

@iftex
@iflatex
\gnusfig{-5.5cm}{-4cm}{\epsfig{figure=ps/red,height=20cm}}
@end iflatex
@end iftex
@itemize @bullet
@item
@file{nntp.el} は非同期に動作するやり方で、完全に改訂されました。

@item
記事の先行取得を行なう機能が Gnus に編入されました (@pxref{Asynchronous
Fetching})。

@item
スコア付けは @code{and}, @code{or}, @code{not} のような論理演算子と、親
記事にさかのぼってリダイレクトすることで実行できるようになりまし
た (@pxref{Advanced Scoring})。

@item
記事の洗濯状態を記事のモード行に表示できるようになりまし
た (@pxref{Misc Article})。

@item
@file{gnus.el} が多くの小さいファイルに分割されました。

@item
Message-ID に基づいて、記事の重複を抑制することができるようになりまし
た (@pxref{Duplicate Suppression})。

@lisp
(setq gnus-suppress-duplicates t)
@end lisp

@item
どのスコアと適応ファイルが、ホームスコアと適応ファイルであるかを指定す
る (@pxref{Home Score File}) 新しい変数が加えられました。

@item
@code{nndoc} がより簡単に拡張できるように改訂されまし
た (@pxref{Document Server Internals})。

@item
グループは親のトピックからグループパラメーターを継承できるようになりまし
た (@pxref{Topic Parameters})。

@item
記事を編集するための機能が継ぎはぎされて、実際に使用可能になりました。

@item
署名がもっと利口なやり方で認識されるようになりました (@pxref{Article
Signature})。

@item
概略ピックモードがもっと (ニュースリーダー) @code{nn} らしくなりました。
行番号が表示され、記事を選ぶために @kbd{.} 命令を使うことができるように
なりました (@code{Pick and Read})。

@item
あるサーバーから別のサーバーへ @file{.newsrc.eld} を移動する命令が加えら
れました (@pxref{Changing Servers})。

@item
今では、バッファーの行を作成するときに、抑制される「興味の無い」部分を指
定する方法があります (@pxref{Advanced Formatting})。

@item
グループバッファーの複数の命令について、それらで行なったこと
を @kbd{C-M-_} で元に戻すことができるようになりました (@pxref{Undo})。

@item
新しいスコア型 @code{w} を使うことによって、単語でスコア付けをすることが
可能になりました (@pxref{Score File Format})。

@item
表題の一語一語を基にして、適応スコアをすることができるようになりまし
た (@pxref{Adaptive Scoring})。

@lisp
(setq gnus-use-adaptive-scoring '(word))
@end lisp

@item
スコアを減衰させることができるようになりました (@pxref{Score Decays})。

@lisp
(setq gnus-decay-scores t)
@end lisp

@item
正規表現を使って、日付のヘッダーでスコア付けを実行できるようになりました。
日付は最初にコンパクトな ISO 8601 様式で正規化されます (@pxref{Score
File Format})。

@item
記事に関するすべてのデータを、基本のサーバーから取り除く命令が加えられま
した (@pxref{Changing Servers})。

@item
文書を寄せ集めたものを読むための新しい命令 (@code{nndoc} グループのてっ
ぺんで @code{nnvirtual} を使います) が加えられました---@kbd{C-M-d}
(@pxref{Really Various Summary Commands})。

@item
プロセス印の設定を push と pop でスタックに出し入れできるようになりまし
た (@pxref{Setting Process Marks})。

@item
@acronym{NNTP} サーバーが投稿を許可していない場合でも、新し
い mail-to-news バックエンドが、投稿することを可能にしまし
た (@pxref{Mail-To-News Gateways})。

@item
ウェブ検索エンジン (@dfn{DejaNews}, @dfn{Alta Vista},
@dfn{InReference}) からの検索結果を読むための、新しいバックエンドが加え
られました (@pxref{Web Searches})。

@item
標準の並べ替え関数を使って、トピックの中にあるグループを並び代えることが
できるようになりました。また、それぞれのトピックを独立して並べ替えること
ができるようになりました (@pxref{Topic Sorting})。

@item
グループ群の一部を、独立して並べ替えることができるようになりまし
た (@code{Sorting})。

@item
キャッシュされた記事を、グループに引き込むことができるようになりまし
た (@pxref{Summary Generation Commands})。
@iftex
@iflatex
\marginpar[\mbox{}\hfill\epsfig{figure=ps/fred,width=3cm}]{\epsfig{figure=ps/fred,width=3cm}}
@end iflatex
@end iftex

@item
スコアファイルがもっと信頼できる順番で適用されるようになりまし
た (@pxref{Score Variables})。

@item
メールメッセージが分割されてどこに行くかの報告を、作成することができるよ
うになりました (@pxref{Splitting Mail})。

@item
入って来たメールを保存する前にがらくたを取り除くフックと関数が、もっと追
加されました (@pxref{Washing Mail})。

@item
強調表示することを指定されたテキストが、適切に表示されるようになりました。
@end itemize

@node Quassia Gnus
@subsubsection Quassia Gnus

Gnus 5.6 の新しい機能:

@itemize @bullet
@item
Gnus をオフラインニュースリーダーとして使う新機能が加えられました。過剰
なほどの新しい命令とモードが追加されました。全貌については @ref{Gnus
Unplugged} を見てください。

@item
@code{nndraft} バックエンドが戻ってきました。でも、依然とは違う動作をし
ます。すべてのメッセージバッファーは、今では自動的に作成され
る @code{nndraft} グループの記事でもあります。

@item
@code{gnus-alter-header-function} を、ヘッダーの値を変えるために使うこと
ができるようになりました。

@item
@code{gnus-summary-goto-article} が Message-ID を受け付けるようになりま
した。

@item
メッセージの本文において、指定したリージョン以外のテキストを消去するため
の新しいメッセージ命令があります: @kbd{C-c C-v}。

@item
@kbd{C-u C-c C-c} によって @code{nnvirtual} グループを構成しているグルー
プに投稿できるようになりました。

@item
@code{nntp-rlogin-program}---カスタマイズを簡単にするための新しい変数で
す。

@item
@code{gnus-article-edit-mode} における @code{C-u C-c C-c} 命令は、記事バッ
ファーの再ハイライトを抑制するようになりました。

@item
@code{gnus-boring-article-headers} に、@code{long-to} という新しい要素が
あります。

@item
@kbd{M-i} シンボル接頭引数命令があります。詳細
は @ref{Symbolic Prefixes} を見てください。

@item
概略バッファーにおける @kbd{L} と @kbd{I} は、@file{all.SCORE} ファイル
にスコア規則を加えるためのシンボル接頭引数 @kbd{a} を受け付けるようにな
りました。

@item
変数 @code{gnus-simplify-subject-functions} によって、表題の単純化を強力
に制御できるようになりました。

@item
@kbd{A T}---現在のスレッドを取得するための新しい命令です。

@item
@kbd{/ T}---現在のスレッドを制限に含めるための新しい命令です。

@item
@kbd{M-@key{RET}} は、引用文の途中に割って入るための新しいメッセージ命令
です。

@item
@samp{\\1} のような表現が @code{nnmail-split-methods} で有効になりました。

@item
関数 @code{custom-face-lookup} が取り除かれました。あなたの初期化ファイ
ルでこの関数を使っていたのなら、代わりに @code{face-spec-set} を使うよう
に書き直さなければなりません。

@item
投稿のキャンセルに、現在の選択方法を使うようになりました。シンボル接頭引
数 @kbd{a} で、普通の投稿方法を強制することができます。

@item
マ■■■ソ■■ sm*rtq**t*s を適切なテキストに翻案する新しい命令がありま
す---@kbd{W d}。

@item
@code{nntp} のデバッグを楽にするために、
@code{nntp-record-commands} を @code{nil} ではない値に設定することができ
ます。

@item
@code{nntp} は @file{~/.authinfo} を使うようになりました。これ
は @file{.netrc} のようなファイルで、どこの @acronym{NNTP} サーバーには
どのように @sc{authinfo} を送るかを制御するためのものです。

@item
概略バッファーのグループパラメーターを編集するための命令が加えられました。

@item
メールがどこに分割されたかの履歴を利用できるようになりました。

@item
記事の日付を表示するための新しい命令が加えられまし
た---@code{article-date-iso8601}。

@item
@code{gnus-score-thread-simplify} を設定することによって、スレッドを作成
するときの表題を単純化できるようになりました。

@item
メッセージで引用をするための新しい関数が加えられました---
@code{message-cite-original-without-signature}。

@item
@code{article-strip-all-blank-lines}---新しい記事命令です。

@item
記事の終わりまでを切り取る (kill する) 新しいメッセージ命令が加えられま
した。

@item
変数 @code{gnus-adaptive-word-minimum} を使うことによって、最小限度の適
応スコアを指定することができます。

@item
@code{gnus-start-date-timer} 命令によって「記事が投稿されたときからの経
過時間」ヘッダーが継続的に更新されるようになりました。

@item
ウェブで提供されているメーリングリストのアーカイブを、
@code{nnlistserv} バックエンドによって読むことができるようになりました。

@item
古い dejanews アーカイブを @code{nnweb} で読むことができるようになりまし
た。
@end itemize

@node Pterodactyl Gnus
@subsubsection Pterodactyl Gnus

Gnus 5.8 の新しい機能:

@itemize @bullet
@item
メールを取り込む機能が変わりました。たくさんの詳細についてはマニュアルを
見てください。特に procmail で取り込むためのすべての変数が無くなっていま
す。

以下のような procmail の使い方は

@lisp
(setq nnmail-use-procmail t)
(setq nnmail-spool-file 'procmail)
(setq nnmail-procmail-directory "~/mail/incoming/")
(setq nnmail-procmail-suffix "\\.in")
@end lisp

現在では次のように変わっています。

@lisp
(setq mail-sources
      '((directory :path "~/mail/incoming/"
                   :suffix ".in")))
@end lisp

@xref{Mail Source Specifiers}.

@item
Gnus は @acronym{MIME} に対応したリーダーになりました。これは Gnus の多
くの部分に影響していて、たくさんの新しいコマンドが追加されています。詳細
はマニュアルを参照してください。

@item
しかも Gnus は各国語対応になりました。ここでは要約できないくらい
に Gnus の多くの部分に影響していて、新しいたくさんの変数が追加されていま
す。

@item
@code{gnus-auto-select-first} が、ポイントを置く場所を決定するための関数
であってもよくなりました。

@item
概略バッファーと @acronym{NOV} ファイルに含める追加のヘッダーを、利用者
が決めることができるようになりました。

@item
@code{gnus-article-display-hook} が削除されました。代わり
に @code{gnus-treat-} で始まるたくさんの変数が追加されました。

@item
Gnus posting styles が再び作り直されました。現在は微妙に違うやり方で動作
します。

@item
新しいウェブに基づいたバックエンドが追加されました。@code{nnslashdot},
@code{nnwarchive} および @code{nnultimate} です。nnweb は常に変化する構
成をとり続けるために、再び作り直されました。

@item
Gnus は @code{nnimap} によって @acronym{IMAP} のメールを読むことができま
す。
@end itemize

@node Oort Gnus
@subsubsection Oort Gnus
@cindex Oort Gnus

Gnus 5.10 の新しい機能:

@itemize @bullet
@item インストールに関する変更
@c ***************************

@itemize @bullet
@item
Oort を使ったことがある場合の、以前の (安定な) 版からのグレードアップ。

Oort (このリリースに先立つ安定ではない Gnus の枝) を使ってみたものの、安
定版に戻してしまったならば、この版にグレードアップするときに注意してくだ
さい。特に、おそらくすべて
の @file{.marks} (nnml) と @file{.mrk} (nnfolder) ファイルを消去する必要
があるでしょう。その目的は、この版 (の Gnus) がフラグを格納す
る @file{.marks}/@file{.mrk} ファイルではなくて @file{.newsrc.eld} から
フラグが読まれるようにするためです (訳注: 言い換えると、古い様式
の @file{.marks}/@file{.mrk} ファイルを新しい Gnus が読んではいけないと
いうことです。それらは新たに作成されます)。後述の項目で、印 (marks) に関
するより多くの情報を読んでください。グレードを下げても一般には助けになら
ないことに注意してください。

@item
Lisp ファイルがディフォルトで @file{.../site-lisp/gnus/} にインストール
されるようになりました。以前は @file{.../site-lisp/} がディフォルトでし
た。加えて、新しいインストーラーは他にインストールされている、新し
い Gnus より優先される Gnus を検出して警告を発します。それらを手動で取り
除いても良いし、@code{make remove-installed-shadows} を使って削除するこ
ともできます。

@item
@file{~/News/overview/} は不要。

以下の変更の結果、もはや @file{~/News/overview/} ディレクトリーは要りま
せん。すべての階層を安全に削除することができます。

@c FIXME: 'gnus-load' について言及している README が、リポジトリーには含
@c まれていません。私たちはこの項目のためのより良い場所を見つけるべきで
@c す。
@item
@code{(require 'gnus-load)}

単独で配布されている Gnus を使う場合には、
@code{load-path} に Gnus の lisp ディレクトリーを追加してから、
@file{~/.emacs} に @code{(require 'gnus-load)} を加えるのが良いです。

@file{gnus-load.el} ファイルは、そのうちのいくつかは Emacsen の配布に入っ
ていないかもしれない自動読み込み (autoload) コマンド、関数および変数を含
んでいます。
@end itemize

@item Gnus に内蔵された新しいパッケージとライブラリー
@c **************************************************

@itemize @bullet
@item
改定された Gnus @acronym{FAQ} がマニュアルに含まれています。
@xref{Frequently Asked Questions}.

@item
@acronym{TLS} ラッパーが Gnus に同梱されました。

@acronym{TLS}/@acronym{SSL} が、@file{tls.el} と GnuTLS を介し
て @acronym{IMAP} と @acronym{NNTP} でサポートされるようになりました。

@item
改良された spam 対抗機能。

Gnus は非常に変化に富んだプログラムと濾過の規則を使って、メールやニュー
スの奔流から spam を抜き取ってしまうことができるようになりました。対応し
ている方式は、RBL blocklists、bogofilter それにホワイト/ブラックリストで
す。また SpamAssassin や Hashcash のような外部パッケージを容易に使うため
の hook も新しくなりました。@ref{Thwarting Email Spam} およ
び @ref{Spam Package}.
@c FIXME: @xref{Spam Package}?.  これは Misc の下にあるべきか?

@item
Gnus は Sieve を使ったサーバー側でのメールの濾過をサポートします。

Sieve の規則はグループパラメーターとして加えることができ、グループバッファー
で @kbd{D g} を使うと完全な Sieve スクリプトが生成されます。そうしたら、
生成された Sieve バッファーで @kbd{C-c C-l} を使って、サーバーにアップロー
ドしてください。@ref{Sieve Commands}、それに新しい Sieve のマニュア
ル (@pxref{Top, ,Top, sieve-ja, Emacs Sieve}) を参照してください。
@end itemize

@item グループモードの変更
@c ***********************

@itemize @bullet
@item
@code{gnus-group-read-ephemeral-group} を @kbd{G M} キーで対話的に呼ぶこ
とができます。

@item
憲章とコントロールメッセージの取得。

二つの新しいコマンドで、ニュースグループの憲章を取り込む (@kbd{H c}) こ
とと、コントロールメッセージを取得する (@kbd{H C}) ことができます。

@item
新しい変数 @code{gnus-parameters} を、グループパラメーターを設定するため
に使うことができます。

これは初期には、パラメーターを @file{~/.newsrc.eld} に格納する @kbd{G p}
(または @kbd{G c}) でしか行なうことができませんでしたが、この変数によっ
てカスタマイズの威力を堪能することができます。また、その変数
は @file{~/.newsrc.eld} ではなくて @file{~/.gnus.el} で設定するので、バッ
クアップが簡単になります。その変数は、グループ名に合致する正規表現を、以
下のような流儀でグループパラメーターに割り当てます:

@lisp
(setq gnus-parameters
      '(("mail\\..*"
         (gnus-show-threads nil)
         (gnus-use-scoring nil))
        ("^nnimap:\\(foo.bar\\)$"
         (to-group . "\\1"))))
@end lisp

@item
nnimap のグループにおける未読の数が正確になりました。

グループバッファーで表示される nnimap グループの未読記事の数の見積りが正
確になったはずです。これは @code{gnus-setup-news-hook} (起動時に呼ばれ
る) と @code{gnus-after-getting-new-news-hook} (新しいメールを取得した直
後に呼ばれる) から @code{nnimap-fixup-unread-after-getting-new-news} を
呼ぶことによって成し遂げられます。これらの変数をディフォルトではない値に
変えている場合は、重ね
て @code{nnimap-fixup-unread-after-getting-new-news} を追加する必要があ
るかもしれません。見積りに満足していて、新しいメールを取得するときにいく
らかの (わずかな) 時間を節約したいのであれば、その関数を外してください。

@item
グループ名は、ディフォルトで UTF-8 であるものとして取り扱われます。

これは USEFOR が移行しようとしていると想定されるものです。カスタマイズす
るには @code{gnus-group-name-charset-group-alist} およ
び @code{gnus-group-name-charset-method-alist} を参照してください。

@item
@code{gnus-group-charset-alist} と @code{gnus-group-ignored-charsets-alist}

これらの変数に設定された正規表現は、完全な (full) グループ名と比較されま
す。Gnus 5.8 では実際の (real) グループ名が比較の対象でした。したがって、
これらの変数をカスタマイズしている利用者は、正規表現を変更しなければなり
ません。例です:

@lisp
("^han\\>" euc-kr) -> ("\\(^\\|:\\)han\\>" euc-kr)
@end lisp

@item
入ってきたメールを一時蓄えるファイル (@file{Incoming*}) の古いものは、即
時ではなく何日か後に消去されます。@xref{Mail Source Customization}.
(Gnus 5.10.10 / Emacs 22.2 の新機能)
@end itemize

@item 概略モードと記事モードの変更
@c *******************************

@itemize @bullet
@item
領域が活性化されている場合に、
@kbd{F} キー (@code{gnus-article-followup-with-original}) およ
び @kbd{R} キー (@code{gnus-article-reply-with-original}) は、その領域に
あるテキストだけを yank します。

@item
ドラフト・グループで @kbd{e} キーが @code{gnus-draft-edit-message} コマ
ンドに割り当てられました。@code{gnus-summary-edit-article} コマンドには、
代わりに @kbd{B w} キーを使ってください。

@item
記事のボタン。

URL、メールアドレス、Message-ID、Info へのリンク、man ページと Emacs ま
たは Gnus に関連した参考文献のための、より多くのボタンが追加されました。
@xref{Article Buttons}. すべての記事のボタンの見栄えを制御するため
に @code{gnus-button-@var{*}-level} 変数を使うことができます。
@xref{Article Button Levels}.

@item
単一の yenc でエンコードされた添付パートをデコードすることができます。

@item
Picons

Picon のコードが、GNU Emacs で動作させるために再実装されました。以前のい
くつかのオプションが、削除または改名されています。

Picon は、利用者、ドメイン、それにニュースグループを表現するための「個人
的なアイコン (personal icons)」で、記事バッファーに表示することができま
す。@xref{Picons}.

@item
新しいオプション @code{gnus-treat-body-boundary} を非-@code{nil} にする
と、ヘッダーのおしまいに境界線が描かれます。

@item
署名された記事のヘッダー (X-PGP-Sig) を、@kbd{W p} で認証することができ
ます。

@item
概略バッファーは fringe の中の矢印で現在の記事を示します。これを無効にす
るには @code{(setq gnus-summary-display-arrow nil)} を使ってください。

@item
ニュースにメールで返信しようとしたら警告します。

間違ってニュースにメールで返信しようとしてしまうことが、しょっちゅうあり
ませんか?  そんなあなたに新オプショ
ン @code{gnus-confirm-mail-reply-to-news}。

@item
新しいオプション @code{gnus-summary-display-while-building} を
非-@code{nil} にすると、概略バッファーが作られていく様子が表示されます。

@item
Gnus は RFC 2369 のメーリングリストのヘッダーをサポートします。また、メー
リングリストのグループ用に数々のコマンドを用意しました。@xref{Mailing
List}.

@item
日付ヘッダーを、英語で発音できる形式で表示することができます。
@xref{Article Date}.

@item
@code{mm-uu-diff-groups-regexp} に合致するグループでは、差分 (diffs) が
自動的にハイライトされます。

@item
マイクロソフト引用様式のより良い取り扱い。

いくつかのマイクロソフトのメイラーが、メッセージの残りの部分が引用である
ことを示すために使う台無しにされたヘッダーブロックを、たとえそれが引用符
で囲まれていなくても、Gnus はとにかく認識しようとします。変
数 @code{gnus-cite-unsightly-citation-regexp} は、それらの引用の先頭に合
致します。

新しい @kbd{W Y f} コマン
ド (@code{gnus-article-outlook-deuglify-article}) で、醜く壊れた Outlook
(Express) の記事を整形し直すことができます。

@item
@code{gnus-article-skip-boring}

@code{gnus-article-skip-boring} を @code{t} に設定すると、Gnus はうんざ
りする文しか含んでいないページを見せるために、下方にスクロールしません。
@code{gnus-article-boring-faces} を使って、何を読み飛ばしてしまっても良
いかをカスタマイズすることができます。

てっぺんに少しだけある新規な内容に、長くて刈り込まれていない引用が続いて
いるたくさんの記事を読む場合に、これは特に役に立ちます。

@item
スマイリー (@samp{:-)}, @samp{;-)} など) が Emacs でもアイコン化されるよ
うになりました。

これを働かないようにするには、@code{(setq gnus-treat-display-smileys
nil)} を @file{~/.gnus.el} に置いてください。

@item
Face ヘッダーを扱えるようになりました。@xref{Face}.

@item
概略バッファーで、新しいコマンド @kbd{/ N} は新着メッセージを挿入し、
@kbd{/ o} は古いメッセージを挿入します。

@item
@kbd{W m} を押すと、Gnus はモールスでエンコードされたメッセージをデコー
ドします。

@item
@code{gnus-summary-line-format}

ディフォルト値が @samp{%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n} に変わりまし
た。さらに、受信者の名前か @acronym{NNTP} グループに投稿したグループ名で
利用者名を置き換えるために、@code{gnus-extra-headers}、
@code{nnmail-extra-headers} および @code{gnus-ignored-from-addresses} の
ディフォルト値が変わりました。

@item
添付ファイルの消去。

@code{gnus-mime-save-part-and-strip} コマンド (@acronym{MIME} ボタン上
で @kbd{C-o} に割り当てられている) は、パートをセーブしてから外部のそれ
と置き換えます。@code{gnus-mime-delete-part} (@acronym{MIME} ボタン上
で @kbd{d} に割り当てられている) は、パートを削除します。これは編集をサ
ポートしているバックエンドでだけ動作します。

@item
@code{gnus-default-charset}

ディフォルト値は @code{iso-8859-1} に代わっ
て @code{current-language-environment} 変数によって決定される値になりま
す。また、@code{gnus-group-charset-alist} にあった @samp{.*} の項目は削
除されました。

@item
印刷の性能が向上しました。

Gnus はそれ自身が、概略と記事バッファーにおけ
る @kbd{O P} で Muttprint をサポートします。さらに @acronym{MIME} ボタン
上で @kbd{p} を使うことによって、個々の @acronym{MIME} パートのそれぞれ
を印刷することができます。

@item
拡張された書法仕様 (format specs)。

書法仕様 @samp{%&user-date;} が @code{gnus-summary-line-format-alist} に
追加されました。それに、利用者定義による拡張されたフォーマットの仕様もサ
ポートされています。拡張された書法仕様は @samp{%u&foo;} のようなもので、
関数 @code{gnus-user-format-function-@var{foo}} を起動します。
@samp{&} がエスケープ文字に使われているので、古い利用者定義書法であ
る @samp{%u&} は今ではサポートされていません。

@item
@kbd{/ *} (@code{gnus-summary-limit-include-cached}) が書き直されました。
@c FIXME: これは利用者に見える変更だったのか?

これは @kbd{Y c} (@code{gnus-summary-insert-cached-articles}) の別名でし
た (訳注: 以前は)。新しい関数は他の記事を濾過して除去します。

@item
いくつかの制限命令は @kbd{C-u} 接頭引数で合致の否定を扱うことができます。

@kbd{C-u} を subject、author または extra ヘッダー、すなわち @kbd{/ s}、
@kbd{/ a} およ
び @kbd{/ x} (@code{gnus-summary-limit-to-@{subject,author,extra@}}) で
使うと、結果としてその表現に合致しないすべての記事が表示されます。

@item
Gnus は外部パート (message/external) をインライン表示します。
@end itemize

@item Message モードの変更と関連する Gnus の機能
@c *********************************************

@itemize @bullet
@item
遅延記事。

Message バッファーにおける @kbd{C-c C-j} で、メッセージの送信を遅らせる
ことができます。メッセージは指定された時刻に配送されます。これはあなた自
信のための忘備録として役に立つでしょう。@xref{Delayed Articles}.

@item
@code{auto-compression-mode} が有効になっていると、添付ファイルを見ると
きに自動で圧縮が解かれます。

@item
新しいオプション @code{gnus-gcc-mark-as-read} は、Gcc の記事に自動的に既
読の印を付けます。

@item
添付ファイルの切り離し (externalizing)。

@code{gnus-gcc-externalize-attachments} また
は @code{message-fcc-externalize-attachments} が非-@code{nil} になってい
ると、ローカルファイルを外部パートとして添付します。

@item
Sendmail を使うときのエンベロープ送信者 (envelope sender) のアドレスが、
カスタマイズできるようになりました。@xref{Mail Variables, ,メール変数,
message-ja, The Message Manual}.

@item
Gnus は今では Sender: ヘッダーを自動では生成しません。

それは初期においては、利用者が設定した email アドレスが Gnus が想定した
利用者のディフォルトのアドレスと違っていた場合に生成されました。今日では
その想定アルゴリズムが正しいことはまれで、Sender: ヘッダーの唯一の (議論
の的になる) 用途は、ニュースを cancel/supersede する資格があるかどうかを
検査すること (これは代わりに、他の章で述べられる Cancel Locks によって解
決されました) なので、そのヘッダーの生成はディフォルトで抑制されています。
変数 @code{message-required-headers}、
@code{message-required-news-headers} およ
び @code{message-required-mail-headers} を参照してください。

@item
サードパーティーによる @file{message-utils.el} の機能
が @file{message.el} に加えられました。

Message は表題の行から @samp{(was: <old subject>)} を削除するかどうかを
尋ねるようになりました (@code{message-subject-trailing-was-query} 参照)。
@kbd{C-c M-m} と @kbd{C-c M-f} は挿入されたテキストを示す印を挿入します。
@kbd{C-c C-f a} は X-No-Archive: ヘッダーを付け加えます。@kbd{C-c C-f
x} は、適切なヘッダーと、クロスポストとフォロー先についての注意書きを本
文に挿入します (@code{message-cross-post-@var{*}} 変数群を見てください)。

@item
今や @code{message-generate-headers-first} が @code{nil} だったら、メッ
セージの作成を始めるときに References と X-Draft-From ヘッダーは生成され
ません。

@item
X-Faces ヘッダーの挿入が簡単になりました。@xref{X-Face}.

@item
グループカーボンコピー (GCC) を引用符で囲む。

空白や他の変な文字を含むグループを扱えるようにするために、グループ
は Gcc: header に置かれる前に引用符で囲まれます。これは、空白を含むグルー
プが使えるようにするために、もはや @code{gnus-message-archive-group} の
ような変数に引用文字を含めるべきではないことを意味します。さらに、文字
列 @samp{nnml:foo, nnml:bar} (二つのグループに Gcc を格納することを示
す) を使っているならば、@code{("nnml:foo" "nnml:bar")} というリストを返
すように変更しなければなりません。さもないと、Gcc: 行は間違った囲まれ方
をされてしまうでしょう。初期のころに文字列 @samp{nnml:foo, nnml:bar} を
返すようにしたことが間違いだったことに着目してください。それは直接挿入さ
れたので、まったく問題を生じませんでした。

@item
@code{message-insinuate-rmail}

@c FIXME それは 'message-user-agent ではだめですか?
@code{(message-insinuate-rmail)} と @code{(setq mail-user-agent
'gnus-user-agent)} を @file{~/.emacs} に加えることによって、
@code{message-mode} でメッセージの作成、返信および転送を行なうよう
に Rmail を説得することができます。そこでは @acronym{MML} の威力を堪能す
ることができます。

@item
@code{message-minibuffer-local-map}

この下の行は、メッセージを再送するときに BBDB を使えるようにします:
@lisp
(define-key message-minibuffer-local-map [(tab)]
  'bbdb-complete-name)
@end lisp

@item
@code{gnus-posting-styles}

このような合致の様式が加わりました。

@lisp
((header "to" "larsi.*org")
 (Organization "Somewhere, Inc."))
@end lisp

下記のような古い様式は時代遅れになりましたが、まだ受け入れられます。

@lisp
(header "to" "larsi.*org"
        (Organization "Somewhere, Inc."))
@end lisp

@item
@code{message-ignored-news-headers} と @code{message-ignored-mail-headers}

@samp{X-Draft-From} と @samp{X-Gnus-Agent-Meta-Information} が、これら二
つの変数に加えられています。それらをカスタマイズする場合に、もしかすると
それら二つのヘッダーも加える必要があります。

@item
Gnus は“format=flowed”(RFC 2646) パラメーターをサポートします。メッセー
ジを作成するときに、それは @code{use-hard-newlines} で活性化されます。
format=flowed のデコードは以前からできましたが、初期の版では説明の文書が
ありませんでした。

@item
@code{mm-fill-flowed} オプションで“format=flowed”メッセージを流動テキ
ストとして処理することをやめさせることができます。また、PGP 署名が埋め込
まれたメッセージを送信するとき、流動テキストの処理は行なわれません。
@xref{Flowed text, ,流動テキスト, emacs-mime-ja, The Emacs MIME Manual}.
(Gnus 5.10.7 の新機能)
@c このエントリーは "No Gnus" 節にもあります。

@item
Gnus は RFC 2298 の開封確認要求の生成をサポートします。

これはメッセージモードの @kbd{C-c M-n} キーで呼び出されます。

@item
Message は Importance: ヘッダー (RFC 2156) をサポートするようになりまし
た。

メッセージバッファーで @kbd{C-c C-f C-i} か @kbd{C-c C-u} を使うと、可能
な値が循環します。

@item
Gnus はニュースの Cancel Locks をサポートします。

投稿するニュース記事に @samp{Cancel-Lock} ヘッダーが挿入されることです。
これは、記事をあなたが書いたのかどうかを確かめるために使います (キャンセ
ルと置き換えのとき)。最初に記事を投稿するときに、Gnus はランダムなパスワー
ド文字列を生成し、カスタムの機構を使って @file{~/.emacs} にセーブします。
その変数は @code{canlock-password} と呼ばれますが、機密を気にするデータ
ではありません。ウェブ上で canlock を公開しても、以前から彼女にできなかっ
た何かを、誰かができるようにするものではありません。
@code{message-insert-canlock} をカスタマイズすることによって、振る舞いを
変更するができます。

@item
Gnus は @acronym{PGP} (RFC 1991/2440)、@acronym{PGP/MIME} (RFC
2015/3156) および @acronym{S/MIME} (RFC 2630--2633) をサポートします。

これには @acronym{S/MIME} と OpenPGP が実装されている必要があります。で
も追加の Lisp ライブラリーは要りません。メッセージの作成時に、いくつかの
メニューと @kbd{C-c @key{RET}} キーの割り当てが Attachments メニューに追
加されます。これはまた、@code{gnus-article-hide-pgp-hook} を時代遅れにし
ました。

@item
@acronym{MML} (Mime 作成) コマンドの接頭キーが、@kbd{M-m} から @kbd{C-c
C-m} に変わりました。

この変更によって、標準キー割り当ての @code{back-to-indentation} との衝突
が回避されました。このコマンドもまた、メッセージモードでは役に立つのです。

@item
@code{message-forward-show-mml} のディフォルトが @code{best} というシン
ボルに変わりました。

値 @code{best} の振る舞いは、それがふさわしい場合は @acronym{MML} を表示
する (すなわち @acronym{MIME} に変換する) ことです。変換がディジタル署名
を無効にしてしまうので、署名された、または暗号化されたメッセージを転送す
るときは @acronym{MML} は使われません。

@item
@code{auto-compression-mode} が有効になっていると、添付ファイルを見ると
きに自動で圧縮が解かれます。
@c FIXME: これは記事モードまたは message モードに影響する?

@item
非-@acronym{ASCII} ドメイン名のサポート。

Message は From:, To: および Cc: にある非-@acronym{ASCII} ドメイン名をサ
ポートし、メッセージの送信をしようとしたときにエンコードするかどうかを尋
ねます。@code{message-use-idna} 変数でこれを制御します。Gnus もまた、メッ
セージを見るときに From:, To: および Cc: にある非-@acronym{ASCII} ドメイ
ン名をデコードします。これを制御するのは @code{gnus-use-idna} 変数です。

@item
Message バッファーに添付ファイルをドラッグ＆ドロップすることができます。

@code{mml-dnd-protocol-alist} と @code{mml-dnd-attach-options} を参照し
てください。@xref{MIME, ,MIME, message, The Message Manual}.
@c New in 5.10.9 / 5.11 (Emacs 22.1)

@item
@code{auto-fill-mode} が Message モードでディフォルトで有効になります。
@code{message-fill-column} を参照してください。@xref{Various Message
Variables, ,いろいろなメッセージ変数, message-ja, The Message Manual}.
@c New in Gnus 5.10.12 / 5.11 (Emacs 22.3)
@end itemize

@item バックエンドの変更
@c *********************

@itemize @bullet
@item
Gnus は RSS のニュース配送を、ニュースグループとして表示します。
@xref{RSS}.

@item
nndoc バックエンドは、mailman のまとめ送りと exim が弾いたメッセージをサ
ポートするようになりました。

@item
Gnus は Maildir グループをサポートします。

Gnus は新バックエンドである @file{nnmaildir.el} を含んでいます。
@xref{Maildir}.

@item
nnml と nnfolder バックエンドは、グループ毎に印 (marks) を格納するように
なりました。

これは nnml/nnfolder サーバー/グループ を @file{~/.newsrc.eld} と切り離
して、しかし印は守りつつ、バックアップすることを可能にします。さらに、例
えば研究室や職場などの組織内で、(@file{~/.newsrc.eld} ファイルを共有する
こと無しに) 利用者間で記事と印を共有することをも可能にします。これは、
@file{~/.newsrc.eld} に格納される印を、グループ毎の @file{.marks} ファイ
ル (nnml 用) と @file{@var{groupname}.mrk} ファイル (@var{groupname} の
名前を持つ nnfolder 用) に格納することによって動作します。
nnml/nnfolder を他のマシンに引っ越しても、
Gnus は @file{~/.newsrc.eld} にある情報の代わりに、自動的
に @file{.marks} か @file{.mrk} ファイルを使います。新しいサーバー変数で
ある @code{nnml-marks-is-evil} と @code{nnfolder-marks-is-evil} が、この
機能を抑制するために使うことができます。
@end itemize

@item 外見に関すること
@c *******************

@itemize @bullet
@item
グループと概略バッファーのメニューバー項目の名前“Misc”は“Gnus”に改名
されました。

@item
Message mode で“@acronym{MML}”と名付けられたメニュー項目は
“Attachments”に改名されました。このメニューは、署名と暗号
化 (@pxref{Security, ,セキュリティー, message-ja, The Message
Manual}) のような、セキュリティーに関連したものも含んでいることに着目し
てください。

@item
ツールバーがグループ、概略および Message モードで GNOME のアイコンを使う
ように更新されました。ツールバーはカスタマイズ可能です: @kbd{M-x
customize-apropos @key{RET} -tool-bar$} から始めてください。これは Gnus
5.10.10 の新機能です。

@item
ツールバーのアイコンが正しく有効に (または無効に) なります。グループバッ
ファーで変数 @code{gnus-group-update-tool-bar} を参照してください。その
ディフォルト値は Emacs のバージョンに依存しています。これは Gnus 5.10.9
の新機能です。
@end itemize

@item その他の変更
@c ***************

@itemize @bullet
@item
@code{gnus-agent}

Gnus エージェントは大規模な更新を経て、今やディフォルトで有効になります。
そし
て @code{gnus-select-method} と @code{gnus-secondary-select-method} で指
定されるすべての nntp と nnimap のサーバーが、ディフォルトでエージェント
化されます。初期においては @code{gnus-select-method} のサーバーだけがディ
フォルトでエージェント化され、エージェントはディフォルトでは有効にされま
せんでした。エージェントが有効にされると、今では可能ならばバックエンドに
代わってエージェントのキャッシュからヘッダーが取り寄せられます。初期には、
これはオフライン (unplugged) の状態でのみ行なわれていました。サーバーバッ
ファーで @kbd{J a} と @kbd{J r} を使うことによって、サーバーの登録と削除
を行なうことができます。グループバッファーから @kbd{J u} か @kbd{J s} を
使って命令しない限り、Gnus は記事をエージェントのキャッシュにダウンロー
ドしません。@code{(setq gnus-agent nil)} を設定することによって、エージェ
ントが有効にされていなかった昔の振る舞いに戻すことができます。もは
や @file{~/.gnus.el} に @code{(gnus-agentize)} を置いておく必要が無いこ
とに注意してください。

@item
Gnus は plugged のときに、エージェントに @acronym{NOV} と記事を読み込み
ます。

Plugged のときに記事を読む場合に、その記事がすでにエージェントにあるなら
ば、もう一度ダウンロードすることはありません。@code{(setq
gnus-agent-cache nil)} は旧式の動作に戻します。

@item
Dired の統合。

@code{gnus-dired-minor-mode} (@ref{Other modes} 参照) は dired のバッファー
で、添付ファイルを送信する、mailcap の適切な項目を使ってファイルを開く、
それに mailcap の項目を使ってファイルを印刷するためのキーを割り当てます。

@item
ポイントの位置決めのための書法仕様 (format spec) である @code{%C} は、
@code{%*} に変更されました。

@item
@code{gnus-slave-unplugged}

オフラインの Gnus をスレーブモードで起動する新しいコマンドです。
@end itemize
@end itemize

@node No Gnus
@subsubsection No Gnus
@cindex No Gnus

No Gnus の新しい機能:
@c FIXME: Gnus 5.12?

@itemize @bullet
@item サポートしている Emacs のバージョン

No Gnus は以下の Emacs のバージョンをサポートします:

@itemize @bullet
@item Emacs 22 以上
@end itemize

@item インストールに関する変更

@itemize @bullet
@item No Gnus を使ったことがあるが、以前の (安定した) 版に戻してしまった
人たちへの注意。

No Gnus (このリリースにつながる不安定な Gnus の枝) を試してみたものの、
安定版に戻してしまっている場合、このバージョンへアップグレードするときに
は注意してください。特に、@file{~/News/marks} ディレクトリーの内容を (も
しかしたら注意深く選んで) 削除する必要があるでしょう。(訳注: 削除しない
と、新しい No Gnus を再び使い始めたときに安定版を使っていた時期に更新さ
れなかった marks ファイルが読み込まれて、@file{~/.newsrc.eld} ファイルの
既読記事番号などを古いもので上書きしてしまいます。)  削除することによっ
て、このリリースで nntp のフラグを保存している marks ファイルからではな
く @file{~/.newsrc.eld} からフラグを読むようになります (訳注: そして新し
い marks ファイルが作られます)。nntp marks については、次の項目でさらに
詳しい情報を得ることができます。一般にダウングレードすることは安全ではあ
りません。

@item Emacs 23 から Emacs 22 に切り替えると非互換性の問題が生じます。

Emacs 23 では、Gnus は記事のドラフトと @file{~/.newsrc.eld} を保存するた
めに Emacs の新しい内部 coding system である @code{utf-8-emacs} を使いま
す。これらのファイルは Emacs 22 以下では正しく読み込まれないかもしれませ
ん。Gnus を異なるバージョンの Emacs にまたがって使いたい場合は、
@code{mm-auto-save-coding-system} を @code{emacs-mule} に設定すれば良い
でしょう。
@c FIXME: 未検証。(それとも誰かテストしましたか?)
@c http://thread.gmane.org/gmane.emacs.gnus.general/66251/focus=66344 参照。

@item Lisp ファイルがディフォルトで @file{.../site-lisp/gnus/} にインス
トールされるようになりました。

以前は @file{.../site-lisp/} がディフォルトでした。加えて、新しい
インストーラーは他にインストールされている、新しい Gnus より
優先される Gnus を検出して警告を発します。それらを手動で取り
除いても良いし、@code{make remove-installed-shadows} を使って
削除することもできます。

@item インストール先のディレクトリ名が空白文字を含むことを許容します。
@end itemize

@item Gnus に含まれる新しいパッケージとライブラリー

@itemize @bullet
@item @code{nnimap} の新バージョン

@code{nnimap} はほとんどの互換性を保って再実装されました。新しいインター
フェースについての説明は Gnus マニュアルを見てください。特
に @code{nnimap-inbox} とクライアント側での分割方法が変化しています。

@item Gnus は Emacs Lisp @acronym{SASL} ライブラリーを含むようになりまし
た。

これによって、Emacs の中から @acronym{SASL} の機構を利用するために、すっ
きりした @acronym{API} を使うことができます。利用者の目に見える利点は、
以前は無かった @acronym{DIGEST}-@acronym{MD5} と @acronym{NTLM} がサポー
トされるようになったことです。@xref{Top, ,Emacs SASL, sasl-ja, Emacs
SASL}.

@item ManageSieve の接続に、ディフォルトで @acronym{SASL} ライブラリーを
使うようになりました。

これによる主な変更点は、サーバーがサポートしている場合
に @acronym{DIGEST-MD5} と @acronym{NTLM} をサポートするようになったこと
です。

@item Gnus は password.el にパスワードをキャッシュする機構を含めました。

パスワードキャッシュはディフォルトで有効です (@code{password-cache} を
参照)。タイムアウトは 16秒と短いです (@code{password-cache-expiry} を参
照)。@acronym{PGG} を @acronym{PGP} のバックエンドとして使う場合に、
@acronym{PGP} のパスフレーズはこの機構で管理されます。ManageSieve 接続の
パスワードは、利用者にそうするかどうかを尋ねてから、この機構が管理します。

@item Gnus は EasyPG を使います。

EasyPG を使うことができる場合、Gnus は @acronym{PGG} の代わりにそれを使
います。EasyPG は GNU Privacy Guard へのユーザーインターフェースです。
@xref{Top, ,EasyPG Assistant user's manual, epa, EasyPG Assistant user's
manual}.  EasyPG は Emacs 23 に含まれていますが、単独でも利用可能です。
@end itemize

@item グループモードの変更
@c ***********************

@itemize @bullet
@item
@code{gcc-self} のようなシンボルは @code{gnus-parameters} と同じ、つまり
他の実在の変数がそうであるような優先度決定規則を持つようになりました。あ
る条件に最初に合致するものではなく、最後に合致するものが採用されます。

@item
入ってきたメールを一時蓄えるファイル (@file{Incoming*}) の古いものは、即
時ではなく何日か後に消去されます。@xref{Mail Source Customization}.
(Gnus 5.10.10/No Gnus 0.8 の新機能)
@c このエントリーは "Oort Gnus" 節にもあります。
@end itemize

@item 概略モードと記事モードの変更

@itemize @bullet
@item @acronym{HTML} をどう描画するかを決めるのは、現在はたったひとつの
変数です: @code{mm-text-html-renderer}.

@item 粘着記事バッファーを使えるようになりました。これは、別の記事を選択
したときに再利用されない記事バッファーです。@xref{Sticky Articles}.
@c
@c @item ブックマーク
@c FIXME: 追加すべし

@item Gnus は @kbd{K H} で @samp{text/html} 記事を WWW ブラウザーで選択
的に表示することができます。@xref{MIME Commands}.
@c
@c gnus-registry-marks
@c FIXME: 追加すべし

@item 国際化ホスト名 (@acronym{IDNA}) を、@kbd{W i}
(@code{gnus-summary-idna-message}) を使うことによって、記事の本文中でデ
コードできるようになりました。この機能を使うには GNU Libidn
(@url{https://www.gnu.org/software/libidn/}) をインストールしておく必要
があります。
@c FIXME: @code{message-use-idna} も書かなくていい?

@item 非-@acronym{ASCII} グループ名の取り扱いが非常に改善されました。完
全にサポートしているバックエンドは現在 @code{nntp}, @code{nnml}, およ
び @code{nnrss} です。エージェント、キャッシュ、それに印 (marks) もそれ
らのバックエンドで機能します。@xref{Non-ASCII Group Names}.

@item Gnus は dns-mode を使って text/dns として送信され
た @acronym{DNS} マスターファイルを表示します。

@item Gnus は概略バッファーで新しい制限コマンド @kbd{/ r}
(@code{gnus-summary-limit-to-replied}) と @kbd{/ R}
(@code{gnus-summary-limit-to-recipient}) をサポートします。
@xref{Limiting}.

@item @kbd{Y t} (@code{gnus-summary-insert-ticked-articles}) を使って、
サーバーからすべての可視記事を取り寄せることができるようになりました。
@xref{Summary Generation Commands}.

@item Gnus は概略バッファーで新しい並べ替えコマンド @kbd{C-c C-s C-t}
(@code{gnus-summary-sort-by-recipient}) をサポートします。
@xref{Summary Sorting}.

@item @acronym{S/MIME} が @acronym{LDAP} の利用者証明書の検索に使えるよ
うになりました。@code{smime-ldap-host-list} でサーバーを設定する必要があ
ります。

@item Open@acronym{PGP} ヘッダーにある URL をクリックすると、ヘッダーが
ダウンロードされてあなたの PGP の鍵束に取り込まれます。

@item
Picon はテキストの対象物の右側に表示できるようになりました。
@code{gnus-picon-style} を見てください。@xref{Picons}.

@item @acronym{ANSI} @acronym{SGR} 制御シーケンスを @kbd{W A} で変換する
ことができます。

中国語のニュース階層のグループにおいて、記事をハイライト表示するため
に @acronym{ANSI} シーケンスが使われま
す (@code{gnus-article-treat-ansi-sequences})。

@item Gnus は記事に“MIME-Version”ヘッダーがなくても記事を MIME デコー
ドします。このために @code{gnus-article-loose-mime} のディフォルト値が変
更されました。

@item @code{gnus-decay-scores} をスコアファイルに合致する正規表現にでき
ます。例えば @samp{\\.ADAPT\\'} に設定すると、適応スコアファイルだけが減
衰されるようになります。@xref{Score Decays}.

@item @code{gnus-ignored-from-addresses} を使う場合に、概略行におい
て @code{To} と @code{Newsgroup} ヘッダーに相当する場所の最初に表示する
文字列を、@code{gnus-summary-to-prefix} およ
び @code{gnus-summary-newsgroup-prefix} でカスタマイズすることができます。
@xref{To From Newsgroups}.

@item @acronym{MIME} パートを外部にある本体で置き換えることができます。
@code{gnus-mime-replace-part} と @code{gnus-article-replace-part} を見て
ください。@xref{MIME Commands}, @ref{Using MIME}.

@item
@code{mm-fill-flowed} オプションで format=flowed なメッセージの取り扱い
を無効にすることができます。また、@acronym{PGP} の署名が埋め込まれたメッ
セージを送信するときに、flowed text は無効にされます。@xref{Flowed text,
,流動テキスト, emacs-mime-ja, The Emacs MIME Manual}.  (Gnus 5.10.7 の新
機能)
@c このエントリーは "Oort Gnus" 節にもあります。

@item 新コマンド @kbd{S W} (@code{gnus-article-wide-reply-with-original}) は
記事バッファーで広い返答をするためのもので、もし領域が設定され
たテキストがあれば @kbd{R} コマン
ド (@code{gnus-article-reply-with-original}) と同様にそれを引用します。
以前は @kbd{R} コマンドに広い返答をさせるために使われた接頭引数が、今で
は受け付けられないことに注意してください。@xref{Article Keymap}.

@item 記事バッファーで使う新コマンド @kbd{C-h b}
(@code{gnus-article-describe-bindings}) は、記事コマンドだけでなく記事バッ
ファーから利用することができる真の簡略コマンドも表示します。
@end itemize

@item Message モードの変更

@itemize @bullet
@item すべての送信済みメッセージのディフォルトの保存先が、月ごと
の nnfolder アーカイブになりました。

@item Gnus は“hashcash”client puzzle anti-spam の機構をサポートします。
@code{(setq message-generate-hashcash t)} で有効になります。
@xref{Hashcash}.

@item メッセージバッファに添付ファイルをドラッグ＆ドロップできます。
@code{mml-dnd-protocol-alist} と @code{mml-dnd-attach-options} を見てく
ださい。@xref{MIME, ,MIME, message-ja, Message Manual}.

@item @code{message-yank-empty-prefix} オプションで、引用文の空行にどん
な引用符を付けるかを制御することができます。@xref{Insertion Variables,
,挿入するための変数, message-ja, Message Manual}.

@item Gnus はメッセージバッファーでヘッダーを隠すために、それら以外の部
分だけが見えるようにバッファーを狭めます。@code{References} はディフォル
トで表示されません。すべてのヘッダーが見えるようにするに
は @code{(setq message-hidden-headers nil)} としてください。
@xref{Message Headers, ,メッセージヘッダー, message-ja, Message Manual}.

@item You can highlight different levels of citations like in the
article buffer.  See @code{gnus-message-highlight-citation}.

@item 記事バッファーでできるのと同様に、引用された文のレベルの違いに応じ
たハイライトを行うことができます。
@code{gnus-message-highlight-citation} を参照してください。

@item Message モードでは @code{auto-fill-mode} がディフォルトで ON にな
ります。@code{message-fill-column} を参照してください。@xref{Message
Headers, ,メッセージヘッダー, message-ja, Message Manual}.

@item 署名ファイルを @code{message-signature-directory} 変数で指定するディ
レクトリーに置くことができます。

@item "○○さん writes:" のような行の形式を、オプショ
ン @code{message-citation-line-format} で指定することができます。これを
使うには @code{message-citation-line-function} 変数
を @code{message-insert-formatted-citation-line} に設定する必要がありま
す。
@end itemize

@item サーバー閲覧モードの変更

@itemize @bullet
@item Gnus の洗練された講読方法がサーバー閲覧バッファーで利用可能です。

変数 @code{gnus-browse-subscribe-newsgroup-method} を使ってください。
@end itemize

@item バックエンドの変更

@itemize @bullet
@item nntp バックエンドは記事の印を @file{~/News/marks} に保管します

そのディレクトリーは @code{nntp-marks-directory} という (カスタマイズ可
能な) 変数で変更することができます。また、nntp で印を使うこと
を @code{nntp-marks-is-evil} という変数 (バックエンド変数) で無効にする
ことができます。印を使うことの利点は、@file{~/News/marks} を別のホストに
インストールされた Gnus にも (rsync, scp などを使って) コピーすることに
よって、どの記事を読んでどの記事に印を付けたかの情報を、そこでも維持でき
ることです (訳注: 同じ nntp サーバーに接続する場合に限ります)。
@file{~/News/marks} のデータは @file{~/.newsrc.eld} にある同じデータより
優先されます。

@item
@acronym{RSS} の購読情報を @acronym{OPML} のファイルから取り込み、または
書き出すことができるようになりました。@xref{RSS}.

@item @acronym{IMAP} の identity (@acronym{RFC} 2971) をサポートします。

ディフォルトでは Gnus はそれ自身に関する情報を送信しませんが、
@code{nnimap-id} 変数を使ってそれをカスタマイズすることができます。

@item @code{nnrss} バックエンドは多言語テキストをサポートします。
@code{nnrss} グループでは非-ASCII 文字列を使ったグループ名もサポートされ
ます。@xref{RSS}.

@item @acronym{POP3} によるメールの取得において、
@acronym{SSL}/@acronym{TLS} と StartTLS をサポートするようになりました。

@item nnml バックエンドではメッセージを圧縮するために @file{gzip} 以外の
プログラムも使うことができます。@xref{Mail Spool}.

@item nnml バックエンドではグループを圧縮することができます。

関数 @code{gnus-group-compact-group} (グループバッファー
の @kbd{G z} キー) および @code{gnus-server-compact-server} (サーバーバッ
ファーの @kbd{z} キー) で呼び出すこの機能は、グループのすべての記事の番
号を 1 から順に振り直して、すきまを取り除きます。その結果として、正しい
全記事数を得ることができます (再びメッセージが削除されるまでは)。
@c
@c @item nnmairix.el
@c FIXME
@c
@c @item nnir.el
@c FIXME
@end itemize

@item 外見
@c もしかしたら "その他" から切り離す価値は無い?

@itemize @bullet
@item ツールバーが GNOME のアイコンを使うように更新されました。ツールバー
をカスタマイズすることもできます:
@kbd{M-x customize-apropos @key{RET} -tool-bar$} で始めてください。
@c FIXME: これをマニュアルに書くべし。

@item ツールバーのアイコンがグループバッファーで正しく活性化 (または不活
性化) されるようになりました。変数 @code{gnus-group-update-tool-bar} を
参照してください。そのディフォルト値は Emacs の版に依存します。
@c FIXME: これをマニュアルに書くべし。
@end itemize

@item その他の変更

@itemize @bullet
@item サーバーバッファーで外部グループのための select-method を変更する
と、すぐにそのサーバーを使うグループの講読に反映されるようになりました。
例えば @code{nntp-via-address} を @samp{foo.example.com} か
ら @samp{bar.example.com} に変更すると、Gnus は次回から中間ホス
ト @samp{bar.example.com} を経由してニュースサーバーに接続するようになり
ます。

@item @kbd{W e} で @file{all.SCORE} ファイルをグループバッファーから編集
することができます。

@item
@code{gnus-mark-copied-or-moved-articles-as-expirable} を @code{nil} で
はない値に設定することによって、読み終わった記事を auto-expire が有効に
なっているグループにコピーするか移動するとき、それらに期限切れ消去可能の
印を自動的に付けるようにすることができます。ディフォルト値
は @code{nil} で、記事のコピーと移動の動作は従来通りです。つまり、記事
を auto-expire が有効になっていないグループにコピーするか移動するときに
期限切れ消去可能の印が削除される以外は、印は変化しません。@xref{Expiring
Mail}.

@item NoCeM のサポートは削除されました。

@item Carpal modeは削除されました。
@end itemize
@end itemize

@node Ma Gnus
@subsubsection Ma Gnus
@cindex Ma Gnus

ここにはたくさんの文章がかかれるでしょう。本当の綴りは「真 Gnus」です。

真 Gnus の新しい機能:

@itemize @bullet
@item インストールに関する変更
@c ***************************

@itemize @bullet
@item
インストールされる Lisp のソースファイルと info ファイルはディフォルト
で gzip によって圧縮されます。

もしそれらのファイルが圧縮されることを望まないのであれば、configure オプ
ションの @samp{--without-compress-install} を使ってください。インストー
ルされるディレクトリーにおいてコンパイルされた elc 版を持たない Lisp の
ソースファイルは圧縮されません。
@end itemize

@item 概略モードと記事モードの変更
@c *******************************

@itemize @bullet
@item
添付ファイル (もしあれば) のための @acronym{MIME} パート・ボタンを、記事
ボディーの底に加えて記事のヘッダーの最後にディフォルトで表示します。その
ため何度も記事をスクロールしなくても、すぐにそれらを見つけることができま
す。@xref{MIME Commands}.
@end itemize

@item Message モードの変更および関連する Gnus の機能
@c ****************************************************

@itemize @bullet
@item
新しい hook である @code{gnus-gcc-pre-body-encode-hook} およ
び @code{gnus-gcc-post-body-encode-hook} が、送信したメッセージ
を @code{Gcc} コピーする際、そのボディーをエンコードする前後に実行されま
す。@xref{Archived Messages}.
@end itemize
@end itemize
@iftex

@page
@node The Manual
@section マニュアル
@cindex colophon
@cindex manual

このマニュアルは TeXinfo ファイルから作成され、それか
ら @code{texi2dvi}
@iflatex
もしくは、Lars さんが作った Texinfo to \LaTeX\ 変換を通り、それから、
@code{latex} と @code{dvips}
@end iflatex
を通して、あなたの手元にあるものになりました。

以下の習慣が用いられました:

@enumerate
@item
これは @samp{文字列} です。

@item
これは @kbd{キー打鍵} です。

@item
これは @file{ファイル} です。

@item
これは @code{シンボル} です。
@end enumerate

ですから、私が「@code{flargnoze} を @samp{yes} に設定する」と言ったとき
は、次のような意味です:

@lisp
(setq flargnoze "yes")
@end lisp

もし、私が「@code{flargnoze} を @code{yes} に設定する」と言ったときは、
次のような意味です:

@lisp
(setq flumphel 'yes)
@end lisp

@samp{yes} と @code{yes} は二つの @emph{まったく} 違ったものです---絶対
に混同しないでください。

@iflatex
@c @head
もちろん、このマニュアルにあるすべては極めて重要なので、あなたは全部を読
むべきです。何度も。しかしマニュアルを斜め読みしたいのであれば、そこの欄
外に見えるはずのヌーの頭を探してください---それはそこで議論されているの
が残りのものより重要であるということです。(一方、すべてが最高に重要なの
であれば、どうすればそれよりもっと重要なものができるのでしょう? この世界
のもう一つの不思議でしょう、たぶん。)
@end iflatex
@end iftex

@node On Writing Manuals
@section マニュアルを書く

おそらく、たいていのマニュアルは事後に書かれていると思います。つまり、す
でにあるプログラムを文書化しているということです。このマニュアルはそうい
う方法で書かれていません。何かを実装するときは、何かをそのままマニュアル
の一節に書きます。それから機能の説明が難しいことを発見して、それがどのよ
うにあるべきであるかを書き、次には実装を変更します。文書とコードを書くこ
とは協調して行なわれていきます。

もちろん、これはこのマニュアルには流れ構造がほとんど無いか、あっても少し
だということを意味します。Gnus の完全にすべてのことが説明されていますが、
あなたが探している場所ではないということがよくあります。これはリファレン
スマニュアルであって、Gnus を始めるための手引きではありません。

それはこのリファレンスマニュアルを元にして書かれた、まったく違った本にな
るでしょう。とても違ったものになるはずです。

@page
@node Terminology
@section 用語
@cindex terminology

@table @dfn
@item ニュース (news)
@cindex news
これは、あなたがそれを読むために使うことになっているもの、つまり、それと
いうのがニュースです。ニュースは一般的には近くの @acronym{NNTP} サーバー
から取得され、一般的にはすべての人が公に利用することができます。もしニュー
スを投稿すると、あなたがまさに書いたものを全世界の人たちが読むことになる
でしょう。そして、みんながいたずらっぽくクスクス笑うでしょう。あなたの知
らないところで。

@item メール (mail)
@cindex mail
あなたに個人的に配送されるすべてのものがメールです。いくつかのニュース/
メールリーダー (Gnus のような) はメールとニュースの区別を曖昧にしますが、
違いがあります。メールは私的です。ニュースは公的です。メールを送信するこ
とは投稿ではなく、返信はフォローアップではありません。

@item 返信 (reply)
@cindex reply
あなたが読んでいるものを書いた人にメールを送ることです。

@item フォローアップ (follow up)
@cindex follow up
あなたが読んでいる記事に応答して、現在のニュースグループに記事を投稿する
ことです。

@item バックエンド (back end)
@cindex back end
Gnus はメールとニュースがほとんど同じだとみなします。本当に。違いは実際
の記事にどのようにアクセスするかだけです。メールメッセージはローカルディ
スクのファイルから読めるのに対して、ニュース記事は一般
に @acronym{NNTP} プロトコルで取得します。Gnus の内部構造は、それらのた
めに「フロントエンド」と数々の「バックエンド」から成り立っています。内部
的には、あなたがグループに入る (そう、@key{RET} をたたく) と、それによっ
て Gnus のフロントエンドの機能を呼び出します。そうするとフロントエンドは、
バックエンドに「foo グループの記事のリストをくれ」とか「4711 番の記事を
見せてよ」と「話す」のです。

そういうわけで、バックエンドは主にプロトコルか、ファイルの形式とディレク
トリーの配置のどちらかを定義します。前者は @code{nntp} バックエンド
が @acronym{NNTP} でニュースにアクセスしたり、@code{nnimap} バックエンド
が @acronym{IMAP} でメールにアクセスすることを指します。また、後者
は @code{nnspool} バックエンドが共通の「スプールディレクトリー」形式にア
クセスしたり、それととてもよく似たファイルの形式とディレクトリーの配置を
介して @code{nnml} バックエンドがメールにアクセスすることを指します。

Gnus は基礎的なメディアを扱いません。言わばこれは、すべてバックエンドに
よって行なわれるということです。バックエンドは記事にアクセスするための機
能の集成です。

しかし、「バックエンド」という用語は「サーバー」と言った方がふさわしい場
面でときどき使われます。そして同じことを指すことができる「選択方法」
(select method) という用語があります。かように Gnus の用語はとても混乱し
ています。

@item 基本 (native)
@cindex native
Gnus はいつも一つの方法 (とバックエンド) を、ニュースを得るための「基本」
もしくはディフォルトの手段として使います。「基本」の選択方法で取得するグ
ループは @samp{gnu.emacs.gnus} のような名前になります。

@item 外部 (foreign)
@cindex foreign
同時に任意の数の外部グループをアクセスできる状態にすることもできます。こ
れらはニュースを取得するための、基本ではなく、二次のでもないバックエンド
を使うグループです。外部グループ
は @samp{nntp+news.gmane.org:gmane.emacs.gnus.devel} のような名前になり
ます。

@item 二次の (secondary)
@cindex secondary
二次のバックエンドは、基本と外部の間くらいに位置するバックエンドですが、
ほとんど基本と同じように動作するものです。しかしそれら
も @samp{nntp+news.gmane.org:gmane.emacs.gnus.devel} のような名前になり
ます。

@item 記事 (article)
@cindex article
ニュースとして投稿されたメッセージです。

@item メールメッセージ (mail message)
@cindex mail message
メールで送られたメッセージです。

@item メッセージ
@cindex message
メールメッセージもしくはニュース記事です。

@item ヘッド (head)
@cindex head
メッセージの最上部で、管理情報 (等) が入れられているところです。

@item 本文 (body)
@cindex body
記事の残りの部分です。ヘッドに無いものはすべて本文です。

@item ヘッダー (header)
@cindex header
記事のヘッドの行です。

@item ヘッダー群 (headers)
@cindex headers
そのような行の集合もしくは、ヘッドの集合です。もしくは、@acronym{NOV} 行
の集合です。

@item @acronym{NOV}
@cindex @acronym{NOV}
@acronym{NOV} は News OverView の略です。それらはニュースサーバーのヘッ
ダーの一つの形式で、記事の簡潔なヘッダーの情報を含むデータを提供するため
に、サーバーが自ら作ります。@code{nntp} バックエンドで
は Gnus は @acronym{NNTP} サーバーが作るものを使いますが、いくつかのサー
バー (特に @code{nnml}) のためには Gnus 自身が作ります。

グループに入ると、Gnus はグループのすべての未読記事のヘッダーをバックエ
ンドに要求します。ほとんどのサーバーは News OverView 様式をサポートして
います。それは標準の @sc{head} 様式よりコンパクトで、とても速く、読んで
解析することができます。

@acronym{NOV} データは一つ以上のテキスト行 (@pxref{Text Lines, ,Motion
by Text Lines, elisp, The Emacs Lisp Reference Manual}) から成り、それぞ
れの行は一つの記事のヘッダー情報を持っています。ヘッダー情報はタブで区切
られた一連のヘッダーの内容で、記事番号、表題、著者、日付、Message-ID、
References などを含んでいます。

それらのデータは Gnus が概略行をすばやく生成することを可能にします。しか
しサーバーが @acronym{NOV} をサポートしていなかったり、故意にまたはある
理由でそれを使わないようにしてしまうと、Gnus はそれぞれの記事のヘッダー
を一つずつ解析することによってヘッダー情報を生成しようとするでしょう。そ
れには時間がかかります。したがって、サーバーが間違った @acronym{NOV} デー
タを作ることがわかっている場合以外は、nn*-nov-is-evil
(@pxref{Slow/Expensive Connection}) を @code{nil} ではない値にすることは、
通常は良い考えではありません。

@item レベル (level)
@cindex levels
それぞれのグループは何らかの「レベル」(1--9) で購読されています。低いレ
ベルのものは高いレベルのものより「より」購読されています。実際のところ、
レベル 1--5 のグループは「購読」; 6--7 は「未購読」; 8 は「ゾンビ」
; 9 は「切られた」(killed) と見なされます。グループの一覧を表示したり、
新しい記事を走査する命令は、すべて数値接頭引数を「動作レベル」として使い
ます。

@item 切られたグループ (killed groups)
@cindex killed groups
切られたグループの情報は保存されたり更新されたりしないので、切られたグルー
プを扱うのは購読されているグループよりも簡単です。

@item ゾンビグループ (zombie groups)
@cindex zombie groups
ほとんど切られたグループと同じで、それより少し死んでいるだけです。

@item アクティブファイル (active file)
@cindex active file
ニュースサーバーは、どの記事を持っているかとどのグループが存在するかを記
録しておかなければなりません。アクティブファイルに格納されるすべてのこの
情報は、あなたが推測するように比較的大きいです。

@item 偽グループ (bogus groups)
@cindex bogus groups
@file{.newsrc} ファイルに存在するけれどもサーバーが知らないグループ (す
なわち、それはアクティブファイルにありません) は @emph{偽グループ} です。
おそらくそのグループは (もはや) 存在していないのでしょう。

@item 活性化 (activating)
@cindex activating groups
サーバーにグループの情報を尋ねて未読記事の数を演算する行為は「グループを
活性化 (activate) する」と呼ばれています。活性化されていないグループは、
グループバッファーに @samp{*} とともに一覧表示されます。

@item スプール (spool)
@cindex spool
ニュースサーバーは何らかのやり方で記事をローカルに保存します。ある古い流
儀の保存方法は、単に記事毎に一つのファイルを持つことです。それは伝統的な
スプール (traditional spool) と呼ばれます。

@item サーバー (server)
@cindex server
接続して、ニュース (もしくはメール) を取得することができるマシンです。

@item 選択方法 (select method)
@cindex select method
バックエンドと、サーバーおよび仮想サーバーの設定を指定する構造です。

@item 仮想サーバー (virtual server)
@cindex virtual server
名前が付けられていて、その名前で指定することができる選択方法です。選択方
法は (物理的な) サーバーに関するすべてを定義するので、ものごとを全体とし
て捉えるのは仮想サーバーになります。

@item 洗濯 (washing)
@cindex washing
バッファーを持ってきて、何らかの種類のフィルターにかけることです。結果
は (たいてい) 元のものよりもよりきれいで喜ばしいものになるでしょう。

@item 一時グループ (ephemeral groups)
@cindex ephemeral groups
@cindex temporary groups
たいていのグループはどの記事を読んだかのデータを保存します。「一時」グルー
プはデータが溜められないグループです---グループを出ると、それは天空のか
なたに消え去ります。

@item 固定グループ (solid groups)
@cindex solid groups
これは一時グループの反対です。グループバッファーに一覧表示されているすべ
てのグループは固定グループです。

@item まばら記事 (sparse articles)
@cindex sparse articles
@code{gnus-build-sparse-threads} が有効にされているときに、それらは概略
バッファーに表示される (存在しない) 記事のための場所取りです。

@item スレッド化 (threading)
@cindex threading
応答の記事を、それが応答した元記事の直後に置くことです---階層的な流儀で。

@item 根 (root)
@cindex root
@cindex thread root
スレッドの最初の記事が根です。それはスレッドのすべての記事の祖先です。

@item 親 (parent)
@cindex parent
応答が得られた記事です。

@item 子 (child)
@cindex child
それとは別の記事、すなわち親に応答する記事です。

@item まとめ送り (digest)
@cindex digest
複数のメッセージを一つのファイルに集めたものです。最も一般的なまとめ送り
の様式は、RFC1153 で規定されています。

@item 分割 (splitting)
@cindex splitting, terminology
@cindex mail sorting
@cindex mail filtering (splitting)
ある規則によってメールを区分けする行為です。ときどき間違ってメールの濾
過 (filtering) と呼ばれます。
@end table

@page
@node Customization
@section カスタマイズ
@cindex gereral customization

すべての変数は、このマニュアルのどこか他のところで適切に説明されています。
この章は、非常に良くある状況でどのように Gnus をカスタマイズすれば良いか
を調べるための、総合的な案内になるように作られています。

@menu
* Slow/Expensive Connection::   ローカルの Emacs で、どこかからニュースを得る
* Slow Terminal Connection::    遠くにあるホストの Emacs を実行する
* Little Disk Space::           大きな設定ファイルを持つことは良くない
* Slow Machine::                速いマシンを買いたい気がする
@end menu

@node Slow/Expensive Connection
@subsection 遅くて高価な接続

Emacs をローカルのマシンで実行していて、非常に細いひもの向こうのマシンか
らニュースを取り寄せているとしたら、Gnus がサーバーから取って来なければ
ならないデータの総量を減らしたくなるでしょうね。

@table @code
@item gnus-read-active-file
これを @code{nil} にしてください。これは Gnus がサーバーにアクティブファ
イル全体を要求することを禁止します。このファイルはしばしば非常に大きいで
す。さらに、Gnus が不意にアクティブファイルをとにかく取り寄せようと決意
しないように、@code{gnus-check-new-newsgroups} およ
び @code{gnus-check-bogus-newsgroups} も @code{nil} に設定する必要があり
ます。

@item gnus-nov-is-evil
@vindex gnus-nov-is-evil
通常これは @emph{常に} @code{nil} にしておかなければなりません (それがディ
フォルトです)。例えばもし @code{nntp} バックエンド
で @acronym{NOV} (@pxref{Terminology}) を使わないようにした
い (@pxref{Crosspost Handling}) のであれば、これを設定する代わり
に @code{nntp-nov-is-evil} を @code{nil} 以外の値にしてください。しか
し Gnus は @acronym{NNTP} サーバーが @acronym{NOV} をサポートするかどう
かを自分で調べるので、通常 @code{nntp-nov-is-evil} を設定する必要はあり
ません。とにかく Gnus が @acronym{NOV} を利用しないようにすると、
@acronym{NNTP} サーバーから記事のヘッダーを掴み取ってくる動作が、あまり
速くなりません。

他のバックエンドのための変数として @code{nndiary-nov-is-evil},
@code{nndir-nov-is-evil}, @code{nnfolder-nov-is-evil},
@code{nnimap-nov-is-evil}, @code{nnml-nov-is-evil} およ
び @code{nnspool-nov-is-evil} があります。
@code{gnus-nov-is-evil} に @code{nil} 以外の値を与えると、それらすべての
変数を上書きしてしまうことに注意してください。
@end table

@node Slow Terminal Connection
@subsection 遅いターミナル接続

Emacs と Gnus を実行しているシステムに、家のコンピューターをダイアルアッ
プで接続しているとしましょう。モデムが遅い場合は、電線を伝って送られてい
るデータの総量を (可能な限り) 減らしたくなるでしょう。

@table @code
@item gnus-auto-center-summary
Gnus が概略バッファーをリセンターする (訳注: 現在の記事が真ん中に表示さ
れるようにする) するために、これを @code{nil} に設定してください。これ
が @code{vertical} だったら、垂直方向のリセンターだけをします。
@code{nil} でも @code{vertical} でも無ければ、水平方向と垂直方向の両方で
リセンターを行ないます。

@item gnus-visible-headers
記事に含まれるヘッダーを最小限に減らします。実際のところ、それらが無くて
もすべて間に合わせることができます---たいていの役に立つデータは、とにか
く概略バッファーにありますから。この変数
を @samp{^NEVVVVER} や @samp{From:} や、何でも必要になりそうなものに設定
してください。

利用できるすべての「隠す」機能を有効にするために、以下を使ってください:

@lisp
(setq gnus-treat-hide-headers 'head
      gnus-treat-hide-signature t
      gnus-treat-hide-citation t)
@end lisp

@item gnus-use-full-window
これを @code{nil} に設定することによって、すべてのウィンドウを小さくする
ことができます。これは総じてそんなに減らしませんが、この記事は何が何でも
読みたくなかったんだと決心する前に、それを少ししか見ないで済みます。

@item gnus-thread-hide-subtree
これを @code{nil} ではない値にしておくと、すべての概略バッファーのスレッ
ド (の親以外) は、初めは隠されているようになります。

@item gnus-updated-mode-lines
これを @code{nil} にすると、Gnus はバッファーのモード行に情報を表示しな
いので、いくらか時間を節約できるでしょう。
@end table

@node Little Disk Space
@subsection 少ないディスク容量
@cindex disk space

起動ファイルはやや大きくなり得るので、空き容量が少なくなってきているとき
は、そのサイズを少し小さくする必要があるでしょう。

@table @code
@item gnus-save-newsrc-file
これを @code{nil} にすると、Gnus は決して @file{.newsrc} を保存しませ
ん---@file{.newsrc.eld} だけを保存します。これは Gnus 以外のニュースリー
ダーが使えなくなることを意味します。この変数はディフォルトで @code{t} で
す。

@item gnus-read-newsrc-file
これが @code{nil} であれば、Gnus は @file{.newsrc} を決して読みませ
ん---@file{.newsrc.eld} だけを読みます。これは Gnus 以外のニュースリーダー
が使えなくなることを意味します。この変数はディフォルトでは @code{t} です。

@item gnus-save-killed-list
これが @code{nil} であると、Gnus は死んだグループのリストを保存しません。
この変数を @code{nil} に設定したときは、
@code{gnus-check-new-newsgroups} を @code{ask-server} に、
@code{gnus-check-bogus-newsgroups} を @code{nil} に設定するべきでしょう。
この変数はディフォルトで @code{t} です。
@end table

@node Slow Machine
@subsection 遅いマシン
@cindex slow machine

遅いマシンを持っているか、または本当は単に忍耐力が無いだけでも、Gnus を
速く走らせるためにできることが少しあります。

起動を速くするために @code{gnus-check-new-newsgroups} およ
び @code{gnus-check-bogus-newsgroups} を @code{nil} に設定してください。
概略バッファーに入ることと抜けることを速くするため
に、@code{gnus-show-threads} と @code{gnus-use-cross-reference}、それ
に @code{gnus-nov-is-evil} を @code{nil} に設定してください。
@ref{Slow/Expensive Connection} も参照してください。

@page
@node Troubleshooting
@section 問題解決
@cindex troubleshooting

Gnus は箱から出してすぐに @emph{非常に} よく動作します---どんな問題が起
きることも想像できません、本当に。

オッホン。

@enumerate
@item
コンピューターの電源が入っていることを確かめてください。

@item
現在通用している版の Gnus を本当に読み込んでいることを確認してください。
今まで @sc{gnus} を実行してきたのであれば、Gnus が動作するように一
度 Emacs を終了して再起動する必要があります。

@item
@kbd{M-x gnus-version} を試してください。もし @samp{Gnus v5.13} のような
@c この行を変更する場合は ../Makefile.in を調整してください。
ものが出てきたなら、正しいファイルが読み込まれています。そうならないのは
古い @file{.el} ファイルが散らかっているせいでしょう。それらを消してくだ
さい。

@item
@acronym{FAQ} と入門書を読むために、ヘルプグループ (グループバッファー
で @kbd{G h}) を読んでください。

@item
@vindex max-lisp-eval-depth
Gnus は多くの再帰構造で動作しているので、何か極端な (そして非常に希
な) 場合には、Gnus は再帰を「あまりに深く」降りすぎてしまい、Emacs があ
なたにビープ音を鳴らすことがあります。もしこれが起こったなら、
@code{max-lisp-eval-depth} を 500 かそこいらの値に設定してください。
@end enumerate

もし他のすべてが失敗したなら、バグとして問題を報告してください。

@cindex bugs
@cindex reporting bugs
@findex gnus-bug
もし Gnus のバグを見つけたなら、@kbd{M-x gnus-bug} 命令で報告することが
できます。
@kbd{M-x set-variable @key{RET} debug-on-error @key{RET} t @key{RET}} と
タイプして、私にバックトレースを送ってください。私はバグを修正しようとし
ますが、あなたがバグを再現させる方法を正確に書いてくれないと、それを修正
することができません。

バグ報告では、詳細すぎることは決してありません。バグ報告をするときは、い
つも @kbd{M-x gnus-bug} 命令を使ってください。それを使うたびに 10KB のメー
ルができてしまっても、そしてあなたの環境のことを以前私に 500 回送ったこ
とがあったとしてもです。

私がどんなたぐいの記憶も持っていないことを、覚えておくことも重要です。も
しあなたがバグ報告を送ると、私は返答を送ります。その後で、あなたが「いや、
そうじゃない! このうすのろめっ!」とだけ送り返してきても、私はあなたが何
について私を侮辱しているかがわかりません。常に、すべてを説明し過ぎてくだ
さい。それは私たちすべてにとって、もっとやり易くなります---もし私が必要
なすべての情報を得られなかったら、私はあなたにメールを送ってさらなる情報
を求め、その結果すべてがより多くの時間を費やすことになります。

もしあなたの直面している問題が非常に視覚的で、それをうまく説明できない場
合は、Emacs のウィンドウをファイルにコピーして (例えば、@kbd{xwd} で)、
それをどこか手の届くどこかにおいて、その画像の URL をバグ報告に含めてく
ださい。

@cindex patches
もしあなたがバグの修正や改善のためのパッチを寄稿してくださるのでしたら、
すみませんがそのパッチは @samp{diff -u} で作ってください。

@cindex edebug
問題を報告する前にもっとデバッグしたければ、あなた自身で問題を解決してパッ
チを送るために edebug を使うことができるでしょう。Lisp コードのデバッグ
については ELisp マニュアル (@pxref{Debugging, ,Debugging Lisp Programs,
elisp, The GNU Emacs Lisp Reference Manual}) に書かれています。edebug を
始めるには、もし @kbd{c} を押したときにある変な振舞いが発見されるならば、
第一歩は @kbd{C-h k c} をタイプし、ドキュメンテーション・バッファー中で
ハイパーリンクをクリック (Emacs のみ) して、その関数定義を参照することで
す。そしてその関数名の場所で @kbd{M-x edebug-defun @key{RET}} をタイプし
て Gnus に戻り、そのコードを呼び出すために @kbd{c} を押しでください。
Lisp バッファーでは、@kbd{@key{SPC}} でシングルステップ動
作、@kbd{M-:} で式を評価、@kbd{C-h v} で変数を検査、@kbd{q} で実行を中断、
あるいは @kbd{c} か @kbd{g} で実行を再開することができます。

@cindex elp
@cindex profile
@cindex slow
ときどき、直接に elisp のエラーを起こさないものの、Gnus が非常に遅くなる
ために明らかになる問題があります。そんな場合には @kbd{M-x
toggle-debug-on-quit} を使って、遅くなったときに @kbd{C-g} を押し、しか
る後にバックトレースを解析してください (その手続きを繰り返すことは、真の
問題領域を分離するのに役立ちます)。

より上等なやり方は elisp プロファイラー (訳注: プログラムの実行時の動き
を分析する道具) ELP を使うことです。プロファイラーについてはどこか他
の場所で完全に文書化されているはずですが、それを始めるために必要な手順を
少々書いておきましょう。第一に、プロファイルしてみたい Gnus の部分を計測
するための設定を、例えば @kbd{M-x elp-instrument-package @key{RET}
gnus} や @kbd{M-x elp-instrument-package @key{RET} message} で行なってく
ださい。そして、遅い動作を行なわせてから @kbd{M-x elp-results} を押しま
しょう。すると、どの動作が時間を食っているかを見て、それらをさらにまたデ
バッグすることができます。動作全体が、プロファイラーの出力の中で最も遅い
関数で費やされた時間よりはるかに長くかかるのは、たぶん Gnus の間違ってい
る部分をプロファイルしたせいでしょう。プロファイルの統計をリセットするに
は @kbd{M-x elp-reset-all} を使ってください。
@kbd{M-x elp-restore-all} はプロファイルする動作を取り除くことになってい
ますが、Gnus によって複雑にされかつ動的なコード生成の影響を受けるため、
それは必ずしも完全には動作しないかもしれません。

@cindex gnu.emacs.gnus
@cindex ding mailing list
もし手助けが欲しいだけであれば、@samp{gnu.emacs.gnus} で尋ねるのが良いで
しょう。私はあまり役に立ちません。また、ding メーリングリス
ト---@email{ding@@gnus.org} で尋ねることもできます。購読するに
は @email{ding-request@@gnus.org} にメールを送ってください。

@page
@node Gnus Reference Guide
@section Gnus リファレンスガイド

誰かが Gnus でできる何か粋なものに知恵を働かせて、その粋なものを書いても
くれることが私の願いです。それを促進するためには、Gnus の内部動作を説明
するのが良いだろうと思いました。それに、さほど内部ではない動作をいくつか
と、私が今やっていることも。

プログラムの内部の仕様が変更されることはない、などと思ってはいけませんが、
Gnus とそのバックエンドの間のインターフェース (これは完全に記述されてい
ます) や、スコアファイルの形式 (同じく)、データ構造 (これは他のものほど
には変更されないでしょう)、それに一般的な操作のメソッドを、(細部にわたっ
て) 定義していきます。

@menu
* Gnus Utility Functions::      共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル標準の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報の形式
* Extended Interactive::        シンボル接頭引数など
* Various File Formats::        Gnus が使用するファイルの形式
@end menu

@node Gnus Utility Functions
@subsection Gnus の有用な関数
@cindex Gnus utility functions
@cindex utility functions
@cindex functions
@cindex internal variables

フックなどから実行される小さな関数を書くときは、Gnus の内部関数や変数に
アクセスすることが絶対に必要です。以下が最もよく使われるものの一覧です。

@table @code
@item gnus-newsgroup-name
@vindex gnus-newsgroup-name
この変数は現在のニュースグループの名前を持っています。

@item gnus-find-method-for-group
@findex gnus-find-method-for-group
@var{group} の選択方法を返す関数です。

@item gnus-group-real-name
@findex gnus-group-real-name
正規の (接頭語付きの) Gnus グループ名を受け取って、接頭語が無い名前を返
します。

@item gnus-group-prefixed-name
@findex gnus-group-prefixed-name
接頭語が無いグループ名と選択方法を受け取って、正規の (接頭語付き
の) Gnus グループ名を返します。

@item gnus-get-info
@findex gnus-get-info
@var{group} のグループ情報のリストを返します (@pxref{Group Info})。

@item gnus-group-unread
@findex gnus-group-unread
@var{group} の未読記事の数か、それが分からない場合は @code{t} を返します。

@item gnus-active
@findex gnus-active
@var{group} に関するアクティブファイルの項目 (最小と最大の記事番号) を返
します。

@item gnus-set-active
@findex gnus-set-active
@var{group} に関するアクティブファイルの項目を設定します。

@item gnus-add-current-to-buffer-list
@findex gnus-add-current-to-buffer-list
Gnus を終了するときに消去するバッファーのリストに、現在のバッファーを追
加します。

@item gnus-continuum-version
@findex gnus-continuum-version
引数として Gnus のバージョン文字列を受け取って、浮動小数点の数値を返しま
す。古いバージョンは必ず新しいバージョンよりも小さい数になります。

@item gnus-group-read-only-p
@findex gnus-group-read-only-p
@var{group} が読み出し専用かどうかを示します。

@item gnus-news-group-p
@findex gnus-news-group-p
@var{group} がニュースバックエンドかどうかを示します。

@item gnus-ephemeral-group-p
@findex gnus-ephemeral-group-p
@var{group} が一時ニュースグループかどうかを示します。

@item gnus-server-to-method
@findex gnus-server-to-method
@var{server} に対応している選択方法を返します。

@item gnus-server-equal
@findex gnus-server-equal
二つの仮想サーバーが実質的に同一かどうかを示します。例えば二つの仮想サー
バーが異なる順序で並んでいるサーバー・パラメーターを持っていても、この関
数はそれらを同一であると見なします。

@item gnus-group-native-p
@findex gnus-group-native-p
@var{group} が基本グループかどうかを示します。

@item gnus-group-secondary-p
@findex gnus-group-secondary-p
@var{group} が二次グループかどうかを示します。

@item gnus-group-foreign-p
@findex gnus-group-foreign-p
@var{group} が外部グループかどうかを示します。

@item gnus-group-find-parameter
@findex gnus-group-find-parameter
@var{group} のパラメーターのリストを返します (@pxref{Group Parameters})。
二つ目の引数を与えると、@var{group} 用のそのパラメーターの値を返します。

@item gnus-group-set-parameter
@findex gnus-group-set-parameter
三つの引数 @var{group}, @var{parameter}, @var{value} を与えて、パラメー
ターとして設定します。

@item gnus-narrow-to-body
@findex gnus-narrow-to-body
現在のバッファーを、記事の本文に狭めます。

@item gnus-check-backend-function
@findex gnus-check-backend-function
二つの引数 @var{function} と @var{group} を取ります。@var{group} のバッ
クエンドが @var{function} をサポートしているなら、@code{nil} ではない値
を返します。

@lisp
(gnus-check-backend-function "request-scan" "nnml:misc")
@result{} t
@end lisp

@item gnus-read-method
@findex gnus-read-method
利用者に選択方法を入力してもらう関数です。
@end table

@node Back End Interface
@subsection バックエンドインターフェース

Gnus は @acronym{NNTP} やスプール、メール、仮想グループについては何も知
りません。ただ仮想サーバー @dfn{virtual servers} と対話する方法を知って
いるだけです。仮想サーバーはバックエンド @dfn{back end} といくつかのバッ
クエンド変数 @dfn{back end variables} からなります。前者の例として
は @code{nntp}, @code{nnspool}, @code{nnmbox} などがあります。後者の例と
しては @code{nntp-port-number} や @code{nnmbox-directory} があります。

Gnus がバックエンド---例えば @code{nntp}---に何かの情報を要求するとき、
通常は関数の引数として仮想サーバー名を含めます。(無い場合は、バックエン
ドは「現在の」仮想サーバーを使うべきです。) 例え
ば @code{nntp-request-list} は、その唯一の (省略可能な) 引数として仮想サー
バーを使います。もしこの仮想サーバーとの接続が開かれていないと、この関数
の実行は失敗するはずです。

仮想サーバー名は、物理的なサーバー名とは何の関係も無いことに注意してくだ
さい。例を挙げましょう:

@lisp
(nntp "odd-one"
      (nntp-address "ifi.uio.no")
      (nntp-port-number 4324))
@end lisp

ここで物理サーバー名は @samp{ifi.uio.no} であるのに対して、仮想サーバー
名は @samp{odd-one} です。

バックエンドは複数の仮想サーバーを切り替えることができなければなりません。
標準のバックエンドは、必要なときに仮想サーバーの環境を取り出し・押し込み
を行なう連想リストを保持することによって、これを実現しています。

インターフェース関数には二つのグループがあります。必ず存在しなければなら
ない必須関数 @dfn{required functions} と、呼び出す前にそれが存在するかど
うかを常に Gnus が確認する任意関数 @dfn{optional functions} です。

これらすべての関数は、その戻り値のデータを @code{nntp-server-buffer}
(@file{ *nntpd*}) バッファーに返すことが求められます。これはちょっと不運
な名前付けですが、これで我慢しなければなりません。私が結果のデー
タ @dfn{resulting data} と言ったときは、そのバッファーの中のデータを指し
ています。戻り値 @dfn{return value} と言ったときは、関数呼び出しによって
返される関数の値のことを言っています。関数が失敗したときは、戻り値とし
て @code{nil} を返さなくてはいけません。

バックエンドにはサーバー型 @dfn{server-forming} のバックエンドと呼ばれる
ものがあり、またそう呼ばれないものもあります。後者は一般には、同時には一
つのグループだけしか操作しないバックエンドで、「サーバー」の概念がありま
せん。このサーバーとは、グループを持ち、そのグループの情報を配送するもの
で、それ以上のものではありません。

Gnus はグループ名と記事番号によって、それぞれのメッセージを特定します。
それら記事番号に関するちょっとした説明をすることは有益かもしれません。ま
ず第一に、その数値は正の整数です。第二に Gnus を混乱させることなく古い記
事番号を、後で「再使用」することは普通はできません。すなわち、もしあるグ
ループにかつて 42 番の記事があったとしたら、別の記事がその番号を持つこと
ができないか、または Gnus が激しく混乱してしまうということです。
@footnote{@code{nnchoke-request-update-info} 関数の説明を見てください。
@xref{Optional Back End Functions}.} 第三に、記事番号はそのグループでの
到着順になっていなければならないことです。メッセージの日付も、必ず到着順
になっているわけではありませんが。

すでに前の節で、記事番号は一回使われただけで役目を終わらなければならな
い「厳しい」制限について説明しました。しかし、記事番号の並びに抜けがある
と Gnus はとても混乱してしまうので、連続した @emph{通し} 番号を付けるこ
とが有用なのかもしれません。ただし「再使用不可」の制限があるので、完全に
番号の抜けを回避できるとは限りません。また、可能な限り記事番号を 1 から
始めることは、番号を使い切ってしまうことを避けるために役立ちます。

慣例として、バックエンドは @code{nnなんたら} と名付けられますが、
Gnus には @file{nnheader.el}、@file{nnmail.el} および @file{nnoo.el} の
ように、いくつかのバックエンドではない @code{nnかんたら} があることに注
意してください。

ここでの例と定義では、想像上のバックエンド @code{nnchoke} を引き合いに出
すことにします。

@cindex @code{nnchoke}

@menu
* Required Back End Functions:: 実装しなければならない関数
* Optional Back End Functions:: 実装しなくてもよい関数
* Error Messaging::             メッセージを発したりエラーを報告する方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メールバックエンドのための助言
@end menu

@node Required Back End Functions
@subsubsection 必須バックエンド関数

@table @code
@item (nnchoke-retrieve-headers ARTICLES &optional GROUP SERVER FETCH-OLD)

@var{articles} は記事番号の範囲か、@code{Message-ID} のリストのどちらか
です。現在のバックエンドは、どちらも完全にサポートしているわけではありま
せん---記事番号のひと続き (リスト) だけで、多くのバックエンド
は @code{Message-ID} による取得をサポートしていません。でも、それらは両
方サポートすることに努めるべきです。

結果のデータは HEADs か @acronym{NOV} 行のいずれかであるべきで、戻り値は
これを反映した @code{headers} か @code{nov} のどちらかでなければなりませ
ん。これは今後、HEADs と @acronym{NOV} 行が混在する @code{various} に拡
張されるかもしれませんが、現在の Gnus ではサポートされていません。

@var{fetch-old} が @code{nil} ではなかったら、ある意味での「余分なヘッ
ダー」を取得しようとします。これは通常、@code{articles} の中の最小番号の
記事よりも小さい番号を持っている (最大で) @var{fetch-old} 個の記事と、
@code{articles} の中で欠番になっている記事の、余分なヘッダーを取得します。
もしバックエンドがこの要求に従うことを煩わしいと思った場合には、このパラ
メーターの存在は無視されることもあります。この値が @code{nil} でも数値で
もなかったら、最大限の取得を行ないます。

これが HEAD の例です:

@example
221 1056 Article retrieved.
Path: ifi.uio.no!sturles
From: sturles@@ifi.uio.no (Sturle Sunde)
Newsgroups: ifi.discussion
Subject: Re: Something very droll
Date: 27 Oct 1994 14:02:57 +0100
Organization: Dept. of Informatics, University of Oslo, Norway
Lines: 26
Message-ID: <38o8e1$a0o@@holmenkollen.ifi.uio.no>
References: <38jdmq$4qu@@visbur.ifi.uio.no>
NNTP-Posting-Host: holmenkollen.ifi.uio.no
.
@end example

そういうわけで、@code{headers} という戻り値は、データバッファーにその要
素数と同じ個数のヘッダーがあることを暗示します。

これがそういうバッファーの BNF 定義です:

@example
headers        = *head
head           = error / valid-head
error-message  = [ "4" / "5" ] 2number " " <error message> eol
valid-head     = valid-message *header "." eol
valid-message  = "221 " <number> " Article retrieved." eol
header         = <text> eol
@end example

@cindex BNF
(ここで使っている拡張 BNF のバージョンは ABNF で、インターネット RFC で
使われています。RFC 5234 を参照してください。)

戻り値が @code{nov} だった場合は、データバッファーに
は @dfn{network overview database} 行が含まれていなければなりません。こ
れは基本的には複数の欄をタブで区切ったものです。

@example
nov-buffer = *nov-line
nov-line   = field 7*8[ <TAB> field ] eol
field      = <text except TAB>
@end example

これらの欄に何が含まれるべきかをきちんと調べたいのならば、
@ref{Headers} を参照してください。

@item (nnchoke-open-server SERVER &optional DEFINITIONS)

ここでの @var{server} は仮想サーバー名です。@var{definitions} はこの仮想
サーバーを定義する @code{(VARIABLE VALUE)} の組のリストです。

サーバーと接続できなかった場合でも、エラーをシグナルして処理を中断しては
いけません。バックエンドは、これ以後さらにこのサーバーに接続しようとする
試みを、拒否することを選ぶことができます。実際、そうすべきです。

すでにそのサーバーと接続されていた場合には、この関数は @code{nil} ではな
い値を返さなければなりません。このとき、返される結果のデータはありません。

@item (nnchoke-close-server &optional SERVER)

@var{server} との接続を閉じて、これに関連するすべてのリソースを開放しま
す。もし何らかの理由でサーバーを閉じることができない場合は、
@code{nil} を返します。

返される結果のデータはありません。

@item (nnchoke-request-close)

すべてのサーバーとの接続を閉じて、バックエンドが保有していたすべてのリソー
スを開放します。このバックエンドによって作られたすべてのバッファーを削除
しなければなりません。(もっとも @code{nntp-server-buffer} は削除されませ
んが。) 普通この関数は Gnus が終了するときにのみ呼び出されます。

返される結果のデータはありません。

@item (nnchoke-server-opened &optional SERVER)

@var{server} が現在の仮想サーバーで、かつその物理サーバーへの接続が生き
ている場合、この関数は @code{nil} ではない値を返さなければなりません。ど
んな状況でも、この関数は接続が失われたサーバーへの再接続を試みてはいけま
せん。

返される結果のデータはありません。

@item (nnchoke-status-message &optional SERVER)

この関数は @var{server} からの最後のエラーメッセージを返します。

返される結果のデータはありません。

@item (nnchoke-request-article ARTICLE &optional GROUP SERVER TO-BUFFER)

この関数の結果のデータは、@var{article} で指定された記事でなければなりま
せん。@code{Message-ID} か番号のいずれかを指定することができます。
@code{Message-ID} による記事の取得を実装するかどうかは任意ですが、それが
可能になっている方が良いでしょう。

@var{to-buffer} が @code{nil} ではなかったら、結果のデータは通常のデータ
バッファーの代わりに、このバッファーに返さなければなりません。Gnus は主
に、記事バッファーに直接記事を挿入するように要求しますが、これによって、
多量のデータをあるバッファーから別のバッファーにコピーするのを避けること
が可能になります。

もし少しでも可能なら、この関数は cons セルを返すべきです。そ
の @code{car} は取得した記事があるグループ名で、@code{cdr} は記事の番号
です。これによって、@code{Message-ID} で記事を取得したときに、Gnus が本
当のグループと記事番号を知ることができるようになるでしょう。これが不可能
な場合は、記事の取得に成功したときに @code{t} を返さなければなりません。

@item (nnchoke-request-group GROUP &optional SERVER FAST INFO)

@var{group} のデータを取得します。この関数には @var{group} を現在のグルー
プにするという副作用もあります。

@var{fast} が設定されたなら、有用なデータを返す面倒を行なわずに、単
に @var{group} を現在のグループにします。

@var{info} が与えられると、バックエンドがグループの情報構
造 (@var{info}) を更新することを可能にします。

これが結果のデータの例と、定義それ自体です:

@example
211 56 1000 1059 ifi.discussion
@end example

最初の数値は状態で、これは 211 でなくてはなりません。次はそのグループに
ある記事の総数、最小の記事番号、最大の記事番号、そして最後がグループ名で
す。しかし、いくつかの記事はキャンセルされているかもしれないので、記事の
総数は、記事の最大・最小番号から単純に考えられる数よりも小さいかもしれな
いことに注意してください。Gnus は総数を単に捨ててしまうので、(それが問題
であるときに) 正しい値を生成する面倒を負うべきかどうかは、読者への課題と
して残してあります。もしそのグループに記事が無かったら、最小記事番号は 1、
最大は 0 として報告しなければなりません。

@example
group-status = [ error / info ] eol
error        = [ "4" / "5" ] 2<number> " " <Error message>
info         = "211 " 3* [ <number> " " ] <string>
@end example

@item (nnchoke-close-group GROUP &optional SERVER)

@var{group} を閉じて、それに関連するすべてのリソースを開放します。ほとん
どのバックエンドは何もすることが無いでしょう。

返される結果のデータはありません。

@item (nnchoke-request-list &optional SERVER)

@var{server} 上で利用可能なすべてのグループのリストを返します。本当
に @emph{全部} という意味です。

これは、たった二つしかグループを持っていないサーバーの場合の例です:

@example
ifi.test 0000002200 0000002000 y
ifi.discussion 3324 3300 n
@end example

各行にはグループ名、そのグループ内の最大の記事番号、最小の記事番号、そし
て最後にフラグがあります。もしそのグループに記事が無かったら、最小記事番
号は 1、最大は 0 として報告しなければなりません。

@example
active-file = *active-line
active-line = name " " <number> " " <number> " " flags eol
name        = <string>
flags       = "n" / "y" / "m" / "x" / "j" / "=" name
@end example

フラグは、そのグループが読み出し専用 (@samp{n}) か、司会者付
き (@samp{m}) なのか、死んでいる (@samp{x}) か、どこか他のグループの別
名 (@samp{=other-group}) なのか、それらのどれでもない (@samp{y}) のかを
示します。

@item (nnchoke-request-post &optional SERVER)

この関数は、現在のバッファーを投稿しなければなりません。投稿が成功したか
どうかを返しても構いませんが、必須ではありません。例えば、投稿が非同期に
行なわれる場合は、この関数が終了した時点では、投稿は普通完了していません。
その場合この関数は、投稿を完了させることができないときに、それをはっきり
と利用者に知らせる見張り (sentinel) のようなものを設定するべきでしょう。

この関数から返される結果のデータはありません。
@end table

@node Optional Back End Functions
@subsubsection 任意バックエンド関数

@table @code
@item (nnchoke-retrieve-groups GROUPS &optional SERVER)

@var{groups} はグループのリストです。また、この関数はそれら全部のグルー
プのデータを要求しなければなりません。どうやってそれを行なうかは Gnus の
知ったことではありませんが、これをできるだけ迅速な方法で行なうことに挑ま
なければなりません。

この関数の戻り値は @code{active} か @code{group} のどちらでも良く、それ
が結果のデータの形式が何であるかを示します。前者
は @code{nnchoke-request-list} によるデータと同じ形式です。一方後者
は @code{nnchoke-request-group} が返すものと同じ形式の、バッファーを埋め
る行です。

@example
group-buffer = *active-line / *group-status
@end example

@item (nnchoke-request-update-info GROUP INFO &optional SERVER)

Gnus のグループ情報 (@pxref{Group Info}) が、バックエンドのそれを改変す
るために渡されます。これはバックエンドが (仮想グループや imap グループの
場合のように)、本当にすべての情報を持っている場合に役に立ちます。この関
数は、その要求に適合させる情報を破壊的に置き換えて、@code{nil} ではない
値を返さなければなりません (例外的に @code{nntp-request-update-info} は、
ネットワーク資源を浪費しないように常に @code{nil} を返します)。

この関数が返す結果のデータはありません。

@item (nnchoke-request-type GROUP &optional ARTICLE)

利用者が「ニュースを送信する」命令 (例えば、概略バッファーで @kbd{F}) を
実行したときに、Gnus は利用者がフォローアップしようとしている記事がニュー
スなのかメールなのかを知っている必要があります。この関数
は @var{group} の中の @var{article} がニュースであれば @code{news} を、
メールであれば @code{mail} を、その種別を判定できない場合
は @code{unknown} を返さなければなりません。(@var{article} 引数は、メー
ルグループとニュースグループがごちゃまぜになっているかもしれな
い @code{nnvirtual} において必要です。) @var{group} と @var{article} は
両方とも @code{nil} であるかもしれません。

この関数が返す結果のデータはありません。

@item (nnchoke-request-set-mark GROUP ACTION &optional SERVER)

記事の印を設定/消去/追加します。通常 Gnus は記事の印 (既読、可視、期限切
れ消去など) を内部で扱い、@file{~/.newsrc.eld} に保存します。しかし、い
くつかのサーバー (例えば @acronym{IMAP}) は記事のすべての情報をサーバー
で持っているので、Gnus が印の情報をサーバーに伝搬させる必要があります。

@var{action} は印を設定する要求のリストで、以下の様式を持ちます:

@example
(RANGE ACTION MARK)
@end example

@var{range} は印を付けたい記事の範囲です。@var{action} は @code{add} ま
たは @code{del} で、印を追加したり消すために使われます (言及されていない
すべての印は保存します)。@var{mark} は印のリストです。それぞれの印はシン
ボルです。現在使われている印は @code{read}, @code{tick}, @code{reply},
@code{expire}, @code{killed}, @code{dormant}, @code{save},
@code{download}, @code{unsend} および @code{forward} ですが、あなたのバッ
クエンドは、可能ならこれらを制限をするべきではありません。

矛盾する動作が指定された場合は、リストの最後の動作が効力を持つものになる
べきです。すなわち、@var{action} が記事 1 に @code{可視} 印を追加する要
求を含んでいて、リストのおしまいの方で、同じ記事から印を消去することを要
求していたならば、印は実際には消去されるべきです。

@var{action} リストの例です:

@example
(((5 12 30) 'del '(tick))
 ((10 . 90) 'add '(read expire))
 ((92 94) 'del '(read)))
@end example

関数は印を設定できなかった記事の範囲を返さなければなりません (現在はどん
な目的のためにも使われていません)。

この関数が返す結果のデータはありません。

@item (nnchoke-request-update-mark GROUP ARTICLE MARK)

バックエンドが嫌う印を利用者が設定しようとしたら、この関数がその印を変更
することができます。この関数が返したどんなものでも、
Gnus は @var{article} への印として元の @var{mark} の代わりに使います。バッ
クエンドがそれでも構わない場合には、元の @var{mark} を返さなければなりま
せん。@code{nil} やその他のゴミを返してはいけません。

私に考えられるこれの利用法は、それで @code{nnvirtual} が行なっていること
だけです---その仮想グループで既読の印を付けると、もし構成要素のグループ
が自動期限切れ消去可能ならば、結果としてその記事に期限切れ消去の印が付け
られます。

この関数が返す結果のデータはありません。

@item (nnchoke-request-scan &optional GROUP SERVER)

バックエンドが新着記事を検査する要求を (Gnus か他の何かによって) 行なう
ときはいつでも、あれやこれやとこの関数が呼び出されるでしょう。この関数が
起動されると、一般にメールバックエンドはスプールファイルを読む
か @acronym{POP} サーバーに問い合わせます。@var{group} に留意する必要は
ありません---バックエンドが、一つのグループだけを走査するのが大変すぎる
と判断した場合には、すべてのグループを総ががりで走査しても構いません。で
すが、その方が実用的ならば、局所に限定するのが良いでしょう。

この関数が返す結果のデータはありません。

@item (nnchoke-request-group-description GROUP &optional SERVER)

この関数が返す結果のデータは、@var{group} の説明でなければなりません。

@example
description-line = name <TAB> description eol
name             = <string>
description      = <text>
@end example

@item (nnchoke-request-list-newsgroups &optional SERVER)

この関数が返す結果のデータは、サーバー上で利用できるすべてのグループの説
明でなければなりません。

@example
description-buffer = *description-line
@end example

@item (nnchoke-request-newgroups DATE &optional SERVER)

この関数から返される結果のデータは、@samp{date} 以降に作成されたすべての
グループでなければなりません。@samp{date} は人間が読める普通の日付の形
式 (すなわち、メールやニュースのヘッダーで使われる形式で、ディフォルトは
関数 @code{message-make-date} が返すもの) です。データは active バッファー
の形式でなければなりません。

この関数が「多すぎる」グループを返すのはオッケーです。いくつかのバックエ
ンドでは、新しいグループだけではなくて、すべてのグループのリストを返す方
が安上がりに済むことを見出すかもしれません。しかし、たくさんのグループが
あるバックエンドで、これをしてはいけません。普通、利用者が自分で作ったグ
ループならば多すぎることはないでしょうから、@code{nnml} とそれに類するも
のはたぶん心配ありません。しかし @code{nntp} のようなバックエンドでは、
グループはサーバーによって作られているので、いかにもたくさんのグループが
ありそうです。

@item (nnchoke-request-create-group GROUP &optional SERVER)

この関数は @var{group} という名前の空のグループを作成しなければなりませ
ん。

返されるデータはありません。

@item (nnchoke-request-expire-articles ARTICLES &optional GROUP SERVER FORCE)

この関数は、@var{articles} の範囲のすべての記事に対して期限切れ消去の処
理を行ないます (現在 @var{articles} は記事番号の単純なリストです)。記事
がどれだけ古いかを、この関数で消去される前に判定することは、バックエンド
に任されています。@var{force} が @code{nil} ではない値だったら、それらが
どんなに新しくても、すべての @var{articles} を消去しなければなりません。

この関数は削除しなかった、あるいは削除することができなかった記事のリスト
を返さなければなりません。

返される結果のデータはありません。

@item (nnchoke-request-move-article ARTICLE GROUP SERVER ACCEPT-FORM &optional LAST)

この関数は @var{group} にある記事 @var{article} (番号) を、
@var{accept-form} を呼び出すことによって移動しなければなりません。

この関数は、当の記事を移動させるための準備として、それが記事に付加したど
んなヘッダー行をも削除して、記事を大体において「きれい」にしておく必要が
あります。そして「きれい」な記事があるバッファーで、
@var{accept-form} を @code{eval} しなければなりません 。これは実際に複製
を行ないます。もしこの @code{eval} が @code{nil} 以外の値を返したら、そ
の記事を削除しなければなりません。

もし @var{last} が @code{nil} だったら、それはこの直後にさらに要求が発行
される見込みが高いことを意味し、これによっていくらか最適化ができるように
なります (訳注: 例えば @code{nil} だったらサーバーとの接続を閉じないでお
くとか)。

この関数は、移動先のグループ名が @code{car} で、移動先の記事番号
が @code{cdr} である cons セルを返さなければなりません。

返されるデータはありません。

訳注: 移動先のグループは @var{accept-form} の中で指定します。そこで使わ
れるのが、次の @code{nnchoke-request-accept-article} です。

@item (nnchoke-request-accept-article GROUP &optional SERVER LAST)

この関数は、現在のバッファーの中身を @var{group} に挿入します。
@var{last} が @code{nil} だったら、この関数へのさらなる呼び出しが直ちに
行なわれるだろうという意味です。

この関数はグループ名が @code{car} で、移動先の記事番号が @code{cdr} であ
る cons セルを返さなければなりません。

そのグループは、記事を受け入れてもらうことをバックエンドが要求する前に存
在しなければなりません。

返されるデータはありません。

@item (nnchoke-request-replace-article ARTICLE GROUP BUFFER)

この関数は @var{group} から記事 @var{article} (番号) を削除して、代わり
に @var{buffer} の中身をそこに挿入しなければなりません。

返されるデータはありません。

@item (nnchoke-request-delete-group GROUP FORCE &optional SERVER)

この関数は @var{group} を消去しなければなりません。もし @var{force} が設
定されていたら、そのグループ内のすべての記事を本当に消去して、そしてその
グループ自身を消去しなければなりません。(もし「グループ自身」というもの
があれば。)

返されるデータはありません。

@item (nnchoke-request-rename-group GROUP NEW-NAME &optional SERVER)

この関数はグループ名を @var{group} から @var{new-name} に変更しなければ
なりません。@var{group} 内にあるすべての記事は、@var{new-name} に移動し
なければなりません。

返されるデータはありません。
@end table

@node Error Messaging
@subsubsection エラーメッセージの発行

@findex nnheader-report
@findex nnheader-get-report
バックエンドはエラーの状況の報告に @code{nnheader-report} を使わなければ
なりません---要求を実行できないときにエラーを生起させてはいけません。こ
の関数の最初の引数はバックエンド名のシンボルで、残りは、複数の引数があれ
ば @code{format} への引数として解釈され、一つであればただの文字列です。
この関数は常に @code{nil} を返さなければなりません。

@lisp
(nnheader-report 'nnchoke "You did something totally bogus")

(nnheader-report 'nnchoke "Could not request group %s" group)
@end lisp

一方 Gnus は、サーバーから @code{nil} を返されたとき
に @code{nnheader-get-report} を呼び出します。するとこの関数が、当のバッ
クエンドに対して最後に報告されたメッセージを返します。この関数は一つの引
数---サーバーのシンボルを取ります。

内部的には、これらの関数は @var{back-end}@code{-status-string} にアクセ
スます、したがって @code{nnchoke} バックエンドはそのエラーメッセージ
を @code{nnchoke-status-string} に格納します。

@node Writing New Back Ends
@subsubsection 新しいバックエンドを書く

多くのバックエンドはよく似通っています。@code{nnml} は @code{nnspool} と
瓜二つですが、サーバー上の記事を編集することができます。@code{nnmh} はま
るで @code{nnml} のようですが、アクティブファイルを使わないし、概要デー
タベースも保持しません。@code{nndir} は @code{nnml} にとても似ていますが、
これには「グループ」の概念は無く、記事の編集はできません。

新しいバックエンドを書くときに他のバックエンドから関数を「継承」できたら
なあ、と思うのは理に適っています。そしてまさに、あなたがそうしたければ、
それができるのです。(あなたがそうしたくなければしなくても良いですよ、も
ちろん。)

すべてのバックエンドは、公共変数と公共関数を @code{nnoo} というパッケー
ジを使って宣言します。

他のバックエンドから関数を継承するには (そして現在のバックエンドから他の
バックエンドに関数を継承できるようにするには)、以下のマクロを使用しなけ
ればなりません:

@table @code
@item nnoo-declare
このマクロは、最初の引数を、その後に続く引数の子供であることを宣言します。
例えば:

@lisp
(nnoo-declare nndir
  nnml nnmh)
@end lisp

ここで @code{nndir} は、@code{nnml} と @code{nnmh} の両方から関数を継承
するつもりであることを宣言しています。

@item defvoo
このマクロは @code{defvar} と等価ですが、その変数を公共サーバー変数とし
て登録します。ほとんどの状態志向型の変数は、@code{defvar} ではな
く @code{defvoo} によって宣言するべきです。

通常の @code{defvar} の引数に加えて、このマクロは親バックエンドにおける
変数のリストを取ります。それらの親バックエンドで定義されている関数を子の
バックエンドで実行するときに、その関数の中でアクセスされる親の変数を、子
の変数で置き換えます。

@lisp
(defvoo nndir-directory nil
  "Where nndir will look for groups."
  nnml-current-directory nnmh-current-directory)
@end lisp

これは @code{nndir} のために @code{nnml} の関数が呼び出されたときに、
@code{nnml-current-directory} は @code{nndir-directory} に設定されるとい
う意味です。(@code{nnmh} も同様です。)

@item nnoo-define-basics
このマクロは、ほとんどすべてのバックエンドが持つべき共通関数をいくつか定
義します。

@lisp
(nnoo-define-basics nndir)
@end lisp

@item deffoo
このマクロはまさに @code{defun} のようなもので、同一の引数を取ります。通
常の @code{defun} の処理に加えて、このマクロは他のバックエンドがそれを継
承できるように、その関数が公共物になっているものとして登録します。

@item nnoo-map-functions
このマクロは、現在のバックエンドの関数から親バックエンドの関数への、置き
換えができるようにします。

@lisp
(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0))
@end lisp

これは @code{nndir-retrieve-headers} が呼び出されたときに、一番目、三番
目、および四番目の引数が @code{nnml-retrieve-headers} に渡され、一方、二
番目の引数は @code{nndir-current-group} の値として設定されるという意味で
す。

@item nnoo-import
このマクロは他のバックエンドから関数を輸入します。これは単にまだ定義され
ていない関数を定義するだけなので、ソースファイルの最後に書かなければなり
ません。

@lisp
(nnoo-import nndir
  (nnmh
   nnmh-request-list
   nnmh-request-newgroups)
  (nnml))
@end lisp

これは、@code{nndir-request-list} への呼び出しは単
に @code{nnmh-request-list} に引き渡されなければならず、一
方 @code{nnml} の公共関数でまだ @code{nndir} で定義されていないものをこ
こで定義するということです。
@end table

以下は @code{nndir} バックエンドのちょっと短縮した版です。

@lisp
;;; @r{nndir.el --- 単一のディレクトリーをニュースグループにする}
;; @r{Copyright (C) 1995,1996 Free Software Foundation, Inc.}

;;; @r{Code:}

(require 'nnheader)
(require 'nnmh)
(require 'nnml)
(require 'nnoo)
(eval-when-compile (require 'cl))

(nnoo-declare nndir
  nnml nnmh)

(defvoo nndir-directory nil
  "nndir がグループを探す場所。"
  nnml-current-directory nnmh-current-directory)

(defvoo nndir-nov-is-evil nil
  "これが nil でなかったら NOV ヘッダーを取得しません。"
  nnml-nov-is-evil)

(defvoo nndir-current-group ""
  nil
  nnml-current-group nnmh-current-group)
(defvoo nndir-top-directory nil nil nnml-directory nnmh-directory)
(defvoo nndir-get-new-mail nil nil nnml-get-new-mail nnmh-get-new-mail)

(defvoo nndir-status-string "" nil nnmh-status-string)
(defconst nndir-version "nndir 1.0")

;;; @r{インターフェース用の関数。}

(nnoo-define-basics nndir)

(deffoo nndir-open-server (server &optional defs)
  (setq nndir-directory
        (or (cadr (assq 'nndir-directory defs))
            server))
  (unless (assq 'nndir-directory defs)
    (push `(nndir-directory ,server) defs))
  (push `(nndir-current-group
          ,(file-name-nondirectory
            (directory-file-name nndir-directory)))
        defs)
  (push `(nndir-top-directory
          ,(file-name-directory (directory-file-name nndir-directory)))
        defs)
  (nnoo-change-server 'nndir server defs))

(nnoo-map-functions nndir
  (nnml-retrieve-headers 0 nndir-current-group 0 0)
  (nnmh-request-article 0 nndir-current-group 0 0)
  (nnmh-request-group nndir-current-group 0 0)
  (nnmh-close-group nndir-current-group 0))

(nnoo-import nndir
  (nnmh
   nnmh-status-message
   nnmh-request-list
   nnmh-request-newgroups))

(provide 'nndir)
@end lisp

@node Hooking New Back Ends Into Gnus
@subsubsection 新しいバックエンドを Gnus に繋げる

@vindex gnus-valid-select-methods
@findex gnus-declare-backend
あなたの新しいバックエンドを Gnus で使い始めるのはとても簡単です---単
に @code{gnus-declare-backend} 関数で宣言するだけです。これはバックエン
ドを @code{gnus-valid-select-methods} 変数に追加します。

@code{gnus-declare-backend} は二つの引数を取ります---バックエンドの名前
と任意の数の能力 @dfn{abilities} です。

これが例です。

@lisp
(gnus-declare-backend "nnchoke" 'mail 'respool 'address)
@end lisp

そして上記の行が @file{nnchoke.el} ファイルに入ります。

能力には以下のものがあります:

@table @code
@item mail
これはメール風バックエンドです---フォローアップは (たいていは) メールで
送られるはずです。
@item post
これはニュース風バックエンドです---フォローアップは (たいていは) ニュー
スで送られるはずです。
@item post-mail
このバックエンドはメールとニュースの両方をサポートします。
@item none
これはニュースでもメールでもないバックエンドです---まったく違った何かで
す。
@item respool
これは再スプールをサポートします---というか、その元の記事とグループを書
き換えることができます。
@item address
サーバーの名前が仮想サーバー名に含まれていなければなりません。これはほと
んど全部のバックエンドに当てはまります。
@item prompt-address
グループバッファーで @kbd{B} などの命令を実行したときに、利用者はアドレ
スの入力を求められるはずです。例えばこれは @code{nntp} のようなバックエ
ンドに当てはまりますが、@code{nnmbox} はそうではありません。
@end table

@node Mail-like Back Ends
@subsubsection メール風バックエンド

メールバックエンドがその他のバックエンドに対して一線を画しているのは、ほ
とんどのメールバックエンドが @file{nnmail.el} で定義されている共通の関数
に強く依存しているという点です。例えばこれは @code{nnml-request-scan} の
定義です:

@lisp
(deffoo nnml-request-scan (&optional group server)
  (setq nnml-article-file-alist nil)
  (nnmail-get-new-mail 'nnml 'nnml-save-nov nnml-directory group))
@end lisp

単に @code{nnmail-get-new-mail} にいくつか引数を与えて呼び出すだけで、
@code{nnmail} がメールの移動や分割のすべての面倒を見てくれます。

この関数は四つの引数を取ります。

@table @var
@item method
これは、どのバックエンドがこの呼び出しの責任を負うかを指示するシンボルで
なければなりません。

@item exit-function
この関数は、分割が実行された後で呼び出されるものでなければなりません。

@item temp-directory
一時ファイルを格納する場所です。

@item group
この引数は省略可能です。分割が一つのグループだけに対して行なわれる場合は、
この引数でグループ名を指定しなけれなばりません。
@end table

@code{nnmail-get-new-mail} は、それぞれの記事を保存するため
に @var{back-end}@code{-save-mail} を呼び出します。
@var{back-end}@code{-active-number} は、この記事に割り当てられた記事番号
を調べるために呼び出されます。

この関数は次の変数も使用します: @var{back-end}@code{-get-new-mail} (この
バックエンドの新着メールを受け取るかどうか)、新しいアクティブファイルを
生成するための @var{back-end}@code{-group-alist} およ
び @var{back-end}@code{-active-file} です。
@var{back-end}@code{-group-alist} は、以下のようなグループとアクティブの
連想リストです:

@example
(("a-group" (1 . 10))
 ("some-group" (34 . 39)))
@end example

@node Score File Syntax
@subsection スコアファイルの構文

スコアファイルは簡単に分析できるだけでなく、極めて柔軟な対応ができるよう
になっています。それには Emacs Lisp のリストとして読み込むことができるよ
うな構文がふさわしいだろうと判断されました。

これは良くあるスコアファイルです:

@lisp
(("summary"
  ("Windows 95" -10000 nil s)
  ("Gnus"))
 ("from"
  ("Lars" -1000))
 (mark -100))
@end lisp

スコアファイルの BNF 定義です。

@example
score-file      = "" / "(" *element ")"
element         = rule / atom
rule            = string-rule / number-rule / date-rule
string-rule     = "(" quote string-header quote space *string-match ")"
number-rule     = "(" quote number-header quote space *number-match ")"
date-rule       = "(" quote date-header quote space *date-match ")"
quote           = <ascii 34>
string-header   = "subject" / "from" / "references" / "message-id" /
                  "xref" / "body" / "head" / "all" / "followup"
number-header   = "lines" / "chars"
date-header     = "date"
string-match    = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space string-match-t ] ] ] ] ] ")"
score           = "nil" / <integer>
date            = "nil" / <natural number>
string-match-t  = "nil" / "s" / "substring" / "S" / "Substring" /
                  "r" / "regex" / "R" / "Regex" /
                  "e" / "exact" / "E" / "Exact" /
                  "f" / "fuzzy" / "F" / "Fuzzy"
number-match    = "(" <integer> [ "" / [ space score [ "" /
                  space date [ "" / [ space number-match-t ] ] ] ] ] ")"
number-match-t  = "nil" / "=" / "<" / ">" / ">=" / "<="
date-match      = "(" quote <string> quote [ "" / [ space score [ "" /
                  space date [ "" / [ space date-match-t ] ] ] ] ")"
date-match-t    = "nil" / "at" / "before" / "after"
atom            = "(" [ required-atom / optional-atom ] ")"
required-atom   = mark / expunge / mark-and-expunge / files /
                  exclude-files / read-only / touched
optional-atom   = adapt / local / eval
mark            = "mark" space nil-or-number
nil-or-number   = "nil" / <integer>
expunge         = "expunge" space nil-or-number
mark-and-expunge = "mark-and-expunge" space nil-or-number
files           = "files" *[ space <string> ]
exclude-files   = "exclude-files" *[ space <string> ]
read-only       = "read-only" [ space "nil" / space "t" ]
adapt        = "adapt" [ space "ignore" / space "t" / space adapt-rule ]
adapt-rule      = "(" *[ <string> *[ "(" <string> <integer> ")" ] ")"
local           = "local" *[ space "(" <string> space <form> ")" ]
eval            = "eval" space <form>
space           = *[ " " / <TAB> / <NEWLINE> ]
@end example

認識不可能なスコアファイルの要素は無視されるべきですが、捨ててしまっては
いけません。

ご覧のように空白が必要ですが、空白の量と型は重要ではありません。つまり、
スコアファイルの様式はプログラマーに任されています---すべてを一つの長ーー
い行に吐き出す方がより簡単なのであれば、それでも構いません。

いろいろなアトムの意味は、このマニュアルのどこかで説明されていま
す (@pxref{Score File Format})。

@node Headers
@subsection ヘッダー

Gnus は記事のヘッダーを溜めておくために、内部的には @acronym{NOV} の規格
を怪しげなやり方で踏襲する様式を使っています。@acronym{NOV} の仕様を見た
作者が、恥知らずにもすべてを @emph{盗んだ} と思うかもしれませんが、それ
は正しいです。

「ヘッダー」はひどく荷の重い用語です。「ヘッダー」は RFC 5536 では記事の
頭の行 (例えば、@code{From}) について話すのに用いられています。それは多
くの人が「ヘッド」---「ヘッダーと本文」の同義語として使っています。(私に
言わせれば、これは避けるべきです。) そして Gnus は、私がここで話す「ヘッ
ダー」と言う様式を内部的に使っています。これは基本的には九つの要素からな
るベクトルで、それぞれのヘッダー (あ痛っ) が一つの場所を占めます。

これらの場所は、順番に @code{number}, @code{subject}, @code{from},
@code{date}, @code{id}, @code{chars}, @code{lines}, @code{xref}, およ
び @code{extra} です。これらの場所を読み出したり設定するマクロがありま
す---それらはすべて、それぞ
れ @code{mail-header-} と @code{mail-header-set-} いう予想しやすい名前を
持っています。

@code{extra} のための場所がヘッダーと値の対の連想リストであることを除い
て、これらすべての場所には文字列が入ります (@pxref{To From Newsgroups})。

@node Ranges
@subsection 範囲

@sc{gnus} は非常に有用な概念を導入してくれました。私はそれをたくさん使い、
かなり入念に仕上げました。

設問は単純です: 何か番号で呼ぶことができる大量のもの (@emph{粗雑な} 例と
しては、例えば記事) を持っていて、それらが「含まれている」ことを表現した
いとしましょう。それらを順番に並べるのは、あまり便利ではありません。
(20,000 個を順番に並べたものは、ちょっと長たらしいですよね。)

解決策は設問と同じくらい単純です。単にその並びを折りたためば良いのです。

@example
(1 2 3 4 5 6 10 11 12)
@end example

は次のように変形されます。

@example
((1 . 6) (10 . 12))
@end example

単独のものを表すために @samp{(13 . 13)} のようなやっかいな要素を持たなく
ても良いように、@samp{13} は有効な要素になっています。例えば:

@example
((1 . 6) 7 (10 . 12))
@end example

以下のような二つの範囲を比較して、それらが等しいがとうかを調べるのは、少
し手のこんだことになります:

@example
((1 . 5) 7 8 (10 . 12))
@end example

と

@example
((1 . 5) (7 . 8) (10 . 12))
@end example

は等しいです。実際のところ、下り順で並んでいないリストは範囲です:

@example
(1 2 3 4 5)
@end example

これはかなり長ったらしいものですが、完璧に有効な範囲です。以下も有効です:

@example
(1 . 5)
@end example

そして、これはその前の範囲と等しいものです。

これは範囲の BNF 定義です。もちろん、数値の並びが下り順であってはならな
いことを覚えておかなければなりません。(同じ数値を任意の回数にわたって繰
り返すことができますが、範囲の扱いにおいて消え去る傾向があります。)

@example
range           = simple-range / normal-range
simple-range    = "(" number " . " number ")"
normal-range    = "(" start-contents ")"
contents        = "" / simple-range *[ " " contents ] /
                  number *[ " " contents ]
@end example

現在 Gnus は既読記事と記事の印を維持するために範囲を使っています。当局が
私にそれをさせたがっているのなら、私は数の範囲の操作を C で実装しようと
思っています。(私はまだ尋ねていません。と言うのは、普通の連続体に変換し
直さずに、世の中を完全に範囲に基づいたものにするためには何が必要かを、私
はもっと考えなければならないからです。)

@node Group Info
@subsection グループ情報

Gnus はグループのすべての永続的な情報を @dfn{group info} リストに格納し
ます。このリストは 3 から 6 (またはそれ以上) の長さの要素で、徹底的にグ
ループを記述します。

ここにあるのはグループ情報 (group info) の二つの例です。一つは非常に単純
なグループですが、二つ目はもっと複雑なものです:

@example
("no.group" 5 ((1 . 54324)))

("nnml:my.mail" 3 ((1 . 5) 9 (20 . 55))
                ((tick (15 . 19)) (replied 3 6 (19 . 3)))
                (nnml "")
                ((auto-expire . t) (to-address . "ding@@gnus.org")))
@end example

最初の要素は「グループ名」---とにかく Gnus が知っているグループです。二
番目の要素は「購読度」で、普通は小さな整数です。(それは「階級」(rank) に
なることもできます。@code{car} がレベルで @code{cdr} がスコアのコンスセ
ルです。) 三番目の要素は既読記事の範囲のリストです。四番目の要素はいろい
ろな種類の記事の印のリストのリストです。五番目の要素は選択方法です (もし
くは、そう言いたければ仮想サーバーです)。六番目の要素は「グループパラメー
ター」のリストで、この章はそのためにあります (訳注: ほんとうに?)。

最後の三つの要素はどれでも、必要が無ければ存在しないこともあります。実際、
グループの非常に大部分は最初の三つの要素だけを持ち、それは (最後の三要素
が省略できることは) 非常に多くのコンスセルを節約します。

これはグループ情報様式の BNF 定義です:

@example
info          = "(" group space ralevel space read
                [ "" / [ space marks-list [ "" / [ space method [ "" /
                space parameters ] ] ] ] ] ")"
group         = quote <string> quote
ralevel       = rank / level
level         = <integer in the range of 1 to inf>
rank          = "(" level "." score ")"
score         = <integer in the range of 1 to inf>
read          = range
marks-lists   = nil / "(" *marks ")"
marks         = "(" <string> range ")"
method        = "(" <string> *elisp-forms ")"
parameters    = "(" *elisp-forms ")"
@end example

実は @samp{marks} の規則はごまかしです。@samp{marks} は @samp{range} と
ともに cons を構成する @samp{<string>} ですが、疑似 BNF でそれを現すのは
難しいのです。

情報の要素群にアクセスして、それらの値を取得または設定するために、
Gnus は一連のマクロを提供しています。

@table @code
@item gnus-info-group
@itemx gnus-info-set-group
@findex gnus-info-group
@findex gnus-info-set-group
グループ名を取得/設定 (get/set) します。

@item gnus-info-rank
@itemx gnus-info-set-rank
@findex gnus-info-rank
@findex gnus-info-set-rank
グループの階級 (rank) を取得/設定します (@pxref{Group Score})。

@item gnus-info-level
@itemx gnus-info-set-level
@findex gnus-info-level
@findex gnus-info-set-level
グループのレベルを取得/設定します。

@item gnus-info-score
@itemx gnus-info-set-score
@findex gnus-info-score
@findex gnus-info-set-score
グループのスコアを取得/設定します (@pxref{Group Score})。

@item gnus-info-read
@itemx gnus-info-set-read
@findex gnus-info-read
@findex gnus-info-set-read
既読記事の範囲を取得/設定します。

@item gnus-info-marks
@itemx gnus-info-set-marks
@findex gnus-info-marks
@findex gnus-info-set-marks
印が付いている記事の範囲のリストを取得/設定します。

@item gnus-info-method
@itemx gnus-info-set-method
@findex gnus-info-method
@findex gnus-info-set-method
グループの選択方法を取得/設定します。

@item gnus-info-params
@itemx gnus-info-set-params
@findex gnus-info-params
@findex gnus-info-set-params
グループパラメーターを取得/設定します。
@end table

取得するためのすべての関数は一つの引数を取ります---情報のリストです。設
定するための関数は二つの引数を取ります---情報のリストと新しい値です。

グループ情報の最後の三つの要素は必須ではないので、要素を設定する前にグルー
プ情報を拡張する必要があるでしょう。それが必要な場合、最後の三つの設定す
るための関数の第三引数に @code{nil} ではない値を指定すれば、自動的に拡張
させることができます。(訳注: 例えば三つの要素しかない情報に四つ目の要素
を加える処理を第三引数を使わずに行なうと、@code{(setcar (nthcdr 3 INFO)
VALUE)} というコードが実行される結果、エラーになってしまいます。)

@node Extended Interactive
@subsection 対話形式の拡張
@cindex interactive
@findex gnus-interactive

Gnus は Emacs 標準の @code{interactive} の仕様を、シンボル接頭引数を簡単
に使うことができるようにするために、少し拡張していま
す (@pxref{Symbolic Prefixes})。これはその使い方の例です:

@lisp
(defun gnus-summary-increase-score (&optional score symp)
  (interactive (gnus-interactive "P\ny"))
  ...
  )
@end lisp

最上のものは @code{interactive} の式を返すマクロとし
て @code{gnus-interactive} を実装することでしょうが、Emacs は関数が対話
的かどうかを調べるために、ラムダ式に対して単純に @code{assq} を行なうの
で、これは不可能です。そこで、文字列を受け取って @code{interactive} で使
うことができる値を返す @code{gnus-interactive} 関数を、代わりに持つこと
にしました。

この関数は (ほとんど) すべての @code{interactive} の指定を受け付けますが、
もう少し加えることにします。

@table @samp
@item y
@vindex gnus-current-prefix-symbol
現在のシンボル接頭引数---変数 @code{gnus-current-prefix-symbol} です。

@item Y
@vindex gnus-current-prefix-symbols
現在のシンボル接頭引数のリスト---変
数 @code{gnus-current-prefix-symbol} です。

@item A
現在の記事番号---関数 @code{gnus-summary-article-number} です。

@item H
現在の記事ヘッダー ---関数 @code{gnus-summary-article-header} です。

@item g
現在のグループ名---関数 @code{gnus-group-group-name} です。
@end table

@node Various File Formats
@subsection いろいろなファイル様式

@menu
* Active File Format::          使用可能な記事とグループの情報
* Newsgroups File Format::      グループの説明
@end menu

@node Active File Format
@subsubsection アクテイブファイルの様式

アクティブファイルは、対象になっているサーバーのすべての使用可能なグルー
プの目録を保持します。そこには、それぞれのグループの最高と最低の記事番号
の目録もあります。

これは普通のアクティブファイルからの抜粋です:

@example
soc.motss 296030 293865 y
alt.binaries.pictures.fractals 3922 3913 n
comp.sources.unix 1605 1593 m
comp.binaries.ibm.pc 5097 5089 y
no.general 1000 900 y
@end example

これはこのファイルの疑似 BNF 定義です:

@example
active      = *group-line
group-line  = group spc high-number spc low-number spc flag <NEWLINE>
group       = <non-white-space string>
spc         = " "
high-number = <non-negative integer>
low-number  = <positive integer>
flag        = "y" / "n" / "m" / "j" / "x" / "=" group
@end example

このファイルの完全な説明は、@samp{innd} のマニュアルページ、特
に @samp{active(5)} を見てください。

@node Newsgroups File Format
@subsubsection ニュースグループファイルの様式

ニュースグループファイルは、グループの目録をそれらの説明とともに保持しま
す。サーバーにあるすべてのグループがある必要は無いし、そのファイルにある
すべてのグループがサーバーに存在しなければならないこともありません。この
ファイルは純粋に利用者の情報のためにあります。

様式はとても単純です: グループ名、タブ、そして説明です。これが定義です:

@example
newsgroups    = *line
line          = group tab description <NEWLINE>
group         = <non-white-space string>
tab           = <TAB>
description   = <string>
@end example

@page
@node Emacs for Heathens
@section 異教徒への Emacs

信じるかどうかはともかく、Gnus Love Boat の旅に搭乗する前にあま
り Emacs を使ったことが無いという Gnus の利用者たちがいます。
“@kbd{C-M-a}”や「リージョンを kill する」、それに
「@code{gnus-flargblossen} を連想リストに設定してください。そのキーはグ
ループ名に合致するために使われる正規表現です。」といったことが、あなたに
とって少しかまったく意味の無い魔法の言葉ならば、この付録はあなたのために
あります。もしあなたがすでに Emacs に親しんでいるのであれば、これを無視
してあなたの猫を可愛がりに行ってください。

@menu
* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語
@end menu

@node Keystrokes
@subsection 打鍵

@itemize @bullet
@item
Q: 経験のある Emacs の利用者とは何ですか?

@item
A: 端末にペダルがあったらなぁと願う人のことです。
@end itemize

はい、Emacs を使うとコントロールキー、シフトキー、メタキーをたくさん使う
ようになるでしょう。これは一部の人々 (主に @code{vi} 利用者) には非常に
煩わしいものですが、私たちはその地獄を愛します。諦めてそれを甘受してくだ
さい。Emacs は本当は“Escape-Meta-Alt-Control-Shift”の略で、あなたがい
かがわしい (Emacs の作者のような) 出どころから聞いているかもしれない
“Editing Macros”ではありません。

シフトキーは普通は両手の小指の近くにあって、普通は大文字などを打つために
使われています。あなたは絶え間なくそれを使いますよね。コントロールキーに
は普通“CTRL”のような印が付いています。メタキーは奇妙なことにどのキーボー
ドでもそういう印が付いていません。それは普通はキーボードの左手側にあって、
最下段にあるのが一般的です。

さて、私たち Emacs 人は、それがひどく不便なので「meta-control-m キーを押
す」とは言いません。私たちが使うのは「@kbd{C-M-m} を押す」です。
@kbd{M-} は「メタ」を現す接頭語で、“C-”は「コントロール」を意味する接
頭語です。ですから「@kbd{C-k} を押す」は、「コントロールキーを押し続けな
がら次に @kbd{k} を押す」ということです。「@kbd{C-M-k} を押す」は「メタ
キーとコントロールキーを押し続けながら次に @kbd{k} を押す」ということで
す。簡単です、よね?

このことは、すべてのキーボードがメタキーを持っているわけではないという事
実によって、多少ややこしくなっています。そういう場合には「エスケープ」キー
を使えばよいでしょう。ただしメタキーを持っているときより作業が増えるので、
メタキーのあるキーボードを手に入れていただくことを謹んでお勧め申し上げま
す。それ無しでは生きて行けないでしょう。

@node Emacs Lisp
@subsection Emacs Lisp

Emacs はエディターの王様です。なぜなら、それが真の Lisp インタープリター
だからです。あなたが叩くすべてのキーは、何らかの Emacs Lisp コードの小片
を実行します。Emacs Lisp はインタープリターで実行される言語なので、どの
キーが何のコードを実行するかを任意に設定することができます。あなたは、た
だそうすれば良いのです。

Gnus は Emacs Lisp によって書かれていて、インタープリターで実行されるた
くさんの関数によって動作します。(これらは速度のためにバイトコンパイルさ
れていますが、インタープリターで実行されることに変わりはありません。) も
し Gnus のある動作が好みではないと感じたら、それを違うやり方で実行させる
のは取るに足らないことです。(えーと、少なくとも Lisp コードの書き方を知っ
ていれば。) でもそれはこのマニュアルの範疇ではないので、Gnus をカスタマ
イズするために @file{~/.gnus.el} ファイルで普段使われるいくつかの一般的
な構文のことだけを話すことにしましょう。(@file{~/.emacs} ファイルを使う
こともできますが、Gnus に関する設定には @file{~/.gnus.el} ファイルを使う
方がはるかに良いです。)

もし変数 @code{gnus-florgbnize} を四 (4) に設定したいのであれば、以下の
ものを書きましょう:

@lisp
(setq gnus-florgbnize 4)
@end lisp

この関数 (本当は「特殊形式」(special form)) @code{setq} は、変数を何かの
値に設定することができるものです。これがあなたが本当に知っていなければな
らないことのすべてです。これからは Gnus の動作を変更するために、たくさん
のこういうもので @file{~/.gnus.el} ファイルを埋め尽くすことができます。

そういうものを @file{~/.gnus.el} ファイルに入れておくと、それらは次回
に Gnus を起動したときに読み込まれ、@code{eval} (それは「実行」
の Lisp 語です) されます。もし変数をすぐに変更したいのであれば、閉じ括弧
の後ろで @kbd{C-x C-e} とタイプすれば良いのです。それは前にある「式」(こ
こでは簡単な @code{setq} 文) を @code{eval} します。

さあ、やってみましょう---あなたが Emacs の前にいるのなら試してみてくださ
い。@kbd{C-x C-e} をタイプすると、エコーエリア (訳注: 一般には Emacs の
画面の一番下) に @samp{4} が現われるのが見えるでしょう。それはあなた
が @code{eval} した式の戻り値です。

いくつかの落とし穴:

もしマニュアルが「@code{gnus-read-active-file} を @code{some} に設定しな
さい」と言ったなら、それは

@lisp
(setq gnus-read-active-file 'some)
@end lisp

ということです。

一方、マニュアル
が「@code{gnus-nntp-server-file} を @file{/etc/nntpserver} に設定しなさ
い」と言ったなら、それは

@lisp
(setq gnus-nntp-server-file "/etc/nntpserver")
@end lisp

ということです。

ですから、文字列 (後者) を シンボル (前者) と混同しないように注意してく
ださい。マニュアルは明確に区別していますが、混乱しやすいかもしれません。

@page
@include gnus-faq-ja.texi

@node GNU Free Documentation License
@chapter GNU フリー文書利用許諾契約書

訳注: @uref{http://www.opensource.jp/fdl/fdl.ja.html.euc-jp,
非公式な日本語訳} があります。

@include doclicense.texi

@node Index
@chapter Index
@printindex cp

@node Key Index
@chapter Key Index
@printindex ky

@bye

@iftex
@iflatex
\end{document}
@end iflatex
@end iftex

@c Local Variables:
@c fill-column: 72
@c End:
